{
    "pandas:63": {
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_63/pandas/core/indexing.py": {
            "buggy_functions": [
                {
                    "function_name": "_convert_key",
                    "function_code": "def _convert_key(self, key, is_setter: bool = False):\n    \"\"\"\n    Require they keys to be the same type as the index. (so we don't\n    fallback)\n    \"\"\"\n    # allow arbitrary setting\n    if is_setter:\n        return list(key)\n\n    for ax, i in zip(self.obj.axes, key):\n        if ax.is_integer():\n            if not is_integer(i):\n                raise ValueError(\n                    \"At based indexing on an integer index \"\n                    \"can only have integer indexers\"\n                )\n        else:\n            if is_integer(i) and not (ax.holds_integer() or ax.is_floating()):\n                raise ValueError(\n                    \"At based indexing on an non-integer \"\n                    \"index can only have non-integer \"\n                    \"indexers\"\n                )\n    return key\n",
                    "decorators": [],
                    "docstring": "Require they keys to be the same type as the index. (so we don't\nfallback)",
                    "start_line": 2081,
                    "variables": {
                        "bool": [
                            2081
                        ],
                        "is_setter": [
                            2087
                        ],
                        "list": [
                            2088
                        ],
                        "key": [
                            2088,
                            2090,
                            2104
                        ],
                        "ax": [
                            2090,
                            2091,
                            2098
                        ],
                        "i": [
                            2090,
                            2092,
                            2098
                        ],
                        "zip": [
                            2090
                        ],
                        "self.obj.axes": [
                            2090
                        ],
                        "self.obj": [
                            2090
                        ],
                        "self": [
                            2090
                        ],
                        "ax.is_integer": [
                            2091
                        ],
                        "is_integer": [
                            2098,
                            2092
                        ],
                        "ValueError": [
                            2099,
                            2093
                        ],
                        "ax.holds_integer": [
                            2098
                        ],
                        "ax.is_floating": [
                            2098
                        ]
                    },
                    "filtered_variables": {
                        "is_setter": [
                            2087
                        ],
                        "key": [
                            2088,
                            2090,
                            2104
                        ],
                        "ax": [
                            2090,
                            2091,
                            2098
                        ],
                        "i": [
                            2090,
                            2092,
                            2098
                        ],
                        "self.obj.axes": [
                            2090
                        ],
                        "self.obj": [
                            2090
                        ],
                        "self": [
                            2090
                        ],
                        "ax.is_integer": [
                            2091
                        ],
                        "is_integer": [
                            2098,
                            2092
                        ],
                        "ax.holds_integer": [
                            2098
                        ],
                        "ax.is_floating": [
                            2098
                        ]
                    },
                    "diff_line_number": 2090,
                    "class_data": {
                        "signature": "class _AtIndexer(_ScalarAccessIndexer)",
                        "docstring": null,
                        "constructor_docstring": null,
                        "functions": [
                            "def _convert_key(self, key, is_setter: bool=False):\n    \"\"\"\n    Require they keys to be the same type as the index. (so we don't\n    fallback)\n    \"\"\"\n    if is_setter:\n        return list(key)\n    for ax, i in zip(self.obj.axes, key):\n        if ax.is_integer():\n            if not is_integer(i):\n                raise ValueError('At based indexing on an integer index can only have integer indexers')\n        elif is_integer(i) and (not (ax.holds_integer() or ax.is_floating())):\n            raise ValueError('At based indexing on an non-integer index can only have non-integer indexers')\n    return key"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_takeable"
                        ],
                        "class_decorators": [
                            "Appender(IndexingMixin.at.__doc__)"
                        ],
                        "function_signatures": [
                            "_convert_key(self, key, is_setter: bool=False)"
                        ]
                    },
                    "variable_values": [
                        [
                            {
                                "is_setter": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "('a',)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "ax": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "i": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.obj.axes": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.obj": {
                                    "variable_value": "a    1\nb    2\nc    3\ndtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<pandas.core.indexing._AtIndexer object at 0x1114a0680>",
                                    "variable_type": "_AtIndexer",
                                    "variable_shape": null
                                },
                                "ax.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ax.holds_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ax.is_floating": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "is_setter": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "('a',)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "ax": {
                                    "variable_value": "Index(['a', 'b', 'c'], dtype='object')",
                                    "variable_type": "Index",
                                    "variable_shape": "3"
                                },
                                "i": {
                                    "variable_value": "'a'",
                                    "variable_type": "str",
                                    "variable_shape": "1"
                                },
                                "self.obj.axes": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.obj": {
                                    "variable_value": "a    1\nb    2\nc    3\ndtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<pandas.core.indexing._AtIndexer object at 0x1114a0680>",
                                    "variable_type": "_AtIndexer",
                                    "variable_shape": null
                                },
                                "ax.is_integer": {
                                    "variable_value": "<bound method Index.is_integer of Index(['a', 'b', 'c'], dtype='object')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ax.holds_integer": {
                                    "variable_value": "<bound method Index.holds_integer of Index(['a', 'b', 'c'], dtype='object')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "ax.is_floating": {
                                    "variable_value": "<bound method Index.is_floating of Index(['a', 'b', 'c'], dtype='object')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "is_setter": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "('a',)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "lkey": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "n": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ax": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "i": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.obj.axes": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.obj": {
                                    "variable_value": "a    1\nb    2\nc    3\ndtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<pandas.core.indexing._AtIndexer object at 0x11264c0e0>",
                                    "variable_type": "_AtIndexer",
                                    "variable_shape": null
                                },
                                "ax._convert_scalar_indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "is_setter": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "('a',)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "lkey": {
                                    "variable_value": "['a']",
                                    "variable_type": "list",
                                    "variable_shape": "1"
                                },
                                "n": {
                                    "variable_value": "0",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "ax": {
                                    "variable_value": "Index(['a', 'b', 'c'], dtype='object')",
                                    "variable_type": "Index",
                                    "variable_shape": "3"
                                },
                                "i": {
                                    "variable_value": "'a'",
                                    "variable_type": "str",
                                    "variable_shape": "1"
                                },
                                "self.obj.axes": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.obj": {
                                    "variable_value": "a    1\nb    2\nc    3\ndtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<pandas.core.indexing._AtIndexer object at 0x11264c0e0>",
                                    "variable_type": "_AtIndexer",
                                    "variable_shape": null
                                },
                                "ax._convert_scalar_indexer": {
                                    "variable_value": "<bound method Index._convert_scalar_indexer of Index(['a', 'b', 'c'], dtype='object')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {},
                            {}
                        ]
                    ]
                }
            ],
            "inscope_functions": [
                "def _tuplify(ndim: int, loc: Hashable) -> Tuple[Union[Hashable, slice], ...]:\n    \"\"\"\n    Given an indexer for the first dimension, create an equivalent tuple\n    for indexing over all dimensions.\n\n    Parameters\n    ----------\n    ndim : int\n    loc : object\n\n    Returns\n    -------\n    tuple\n    \"\"\"\n    _tup: List[Union[Hashable, slice]]\n    _tup = [slice(None, None) for _ in range(ndim)]\n    _tup[0] = loc\n    return tuple(_tup)",
                "def convert_to_index_sliceable(obj, key):\n    \"\"\"\n    If we are index sliceable, then return my slicer, otherwise return None.\n    \"\"\"\n    idx = obj.index\n    if isinstance(key, slice):\n        return idx._convert_slice_indexer(key, kind=\"getitem\")\n\n    elif isinstance(key, str):\n\n        # we are an actual column\n        if key in obj._data.items:\n            return None\n\n        # We might have a datetimelike string that we can translate to a\n        # slice here via partial string indexing\n        if idx._supports_partial_string_indexing:\n            try:\n                return idx._get_string_slice(key)\n            except (KeyError, ValueError, NotImplementedError):\n                return None\n\n    return None",
                "def check_bool_indexer(index: Index, key) -> np.ndarray:\n    \"\"\"\n    Check if key is a valid boolean indexer for an object with such index and\n    perform reindexing or conversion if needed.\n\n    This function assumes that is_bool_indexer(key) == True.\n\n    Parameters\n    ----------\n    index : Index\n        Index of the object on which the indexing is done.\n    key : list-like\n        Boolean indexer to check.\n\n    Returns\n    -------\n    np.array\n        Resulting key.\n\n    Raises\n    ------\n    IndexError\n        If the key does not have the same length as index.\n    IndexingError\n        If the index of the key is unalignable to index.\n    \"\"\"\n    result = key\n    if isinstance(key, ABCSeries) and not key.index.equals(index):\n        result = result.reindex(index)\n        mask = isna(result._values)\n        if mask.any():\n            raise IndexingError(\n                \"Unalignable boolean Series provided as \"\n                \"indexer (index of the boolean Series and of \"\n                \"the indexed object do not match).\"\n            )\n        result = result.astype(bool)._values\n    else:\n        # key might be sparse / object-dtype bool, check_array_indexer needs bool array\n        result = np.asarray(result, dtype=bool)\n        result = check_array_indexer(index, result)\n\n    return result",
                "def convert_missing_indexer(indexer):\n    \"\"\"\n    Reverse convert a missing indexer, which is a dict\n    return the scalar indexer and a boolean indicating if we converted\n    \"\"\"\n    if isinstance(indexer, dict):\n\n        # a missing key (but not a tuple indexer)\n        indexer = indexer[\"key\"]\n\n        if isinstance(indexer, bool):\n            raise KeyError(\"cannot use a single bool to index into setitem\")\n        return indexer, True\n\n    return indexer, False",
                "def convert_from_missing_indexer_tuple(indexer, axes):\n    \"\"\"\n    Create a filtered indexer that doesn't have any missing indexers.\n    \"\"\"\n\n    def get_indexer(_i, _idx):\n        return axes[_i].get_loc(_idx[\"key\"]) if isinstance(_idx, dict) else _idx\n\n    return tuple(get_indexer(_i, _idx) for _i, _idx in enumerate(indexer))",
                "def maybe_convert_ix(*args):\n    \"\"\"\n    We likely want to take the cross-product.\n    \"\"\"\n    ixify = True\n    for arg in args:\n        if not isinstance(arg, (np.ndarray, list, ABCSeries, Index)):\n            ixify = False\n\n    if ixify:\n        return np.ix_(*args)\n    else:\n        return args",
                "def is_nested_tuple(tup, labels) -> bool:\n    \"\"\"\n    Returns\n    -------\n    bool\n    \"\"\"\n    # check for a compatible nested tuple and multiindexes among the axes\n    if not isinstance(tup, tuple):\n        return False\n\n    for i, k in enumerate(tup):\n\n        if is_list_like(k) or isinstance(k, slice):\n            return isinstance(labels, ABCMultiIndex)\n\n    return False",
                "def is_label_like(key) -> bool:\n    \"\"\"\n    Returns\n    -------\n    bool\n    \"\"\"\n    # select a label or row\n    return not isinstance(key, slice) and not is_list_like_indexer(key)",
                "def need_slice(obj) -> bool:\n    \"\"\"\n    Returns\n    -------\n    bool\n    \"\"\"\n    return (\n        obj.start is not None\n        or obj.stop is not None\n        or (obj.step is not None and obj.step != 1)\n    )",
                "def _non_reducing_slice(slice_):\n    \"\"\"\n    Ensurse that a slice doesn't reduce to a Series or Scalar.\n\n    Any user-paseed `subset` should have this called on it\n    to make sure we're always working with DataFrames.\n    \"\"\"\n    # default to column slice, like DataFrame\n    # ['A', 'B'] -> IndexSlices[:, ['A', 'B']]\n    kinds = (ABCSeries, np.ndarray, Index, list, str)\n    if isinstance(slice_, kinds):\n        slice_ = IndexSlice[:, slice_]\n\n    def pred(part) -> bool:\n        \"\"\"\n        Returns\n        -------\n        bool\n            True if slice does *not* reduce,\n            False if `part` is a tuple.\n        \"\"\"\n        # true when slice does *not* reduce, False when part is a tuple,\n        # i.e. MultiIndex slice\n        return (isinstance(part, slice) or is_list_like(part)) and not isinstance(\n            part, tuple\n        )\n\n    if not is_list_like(slice_):\n        if not isinstance(slice_, slice):\n            # a 1-d slice, like df.loc[1]\n            slice_ = [[slice_]]\n        else:\n            # slice(a, b, c)\n            slice_ = [slice_]  # to tuplize later\n    else:\n        slice_ = [part if pred(part) else [part] for part in slice_]\n    return tuple(slice_)",
                "def _maybe_numeric_slice(df, slice_, include_bool=False):\n    \"\"\"\n    Want nice defaults for background_gradient that don't break\n    with non-numeric data. But if slice_ is passed go with that.\n    \"\"\"\n    if slice_ is None:\n        dtypes = [np.number]\n        if include_bool:\n            dtypes.append(bool)\n        slice_ = IndexSlice[:, df.select_dtypes(include=dtypes).columns]\n    return slice_",
                "def _can_do_equal_len(labels, value, plane_indexer, lplane_indexer, obj) -> bool:\n    \"\"\"\n    Returns\n    -------\n    bool\n        True if we have an equal len settable.\n    \"\"\"\n    if not len(labels) == 1 or not np.iterable(value) or is_scalar(plane_indexer[0]):\n        return False\n\n    item = labels[0]\n    index = obj[item].index\n\n    values_len = len(value)\n    # equal len list/ndarray\n    if len(index) == values_len:\n        return True\n    elif lplane_indexer == values_len:\n        return True\n\n    return False",
                "def __getitem__(self, arg):\n    return arg",
                "@property\ndef iloc(self) -> \"_iLocIndexer\":\n    \"\"\"\n    Purely integer-location based indexing for selection by position.\n\n    ``.iloc[]`` is primarily integer position based (from ``0`` to\n    ``length-1`` of the axis), but may also be used with a boolean\n    array.\n\n    Allowed inputs are:\n\n    - An integer, e.g. ``5``.\n    - A list or array of integers, e.g. ``[4, 3, 0]``.\n    - A slice object with ints, e.g. ``1:7``.\n    - A boolean array.\n    - A ``callable`` function with one argument (the calling Series or\n      DataFrame) and that returns valid output for indexing (one of the above).\n      This is useful in method chains, when you don't have a reference to the\n      calling object, but would like to base your selection on some value.\n\n    ``.iloc`` will raise ``IndexError`` if a requested indexer is\n    out-of-bounds, except *slice* indexers which allow out-of-bounds\n    indexing (this conforms with python/numpy *slice* semantics).\n\n    See more at :ref:`Selection by Position <indexing.integer>`.\n\n    See Also\n    --------\n    DataFrame.iat : Fast integer location scalar accessor.\n    DataFrame.loc : Purely label-location based indexer for selection by label.\n    Series.iloc : Purely integer-location based indexing for\n                   selection by position.\n\n    Examples\n    --------\n\n    >>> mydict = [{'a': 1, 'b': 2, 'c': 3, 'd': 4},\n    ...           {'a': 100, 'b': 200, 'c': 300, 'd': 400},\n    ...           {'a': 1000, 'b': 2000, 'c': 3000, 'd': 4000 }]\n    >>> df = pd.DataFrame(mydict)\n    >>> df\n          a     b     c     d\n    0     1     2     3     4\n    1   100   200   300   400\n    2  1000  2000  3000  4000\n\n    **Indexing just the rows**\n\n    With a scalar integer.\n\n    >>> type(df.iloc[0])\n    <class 'pandas.core.series.Series'>\n    >>> df.iloc[0]\n    a    1\n    b    2\n    c    3\n    d    4\n    Name: 0, dtype: int64\n\n    With a list of integers.\n\n    >>> df.iloc[[0]]\n       a  b  c  d\n    0  1  2  3  4\n    >>> type(df.iloc[[0]])\n    <class 'pandas.core.frame.DataFrame'>\n\n    >>> df.iloc[[0, 1]]\n         a    b    c    d\n    0    1    2    3    4\n    1  100  200  300  400\n\n    With a `slice` object.\n\n    >>> df.iloc[:3]\n          a     b     c     d\n    0     1     2     3     4\n    1   100   200   300   400\n    2  1000  2000  3000  4000\n\n    With a boolean mask the same length as the index.\n\n    >>> df.iloc[[True, False, True]]\n          a     b     c     d\n    0     1     2     3     4\n    2  1000  2000  3000  4000\n\n    With a callable, useful in method chains. The `x` passed\n    to the ``lambda`` is the DataFrame being sliced. This selects\n    the rows whose index label even.\n\n    >>> df.iloc[lambda x: x.index % 2 == 0]\n          a     b     c     d\n    0     1     2     3     4\n    2  1000  2000  3000  4000\n\n    **Indexing both axes**\n\n    You can mix the indexer types for the index and columns. Use ``:`` to\n    select the entire axis.\n\n    With scalar integers.\n\n    >>> df.iloc[0, 1]\n    2\n\n    With lists of integers.\n\n    >>> df.iloc[[0, 2], [1, 3]]\n          b     d\n    0     2     4\n    2  2000  4000\n\n    With `slice` objects.\n\n    >>> df.iloc[1:3, 0:3]\n          a     b     c\n    1   100   200   300\n    2  1000  2000  3000\n\n    With a boolean array whose length matches the columns.\n\n    >>> df.iloc[:, [True, False, True, False]]\n          a     c\n    0     1     3\n    1   100   300\n    2  1000  3000\n\n    With a callable function that expects the Series or DataFrame.\n\n    >>> df.iloc[:, lambda df: [0, 2]]\n          a     c\n    0     1     3\n    1   100   300\n    2  1000  3000\n    \"\"\"\n    return _iLocIndexer(\"iloc\", self)",
                "@property\ndef loc(self) -> \"_LocIndexer\":\n    \"\"\"\n    Access a group of rows and columns by label(s) or a boolean array.\n\n    ``.loc[]`` is primarily label based, but may also be used with a\n    boolean array.\n\n    Allowed inputs are:\n\n    - A single label, e.g. ``5`` or ``'a'``, (note that ``5`` is\n      interpreted as a *label* of the index, and **never** as an\n      integer position along the index).\n    - A list or array of labels, e.g. ``['a', 'b', 'c']``.\n    - A slice object with labels, e.g. ``'a':'f'``.\n\n      .. warning:: Note that contrary to usual python slices, **both** the\n          start and the stop are included\n\n    - A boolean array of the same length as the axis being sliced,\n      e.g. ``[True, False, True]``.\n    - A ``callable`` function with one argument (the calling Series or\n      DataFrame) and that returns valid output for indexing (one of the above)\n\n    See more at :ref:`Selection by Label <indexing.label>`\n\n    Raises\n    ------\n    KeyError\n        If any items are not found.\n\n    See Also\n    --------\n    DataFrame.at : Access a single value for a row/column label pair.\n    DataFrame.iloc : Access group of rows and columns by integer position(s).\n    DataFrame.xs : Returns a cross-section (row(s) or column(s)) from the\n        Series/DataFrame.\n    Series.loc : Access group of values using labels.\n\n    Examples\n    --------\n    **Getting values**\n\n    >>> df = pd.DataFrame([[1, 2], [4, 5], [7, 8]],\n    ...      index=['cobra', 'viper', 'sidewinder'],\n    ...      columns=['max_speed', 'shield'])\n    >>> df\n                max_speed  shield\n    cobra               1       2\n    viper               4       5\n    sidewinder          7       8\n\n    Single label. Note this returns the row as a Series.\n\n    >>> df.loc['viper']\n    max_speed    4\n    shield       5\n    Name: viper, dtype: int64\n\n    List of labels. Note using ``[[]]`` returns a DataFrame.\n\n    >>> df.loc[['viper', 'sidewinder']]\n                max_speed  shield\n    viper               4       5\n    sidewinder          7       8\n\n    Single label for row and column\n\n    >>> df.loc['cobra', 'shield']\n    2\n\n    Slice with labels for row and single label for column. As mentioned\n    above, note that both the start and stop of the slice are included.\n\n    >>> df.loc['cobra':'viper', 'max_speed']\n    cobra    1\n    viper    4\n    Name: max_speed, dtype: int64\n\n    Boolean list with the same length as the row axis\n\n    >>> df.loc[[False, False, True]]\n                max_speed  shield\n    sidewinder          7       8\n\n    Conditional that returns a boolean Series\n\n    >>> df.loc[df['shield'] > 6]\n                max_speed  shield\n    sidewinder          7       8\n\n    Conditional that returns a boolean Series with column labels specified\n\n    >>> df.loc[df['shield'] > 6, ['max_speed']]\n                max_speed\n    sidewinder          7\n\n    Callable that returns a boolean Series\n\n    >>> df.loc[lambda df: df['shield'] == 8]\n                max_speed  shield\n    sidewinder          7       8\n\n    **Setting values**\n\n    Set value for all items matching the list of labels\n\n    >>> df.loc[['viper', 'sidewinder'], ['shield']] = 50\n    >>> df\n                max_speed  shield\n    cobra               1       2\n    viper               4      50\n    sidewinder          7      50\n\n    Set value for an entire row\n\n    >>> df.loc['cobra'] = 10\n    >>> df\n                max_speed  shield\n    cobra              10      10\n    viper               4      50\n    sidewinder          7      50\n\n    Set value for an entire column\n\n    >>> df.loc[:, 'max_speed'] = 30\n    >>> df\n                max_speed  shield\n    cobra              30      10\n    viper              30      50\n    sidewinder         30      50\n\n    Set value for rows matching callable condition\n\n    >>> df.loc[df['shield'] > 35] = 0\n    >>> df\n                max_speed  shield\n    cobra              30      10\n    viper               0       0\n    sidewinder          0       0\n\n    **Getting values on a DataFrame with an index that has integer labels**\n\n    Another example using integers for the index\n\n    >>> df = pd.DataFrame([[1, 2], [4, 5], [7, 8]],\n    ...      index=[7, 8, 9], columns=['max_speed', 'shield'])\n    >>> df\n       max_speed  shield\n    7          1       2\n    8          4       5\n    9          7       8\n\n    Slice with integer labels for rows. As mentioned above, note that both\n    the start and stop of the slice are included.\n\n    >>> df.loc[7:9]\n       max_speed  shield\n    7          1       2\n    8          4       5\n    9          7       8\n\n    **Getting values with a MultiIndex**\n\n    A number of examples using a DataFrame with a MultiIndex\n\n    >>> tuples = [\n    ...    ('cobra', 'mark i'), ('cobra', 'mark ii'),\n    ...    ('sidewinder', 'mark i'), ('sidewinder', 'mark ii'),\n    ...    ('viper', 'mark ii'), ('viper', 'mark iii')\n    ... ]\n    >>> index = pd.MultiIndex.from_tuples(tuples)\n    >>> values = [[12, 2], [0, 4], [10, 20],\n    ...         [1, 4], [7, 1], [16, 36]]\n    >>> df = pd.DataFrame(values, columns=['max_speed', 'shield'], index=index)\n    >>> df\n                         max_speed  shield\n    cobra      mark i           12       2\n               mark ii           0       4\n    sidewinder mark i           10      20\n               mark ii           1       4\n    viper      mark ii           7       1\n               mark iii         16      36\n\n    Single label. Note this returns a DataFrame with a single index.\n\n    >>> df.loc['cobra']\n             max_speed  shield\n    mark i          12       2\n    mark ii          0       4\n\n    Single index tuple. Note this returns a Series.\n\n    >>> df.loc[('cobra', 'mark ii')]\n    max_speed    0\n    shield       4\n    Name: (cobra, mark ii), dtype: int64\n\n    Single label for row and column. Similar to passing in a tuple, this\n    returns a Series.\n\n    >>> df.loc['cobra', 'mark i']\n    max_speed    12\n    shield        2\n    Name: (cobra, mark i), dtype: int64\n\n    Single tuple. Note using ``[[]]`` returns a DataFrame.\n\n    >>> df.loc[[('cobra', 'mark ii')]]\n                   max_speed  shield\n    cobra mark ii          0       4\n\n    Single tuple for the index with a single label for the column\n\n    >>> df.loc[('cobra', 'mark i'), 'shield']\n    2\n\n    Slice from index tuple to single label\n\n    >>> df.loc[('cobra', 'mark i'):'viper']\n                         max_speed  shield\n    cobra      mark i           12       2\n               mark ii           0       4\n    sidewinder mark i           10      20\n               mark ii           1       4\n    viper      mark ii           7       1\n               mark iii         16      36\n\n    Slice from index tuple to index tuple\n\n    >>> df.loc[('cobra', 'mark i'):('viper', 'mark ii')]\n                        max_speed  shield\n    cobra      mark i          12       2\n               mark ii          0       4\n    sidewinder mark i          10      20\n               mark ii          1       4\n    viper      mark ii          7       1\n    \"\"\"\n    return _LocIndexer(\"loc\", self)",
                "@property\ndef at(self) -> \"_AtIndexer\":\n    \"\"\"\n    Access a single value for a row/column label pair.\n\n    Similar to ``loc``, in that both provide label-based lookups. Use\n    ``at`` if you only need to get or set a single value in a DataFrame\n    or Series.\n\n    Raises\n    ------\n    KeyError\n        If 'label' does not exist in DataFrame.\n\n    See Also\n    --------\n    DataFrame.iat : Access a single value for a row/column pair by integer\n        position.\n    DataFrame.loc : Access a group of rows and columns by label(s).\n    Series.at : Access a single value using a label.\n\n    Examples\n    --------\n    >>> df = pd.DataFrame([[0, 2, 3], [0, 4, 1], [10, 20, 30]],\n    ...                   index=[4, 5, 6], columns=['A', 'B', 'C'])\n    >>> df\n        A   B   C\n    4   0   2   3\n    5   0   4   1\n    6  10  20  30\n\n    Get value at specified row/column pair\n\n    >>> df.at[4, 'B']\n    2\n\n    Set value at specified row/column pair\n\n    >>> df.at[4, 'B'] = 10\n    >>> df.at[4, 'B']\n    10\n\n    Get value within a Series\n\n    >>> df.loc[5].at['B']\n    4\n    \"\"\"\n    return _AtIndexer(\"at\", self)",
                "@property\ndef iat(self) -> \"_iAtIndexer\":\n    \"\"\"\n    Access a single value for a row/column pair by integer position.\n\n    Similar to ``iloc``, in that both provide integer-based lookups. Use\n    ``iat`` if you only need to get or set a single value in a DataFrame\n    or Series.\n\n    Raises\n    ------\n    IndexError\n        When integer position is out of bounds.\n\n    See Also\n    --------\n    DataFrame.at : Access a single value for a row/column label pair.\n    DataFrame.loc : Access a group of rows and columns by label(s).\n    DataFrame.iloc : Access a group of rows and columns by integer position(s).\n\n    Examples\n    --------\n    >>> df = pd.DataFrame([[0, 2, 3], [0, 4, 1], [10, 20, 30]],\n    ...                   columns=['A', 'B', 'C'])\n    >>> df\n        A   B   C\n    0   0   2   3\n    1   0   4   1\n    2  10  20  30\n\n    Get value at specified row/column pair\n\n    >>> df.iat[1, 2]\n    1\n\n    Set value at specified row/column pair\n\n    >>> df.iat[1, 2] = 10\n    >>> df.iat[1, 2]\n    10\n\n    Get value within a series\n\n    >>> df.loc[0].iat[1]\n    2\n    \"\"\"\n    return _iAtIndexer(\"iat\", self)",
                "def __call__(self, axis=None):\n    # we need to return a copy of ourselves\n    new_self = type(self)(self.name, self.obj)\n\n    if axis is not None:\n        axis = self.obj._get_axis_number(axis)\n    new_self.axis = axis\n    return new_self",
                "def _get_label(self, label, axis: int):\n    if self.ndim == 1:\n        # for perf reasons we want to try _xs first\n        # as its basically direct indexing\n        # but will fail when the index is not present\n        # see GH5667\n        return self.obj._xs(label, axis=axis)\n    elif isinstance(label, tuple) and isinstance(label[axis], slice):\n        raise IndexingError(\"no slices here, handle elsewhere\")\n\n    return self.obj._xs(label, axis=axis)",
                "def _get_setitem_indexer(self, key):\n    if self.axis is not None:\n        return self._convert_tuple(key, is_setter=True)\n\n    ax = self.obj._get_axis(0)\n\n    if isinstance(ax, ABCMultiIndex) and self.name != \"iloc\":\n        try:\n            return ax.get_loc(key)\n        except (TypeError, KeyError, InvalidIndexError):\n            # TypeError e.g. passed a bool\n            pass\n\n    if isinstance(key, tuple):\n        try:\n            return self._convert_tuple(key, is_setter=True)\n        except IndexingError:\n            pass\n\n    if isinstance(key, range):\n        return list(key)\n\n    try:\n        return self._convert_to_indexer(key, axis=0, is_setter=True)\n    except TypeError as e:\n\n        # invalid indexer type vs 'other' indexing errors\n        if \"cannot do\" in str(e):\n            raise\n        raise IndexingError(key)",
                "def __setitem__(self, key, value):\n    if isinstance(key, tuple):\n        key = tuple(com.apply_if_callable(x, self.obj) for x in key)\n    else:\n        key = com.apply_if_callable(key, self.obj)\n    indexer = self._get_setitem_indexer(key)\n    self._setitem_with_indexer(indexer, value)",
                "def _validate_key(self, key, axis: int):\n    \"\"\"\n    Ensure that key is valid for current indexer.\n\n    Parameters\n    ----------\n    key : scalar, slice or list-like\n        Key requested.\n    axis : int\n        Dimension on which the indexing is being made.\n\n    Raises\n    ------\n    TypeError\n        If the key (or some element of it) has wrong type.\n    IndexError\n        If the key (or some element of it) is out of bounds.\n    KeyError\n        If the key was not found.\n    \"\"\"\n    raise AbstractMethodError(self)",
                "def _has_valid_tuple(self, key: Tuple):\n    \"\"\"\n    Check the key for valid keys across my indexer.\n    \"\"\"\n    for i, k in enumerate(key):\n        if i >= self.ndim:\n            raise IndexingError(\"Too many indexers\")\n        try:\n            self._validate_key(k, i)\n        except ValueError:\n            raise ValueError(\n                \"Location based indexing can only have \"\n                f\"[{self._valid_types}] types\"\n            )",
                "def _is_nested_tuple_indexer(self, tup: Tuple) -> bool:\n    \"\"\"\n    Returns\n    -------\n    bool\n    \"\"\"\n    if any(isinstance(ax, ABCMultiIndex) for ax in self.obj.axes):\n        return any(is_nested_tuple(tup, ax) for ax in self.obj.axes)\n    return False",
                "def _convert_tuple(self, key, is_setter: bool = False):\n    keyidx = []\n    if self.axis is not None:\n        axis = self.obj._get_axis_number(self.axis)\n        for i in range(self.ndim):\n            if i == axis:\n                keyidx.append(\n                    self._convert_to_indexer(key, axis=axis, is_setter=is_setter)\n                )\n            else:\n                keyidx.append(slice(None))\n    else:\n        for i, k in enumerate(key):\n            if i >= self.ndim:\n                raise IndexingError(\"Too many indexers\")\n            idx = self._convert_to_indexer(k, axis=i, is_setter=is_setter)\n            keyidx.append(idx)\n    return tuple(keyidx)",
                "def _has_valid_setitem_indexer(self, indexer) -> bool:\n    return True",
                "def _has_valid_positional_setitem_indexer(self, indexer) -> bool:\n    \"\"\"\n    Validate that a positional indexer cannot enlarge its target\n    will raise if needed, does not modify the indexer externally.\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    if isinstance(indexer, dict):\n        raise IndexError(f\"{self.name} cannot enlarge its target object\")\n    else:\n        if not isinstance(indexer, tuple):\n            indexer = _tuplify(self.ndim, indexer)\n        for ax, i in zip(self.obj.axes, indexer):\n            if isinstance(i, slice):\n                # should check the stop slice?\n                pass\n            elif is_list_like_indexer(i):\n                # should check the elements?\n                pass\n            elif is_integer(i):\n                if i >= len(ax):\n                    raise IndexError(\n                        f\"{self.name} cannot enlarge its target object\"\n                    )\n            elif isinstance(i, dict):\n                raise IndexError(f\"{self.name} cannot enlarge its target object\")\n\n    return True",
                "def _setitem_with_indexer(self, indexer, value):\n    self._has_valid_setitem_indexer(indexer)\n\n    # also has the side effect of consolidating in-place\n    from pandas import Series\n\n    info_axis = self.obj._info_axis_number\n\n    # maybe partial set\n    take_split_path = self.obj._is_mixed_type\n\n    # if there is only one block/type, still have to take split path\n    # unless the block is one-dimensional or it can hold the value\n    if not take_split_path and self.obj._data.blocks:\n        (blk,) = self.obj._data.blocks\n        if 1 < blk.ndim:  # in case of dict, keys are indices\n            val = list(value.values()) if isinstance(value, dict) else value\n            take_split_path = not blk._can_hold_element(val)\n\n    # if we have any multi-indexes that have non-trivial slices\n    # (not null slices) then we must take the split path, xref\n    # GH 10360, GH 27841\n    if isinstance(indexer, tuple) and len(indexer) == len(self.obj.axes):\n        for i, ax in zip(indexer, self.obj.axes):\n            if isinstance(ax, ABCMultiIndex) and not (\n                is_integer(i) or com.is_null_slice(i)\n            ):\n                take_split_path = True\n                break\n\n    if isinstance(indexer, tuple):\n        nindexer = []\n        for i, idx in enumerate(indexer):\n            if isinstance(idx, dict):\n\n                # reindex the axis to the new value\n                # and set inplace\n                key, _ = convert_missing_indexer(idx)\n\n                # if this is the items axes, then take the main missing\n                # path first\n                # this correctly sets the dtype and avoids cache issues\n                # essentially this separates out the block that is needed\n                # to possibly be modified\n                if self.ndim > 1 and i == self.obj._info_axis_number:\n\n                    # add the new item, and set the value\n                    # must have all defined axes if we have a scalar\n                    # or a list-like on the non-info axes if we have a\n                    # list-like\n                    len_non_info_axes = (\n                        len(_ax) for _i, _ax in enumerate(self.obj.axes) if _i != i\n                    )\n                    if any(not l for l in len_non_info_axes):\n                        if not is_list_like_indexer(value):\n                            raise ValueError(\n                                \"cannot set a frame with no \"\n                                \"defined index and a scalar\"\n                            )\n                        self.obj[key] = value\n                        return self.obj\n\n                    # add a new item with the dtype setup\n                    self.obj[key] = _infer_fill_value(value)\n\n                    new_indexer = convert_from_missing_indexer_tuple(\n                        indexer, self.obj.axes\n                    )\n                    self._setitem_with_indexer(new_indexer, value)\n\n                    return self.obj\n\n                # reindex the axis\n                # make sure to clear the cache because we are\n                # just replacing the block manager here\n                # so the object is the same\n                index = self.obj._get_axis(i)\n                labels = index.insert(len(index), key)\n                self.obj._data = self.obj.reindex(labels, axis=i)._data\n                self.obj._maybe_update_cacher(clear=True)\n                self.obj._is_copy = None\n\n                nindexer.append(labels.get_loc(key))\n\n            else:\n                nindexer.append(idx)\n\n        indexer = tuple(nindexer)\n    else:\n\n        indexer, missing = convert_missing_indexer(indexer)\n\n        if missing:\n            return self._setitem_with_indexer_missing(indexer, value)\n\n    # set\n    item_labels = self.obj._get_axis(info_axis)\n\n    # align and set the values\n    if take_split_path:\n        # Above we only set take_split_path to True for 2D cases\n        assert self.ndim == 2\n        assert info_axis == 1\n\n        if not isinstance(indexer, tuple):\n            indexer = _tuplify(self.ndim, indexer)\n\n        if isinstance(value, ABCSeries):\n            value = self._align_series(indexer, value)\n\n        info_idx = indexer[info_axis]\n        if is_integer(info_idx):\n            info_idx = [info_idx]\n        labels = item_labels[info_idx]\n\n        # if we have a partial multiindex, then need to adjust the plane\n        # indexer here\n        if len(labels) == 1 and isinstance(\n            self.obj[labels[0]].axes[0], ABCMultiIndex\n        ):\n            item = labels[0]\n            obj = self.obj[item]\n            index = obj.index\n            idx = indexer[:info_axis][0]\n\n            plane_indexer = tuple([idx]) + indexer[info_axis + 1 :]\n            lplane_indexer = length_of_indexer(plane_indexer[0], index)\n\n            # require that we are setting the right number of values that\n            # we are indexing\n            if (\n                is_list_like_indexer(value)\n                and np.iterable(value)\n                and lplane_indexer != len(value)\n            ):\n\n                if len(obj[idx]) != len(value):\n                    raise ValueError(\n                        \"cannot set using a multi-index \"\n                        \"selection indexer with a different \"\n                        \"length than the value\"\n                    )\n\n                # make sure we have an ndarray\n                value = getattr(value, \"values\", value).ravel()\n\n                # we can directly set the series here\n                # as we select a slice indexer on the mi\n                if isinstance(idx, slice):\n                    idx = index._convert_slice_indexer(idx)\n                obj._consolidate_inplace()\n                obj = obj.copy()\n                obj._data = obj._data.setitem(indexer=tuple([idx]), value=value)\n                self.obj[item] = obj\n                return\n\n        # non-mi\n        else:\n            plane_indexer = indexer[:info_axis] + indexer[info_axis + 1 :]\n            plane_axis = self.obj.axes[:info_axis][0]\n            lplane_indexer = length_of_indexer(plane_indexer[0], plane_axis)\n\n        def setter(item, v):\n            s = self.obj[item]\n            pi = plane_indexer[0] if lplane_indexer == 1 else plane_indexer\n\n            # perform the equivalent of a setitem on the info axis\n            # as we have a null slice or a slice with full bounds\n            # which means essentially reassign to the columns of a\n            # multi-dim object\n            # GH6149 (null slice), GH10408 (full bounds)\n            if isinstance(pi, tuple) and all(\n                com.is_null_slice(idx) or com.is_full_slice(idx, len(self.obj))\n                for idx in pi\n            ):\n                s = v\n            else:\n                # set the item, possibly having a dtype change\n                s._consolidate_inplace()\n                s = s.copy()\n                s._data = s._data.setitem(indexer=pi, value=v)\n                s._maybe_update_cacher(clear=True)\n\n            # reset the sliced object if unique\n            self.obj[item] = s\n\n        # we need an iterable, with a ndim of at least 1\n        # eg. don't pass through np.array(0)\n        if is_list_like_indexer(value) and getattr(value, \"ndim\", 1) > 0:\n\n            # we have an equal len Frame\n            if isinstance(value, ABCDataFrame):\n                sub_indexer = list(indexer)\n                multiindex_indexer = isinstance(labels, ABCMultiIndex)\n\n                for item in labels:\n                    if item in value:\n                        sub_indexer[info_axis] = item\n                        v = self._align_series(\n                            tuple(sub_indexer), value[item], multiindex_indexer\n                        )\n                    else:\n                        v = np.nan\n\n                    setter(item, v)\n\n            # we have an equal len ndarray/convertible to our labels\n            # hasattr first, to avoid coercing to ndarray without reason.\n            # But we may be relying on the ndarray coercion to check ndim.\n            # Why not just convert to an ndarray earlier on if needed?\n            elif np.ndim(value) == 2:\n\n                # note that this coerces the dtype if we are mixed\n                # GH 7551\n                value = np.array(value, dtype=object)\n                if len(labels) != value.shape[1]:\n                    raise ValueError(\n                        \"Must have equal len keys and value \"\n                        \"when setting with an ndarray\"\n                    )\n\n                for i, item in enumerate(labels):\n\n                    # setting with a list, recoerces\n                    setter(item, value[:, i].tolist())\n\n            # we have an equal len list/ndarray\n            elif _can_do_equal_len(\n                labels, value, plane_indexer, lplane_indexer, self.obj\n            ):\n                setter(labels[0], value)\n\n            # per label values\n            else:\n\n                if len(labels) != len(value):\n                    raise ValueError(\n                        \"Must have equal len keys and value \"\n                        \"when setting with an iterable\"\n                    )\n\n                for item, v in zip(labels, value):\n                    setter(item, v)\n        else:\n\n            # scalar\n            for item in labels:\n                setter(item, value)\n\n    else:\n        if isinstance(indexer, tuple):\n            indexer = maybe_convert_ix(*indexer)\n\n            # if we are setting on the info axis ONLY\n            # set using those methods to avoid block-splitting\n            # logic here\n            if (\n                len(indexer) > info_axis\n                and is_integer(indexer[info_axis])\n                and all(\n                    com.is_null_slice(idx)\n                    for i, idx in enumerate(indexer)\n                    if i != info_axis\n                )\n                and item_labels.is_unique\n            ):\n                self.obj[item_labels[indexer[info_axis]]] = value\n                return\n\n        if isinstance(value, (ABCSeries, dict)):\n            # TODO(EA): ExtensionBlock.setitem this causes issues with\n            # setting for extensionarrays that store dicts. Need to decide\n            # if it's worth supporting that.\n            value = self._align_series(indexer, Series(value))\n\n        elif isinstance(value, ABCDataFrame):\n            value = self._align_frame(indexer, value)\n\n        # check for chained assignment\n        self.obj._check_is_chained_assignment_possible()\n\n        # actually do the set\n        self.obj._consolidate_inplace()\n        self.obj._data = self.obj._data.setitem(indexer=indexer, value=value)\n        self.obj._maybe_update_cacher(clear=True)",
                "def _setitem_with_indexer_missing(self, indexer, value):\n    \"\"\"\n    Insert new row(s) or column(s) into the Series or DataFrame.\n    \"\"\"\n    from pandas import Series\n\n    # reindex the axis to the new value\n    # and set inplace\n    if self.ndim == 1:\n        index = self.obj.index\n        new_index = index.insert(len(index), indexer)\n\n        # we have a coerced indexer, e.g. a float\n        # that matches in an Int64Index, so\n        # we will not create a duplicate index, rather\n        # index to that element\n        # e.g. 0.0 -> 0\n        # GH#12246\n        if index.is_unique:\n            new_indexer = index.get_indexer([new_index[-1]])\n            if (new_indexer != -1).any():\n                return self._setitem_with_indexer(new_indexer, value)\n\n        # this preserves dtype of the value\n        new_values = Series([value])._values\n        if len(self.obj._values):\n            # GH#22717 handle casting compatibility that np.concatenate\n            #  does incorrectly\n            new_values = concat_compat([self.obj._values, new_values])\n        self.obj._data = self.obj._constructor(\n            new_values, index=new_index, name=self.obj.name\n        )._data\n        self.obj._maybe_update_cacher(clear=True)\n        return self.obj\n\n    elif self.ndim == 2:\n\n        if not len(self.obj.columns):\n            # no columns and scalar\n            raise ValueError(\"cannot set a frame with no defined columns\")\n\n        if isinstance(value, ABCSeries):\n            # append a Series\n            value = value.reindex(index=self.obj.columns, copy=True)\n            value.name = indexer\n\n        else:\n            # a list-list\n            if is_list_like_indexer(value):\n                # must have conforming columns\n                if len(value) != len(self.obj.columns):\n                    raise ValueError(\"cannot set a row with mismatched columns\")\n\n            value = Series(value, index=self.obj.columns, name=indexer)\n\n        self.obj._data = self.obj.append(value)._data\n        self.obj._maybe_update_cacher(clear=True)\n        return self.obj",
                "def _align_series(self, indexer, ser: ABCSeries, multiindex_indexer: bool = False):\n    \"\"\"\n    Parameters\n    ----------\n    indexer : tuple, slice, scalar\n        Indexer used to get the locations that will be set to `ser`.\n    ser : pd.Series\n        Values to assign to the locations specified by `indexer`.\n    multiindex_indexer : boolean, optional\n        Defaults to False. Should be set to True if `indexer` was from\n        a `pd.MultiIndex`, to avoid unnecessary broadcasting.\n\n    Returns\n    -------\n    `np.array` of `ser` broadcast to the appropriate shape for assignment\n    to the locations selected by `indexer`\n    \"\"\"\n    if isinstance(indexer, (slice, np.ndarray, list, Index)):\n        indexer = tuple([indexer])\n\n    if isinstance(indexer, tuple):\n\n        # flatten np.ndarray indexers\n        def ravel(i):\n            return i.ravel() if isinstance(i, np.ndarray) else i\n\n        indexer = tuple(map(ravel, indexer))\n\n        aligners = [not com.is_null_slice(idx) for idx in indexer]\n        sum_aligners = sum(aligners)\n        single_aligner = sum_aligners == 1\n        is_frame = self.ndim == 2\n        obj = self.obj\n\n        # are we a single alignable value on a non-primary\n        # dim (e.g. panel: 1,2, or frame: 0) ?\n        # hence need to align to a single axis dimension\n        # rather that find all valid dims\n\n        # frame\n        if is_frame:\n            single_aligner = single_aligner and aligners[0]\n\n        # we have a frame, with multiple indexers on both axes; and a\n        # series, so need to broadcast (see GH5206)\n        if sum_aligners == self.ndim and all(is_sequence(_) for _ in indexer):\n            ser = ser.reindex(obj.axes[0][indexer[0]], copy=True)._values\n\n            # single indexer\n            if len(indexer) > 1 and not multiindex_indexer:\n                len_indexer = len(indexer[1])\n                ser = np.tile(ser, len_indexer).reshape(len_indexer, -1).T\n\n            return ser\n\n        for i, idx in enumerate(indexer):\n            ax = obj.axes[i]\n\n            # multiple aligners (or null slices)\n            if is_sequence(idx) or isinstance(idx, slice):\n                if single_aligner and com.is_null_slice(idx):\n                    continue\n                new_ix = ax[idx]\n                if not is_list_like_indexer(new_ix):\n                    new_ix = Index([new_ix])\n                else:\n                    new_ix = Index(new_ix)\n                if ser.index.equals(new_ix) or not len(new_ix):\n                    return ser._values.copy()\n\n                return ser.reindex(new_ix)._values\n\n            # 2 dims\n            elif single_aligner:\n\n                # reindex along index\n                ax = self.obj.axes[1]\n                if ser.index.equals(ax) or not len(ax):\n                    return ser._values.copy()\n                return ser.reindex(ax)._values\n\n    elif is_scalar(indexer):\n        ax = self.obj._get_axis(1)\n\n        if ser.index.equals(ax):\n            return ser._values.copy()\n\n        return ser.reindex(ax)._values\n\n    raise ValueError(\"Incompatible indexer with Series\")",
                "def _align_frame(self, indexer, df: ABCDataFrame):\n    is_frame = self.ndim == 2\n\n    if isinstance(indexer, tuple):\n\n        idx, cols = None, None\n        sindexers = []\n        for i, ix in enumerate(indexer):\n            ax = self.obj.axes[i]\n            if is_sequence(ix) or isinstance(ix, slice):\n                if isinstance(ix, np.ndarray):\n                    ix = ix.ravel()\n                if idx is None:\n                    idx = ax[ix]\n                elif cols is None:\n                    cols = ax[ix]\n                else:\n                    break\n            else:\n                sindexers.append(i)\n\n        if idx is not None and cols is not None:\n\n            if df.index.equals(idx) and df.columns.equals(cols):\n                val = df.copy()._values\n            else:\n                val = df.reindex(idx, columns=cols)._values\n            return val\n\n    elif (isinstance(indexer, slice) or is_list_like_indexer(indexer)) and is_frame:\n        ax = self.obj.index[indexer]\n        if df.index.equals(ax):\n            val = df.copy()._values\n        else:\n\n            # we have a multi-index and are trying to align\n            # with a particular, level GH3738\n            if (\n                isinstance(ax, ABCMultiIndex)\n                and isinstance(df.index, ABCMultiIndex)\n                and ax.nlevels != df.index.nlevels\n            ):\n                raise TypeError(\n                    \"cannot align on a multi-index with out \"\n                    \"specifying the join levels\"\n                )\n\n            val = df.reindex(index=ax)._values\n        return val\n\n    raise ValueError(\"Incompatible indexer with DataFrame\")",
                "def _getitem_tuple(self, tup: Tuple):\n    try:\n        return self._getitem_lowerdim(tup)\n    except IndexingError:\n        pass\n\n    # no multi-index, so validate all of the indexers\n    self._has_valid_tuple(tup)\n\n    # ugly hack for GH #836\n    if self._multi_take_opportunity(tup):\n        return self._multi_take(tup)\n\n    # no shortcut needed\n    retval = self.obj\n    for i, key in enumerate(tup):\n        if com.is_null_slice(key):\n            continue\n\n        retval = getattr(retval, self.name)._getitem_axis(key, axis=i)\n\n    return retval",
                "def _multi_take_opportunity(self, tup: Tuple) -> bool:\n    \"\"\"\n    Check whether there is the possibility to use ``_multi_take``.\n\n    Currently the limit is that all axes being indexed, must be indexed with\n    list-likes.\n\n    Parameters\n    ----------\n    tup : tuple\n        Tuple of indexers, one per axis.\n\n    Returns\n    -------\n    bool\n        Whether the current indexing,\n        can be passed through `_multi_take`.\n    \"\"\"\n    if not all(is_list_like_indexer(x) for x in tup):\n        return False\n\n    # just too complicated\n    if any(com.is_bool_indexer(x) for x in tup):\n        return False\n\n    return True",
                "def _multi_take(self, tup: Tuple):\n    \"\"\"\n    Create the indexers for the passed tuple of keys, and\n    executes the take operation. This allows the take operation to be\n    executed all at once, rather than once for each dimension.\n    Improving efficiency.\n\n    Parameters\n    ----------\n    tup : tuple\n        Tuple of indexers, one per axis.\n\n    Returns\n    -------\n    values: same type as the object being indexed\n    \"\"\"\n    # GH 836\n    o = self.obj\n    d = {\n        axis: self._get_listlike_indexer(key, axis)\n        for (key, axis) in zip(tup, o._AXIS_ORDERS)\n    }\n    return o._reindex_with_indexers(d, copy=True, allow_dups=True)",
                "def _handle_lowerdim_multi_index_axis0(self, tup: Tuple):\n    # we have an axis0 multi-index, handle or raise\n    axis = self.axis or 0\n    try:\n        # fast path for series or for tup devoid of slices\n        return self._get_label(tup, axis=axis)\n    except TypeError:\n        # slices are unhashable\n        pass\n    except KeyError as ek:\n        # raise KeyError if number of indexers match\n        # else IndexingError will be raised\n        if len(tup) <= self.obj.index.nlevels and len(tup) > self.ndim:\n            raise ek\n\n    return None",
                "def _getitem_lowerdim(self, tup: Tuple):\n\n    # we can directly get the axis result since the axis is specified\n    if self.axis is not None:\n        axis = self.obj._get_axis_number(self.axis)\n        return self._getitem_axis(tup, axis=axis)\n\n    # we may have a nested tuples indexer here\n    if self._is_nested_tuple_indexer(tup):\n        return self._getitem_nested_tuple(tup)\n\n    # we maybe be using a tuple to represent multiple dimensions here\n    ax0 = self.obj._get_axis(0)\n    # ...but iloc should handle the tuple as simple integer-location\n    # instead of checking it as multiindex representation (GH 13797)\n    if isinstance(ax0, ABCMultiIndex) and self.name != \"iloc\":\n        result = self._handle_lowerdim_multi_index_axis0(tup)\n        if result is not None:\n            return result\n\n    if len(tup) > self.ndim:\n        raise IndexingError(\"Too many indexers. handle elsewhere\")\n\n    for i, key in enumerate(tup):\n        if is_label_like(key) or isinstance(key, tuple):\n            section = self._getitem_axis(key, axis=i)\n\n            # we have yielded a scalar ?\n            if not is_list_like_indexer(section):\n                return section\n\n            elif section.ndim == self.ndim:\n                # we're in the middle of slicing through a MultiIndex\n                # revise the key wrt to `section` by inserting an _NS\n                new_key = tup[:i] + (_NS,) + tup[i + 1 :]\n\n            else:\n                new_key = tup[:i] + tup[i + 1 :]\n\n                # unfortunately need an odious kludge here because of\n                # DataFrame transposing convention\n                if (\n                    isinstance(section, ABCDataFrame)\n                    and i > 0\n                    and len(new_key) == 2\n                ):\n                    a, b = new_key\n                    new_key = b, a\n\n                if len(new_key) == 1:\n                    new_key = new_key[0]\n\n            # Slices should return views, but calling iloc/loc with a null\n            # slice returns a new object.\n            if com.is_null_slice(new_key):\n                return section\n            # This is an elided recursive call to iloc/loc/etc'\n            return getattr(section, self.name)[new_key]\n\n    raise IndexingError(\"not applicable\")",
                "def _getitem_nested_tuple(self, tup: Tuple):\n    # we have a nested tuple so have at least 1 multi-index level\n    # we should be able to match up the dimensionality here\n\n    # we have too many indexers for our dim, but have at least 1\n    # multi-index dimension, try to see if we have something like\n    # a tuple passed to a series with a multi-index\n    if len(tup) > self.ndim:\n        result = self._handle_lowerdim_multi_index_axis0(tup)\n        if result is not None:\n            return result\n\n        # this is a series with a multi-index specified a tuple of\n        # selectors\n        axis = self.axis or 0\n        return self._getitem_axis(tup, axis=axis)\n\n    # handle the multi-axis by taking sections and reducing\n    # this is iterative\n    obj = self.obj\n    axis = 0\n    for i, key in enumerate(tup):\n\n        if com.is_null_slice(key):\n            axis += 1\n            continue\n\n        current_ndim = obj.ndim\n        obj = getattr(obj, self.name)._getitem_axis(key, axis=axis)\n        axis += 1\n\n        # if we have a scalar, we are done\n        if is_scalar(obj) or not hasattr(obj, \"ndim\"):\n            break\n\n        # has the dim of the obj changed?\n        # GH 7199\n        if obj.ndim < current_ndim:\n            axis -= 1\n\n    return obj",
                "def _get_listlike_indexer(self, key, axis: int, raise_missing: bool = False):\n    \"\"\"\n    Transform a list-like of keys into a new index and an indexer.\n\n    Parameters\n    ----------\n    key : list-like\n        Targeted labels.\n    axis: int\n        Dimension on which the indexing is being made.\n    raise_missing: bool, default False\n        Whether to raise a KeyError if some labels were not found.\n        Will be removed in the future, and then this method will always behave as\n        if ``raise_missing=True``.\n\n    Raises\n    ------\n    KeyError\n        If at least one key was requested but none was found, and\n        raise_missing=True.\n\n    Returns\n    -------\n    keyarr: Index\n        New index (coinciding with 'key' if the axis is unique).\n    values : array-like\n        Indexer for the return object, -1 denotes keys not found.\n    \"\"\"\n    o = self.obj\n    ax = o._get_axis(axis)\n\n    # Have the index compute an indexer or return None\n    # if it cannot handle:\n    assert self.name == \"loc\"\n    indexer, keyarr = ax._convert_listlike_indexer(key)\n    # We only act on all found values:\n    if indexer is not None and (indexer != -1).all():\n        self._validate_read_indexer(key, indexer, axis, raise_missing=raise_missing)\n        return ax[indexer], indexer\n\n    if ax.is_unique and not getattr(ax, \"is_overlapping\", False):\n        indexer = ax.get_indexer_for(key)\n        keyarr = ax.reindex(keyarr)[0]\n    else:\n        keyarr, indexer, new_indexer = ax._reindex_non_unique(keyarr)\n\n    self._validate_read_indexer(keyarr, indexer, axis, raise_missing=raise_missing)\n    return keyarr, indexer",
                "def _getitem_iterable(self, key, axis: int):\n    \"\"\"\n    Index current object with an an iterable collection of keys.\n\n    Parameters\n    ----------\n    key : iterable\n        Targeted labels.\n    axis: int\n        Dimension on which the indexing is being made.\n\n    Raises\n    ------\n    KeyError\n        If no key was found. Will change in the future to raise if not all\n        keys were found.\n\n    Returns\n    -------\n    scalar, DataFrame, or Series: indexed value(s).\n    \"\"\"\n    # we assume that not com.is_bool_indexer(key), as that is\n    #  handled before we get here.\n    self._validate_key(key, axis)\n\n    # A collection of keys\n    keyarr, indexer = self._get_listlike_indexer(key, axis, raise_missing=False)\n    return self.obj._reindex_with_indexers(\n        {axis: [keyarr, indexer]}, copy=True, allow_dups=True\n    )",
                "def _validate_read_indexer(\n    self, key, indexer, axis: int, raise_missing: bool = False\n):\n    \"\"\"\n    Check that indexer can be used to return a result.\n\n    e.g. at least one element was found,\n    unless the list of keys was actually empty.\n\n    Parameters\n    ----------\n    key : list-like\n        Targeted labels (only used to show correct error message).\n    indexer: array-like of booleans\n        Indices corresponding to the key,\n        (with -1 indicating not found).\n    axis: int\n        Dimension on which the indexing is being made.\n    raise_missing: bool\n        Whether to raise a KeyError if some labels are not found. Will be\n        removed in the future, and then this method will always behave as\n        if raise_missing=True.\n\n    Raises\n    ------\n    KeyError\n        If at least one key was requested but none was found, and\n        raise_missing=True.\n    \"\"\"\n    ax = self.obj._get_axis(axis)\n\n    if len(key) == 0:\n        return\n\n    # Count missing values:\n    missing = (indexer < 0).sum()\n\n    if missing:\n        if missing == len(indexer):\n            axis_name = self.obj._get_axis_name(axis)\n            raise KeyError(f\"None of [{key}] are in the [{axis_name}]\")\n\n        # We (temporarily) allow for some missing keys with .loc, except in\n        # some cases (e.g. setting) in which \"raise_missing\" will be False\n        if not (self.name == \"loc\" and not raise_missing):\n            not_found = list(set(key) - set(ax))\n            raise KeyError(f\"{not_found} not in index\")\n\n        # we skip the warning on Categorical/Interval\n        # as this check is actually done (check for\n        # non-missing values), but a bit later in the\n        # code, so we want to avoid warning & then\n        # just raising\n        if not (ax.is_categorical() or ax.is_interval()):\n            raise KeyError(\n                \"Passing list-likes to .loc or [] with any missing labels \"\n                \"is no longer supported, see \"\n                \"https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#deprecate-loc-reindex-listlike\"  # noqa:E501\n            )",
                "def _convert_to_indexer(self, key, axis: int, is_setter: bool = False):\n    raise AbstractMethodError(self)",
                "def __getitem__(self, key):\n    if type(key) is tuple:\n        key = tuple(com.apply_if_callable(x, self.obj) for x in key)\n        if self._is_scalar_access(key):\n            try:\n                return self.obj._get_value(*key, takeable=self._takeable)\n            except (KeyError, IndexError, AttributeError):\n                # AttributeError for IntervalTree get_value\n                pass\n        return self._getitem_tuple(key)\n    else:\n        # we by definition only have the 0th axis\n        axis = self.axis or 0\n\n        maybe_callable = com.apply_if_callable(key, self.obj)\n        return self._getitem_axis(maybe_callable, axis=axis)",
                "def _is_scalar_access(self, key: Tuple):\n    raise NotImplementedError()",
                "def _getitem_axis(self, key, axis: int):\n    raise NotImplementedError()",
                "def _getbool_axis(self, key, axis: int):\n    # caller is responsible for ensuring non-None axis\n    labels = self.obj._get_axis(axis)\n    key = check_bool_indexer(labels, key)\n    inds = key.nonzero()[0]\n    return self.obj._take_with_is_copy(inds, axis=axis)",
                "@Appender(_LocationIndexer._validate_key.__doc__)\ndef _validate_key(self, key, axis: int):\n\n    # valid for a collection of labels (we check their presence later)\n    # slice of labels (where start-end in labels)\n    # slice of integers (only if in the labels)\n    # boolean\n\n    if isinstance(key, slice):\n        return\n\n    if com.is_bool_indexer(key):\n        return\n\n    if not is_list_like_indexer(key):\n        labels = self.obj._get_axis(axis)\n        labels._convert_scalar_indexer(key, kind=\"loc\")",
                "def _is_scalar_access(self, key: Tuple) -> bool:\n    \"\"\"\n    Returns\n    -------\n    bool\n    \"\"\"\n    # this is a shortcut accessor to both .loc and .iloc\n    # that provide the equivalent access of .at and .iat\n    # a) avoid getting things via sections and (to minimize dtype changes)\n    # b) provide a performant path\n    if len(key) != self.ndim:\n        return False\n\n    for i, k in enumerate(key):\n        if not is_scalar(k):\n            return False\n\n        ax = self.obj.axes[i]\n        if isinstance(ax, ABCMultiIndex):\n            return False\n\n        if isinstance(k, str) and ax._supports_partial_string_indexing:\n            # partial string indexing, df.loc['2000', 'A']\n            # should not be considered scalar\n            return False\n\n        if not ax.is_unique:\n            return False\n\n    return True",
                "def _get_partial_string_timestamp_match_key(self, key, labels):\n    \"\"\"\n    Translate any partial string timestamp matches in key, returning the\n    new key.\n\n    (GH 10331)\n    \"\"\"\n    if isinstance(labels, ABCMultiIndex):\n        if (\n            isinstance(key, str)\n            and labels.levels[0]._supports_partial_string_indexing\n        ):\n            # Convert key '2016-01-01' to\n            # ('2016-01-01'[, slice(None, None, None)]+)\n            key = tuple([key] + [slice(None)] * (len(labels.levels) - 1))\n\n        if isinstance(key, tuple):\n            # Convert (..., '2016-01-01', ...) in tuple to\n            # (..., slice('2016-01-01', '2016-01-01', None), ...)\n            new_key = []\n            for i, component in enumerate(key):\n                if (\n                    isinstance(component, str)\n                    and labels.levels[i]._supports_partial_string_indexing\n                ):\n                    new_key.append(slice(component, component, None))\n                else:\n                    new_key.append(component)\n            key = tuple(new_key)\n\n    return key",
                "def _getitem_axis(self, key, axis: int):\n    key = item_from_zerodim(key)\n    if is_iterator(key):\n        key = list(key)\n\n    labels = self.obj._get_axis(axis)\n    key = self._get_partial_string_timestamp_match_key(key, labels)\n\n    if isinstance(key, slice):\n        self._validate_key(key, axis)\n        return self._get_slice_axis(key, axis=axis)\n    elif com.is_bool_indexer(key):\n        return self._getbool_axis(key, axis=axis)\n    elif is_list_like_indexer(key):\n\n        # convert various list-like indexers\n        # to a list of keys\n        # we will use the *values* of the object\n        # and NOT the index if its a PandasObject\n        if isinstance(labels, ABCMultiIndex):\n\n            if isinstance(key, (ABCSeries, np.ndarray)) and key.ndim <= 1:\n                # Series, or 0,1 ndim ndarray\n                # GH 14730\n                key = list(key)\n            elif isinstance(key, ABCDataFrame):\n                # GH 15438\n                raise NotImplementedError(\n                    \"Indexing a MultiIndex with a \"\n                    \"DataFrame key is not \"\n                    \"implemented\"\n                )\n            elif hasattr(key, \"ndim\") and key.ndim > 1:\n                raise NotImplementedError(\n                    \"Indexing a MultiIndex with a \"\n                    \"multidimensional key is not \"\n                    \"implemented\"\n                )\n\n            if (\n                not isinstance(key, tuple)\n                and len(key)\n                and not isinstance(key[0], tuple)\n            ):\n                key = tuple([key])\n\n        # an iterable multi-selection\n        if not (isinstance(key, tuple) and isinstance(labels, ABCMultiIndex)):\n\n            if hasattr(key, \"ndim\") and key.ndim > 1:\n                raise ValueError(\"Cannot index with multidimensional key\")\n\n            return self._getitem_iterable(key, axis=axis)\n\n        # nested tuple slicing\n        if is_nested_tuple(key, labels):\n            locs = labels.get_locs(key)\n            indexer = [slice(None)] * self.ndim\n            indexer[axis] = locs\n            return self.obj.iloc[tuple(indexer)]\n\n    # fall thru to straight lookup\n    self._validate_key(key, axis)\n    return self._get_label(key, axis=axis)",
                "def _get_slice_axis(self, slice_obj: slice, axis: int):\n    \"\"\"\n    This is pretty simple as we just have to deal with labels.\n    \"\"\"\n    # caller is responsible for ensuring non-None axis\n    obj = self.obj\n    if not need_slice(slice_obj):\n        return obj.copy(deep=False)\n\n    labels = obj._get_axis(axis)\n    indexer = labels.slice_indexer(\n        slice_obj.start, slice_obj.stop, slice_obj.step, kind=self.name\n    )\n\n    if isinstance(indexer, slice):\n        return self.obj._slice(indexer, axis=axis, kind=\"iloc\")\n    else:\n        # DatetimeIndex overrides Index.slice_indexer and may\n        #  return a DatetimeIndex instead of a slice object.\n        return self.obj.take(indexer, axis=axis)",
                "def _convert_to_indexer(self, key, axis: int, is_setter: bool = False):\n    \"\"\"\n    Convert indexing key into something we can use to do actual fancy\n    indexing on a ndarray.\n\n    Examples\n    ix[:5] -> slice(0, 5)\n    ix[[1,2,3]] -> [1,2,3]\n    ix[['foo', 'bar', 'baz']] -> [i, j, k] (indices of foo, bar, baz)\n\n    Going by Zen of Python?\n    'In the face of ambiguity, refuse the temptation to guess.'\n    raise AmbiguousIndexError with integer labels?\n    - No, prefer label-based indexing\n    \"\"\"\n    labels = self.obj._get_axis(axis)\n\n    if isinstance(key, slice):\n        return labels._convert_slice_indexer(key, kind=\"loc\")\n\n    if is_scalar(key):\n        # try to find out correct indexer, if not type correct raise\n        try:\n            key = labels._convert_scalar_indexer(key, kind=\"loc\")\n        except TypeError:\n            # but we will allow setting\n            if not is_setter:\n                raise\n\n    # see if we are positional in nature\n    is_int_index = labels.is_integer()\n    is_int_positional = is_integer(key) and not is_int_index\n\n    if is_scalar(key) or isinstance(labels, ABCMultiIndex):\n        # Otherwise get_loc will raise InvalidIndexError\n\n        # if we are a label return me\n        try:\n            return labels.get_loc(key)\n        except LookupError:\n            if isinstance(key, tuple) and isinstance(labels, ABCMultiIndex):\n                if len(key) == labels.nlevels:\n                    return {\"key\": key}\n                raise\n        except TypeError:\n            pass\n        except ValueError:\n            if not is_int_positional:\n                raise\n\n    # a positional\n    if is_int_positional:\n\n        # if we are setting and its not a valid location\n        # its an insert which fails by definition\n\n        # always valid\n        return {\"key\": key}\n\n    if is_nested_tuple(key, labels):\n        return labels.get_locs(key)\n\n    elif is_list_like_indexer(key):\n\n        if com.is_bool_indexer(key):\n            key = check_bool_indexer(labels, key)\n            (inds,) = key.nonzero()\n            return inds\n        else:\n            # When setting, missing keys are not allowed, even with .loc:\n            return self._get_listlike_indexer(key, axis, raise_missing=True)[1]\n    else:\n        try:\n            return labels.get_loc(key)\n        except LookupError:\n            # allow a not found key only if we are a setter\n            if not is_list_like_indexer(key):\n                return {\"key\": key}\n            raise",
                "def _validate_key(self, key, axis: int):\n    if com.is_bool_indexer(key):\n        if hasattr(key, \"index\") and isinstance(key.index, Index):\n            if key.index.inferred_type == \"integer\":\n                raise NotImplementedError(\n                    \"iLocation based boolean \"\n                    \"indexing on an integer type \"\n                    \"is not available\"\n                )\n            raise ValueError(\n                \"iLocation based boolean indexing cannot use \"\n                \"an indexable as a mask\"\n            )\n        return\n\n    if isinstance(key, slice):\n        return\n    elif is_integer(key):\n        self._validate_integer(key, axis)\n    elif isinstance(key, tuple):\n        # a tuple should already have been caught by this point\n        # so don't treat a tuple as a valid indexer\n        raise IndexingError(\"Too many indexers\")\n    elif is_list_like_indexer(key):\n        arr = np.array(key)\n        len_axis = len(self.obj._get_axis(axis))\n\n        # check that the key has a numeric dtype\n        if not is_numeric_dtype(arr.dtype):\n            raise IndexError(f\".iloc requires numeric indexers, got {arr}\")\n\n        # check that the key does not exceed the maximum size of the index\n        if len(arr) and (arr.max() >= len_axis or arr.min() < -len_axis):\n            raise IndexError(\"positional indexers are out-of-bounds\")\n    else:\n        raise ValueError(f\"Can only index by location with a [{self._valid_types}]\")",
                "def _has_valid_setitem_indexer(self, indexer):\n    self._has_valid_positional_setitem_indexer(indexer)",
                "def _is_scalar_access(self, key: Tuple) -> bool:\n    \"\"\"\n    Returns\n    -------\n    bool\n    \"\"\"\n    # this is a shortcut accessor to both .loc and .iloc\n    # that provide the equivalent access of .at and .iat\n    # a) avoid getting things via sections and (to minimize dtype changes)\n    # b) provide a performant path\n    if len(key) != self.ndim:\n        return False\n\n    for i, k in enumerate(key):\n        if not is_integer(k):\n            return False\n\n        ax = self.obj.axes[i]\n        if not ax.is_unique:\n            return False\n\n    return True",
                "def _validate_integer(self, key: int, axis: int) -> None:\n    \"\"\"\n    Check that 'key' is a valid position in the desired axis.\n\n    Parameters\n    ----------\n    key : int\n        Requested position.\n    axis : int\n        Desired axis.\n\n    Raises\n    ------\n    IndexError\n        If 'key' is not a valid position in axis 'axis'.\n    \"\"\"\n    len_axis = len(self.obj._get_axis(axis))\n    if key >= len_axis or key < -len_axis:\n        raise IndexError(\"single positional indexer is out-of-bounds\")",
                "def _getitem_tuple(self, tup: Tuple):\n\n    self._has_valid_tuple(tup)\n    try:\n        return self._getitem_lowerdim(tup)\n    except IndexingError:\n        pass\n\n    retval = self.obj\n    axis = 0\n    for i, key in enumerate(tup):\n        if com.is_null_slice(key):\n            axis += 1\n            continue\n\n        retval = getattr(retval, self.name)._getitem_axis(key, axis=axis)\n\n        # if the dim was reduced, then pass a lower-dim the next time\n        if retval.ndim < self.ndim:\n            # TODO: this is never reached in tests; can we confirm that\n            #  it is impossible?\n            axis -= 1\n\n        # try to get for the next axis\n        axis += 1\n\n    return retval",
                "def _get_list_axis(self, key, axis: int):\n    \"\"\"\n    Return Series values by list or array of integers.\n\n    Parameters\n    ----------\n    key : list-like positional indexer\n    axis : int\n\n    Returns\n    -------\n    Series object\n\n    Notes\n    -----\n    `axis` can only be zero.\n    \"\"\"\n    try:\n        return self.obj._take_with_is_copy(key, axis=axis)\n    except IndexError:\n        # re-raise with different error message\n        raise IndexError(\"positional indexers are out-of-bounds\")",
                "def _getitem_axis(self, key, axis: int):\n    if isinstance(key, slice):\n        return self._get_slice_axis(key, axis=axis)\n\n    if isinstance(key, list):\n        key = np.asarray(key)\n\n    if com.is_bool_indexer(key):\n        self._validate_key(key, axis)\n        return self._getbool_axis(key, axis=axis)\n\n    # a list of integers\n    elif is_list_like_indexer(key):\n        return self._get_list_axis(key, axis=axis)\n\n    # a single integer\n    else:\n        key = item_from_zerodim(key)\n        if not is_integer(key):\n            raise TypeError(\"Cannot index by location index with a non-integer key\")\n\n        # validate the location\n        self._validate_integer(key, axis)\n\n        return self.obj._ixs(key, axis=axis)",
                "def _get_slice_axis(self, slice_obj: slice, axis: int):\n    # caller is responsible for ensuring non-None axis\n    obj = self.obj\n\n    if not need_slice(slice_obj):\n        return obj.copy(deep=False)\n\n    labels = obj._get_axis(axis)\n    indexer = labels._convert_slice_indexer(slice_obj, kind=\"iloc\")\n    return self.obj._slice(indexer, axis=axis, kind=\"iloc\")",
                "def _convert_to_indexer(self, key, axis: int, is_setter: bool = False):\n    \"\"\"\n    Much simpler as we only have to deal with our valid types.\n    \"\"\"\n    labels = self.obj._get_axis(axis)\n\n    # make need to convert a float key\n    if isinstance(key, slice):\n        return labels._convert_slice_indexer(key, kind=\"iloc\")\n\n    elif is_float(key):\n        return labels._convert_scalar_indexer(key, kind=\"iloc\")\n\n    self._validate_key(key, axis)\n    return key",
                "def _convert_key(self, key, is_setter: bool = False):\n    raise AbstractMethodError(self)",
                "def __getitem__(self, key):\n    if not isinstance(key, tuple):\n\n        # we could have a convertible item here (e.g. Timestamp)\n        if not is_list_like_indexer(key):\n            key = tuple([key])\n        else:\n            raise ValueError(\"Invalid call for scalar access (getting)!\")\n\n    key = self._convert_key(key)\n    return self.obj._get_value(*key, takeable=self._takeable)",
                "def __setitem__(self, key, value):\n    if isinstance(key, tuple):\n        key = tuple(com.apply_if_callable(x, self.obj) for x in key)\n    else:\n        # scalar callable may return tuple\n        key = com.apply_if_callable(key, self.obj)\n\n    if not isinstance(key, tuple):\n        key = _tuplify(self.ndim, key)\n    if len(key) != self.ndim:\n        raise ValueError(\"Not enough indexers for scalar access (setting)!\")\n    key = list(self._convert_key(key, is_setter=True))\n    self.obj._set_value(*key, value=value, takeable=self._takeable)",
                "def _convert_key(self, key, is_setter: bool = False):\n    \"\"\"\n    Require they keys to be the same type as the index. (so we don't\n    fallback)\n    \"\"\"\n    # allow arbitrary setting\n    if is_setter:\n        return list(key)\n\n    for ax, i in zip(self.obj.axes, key):\n        if ax.is_integer():\n            if not is_integer(i):\n                raise ValueError(\n                    \"At based indexing on an integer index \"\n                    \"can only have integer indexers\"\n                )\n        else:\n            if is_integer(i) and not (ax.holds_integer() or ax.is_floating()):\n                raise ValueError(\n                    \"At based indexing on an non-integer \"\n                    \"index can only have non-integer \"\n                    \"indexers\"\n                )\n    return key",
                "def _convert_key(self, key, is_setter: bool = False):\n    \"\"\"\n    Require integer args. (and convert to label arguments)\n    \"\"\"\n    for a, i in zip(self.obj.axes, key):\n        if not is_integer(i):\n            raise ValueError(\"iAt based indexing can only have integer indexers\")\n    return key",
                "def get_indexer(_i, _idx):\n    return axes[_i].get_loc(_idx[\"key\"]) if isinstance(_idx, dict) else _idx",
                "def pred(part) -> bool:\n    \"\"\"\n    Returns\n    -------\n    bool\n        True if slice does *not* reduce,\n        False if `part` is a tuple.\n    \"\"\"\n    # true when slice does *not* reduce, False when part is a tuple,\n    # i.e. MultiIndex slice\n    return (isinstance(part, slice) or is_list_like(part)) and not isinstance(\n        part, tuple\n    )",
                "def setter(item, v):\n    s = self.obj[item]\n    pi = plane_indexer[0] if lplane_indexer == 1 else plane_indexer\n\n    # perform the equivalent of a setitem on the info axis\n    # as we have a null slice or a slice with full bounds\n    # which means essentially reassign to the columns of a\n    # multi-dim object\n    # GH6149 (null slice), GH10408 (full bounds)\n    if isinstance(pi, tuple) and all(\n        com.is_null_slice(idx) or com.is_full_slice(idx, len(self.obj))\n        for idx in pi\n    ):\n        s = v\n    else:\n        # set the item, possibly having a dtype change\n        s._consolidate_inplace()\n        s = s.copy()\n        s._data = s._data.setitem(indexer=pi, value=v)\n        s._maybe_update_cacher(clear=True)\n\n    # reset the sliced object if unique\n    self.obj[item] = s",
                "def ravel(i):\n    return i.ravel() if isinstance(i, np.ndarray) else i"
            ],
            "inscope_function_signatures": [
                "_tuplify(ndim: int, loc: Hashable) -> Tuple[Union[Hashable, slice], ...]",
                "convert_to_index_sliceable(obj, key)",
                "check_bool_indexer(index: Index, key) -> np.ndarray",
                "convert_missing_indexer(indexer)",
                "convert_from_missing_indexer_tuple(indexer, axes)",
                "maybe_convert_ix(*args)",
                "is_nested_tuple(tup, labels) -> bool",
                "is_label_like(key) -> bool",
                "need_slice(obj) -> bool",
                "_non_reducing_slice(slice_)",
                "_maybe_numeric_slice(df, slice_, include_bool=False)",
                "_can_do_equal_len(labels, value, plane_indexer, lplane_indexer, obj) -> bool",
                "__getitem__(self, arg)",
                "iloc(self) -> '_iLocIndexer'",
                "loc(self) -> '_LocIndexer'",
                "at(self) -> '_AtIndexer'",
                "iat(self) -> '_iAtIndexer'",
                "__call__(self, axis=None)",
                "_get_label(self, label, axis: int)",
                "_get_setitem_indexer(self, key)",
                "__setitem__(self, key, value)",
                "_validate_key(self, key, axis: int)",
                "_has_valid_tuple(self, key: Tuple)",
                "_is_nested_tuple_indexer(self, tup: Tuple) -> bool",
                "_convert_tuple(self, key, is_setter: bool=False)",
                "_has_valid_setitem_indexer(self, indexer) -> bool",
                "_has_valid_positional_setitem_indexer(self, indexer) -> bool",
                "_setitem_with_indexer(self, indexer, value)",
                "_setitem_with_indexer_missing(self, indexer, value)",
                "_align_series(self, indexer, ser: ABCSeries, multiindex_indexer: bool=False)",
                "_align_frame(self, indexer, df: ABCDataFrame)",
                "_getitem_tuple(self, tup: Tuple)",
                "_multi_take_opportunity(self, tup: Tuple) -> bool",
                "_multi_take(self, tup: Tuple)",
                "_handle_lowerdim_multi_index_axis0(self, tup: Tuple)",
                "_getitem_lowerdim(self, tup: Tuple)",
                "_getitem_nested_tuple(self, tup: Tuple)",
                "_get_listlike_indexer(self, key, axis: int, raise_missing: bool=False)",
                "_getitem_iterable(self, key, axis: int)",
                "_validate_read_indexer(self, key, indexer, axis: int, raise_missing: bool=False)",
                "_convert_to_indexer(self, key, axis: int, is_setter: bool=False)",
                "__getitem__(self, key)",
                "_is_scalar_access(self, key: Tuple)",
                "_getitem_axis(self, key, axis: int)",
                "_getbool_axis(self, key, axis: int)",
                "_validate_key(self, key, axis: int)",
                "_is_scalar_access(self, key: Tuple) -> bool",
                "_get_partial_string_timestamp_match_key(self, key, labels)",
                "_getitem_axis(self, key, axis: int)",
                "_get_slice_axis(self, slice_obj: slice, axis: int)",
                "_convert_to_indexer(self, key, axis: int, is_setter: bool=False)",
                "_validate_key(self, key, axis: int)",
                "_has_valid_setitem_indexer(self, indexer)",
                "_is_scalar_access(self, key: Tuple) -> bool",
                "_validate_integer(self, key: int, axis: int) -> None",
                "_getitem_tuple(self, tup: Tuple)",
                "_get_list_axis(self, key, axis: int)",
                "_getitem_axis(self, key, axis: int)",
                "_get_slice_axis(self, slice_obj: slice, axis: int)",
                "_convert_to_indexer(self, key, axis: int, is_setter: bool=False)",
                "_convert_key(self, key, is_setter: bool=False)",
                "__getitem__(self, key)",
                "__setitem__(self, key, value)",
                "_convert_key(self, key, is_setter: bool=False)",
                "_convert_key(self, key, is_setter: bool=False)",
                "get_indexer(_i, _idx)",
                "pred(part) -> bool",
                "setter(item, v)",
                "ravel(i)"
            ],
            "variables_in_file": {
                "_NS": [
                    33,
                    1346
                ],
                "slice": [
                    1672,
                    2318,
                    2323,
                    1687,
                    1178,
                    33,
                    1198,
                    690,
                    1989,
                    1606,
                    1095,
                    1736,
                    2121,
                    717,
                    589,
                    1869,
                    1744,
                    2135,
                    2136,
                    2266,
                    1758,
                    2014,
                    2146,
                    2279,
                    2032,
                    881,
                    1137,
                    1782,
                    1661
                ],
                "arg": [
                    2244,
                    2245,
                    79
                ],
                "IndexSlice": [
                    82,
                    2306,
                    2343
                ],
                "_IndexSlice": [
                    82
                ],
                "Exception": [
                    85
                ],
                "_iLocIndexer": [
                    229
                ],
                "self": [
                    2048,
                    1027,
                    1028,
                    1539,
                    518,
                    2059,
                    2060,
                    1040,
                    2064,
                    2067,
                    1044,
                    1556,
                    2070,
                    1047,
                    1048,
                    1049,
                    1560,
                    1051,
                    1052,
                    1561,
                    1054,
                    1563,
                    1056,
                    1567,
                    1570,
                    2074,
                    1572,
                    1573,
                    1062,
                    2090,
                    1069,
                    1583,
                    1072,
                    1074,
                    1075,
                    1076,
                    1586,
                    566,
                    575,
                    578,
                    2115,
                    583,
                    588,
                    1613,
                    592,
                    595,
                    596,
                    1109,
                    598,
                    1110,
                    600,
                    1626,
                    609,
                    1633,
                    1123,
                    617,
                    627,
                    629,
                    630,
                    631,
                    1154,
                    1160,
                    653,
                    1170,
                    660,
                    1684,
                    1685,
                    663,
                    1688,
                    1177,
                    1689,
                    667,
                    1691,
                    676,
                    677,
                    682,
                    683,
                    684,
                    687,
                    1199,
                    2071,
                    693,
                    695,
                    2073,
                    1731,
                    1223,
                    712,
                    1736,
                    1738,
                    715,
                    716,
                    1228,
                    1741,
                    1231,
                    1232,
                    1742,
                    1235,
                    1749,
                    726,
                    1240,
                    729,
                    1755,
                    734,
                    1759,
                    739,
                    1763,
                    229,
                    742,
                    746,
                    747,
                    755,
                    756,
                    1780,
                    1288,
                    777,
                    1290,
                    784,
                    1297,
                    1300,
                    792,
                    793,
                    1307,
                    796,
                    799,
                    801,
                    803,
                    1315,
                    1316,
                    1317,
                    1320,
                    809,
                    1321,
                    811,
                    812,
                    813,
                    1324,
                    1327,
                    1328,
                    1835,
                    1332,
                    1337,
                    826,
                    829,
                    1343,
                    834,
                    838,
                    841,
                    1872,
                    851,
                    854,
                    1879,
                    1369,
                    1889,
                    1380,
                    1381,
                    1892,
                    1387,
                    1388,
                    1392,
                    1904,
                    886,
                    1911,
                    1401,
                    892,
                    896,
                    905,
                    1933,
                    1939,
                    917,
                    1941,
                    1945,
                    1952,
                    931,
                    1443,
                    1955,
                    1448,
                    1452,
                    1461,
                    1983,
                    961,
                    1990,
                    1996,
                    1997,
                    1487,
                    2001,
                    1490,
                    1491,
                    469,
                    2010,
                    2012,
                    2016,
                    999,
                    2023,
                    2029,
                    1006,
                    1009,
                    1012,
                    1524,
                    2038,
                    1015,
                    1016,
                    1017,
                    1534
                ],
                "property": [
                    520,
                    471,
                    93,
                    231
                ],
                "_LocIndexer": [
                    469
                ],
                "_AtIndexer": [
                    518
                ],
                "_iAtIndexer": [
                    566
                ],
                "_NDFrameIndexerBase": [
                    569,
                    2042
                ],
                "_valid_types": [
                    1592,
                    570,
                    1848
                ],
                "str": [
                    2304,
                    1637,
                    1669,
                    2149,
                    621,
                    1656,
                    570
                ],
                "axis": [
                    1411,
                    1290,
                    1291,
                    1933,
                    1297,
                    1300,
                    1684,
                    1688,
                    1689,
                    1946,
                    1691,
                    1949,
                    1952,
                    1570,
                    1316,
                    1317,
                    1444,
                    1573,
                    1958,
                    1961,
                    683,
                    1452,
                    685,
                    1835,
                    687,
                    1583,
                    1586,
                    1461,
                    571,
                    1996,
                    1983,
                    577,
                    578,
                    579,
                    1731,
                    1990,
                    1737,
                    588,
                    589,
                    1613,
                    1487,
                    592,
                    1741,
                    1490,
                    1742,
                    1492,
                    1872,
                    1997,
                    1879,
                    2001,
                    1753,
                    2010,
                    2012,
                    1759,
                    1763,
                    2021,
                    2023,
                    1387,
                    1388,
                    2029,
                    1393,
                    1524,
                    1397,
                    1780,
                    2038,
                    1401,
                    1402,
                    1534
                ],
                "new_self": [
                    579,
                    580,
                    575
                ],
                "type": [
                    1559,
                    575
                ],
                "self.name": [
                    1952,
                    1539,
                    712,
                    1369,
                    1401,
                    1448,
                    1327,
                    726,
                    600,
                    729,
                    1755,
                    1240,
                    575
                ],
                "self.obj": [
                    1028,
                    2060,
                    2064,
                    2067,
                    1044,
                    1047,
                    1048,
                    1049,
                    1560,
                    1051,
                    1052,
                    1563,
                    2074,
                    1056,
                    1572,
                    1062,
                    2090,
                    1069,
                    1583,
                    1072,
                    1074,
                    1075,
                    1076,
                    1586,
                    575,
                    578,
                    2115,
                    588,
                    1613,
                    592,
                    598,
                    1110,
                    1633,
                    627,
                    629,
                    1154,
                    1160,
                    1684,
                    1177,
                    676,
                    677,
                    683,
                    1199,
                    1738,
                    716,
                    1235,
                    1749,
                    1759,
                    739,
                    1763,
                    742,
                    746,
                    747,
                    755,
                    756,
                    1780,
                    1288,
                    777,
                    784,
                    792,
                    793,
                    1307,
                    796,
                    799,
                    803,
                    1316,
                    809,
                    811,
                    812,
                    813,
                    1324,
                    829,
                    851,
                    854,
                    1879,
                    1392,
                    886,
                    1911,
                    892,
                    896,
                    905,
                    1933,
                    917,
                    1945,
                    1443,
                    1983,
                    961,
                    1491,
                    2012,
                    2016,
                    999,
                    2023,
                    2029,
                    1012,
                    1524,
                    1015,
                    1016,
                    1017,
                    1534
                ],
                "self.obj._get_axis_number": [
                    578,
                    683,
                    1316
                ],
                "new_self.axis": [
                    579
                ],
                "int": [
                    1415,
                    1679,
                    1555,
                    1578,
                    1581,
                    1965,
                    1464,
                    1854,
                    1599,
                    1988,
                    582,
                    2121,
                    1744,
                    1496,
                    2014,
                    1765,
                    2025,
                    633,
                    1917
                ],
                "self.ndim": [
                    1027,
                    777,
                    1170,
                    660,
                    2070,
                    2071,
                    1307,
                    1054,
                    1955,
                    684,
                    1332,
                    693,
                    1343,
                    834,
                    838,
                    583,
                    1736,
                    715,
                    1109,
                    1626,
                    1123,
                    1380,
                    1904
                ],
                "self.obj._xs": [
                    592,
                    588
                ],
                "label": [
                    592,
                    588,
                    589
                ],
                "isinstance": [
                    2051,
                    2063,
                    2069,
                    1060,
                    1606,
                    1095,
                    1098,
                    589,
                    1102,
                    600,
                    607,
                    1634,
                    2146,
                    613,
                    1637,
                    2149,
                    1137,
                    626,
                    1654,
                    1656,
                    1663,
                    1669,
                    2193,
                    1172,
                    1687,
                    1178,
                    1179,
                    1698,
                    676,
                    1700,
                    1704,
                    2216,
                    2221,
                    1198,
                    1207,
                    1208,
                    1719,
                    1721,
                    2234,
                    1726,
                    2245,
                    711,
                    714,
                    717,
                    2261,
                    728,
                    2266,
                    2267,
                    1758,
                    2279,
                    749,
                    755,
                    757,
                    1782,
                    763,
                    766,
                    2305,
                    1798,
                    1805,
                    2318,
                    2323,
                    1327,
                    1336,
                    1856,
                    837,
                    840,
                    1354,
                    1869,
                    1873,
                    850,
                    881,
                    904,
                    924,
                    926,
                    1989,
                    1992,
                    983,
                    1002,
                    1008,
                    2032
                ],
                "tuple": [
                    2051,
                    2055,
                    904,
                    1675,
                    1805,
                    2063,
                    2064,
                    2319,
                    1172,
                    2069,
                    1559,
                    1560,
                    2331,
                    932,
                    820,
                    1719,
                    1336,
                    697,
                    1721,
                    1723,
                    2236,
                    1726,
                    837,
                    1096,
                    714,
                    1098,
                    1738,
                    589,
                    1104,
                    1873,
                    2261,
                    983,
                    858,
                    2138,
                    607,
                    626,
                    627,
                    755,
                    885,
                    763,
                    1661,
                    1663
                ],
                "IndexingError": [
                    610,
                    1224,
                    590,
                    623,
                    1876,
                    661,
                    694,
                    1333,
                    1942,
                    2197,
                    1371
                ],
                "self.axis": [
                    1570,
                    1315,
                    1316,
                    682,
                    683,
                    1387,
                    1297,
                    595
                ],
                "self._convert_tuple": [
                    609,
                    596
                ],
                "key": [
                    2051,
                    1540,
                    2054,
                    2055,
                    2059,
                    2060,
                    2063,
                    2064,
                    2039,
                    2067,
                    2069,
                    2070,
                    1559,
                    1560,
                    1561,
                    2071,
                    1563,
                    2073,
                    2074,
                    1567,
                    1572,
                    2088,
                    2090,
                    1584,
                    1585,
                    2104,
                    2115,
                    1606,
                    2118,
                    1609,
                    1612,
                    1614,
                    596,
                    602,
                    1626,
                    1629,
                    607,
                    609,
                    2146,
                    2147,
                    613,
                    614,
                    2149,
                    2152,
                    617,
                    623,
                    2159,
                    626,
                    627,
                    629,
                    630,
                    1656,
                    1661,
                    1663,
                    1667,
                    1675,
                    1677,
                    1680,
                    1681,
                    1682,
                    659,
                    2192,
                    1685,
                    2193,
                    1687,
                    1688,
                    1689,
                    1690,
                    1691,
                    1692,
                    1700,
                    1703,
                    1704,
                    687,
                    1711,
                    692,
                    1719,
                    1720,
                    1721,
                    1723,
                    1726,
                    1728,
                    1731,
                    1734,
                    1735,
                    1741,
                    1742,
                    1236,
                    1237,
                    1240,
                    2279,
                    1782,
                    1783,
                    1785,
                    1788,
                    770,
                    1796,
                    1798,
                    1290,
                    1291,
                    1803,
                    1805,
                    1806,
                    1807,
                    792,
                    796,
                    1822,
                    1824,
                    1825,
                    1827,
                    1829,
                    1830,
                    1831,
                    810,
                    1835,
                    1838,
                    815,
                    1841,
                    1842,
                    1335,
                    1336,
                    1337,
                    1855,
                    1856,
                    1857,
                    1869,
                    1871,
                    1872,
                    1873,
                    1877,
                    1878,
                    1904,
                    1394,
                    1907,
                    1396,
                    1401,
                    1934,
                    1947,
                    1948,
                    1952,
                    1449,
                    1452,
                    1456,
                    1983,
                    1989,
                    1990,
                    1992,
                    1993,
                    1995,
                    1996,
                    1997,
                    1487,
                    2000,
                    2001,
                    1490,
                    2005,
                    2006,
                    2010,
                    2012,
                    2032,
                    2033,
                    2035,
                    2036,
                    1526,
                    2038,
                    1535
                ],
                "ax": [
                    1154,
                    1155,
                    1540,
                    1157,
                    1160,
                    1162,
                    1548,
                    1165,
                    1911,
                    1177,
                    1182,
                    1184,
                    676,
                    677,
                    1444,
                    1449,
                    2090,
                    2091,
                    1453,
                    1199,
                    1200,
                    1455,
                    1456,
                    1457,
                    1459,
                    2098,
                    1207,
                    1209,
                    1216,
                    716,
                    724,
                    598,
                    600,
                    602,
                    1633,
                    1634,
                    1637,
                    1642,
                    1134,
                    756,
                    757,
                    1140,
                    1524,
                    1912
                ],
                "self.obj._get_axis": [
                    1160,
                    809,
                    1324,
                    1613,
                    1879,
                    1583,
                    1933,
                    2029,
                    1524,
                    1684,
                    598,
                    1780,
                    829
                ],
                "ABCMultiIndex": [
                    1634,
                    1698,
                    676,
                    1798,
                    1726,
                    1805,
                    1327,
                    851,
                    757,
                    1654,
                    1207,
                    600,
                    1208,
                    2267,
                    926
                ],
                "ax.get_loc": [
                    602
                ],
                "TypeError": [
                    618,
                    1211,
                    1809,
                    1301,
                    2007,
                    603,
                    1789
                ],
                "KeyError": [
                    1541,
                    1549,
                    2222,
                    2160,
                    1304,
                    603,
                    1564,
                    1535
                ],
                "InvalidIndexError": [
                    603
                ],
                "range": [
                    2136,
                    684,
                    613
                ],
                "list": [
                    2304,
                    1540,
                    2245,
                    614,
                    1095,
                    1703,
                    1992,
                    2088,
                    749,
                    1682,
                    2073,
                    925
                ],
                "self._convert_to_indexer": [
                    617,
                    695,
                    687
                ],
                "e": [
                    621
                ],
                "com.apply_if_callable": [
                    1572,
                    2064,
                    627,
                    2067,
                    629,
                    1560
                ],
                "com": [
                    905,
                    2064,
                    2067,
                    1560,
                    1690,
                    1948,
                    1572,
                    1829,
                    1855,
                    1609,
                    1995,
                    1106,
                    1237,
                    1366,
                    993,
                    1138,
                    627,
                    1266,
                    629,
                    758,
                    1396
                ],
                "x": [
                    1262,
                    2064,
                    1266,
                    627,
                    1560
                ],
                "indexer": [
                    1029,
                    1063,
                    1072,
                    1095,
                    1096,
                    1098,
                    1104,
                    1106,
                    1123,
                    1124,
                    1127,
                    1128,
                    1133,
                    630,
                    631,
                    1159,
                    1172,
                    1176,
                    2216,
                    2219,
                    2221,
                    1198,
                    1199,
                    2223,
                    2225,
                    2236,
                    711,
                    1736,
                    1737,
                    1738,
                    714,
                    715,
                    716,
                    1754,
                    734,
                    1758,
                    1759,
                    1763,
                    755,
                    756,
                    763,
                    765,
                    799,
                    820,
                    823,
                    826,
                    837,
                    838,
                    841,
                    843,
                    856,
                    858,
                    1892,
                    891,
                    925,
                    1449,
                    1451,
                    1452,
                    1453,
                    1456,
                    1459,
                    1461,
                    1462,
                    1490,
                    1492,
                    983,
                    984,
                    990,
                    991,
                    994,
                    2022,
                    999,
                    2023,
                    1006,
                    1009,
                    1016,
                    1530,
                    1533
                ],
                "self._get_setitem_indexer": [
                    630
                ],
                "self._setitem_with_indexer": [
                    1040,
                    801,
                    631
                ],
                "value": [
                    1040,
                    787,
                    1043,
                    792,
                    921,
                    2074,
                    924,
                    796,
                    801,
                    929,
                    932,
                    1060,
                    1062,
                    1063,
                    1067,
                    1069,
                    943,
                    1072,
                    1074,
                    947,
                    948,
                    2354,
                    2360,
                    826,
                    957,
                    961,
                    963,
                    840,
                    841,
                    968,
                    974,
                    980,
                    864,
                    865,
                    866,
                    869,
                    999,
                    1002,
                    749,
                    877,
                    1006,
                    1008,
                    1009,
                    885,
                    631,
                    1016
                ],
                "AbstractMethodError": [
                    2048,
                    1556,
                    653
                ],
                "Tuple": [
                    1312,
                    1221,
                    1894,
                    1575,
                    2121,
                    655,
                    1295,
                    1616,
                    1937,
                    1271,
                    1244,
                    1373,
                    670
                ],
                "i": [
                    1667,
                    1670,
                    777,
                    784,
                    659,
                    660,
                    663,
                    1176,
                    1177,
                    1947,
                    1188,
                    809,
                    2090,
                    811,
                    684,
                    685,
                    2092,
                    2098,
                    692,
                    693,
                    695,
                    1335,
                    1337,
                    954,
                    957,
                    1346,
                    2115,
                    2116,
                    1349,
                    1355,
                    716,
                    717,
                    1102,
                    720,
                    723,
                    724,
                    1236,
                    728,
                    1240,
                    2264,
                    1629,
                    1633,
                    994,
                    995,
                    1133,
                    1134,
                    1394,
                    1907,
                    756,
                    758,
                    1911,
                    765
                ],
                "k": [
                    1637,
                    663,
                    659,
                    692,
                    1907,
                    1908,
                    695,
                    2264,
                    2266,
                    1629,
                    1630
                ],
                "enumerate": [
                    994,
                    1667,
                    1629,
                    1133,
                    784,
                    1394,
                    659,
                    692,
                    1236,
                    1907,
                    1335,
                    1176,
                    954,
                    1947,
                    2236,
                    765,
                    2264
                ],
                "self._validate_key": [
                    1996,
                    1741,
                    1487,
                    2038,
                    663,
                    1688
                ],
                "ValueError": [
                    2057,
                    1167,
                    1811,
                    788,
                    2072,
                    664,
                    665,
                    1058,
                    2093,
                    1070,
                    2099,
                    949,
                    1729,
                    1219,
                    2117,
                    1863,
                    969,
                    1889,
                    870,
                    2160
                ],
                "self._valid_types": [
                    1889,
                    667
                ],
                "any": [
                    676,
                    677,
                    1039,
                    786,
                    1266
                ],
                "self.obj.axes": [
                    1633,
                    1154,
                    2115,
                    676,
                    677,
                    2090,
                    716,
                    784,
                    755,
                    756,
                    1911,
                    1177,
                    892,
                    799
                ],
                "is_nested_tuple": [
                    1824,
                    677,
                    1734
                ],
                "tup": [
                    1291,
                    1939,
                    1300,
                    1941,
                    1307,
                    1947,
                    677,
                    1317,
                    1320,
                    1321,
                    1328,
                    1332,
                    1335,
                    1346,
                    1349,
                    1223,
                    1228,
                    1231,
                    1232,
                    1236,
                    2261,
                    2264,
                    1380,
                    1381,
                    1388,
                    1262,
                    1266,
                    1394
                ],
                "bool": [
                    2308,
                    1415,
                    1555,
                    2202,
                    2205,
                    670,
                    2081,
                    2342,
                    680,
                    2347,
                    2221,
                    1078,
                    1591,
                    699,
                    702,
                    2111,
                    2254,
                    1616,
                    1496,
                    1244,
                    2272,
                    1765,
                    1894,
                    2025,
                    2282,
                    2047
                ],
                "keyidx": [
                    681,
                    686,
                    690,
                    696,
                    697
                ],
                "keyidx.append": [
                    696,
                    690,
                    686
                ],
                "is_setter": [
                    695,
                    1791,
                    2087,
                    687
                ],
                "idx": [
                    770,
                    905,
                    906,
                    1174,
                    1181,
                    1182,
                    1190,
                    1192,
                    1195,
                    818,
                    695,
                    696,
                    1106,
                    856,
                    858,
                    993,
                    994,
                    2145,
                    2147,
                    869,
                    1133,
                    2157,
                    2159,
                    881,
                    882,
                    1137,
                    1138,
                    885,
                    1140,
                    765,
                    766
                ],
                "dict": [
                    711,
                    2216,
                    1002,
                    749,
                    728,
                    2234,
                    766
                ],
                "IndexError": [
                    1984,
                    1986,
                    712,
                    1935,
                    725,
                    729,
                    1883,
                    1564,
                    1887
                ],
                "_tuplify": [
                    715,
                    838,
                    2070
                ],
                "zip": [
                    2115,
                    2090,
                    1291,
                    716,
                    974,
                    756
                ],
                "is_list_like_indexer": [
                    864,
                    1692,
                    1827,
                    2054,
                    2279,
                    1067,
                    1612,
                    1198,
                    1262,
                    720,
                    1841,
                    2000,
                    787,
                    1141,
                    1877,
                    921,
                    1340
                ],
                "is_integer": [
                    1796,
                    2116,
                    844,
                    2092,
                    1871,
                    2098,
                    723,
                    1908,
                    758,
                    2006,
                    991
                ],
                "len": [
                    1155,
                    1029,
                    905,
                    1933,
                    1806,
                    784,
                    1044,
                    2071,
                    1307,
                    1056,
                    1661,
                    810,
                    1069,
                    2354,
                    948,
                    1332,
                    1720,
                    2360,
                    2362,
                    968,
                    1356,
                    1361,
                    850,
                    724,
                    1879,
                    1626,
                    990,
                    1886,
                    866,
                    1380,
                    869,
                    1127,
                    1128,
                    1904,
                    755,
                    1526,
                    1145,
                    1533
                ],
                "self._has_valid_setitem_indexer": [
                    734
                ],
                "info_axis": [
                    930,
                    835,
                    739,
                    995,
                    999,
                    843,
                    856,
                    858,
                    891,
                    892,
                    829,
                    990,
                    991
                ],
                "self.obj._info_axis_number": [
                    777,
                    739
                ],
                "take_split_path": [
                    832,
                    742,
                    746,
                    750,
                    760
                ],
                "self.obj._is_mixed_type": [
                    742
                ],
                "self.obj._data.blocks": [
                    746,
                    747
                ],
                "self.obj._data": [
                    746,
                    811,
                    747,
                    1074,
                    1016,
                    1048
                ],
                "blk": [
                    747,
                    748,
                    750
                ],
                "blk.ndim": [
                    748
                ],
                "val": [
                    1216,
                    1217,
                    1193,
                    1195,
                    1196,
                    749,
                    750,
                    1201
                ],
                "value.values": [
                    749
                ],
                "blk._can_hold_element": [
                    750
                ],
                "com.is_null_slice": [
                    993,
                    905,
                    1138,
                    1106,
                    1396,
                    1237,
                    758,
                    1366,
                    1948
                ],
                "nindexer": [
                    818,
                    764,
                    820,
                    815
                ],
                "_": [
                    2136,
                    770,
                    1123
                ],
                "convert_missing_indexer": [
                    770,
                    823
                ],
                "len_non_info_axes": [
                    786,
                    783
                ],
                "_ax": [
                    784
                ],
                "_i": [
                    784,
                    2234,
                    2236
                ],
                "l": [
                    786
                ],
                "_infer_fill_value": [
                    796
                ],
                "new_indexer": [
                    801,
                    1038,
                    1039,
                    1040,
                    1459,
                    798
                ],
                "convert_from_missing_indexer_tuple": [
                    798
                ],
                "index": [
                    1028,
                    1029,
                    809,
                    810,
                    1037,
                    1038,
                    2193,
                    882,
                    2194,
                    2358,
                    855,
                    2362,
                    859,
                    2206
                ],
                "labels": [
                    1795,
                    1670,
                    1798,
                    1803,
                    1805,
                    1806,
                    1684,
                    1685,
                    926,
                    928,
                    1824,
                    1698,
                    1825,
                    1830,
                    810,
                    811,
                    1838,
                    815,
                    1583,
                    1584,
                    2354,
                    948,
                    2357,
                    954,
                    1726,
                    961,
                    963,
                    1734,
                    1735,
                    968,
                    1613,
                    846,
                    974,
                    1614,
                    850,
                    851,
                    979,
                    853,
                    1753,
                    1754,
                    2267,
                    2021,
                    2022,
                    2029,
                    2033,
                    1780,
                    2036,
                    1654,
                    1783,
                    1657,
                    1788,
                    1661
                ],
                "index.insert": [
                    810,
                    1029
                ],
                "_data": [
                    1048,
                    1074,
                    811
                ],
                "self.obj.reindex": [
                    811
                ],
                "self.obj._maybe_update_cacher": [
                    1017,
                    1051,
                    812,
                    1075
                ],
                "self.obj._is_copy": [
                    813
                ],
                "nindexer.append": [
                    818,
                    815
                ],
                "labels.get_loc": [
                    1803,
                    1838,
                    815
                ],
                "missing": [
                    823,
                    825,
                    1530,
                    1532,
                    1533
                ],
                "self._setitem_with_indexer_missing": [
                    826
                ],
                "item_labels": [
                    997,
                    829,
                    846,
                    999
                ],
                "ABCSeries": [
                    2304,
                    1060,
                    1700,
                    2245,
                    840,
                    1002,
                    2193,
                    1078
                ],
                "self._align_series": [
                    841,
                    931,
                    1006
                ],
                "info_idx": [
                    843,
                    844,
                    845,
                    846
                ],
                "axes": [
                    2234,
                    851
                ],
                "item": [
                    896,
                    928,
                    929,
                    930,
                    932,
                    937,
                    974,
                    975,
                    979,
                    980,
                    853,
                    886,
                    854,
                    917,
                    2357,
                    954,
                    2358,
                    957
                ],
                "obj": [
                    1410,
                    1413,
                    2358,
                    1749,
                    854,
                    1751,
                    855,
                    1110,
                    1753,
                    2016,
                    2145,
                    2019,
                    1124,
                    869,
                    2021,
                    2152,
                    1134,
                    1392,
                    2289,
                    2290,
                    883,
                    884,
                    885,
                    886,
                    2291,
                    1400,
                    1401,
                    1405
                ],
                "obj.index": [
                    2145,
                    855
                ],
                "plane_indexer": [
                    897,
                    859,
                    961,
                    2354,
                    858,
                    891,
                    893
                ],
                "lplane_indexer": [
                    897,
                    866,
                    961,
                    859,
                    2364,
                    893
                ],
                "length_of_indexer": [
                    859,
                    893
                ],
                "np.iterable": [
                    865,
                    2354
                ],
                "np": [
                    2304,
                    865,
                    1700,
                    2245,
                    2340,
                    1095,
                    935,
                    1129,
                    1993,
                    2249,
                    1102,
                    943,
                    2354,
                    947,
                    1878,
                    2166,
                    1179,
                    2205
                ],
                "ravel": [
                    1104,
                    877
                ],
                "getattr": [
                    1952,
                    1369,
                    1401,
                    877,
                    1455,
                    1240,
                    921
                ],
                "index._convert_slice_indexer": [
                    882
                ],
                "obj._consolidate_inplace": [
                    883
                ],
                "obj.copy": [
                    2019,
                    884,
                    1751
                ],
                "obj._data": [
                    2152,
                    885
                ],
                "obj._data.setitem": [
                    885
                ],
                "plane_axis": [
                    892,
                    893
                ],
                "s": [
                    896,
                    908,
                    911,
                    912,
                    913,
                    914,
                    917
                ],
                "pi": [
                    904,
                    897,
                    906,
                    913
                ],
                "all": [
                    992,
                    1123,
                    904,
                    1451,
                    1262
                ],
                "com.is_full_slice": [
                    905
                ],
                "v": [
                    931,
                    935,
                    937,
                    908,
                    974,
                    975,
                    913
                ],
                "s._consolidate_inplace": [
                    911
                ],
                "s.copy": [
                    912
                ],
                "s._data": [
                    913
                ],
                "s._data.setitem": [
                    913
                ],
                "s._maybe_update_cacher": [
                    914
                ],
                "ABCDataFrame": [
                    1704,
                    1354,
                    1008,
                    1169,
                    924
                ],
                "sub_indexer": [
                    930,
                    932,
                    925
                ],
                "multiindex_indexer": [
                    932,
                    926,
                    1127
                ],
                "np.nan": [
                    935
                ],
                "setter": [
                    963,
                    937,
                    975,
                    980,
                    957
                ],
                "np.ndim": [
                    943
                ],
                "np.array": [
                    947,
                    1878
                ],
                "object": [
                    947
                ],
                "value.shape": [
                    948
                ],
                "tolist": [
                    957
                ],
                "_can_do_equal_len": [
                    960
                ],
                "maybe_convert_ix": [
                    984
                ],
                "item_labels.is_unique": [
                    997
                ],
                "Series": [
                    1072,
                    1043,
                    1006
                ],
                "self._align_frame": [
                    1009
                ],
                "self.obj._check_is_chained_assignment_possible": [
                    1012
                ],
                "self.obj._consolidate_inplace": [
                    1015
                ],
                "self.obj._data.setitem": [
                    1016
                ],
                "self.obj.index": [
                    1307,
                    1028,
                    1199
                ],
                "new_index": [
                    1049,
                    1029,
                    1038
                ],
                "index.is_unique": [
                    1037
                ],
                "index.get_indexer": [
                    1038
                ],
                "new_values": [
                    1049,
                    1043,
                    1047
                ],
                "_values": [
                    1216,
                    1124,
                    1157,
                    1193,
                    1195,
                    1165,
                    1201,
                    1043,
                    2202,
                    1148
                ],
                "self.obj._values": [
                    1044,
                    1047
                ],
                "concat_compat": [
                    1047
                ],
                "self.obj._constructor": [
                    1048
                ],
                "self.obj.name": [
                    1049
                ],
                "self.obj.columns": [
                    1056,
                    1072,
                    1069,
                    1062
                ],
                "value.reindex": [
                    1062
                ],
                "value.name": [
                    1063
                ],
                "self.obj.append": [
                    1074
                ],
                "np.ndarray": [
                    2304,
                    1700,
                    2245,
                    1095,
                    1102,
                    2166,
                    1179
                ],
                "Index": [
                    1856,
                    2304,
                    2245,
                    1095,
                    2166,
                    1142,
                    1144
                ],
                "i.ravel": [
                    1102
                ],
                "map": [
                    1104
                ],
                "aligners": [
                    1106,
                    1107,
                    1119
                ],
                "sum_aligners": [
                    1123,
                    1107,
                    1108
                ],
                "sum": [
                    1530,
                    1107
                ],
                "single_aligner": [
                    1138,
                    1108,
                    1151,
                    1119
                ],
                "is_frame": [
                    1170,
                    1198,
                    1109,
                    1118
                ],
                "is_sequence": [
                    1137,
                    1178,
                    1123
                ],
                "ser": [
                    1155,
                    1124,
                    1156,
                    1157,
                    1129,
                    1162,
                    1131,
                    1163,
                    1165,
                    1145,
                    1146,
                    1148
                ],
                "ser.reindex": [
                    1148,
                    1124,
                    1157,
                    1165
                ],
                "obj.axes": [
                    1124,
                    1134
                ],
                "len_indexer": [
                    1128,
                    1129
                ],
                "T": [
                    1129
                ],
                "reshape": [
                    1129
                ],
                "np.tile": [
                    1129
                ],
                "new_ix": [
                    1140,
                    1141,
                    1142,
                    1144,
                    1145,
                    1148
                ],
                "ser.index.equals": [
                    1145,
                    1162,
                    1155
                ],
                "ser.index": [
                    1145,
                    1162,
                    1155
                ],
                "ser._values.copy": [
                    1146,
                    1163,
                    1156
                ],
                "ser._values": [
                    1146,
                    1163,
                    1156
                ],
                "is_scalar": [
                    1798,
                    1159,
                    2354,
                    1785,
                    1405,
                    1630
                ],
                "cols": [
                    1184,
                    1190,
                    1192,
                    1195,
                    1174,
                    1183
                ],
                "sindexers": [
                    1188,
                    1175
                ],
                "ix": [
                    1184,
                    1176,
                    1178,
                    1179,
                    1180,
                    1182
                ],
                "ix.ravel": [
                    1180
                ],
                "sindexers.append": [
                    1188
                ],
                "df.index.equals": [
                    1192,
                    1200
                ],
                "df.index": [
                    1192,
                    1208,
                    1209,
                    1200
                ],
                "df": [
                    1216,
                    2343,
                    1192,
                    1193,
                    1195,
                    1200,
                    1201,
                    1208,
                    1209
                ],
                "df.columns.equals": [
                    1192
                ],
                "df.columns": [
                    1192
                ],
                "df.copy": [
                    1193,
                    1201
                ],
                "df.reindex": [
                    1216,
                    1195
                ],
                "ax.nlevels": [
                    1209
                ],
                "df.index.nlevels": [
                    1209
                ],
                "self._getitem_lowerdim": [
                    1941,
                    1223
                ],
                "self._has_valid_tuple": [
                    1939,
                    1228
                ],
                "self._multi_take_opportunity": [
                    1231
                ],
                "self._multi_take": [
                    1232
                ],
                "retval": [
                    1952,
                    1955,
                    1963,
                    1235,
                    1240,
                    1945,
                    1242
                ],
                "_getitem_axis": [
                    1240,
                    1401,
                    1952
                ],
                "com.is_bool_indexer": [
                    1829,
                    1609,
                    1995,
                    1266,
                    1690,
                    1855
                ],
                "o": [
                    1443,
                    1444,
                    1288,
                    1291,
                    1293
                ],
                "d": [
                    1289,
                    1293
                ],
                "self._get_listlike_indexer": [
                    1490,
                    1290,
                    1835
                ],
                "o._AXIS_ORDERS": [
                    1291
                ],
                "o._reindex_with_indexers": [
                    1293
                ],
                "self._get_label": [
                    1300,
                    1742
                ],
                "self.obj.index.nlevels": [
                    1307
                ],
                "ek": [
                    1308
                ],
                "self._getitem_axis": [
                    1337,
                    1573,
                    1388,
                    1317
                ],
                "self._is_nested_tuple_indexer": [
                    1320
                ],
                "self._getitem_nested_tuple": [
                    1321
                ],
                "ax0": [
                    1324,
                    1327
                ],
                "result": [
                    2208,
                    1381,
                    1382,
                    1383,
                    1328,
                    1329,
                    1330,
                    2192,
                    2194,
                    2195,
                    2202,
                    2205,
                    2206
                ],
                "self._handle_lowerdim_multi_index_axis0": [
                    1328,
                    1381
                ],
                "is_label_like": [
                    1336
                ],
                "section": [
                    1369,
                    1354,
                    1367,
                    1337,
                    1340,
                    1341,
                    1343
                ],
                "section.ndim": [
                    1343
                ],
                "new_key": [
                    1346,
                    1666,
                    1349,
                    1672,
                    1674,
                    1675,
                    1356,
                    1358,
                    1359,
                    1361,
                    1362,
                    1366,
                    1369
                ],
                "a": [
                    2115,
                    1358,
                    1359
                ],
                "b": [
                    1358,
                    1359
                ],
                "current_ndim": [
                    1400,
                    1410
                ],
                "obj.ndim": [
                    1400,
                    1410
                ],
                "hasattr": [
                    1728,
                    1856,
                    1405,
                    1711
                ],
                "o._get_axis": [
                    1444
                ],
                "keyarr": [
                    1449,
                    1457,
                    1490,
                    1459,
                    1492,
                    1461,
                    1462
                ],
                "ax._convert_listlike_indexer": [
                    1449
                ],
                "self._validate_read_indexer": [
                    1452,
                    1461
                ],
                "raise_missing": [
                    1539,
                    1452,
                    1461
                ],
                "ax.is_unique": [
                    1912,
                    1642,
                    1455
                ],
                "ax.get_indexer_for": [
                    1456
                ],
                "ax.reindex": [
                    1457
                ],
                "ax._reindex_non_unique": [
                    1459
                ],
                "self.obj._reindex_with_indexers": [
                    1491
                ],
                "axis_name": [
                    1534,
                    1535
                ],
                "self.obj._get_axis_name": [
                    1534
                ],
                "not_found": [
                    1540,
                    1541
                ],
                "set": [
                    1540
                ],
                "ax.is_categorical": [
                    1548
                ],
                "ax.is_interval": [
                    1548
                ],
                "self._is_scalar_access": [
                    1561
                ],
                "self.obj._get_value": [
                    1563,
                    2060
                ],
                "self._takeable": [
                    2074,
                    1563,
                    2060
                ],
                "AttributeError": [
                    1564
                ],
                "self._getitem_tuple": [
                    1567
                ],
                "maybe_callable": [
                    1572,
                    1573
                ],
                "NotImplementedError": [
                    1858,
                    1576,
                    1706,
                    1579,
                    1712,
                    2160
                ],
                "check_bool_indexer": [
                    1584,
                    1830
                ],
                "inds": [
                    1832,
                    1585,
                    1586,
                    1831
                ],
                "key.nonzero": [
                    1585,
                    1831
                ],
                "self.obj._take_with_is_copy": [
                    1586,
                    1983
                ],
                "_LocationIndexer": [
                    1598,
                    1590,
                    1847
                ],
                "_takeable": [
                    2109,
                    1852,
                    2079,
                    1591
                ],
                "labels._convert_scalar_indexer": [
                    1788,
                    1614,
                    2036
                ],
                "Appender": [
                    1589,
                    1846,
                    2107,
                    2077,
                    1598
                ],
                "_LocationIndexer._validate_key.__doc__": [
                    1598
                ],
                "_LocationIndexer._validate_key": [
                    1598
                ],
                "ax._supports_partial_string_indexing": [
                    1637
                ],
                "_supports_partial_string_indexing": [
                    1657,
                    1670
                ],
                "labels.levels": [
                    1657,
                    1661,
                    1670
                ],
                "component": [
                    1672,
                    1674,
                    1667,
                    1669
                ],
                "new_key.append": [
                    1672,
                    1674
                ],
                "item_from_zerodim": [
                    1680,
                    2005
                ],
                "is_iterator": [
                    1681
                ],
                "self._get_partial_string_timestamp_match_key": [
                    1685
                ],
                "self._get_slice_axis": [
                    1689,
                    1990
                ],
                "self._getbool_axis": [
                    1691,
                    1997
                ],
                "key.ndim": [
                    1728,
                    1700,
                    1711
                ],
                "self._getitem_iterable": [
                    1731
                ],
                "locs": [
                    1737,
                    1735
                ],
                "labels.get_locs": [
                    1825,
                    1735
                ],
                "self.obj.iloc": [
                    1738
                ],
                "need_slice": [
                    2018,
                    1750
                ],
                "slice_obj": [
                    2022,
                    2018,
                    1755,
                    1750
                ],
                "obj._get_axis": [
                    1753,
                    2021
                ],
                "labels.slice_indexer": [
                    1754
                ],
                "slice_obj.start": [
                    1755
                ],
                "slice_obj.stop": [
                    1755
                ],
                "slice_obj.step": [
                    1755
                ],
                "self.obj._slice": [
                    2023,
                    1759
                ],
                "self.obj.take": [
                    1763
                ],
                "labels._convert_slice_indexer": [
                    2033,
                    2022,
                    1783
                ],
                "is_int_index": [
                    1795,
                    1796
                ],
                "labels.is_integer": [
                    1795
                ],
                "is_int_positional": [
                    1816,
                    1796,
                    1812
                ],
                "LookupError": [
                    1804,
                    1839
                ],
                "labels.nlevels": [
                    1806
                ],
                "IndexingMixin.loc.__doc__": [
                    1589
                ],
                "IndexingMixin.loc": [
                    1589
                ],
                "IndexingMixin": [
                    2077,
                    2107,
                    1589,
                    1846
                ],
                "key.index": [
                    1856,
                    1857,
                    2193
                ],
                "key.index.inferred_type": [
                    1857
                ],
                "self._validate_integer": [
                    1872,
                    2010
                ],
                "arr": [
                    1886,
                    1882,
                    1883,
                    1878
                ],
                "len_axis": [
                    1934,
                    1933,
                    1886,
                    1879
                ],
                "is_numeric_dtype": [
                    1882
                ],
                "arr.dtype": [
                    1882
                ],
                "arr.max": [
                    1886
                ],
                "arr.min": [
                    1886
                ],
                "self._has_valid_positional_setitem_indexer": [
                    1892
                ],
                "retval.ndim": [
                    1955
                ],
                "np.asarray": [
                    1993,
                    2205
                ],
                "self._get_list_axis": [
                    2001
                ],
                "self.obj._ixs": [
                    2012
                ],
                "is_float": [
                    2035
                ],
                "IndexingMixin.iloc.__doc__": [
                    1846
                ],
                "IndexingMixin.iloc": [
                    1846
                ],
                "self._convert_key": [
                    2073,
                    2059
                ],
                "self.obj._set_value": [
                    2074
                ],
                "_ScalarAccessIndexer": [
                    2108,
                    2078
                ],
                "ax.is_integer": [
                    2091
                ],
                "ax.holds_integer": [
                    2098
                ],
                "ax.is_floating": [
                    2098
                ],
                "IndexingMixin.at.__doc__": [
                    2077
                ],
                "IndexingMixin.at": [
                    2077
                ],
                "IndexingMixin.iat.__doc__": [
                    2107
                ],
                "IndexingMixin.iat": [
                    2107
                ],
                "Hashable": [
                    2121,
                    2135
                ],
                "_tup": [
                    2136,
                    2137,
                    2138,
                    2135
                ],
                "List": [
                    2135
                ],
                "Union": [
                    2121,
                    2135
                ],
                "ndim": [
                    2136
                ],
                "loc": [
                    2137
                ],
                "idx._convert_slice_indexer": [
                    2147
                ],
                "obj._data.items": [
                    2152
                ],
                "idx._supports_partial_string_indexing": [
                    2157
                ],
                "idx._get_string_slice": [
                    2159
                ],
                "key.index.equals": [
                    2193
                ],
                "result.reindex": [
                    2194
                ],
                "mask": [
                    2195,
                    2196
                ],
                "isna": [
                    2195
                ],
                "result._values": [
                    2195
                ],
                "mask.any": [
                    2196
                ],
                "result.astype": [
                    2202
                ],
                "check_array_indexer": [
                    2206
                ],
                "_idx": [
                    2234,
                    2236
                ],
                "get_loc": [
                    2234
                ],
                "get_indexer": [
                    2236
                ],
                "ixify": [
                    2248,
                    2243,
                    2246
                ],
                "args": [
                    2249,
                    2251,
                    2244
                ],
                "np.ix_": [
                    2249
                ],
                "is_list_like": [
                    2266,
                    2322,
                    2318
                ],
                "obj.start": [
                    2289
                ],
                "obj.stop": [
                    2290
                ],
                "obj.step": [
                    2291
                ],
                "kinds": [
                    2304,
                    2305
                ],
                "slice_": [
                    2305,
                    2306,
                    2339,
                    2343,
                    2344,
                    2322,
                    2323,
                    2325,
                    2328,
                    2330,
                    2331
                ],
                "part": [
                    2330,
                    2318,
                    2319
                ],
                "pred": [
                    2330
                ],
                "dtypes": [
                    2340,
                    2342,
                    2343
                ],
                "np.number": [
                    2340
                ],
                "include_bool": [
                    2341
                ],
                "dtypes.append": [
                    2342
                ],
                "columns": [
                    2343
                ],
                "df.select_dtypes": [
                    2343
                ],
                "values_len": [
                    2360,
                    2362,
                    2364
                ]
            },
            "filtered_variables_in_file": {
                "_NS": [
                    33,
                    1346
                ],
                "arg": [
                    2244,
                    2245,
                    79
                ],
                "IndexSlice": [
                    82,
                    2306,
                    2343
                ],
                "_IndexSlice": [
                    82
                ],
                "_iLocIndexer": [
                    229
                ],
                "self": [
                    2048,
                    1027,
                    1028,
                    1539,
                    518,
                    2059,
                    2060,
                    1040,
                    2064,
                    2067,
                    1044,
                    1556,
                    2070,
                    1047,
                    1048,
                    1049,
                    1560,
                    1051,
                    1052,
                    1561,
                    1054,
                    1563,
                    1056,
                    1567,
                    1570,
                    2074,
                    1572,
                    1573,
                    1062,
                    2090,
                    1069,
                    1583,
                    1072,
                    1074,
                    1075,
                    1076,
                    1586,
                    566,
                    575,
                    578,
                    2115,
                    583,
                    588,
                    1613,
                    592,
                    595,
                    596,
                    1109,
                    598,
                    1110,
                    600,
                    1626,
                    609,
                    1633,
                    1123,
                    617,
                    627,
                    629,
                    630,
                    631,
                    1154,
                    1160,
                    653,
                    1170,
                    660,
                    1684,
                    1685,
                    663,
                    1688,
                    1177,
                    1689,
                    667,
                    1691,
                    676,
                    677,
                    682,
                    683,
                    684,
                    687,
                    1199,
                    2071,
                    693,
                    695,
                    2073,
                    1731,
                    1223,
                    712,
                    1736,
                    1738,
                    715,
                    716,
                    1228,
                    1741,
                    1231,
                    1232,
                    1742,
                    1235,
                    1749,
                    726,
                    1240,
                    729,
                    1755,
                    734,
                    1759,
                    739,
                    1763,
                    229,
                    742,
                    746,
                    747,
                    755,
                    756,
                    1780,
                    1288,
                    777,
                    1290,
                    784,
                    1297,
                    1300,
                    792,
                    793,
                    1307,
                    796,
                    799,
                    801,
                    803,
                    1315,
                    1316,
                    1317,
                    1320,
                    809,
                    1321,
                    811,
                    812,
                    813,
                    1324,
                    1327,
                    1328,
                    1835,
                    1332,
                    1337,
                    826,
                    829,
                    1343,
                    834,
                    838,
                    841,
                    1872,
                    851,
                    854,
                    1879,
                    1369,
                    1889,
                    1380,
                    1381,
                    1892,
                    1387,
                    1388,
                    1392,
                    1904,
                    886,
                    1911,
                    1401,
                    892,
                    896,
                    905,
                    1933,
                    1939,
                    917,
                    1941,
                    1945,
                    1952,
                    931,
                    1443,
                    1955,
                    1448,
                    1452,
                    1461,
                    1983,
                    961,
                    1990,
                    1996,
                    1997,
                    1487,
                    2001,
                    1490,
                    1491,
                    469,
                    2010,
                    2012,
                    2016,
                    999,
                    2023,
                    2029,
                    1006,
                    1009,
                    1012,
                    1524,
                    2038,
                    1015,
                    1016,
                    1017,
                    1534
                ],
                "_LocIndexer": [
                    469
                ],
                "_AtIndexer": [
                    518
                ],
                "_iAtIndexer": [
                    566
                ],
                "_NDFrameIndexerBase": [
                    569,
                    2042
                ],
                "_valid_types": [
                    1592,
                    570,
                    1848
                ],
                "axis": [
                    1411,
                    1290,
                    1291,
                    1933,
                    1297,
                    1300,
                    1684,
                    1688,
                    1689,
                    1946,
                    1691,
                    1949,
                    1952,
                    1570,
                    1316,
                    1317,
                    1444,
                    1573,
                    1958,
                    1961,
                    683,
                    1452,
                    685,
                    1835,
                    687,
                    1583,
                    1586,
                    1461,
                    571,
                    1996,
                    1983,
                    577,
                    578,
                    579,
                    1731,
                    1990,
                    1737,
                    588,
                    589,
                    1613,
                    1487,
                    592,
                    1741,
                    1490,
                    1742,
                    1492,
                    1872,
                    1997,
                    1879,
                    2001,
                    1753,
                    2010,
                    2012,
                    1759,
                    1763,
                    2021,
                    2023,
                    1387,
                    1388,
                    2029,
                    1393,
                    1524,
                    1397,
                    1780,
                    2038,
                    1401,
                    1402,
                    1534
                ],
                "new_self": [
                    579,
                    580,
                    575
                ],
                "self.name": [
                    1952,
                    1539,
                    712,
                    1369,
                    1401,
                    1448,
                    1327,
                    726,
                    600,
                    729,
                    1755,
                    1240,
                    575
                ],
                "self.obj": [
                    1028,
                    2060,
                    2064,
                    2067,
                    1044,
                    1047,
                    1048,
                    1049,
                    1560,
                    1051,
                    1052,
                    1563,
                    2074,
                    1056,
                    1572,
                    1062,
                    2090,
                    1069,
                    1583,
                    1072,
                    1074,
                    1075,
                    1076,
                    1586,
                    575,
                    578,
                    2115,
                    588,
                    1613,
                    592,
                    598,
                    1110,
                    1633,
                    627,
                    629,
                    1154,
                    1160,
                    1684,
                    1177,
                    676,
                    677,
                    683,
                    1199,
                    1738,
                    716,
                    1235,
                    1749,
                    1759,
                    739,
                    1763,
                    742,
                    746,
                    747,
                    755,
                    756,
                    1780,
                    1288,
                    777,
                    784,
                    792,
                    793,
                    1307,
                    796,
                    799,
                    803,
                    1316,
                    809,
                    811,
                    812,
                    813,
                    1324,
                    829,
                    851,
                    854,
                    1879,
                    1392,
                    886,
                    1911,
                    892,
                    896,
                    905,
                    1933,
                    917,
                    1945,
                    1443,
                    1983,
                    961,
                    1491,
                    2012,
                    2016,
                    999,
                    2023,
                    2029,
                    1012,
                    1524,
                    1015,
                    1016,
                    1017,
                    1534
                ],
                "self.obj._get_axis_number": [
                    578,
                    683,
                    1316
                ],
                "new_self.axis": [
                    579
                ],
                "self.ndim": [
                    1027,
                    777,
                    1170,
                    660,
                    2070,
                    2071,
                    1307,
                    1054,
                    1955,
                    684,
                    1332,
                    693,
                    1343,
                    834,
                    838,
                    583,
                    1736,
                    715,
                    1109,
                    1626,
                    1123,
                    1380,
                    1904
                ],
                "self.obj._xs": [
                    592,
                    588
                ],
                "label": [
                    592,
                    588,
                    589
                ],
                "IndexingError": [
                    610,
                    1224,
                    590,
                    623,
                    1876,
                    661,
                    694,
                    1333,
                    1942,
                    2197,
                    1371
                ],
                "self.axis": [
                    1570,
                    1315,
                    1316,
                    682,
                    683,
                    1387,
                    1297,
                    595
                ],
                "self._convert_tuple": [
                    609,
                    596
                ],
                "key": [
                    2051,
                    1540,
                    2054,
                    2055,
                    2059,
                    2060,
                    2063,
                    2064,
                    2039,
                    2067,
                    2069,
                    2070,
                    1559,
                    1560,
                    1561,
                    2071,
                    1563,
                    2073,
                    2074,
                    1567,
                    1572,
                    2088,
                    2090,
                    1584,
                    1585,
                    2104,
                    2115,
                    1606,
                    2118,
                    1609,
                    1612,
                    1614,
                    596,
                    602,
                    1626,
                    1629,
                    607,
                    609,
                    2146,
                    2147,
                    613,
                    614,
                    2149,
                    2152,
                    617,
                    623,
                    2159,
                    626,
                    627,
                    629,
                    630,
                    1656,
                    1661,
                    1663,
                    1667,
                    1675,
                    1677,
                    1680,
                    1681,
                    1682,
                    659,
                    2192,
                    1685,
                    2193,
                    1687,
                    1688,
                    1689,
                    1690,
                    1691,
                    1692,
                    1700,
                    1703,
                    1704,
                    687,
                    1711,
                    692,
                    1719,
                    1720,
                    1721,
                    1723,
                    1726,
                    1728,
                    1731,
                    1734,
                    1735,
                    1741,
                    1742,
                    1236,
                    1237,
                    1240,
                    2279,
                    1782,
                    1783,
                    1785,
                    1788,
                    770,
                    1796,
                    1798,
                    1290,
                    1291,
                    1803,
                    1805,
                    1806,
                    1807,
                    792,
                    796,
                    1822,
                    1824,
                    1825,
                    1827,
                    1829,
                    1830,
                    1831,
                    810,
                    1835,
                    1838,
                    815,
                    1841,
                    1842,
                    1335,
                    1336,
                    1337,
                    1855,
                    1856,
                    1857,
                    1869,
                    1871,
                    1872,
                    1873,
                    1877,
                    1878,
                    1904,
                    1394,
                    1907,
                    1396,
                    1401,
                    1934,
                    1947,
                    1948,
                    1952,
                    1449,
                    1452,
                    1456,
                    1983,
                    1989,
                    1990,
                    1992,
                    1993,
                    1995,
                    1996,
                    1997,
                    1487,
                    2000,
                    2001,
                    1490,
                    2005,
                    2006,
                    2010,
                    2012,
                    2032,
                    2033,
                    2035,
                    2036,
                    1526,
                    2038,
                    1535
                ],
                "ax": [
                    1154,
                    1155,
                    1540,
                    1157,
                    1160,
                    1162,
                    1548,
                    1165,
                    1911,
                    1177,
                    1182,
                    1184,
                    676,
                    677,
                    1444,
                    1449,
                    2090,
                    2091,
                    1453,
                    1199,
                    1200,
                    1455,
                    1456,
                    1457,
                    1459,
                    2098,
                    1207,
                    1209,
                    1216,
                    716,
                    724,
                    598,
                    600,
                    602,
                    1633,
                    1634,
                    1637,
                    1642,
                    1134,
                    756,
                    757,
                    1140,
                    1524,
                    1912
                ],
                "self.obj._get_axis": [
                    1160,
                    809,
                    1324,
                    1613,
                    1879,
                    1583,
                    1933,
                    2029,
                    1524,
                    1684,
                    598,
                    1780,
                    829
                ],
                "ABCMultiIndex": [
                    1634,
                    1698,
                    676,
                    1798,
                    1726,
                    1805,
                    1327,
                    851,
                    757,
                    1654,
                    1207,
                    600,
                    1208,
                    2267,
                    926
                ],
                "ax.get_loc": [
                    602
                ],
                "InvalidIndexError": [
                    603
                ],
                "self._convert_to_indexer": [
                    617,
                    695,
                    687
                ],
                "e": [
                    621
                ],
                "com.apply_if_callable": [
                    1572,
                    2064,
                    627,
                    2067,
                    629,
                    1560
                ],
                "com": [
                    905,
                    2064,
                    2067,
                    1560,
                    1690,
                    1948,
                    1572,
                    1829,
                    1855,
                    1609,
                    1995,
                    1106,
                    1237,
                    1366,
                    993,
                    1138,
                    627,
                    1266,
                    629,
                    758,
                    1396
                ],
                "x": [
                    1262,
                    2064,
                    1266,
                    627,
                    1560
                ],
                "indexer": [
                    1029,
                    1063,
                    1072,
                    1095,
                    1096,
                    1098,
                    1104,
                    1106,
                    1123,
                    1124,
                    1127,
                    1128,
                    1133,
                    630,
                    631,
                    1159,
                    1172,
                    1176,
                    2216,
                    2219,
                    2221,
                    1198,
                    1199,
                    2223,
                    2225,
                    2236,
                    711,
                    1736,
                    1737,
                    1738,
                    714,
                    715,
                    716,
                    1754,
                    734,
                    1758,
                    1759,
                    1763,
                    755,
                    756,
                    763,
                    765,
                    799,
                    820,
                    823,
                    826,
                    837,
                    838,
                    841,
                    843,
                    856,
                    858,
                    1892,
                    891,
                    925,
                    1449,
                    1451,
                    1452,
                    1453,
                    1456,
                    1459,
                    1461,
                    1462,
                    1490,
                    1492,
                    983,
                    984,
                    990,
                    991,
                    994,
                    2022,
                    999,
                    2023,
                    1006,
                    1009,
                    1016,
                    1530,
                    1533
                ],
                "self._get_setitem_indexer": [
                    630
                ],
                "self._setitem_with_indexer": [
                    1040,
                    801,
                    631
                ],
                "value": [
                    1040,
                    787,
                    1043,
                    792,
                    921,
                    2074,
                    924,
                    796,
                    801,
                    929,
                    932,
                    1060,
                    1062,
                    1063,
                    1067,
                    1069,
                    943,
                    1072,
                    1074,
                    947,
                    948,
                    2354,
                    2360,
                    826,
                    957,
                    961,
                    963,
                    840,
                    841,
                    968,
                    974,
                    980,
                    864,
                    865,
                    866,
                    869,
                    999,
                    1002,
                    749,
                    877,
                    1006,
                    1008,
                    1009,
                    885,
                    631,
                    1016
                ],
                "AbstractMethodError": [
                    2048,
                    1556,
                    653
                ],
                "Tuple": [
                    1312,
                    1221,
                    1894,
                    1575,
                    2121,
                    655,
                    1295,
                    1616,
                    1937,
                    1271,
                    1244,
                    1373,
                    670
                ],
                "i": [
                    1667,
                    1670,
                    777,
                    784,
                    659,
                    660,
                    663,
                    1176,
                    1177,
                    1947,
                    1188,
                    809,
                    2090,
                    811,
                    684,
                    685,
                    2092,
                    2098,
                    692,
                    693,
                    695,
                    1335,
                    1337,
                    954,
                    957,
                    1346,
                    2115,
                    2116,
                    1349,
                    1355,
                    716,
                    717,
                    1102,
                    720,
                    723,
                    724,
                    1236,
                    728,
                    1240,
                    2264,
                    1629,
                    1633,
                    994,
                    995,
                    1133,
                    1134,
                    1394,
                    1907,
                    756,
                    758,
                    1911,
                    765
                ],
                "k": [
                    1637,
                    663,
                    659,
                    692,
                    1907,
                    1908,
                    695,
                    2264,
                    2266,
                    1629,
                    1630
                ],
                "self._validate_key": [
                    1996,
                    1741,
                    1487,
                    2038,
                    663,
                    1688
                ],
                "self._valid_types": [
                    1889,
                    667
                ],
                "self.obj.axes": [
                    1633,
                    1154,
                    2115,
                    676,
                    677,
                    2090,
                    716,
                    784,
                    755,
                    756,
                    1911,
                    1177,
                    892,
                    799
                ],
                "is_nested_tuple": [
                    1824,
                    677,
                    1734
                ],
                "tup": [
                    1291,
                    1939,
                    1300,
                    1941,
                    1307,
                    1947,
                    677,
                    1317,
                    1320,
                    1321,
                    1328,
                    1332,
                    1335,
                    1346,
                    1349,
                    1223,
                    1228,
                    1231,
                    1232,
                    1236,
                    2261,
                    2264,
                    1380,
                    1381,
                    1388,
                    1262,
                    1266,
                    1394
                ],
                "keyidx": [
                    681,
                    686,
                    690,
                    696,
                    697
                ],
                "keyidx.append": [
                    696,
                    690,
                    686
                ],
                "is_setter": [
                    695,
                    1791,
                    2087,
                    687
                ],
                "idx": [
                    770,
                    905,
                    906,
                    1174,
                    1181,
                    1182,
                    1190,
                    1192,
                    1195,
                    818,
                    695,
                    696,
                    1106,
                    856,
                    858,
                    993,
                    994,
                    2145,
                    2147,
                    869,
                    1133,
                    2157,
                    2159,
                    881,
                    882,
                    1137,
                    1138,
                    885,
                    1140,
                    765,
                    766
                ],
                "_tuplify": [
                    715,
                    838,
                    2070
                ],
                "is_list_like_indexer": [
                    864,
                    1692,
                    1827,
                    2054,
                    2279,
                    1067,
                    1612,
                    1198,
                    1262,
                    720,
                    1841,
                    2000,
                    787,
                    1141,
                    1877,
                    921,
                    1340
                ],
                "is_integer": [
                    1796,
                    2116,
                    844,
                    2092,
                    1871,
                    2098,
                    723,
                    1908,
                    758,
                    2006,
                    991
                ],
                "self._has_valid_setitem_indexer": [
                    734
                ],
                "info_axis": [
                    930,
                    835,
                    739,
                    995,
                    999,
                    843,
                    856,
                    858,
                    891,
                    892,
                    829,
                    990,
                    991
                ],
                "self.obj._info_axis_number": [
                    777,
                    739
                ],
                "take_split_path": [
                    832,
                    742,
                    746,
                    750,
                    760
                ],
                "self.obj._is_mixed_type": [
                    742
                ],
                "self.obj._data.blocks": [
                    746,
                    747
                ],
                "self.obj._data": [
                    746,
                    811,
                    747,
                    1074,
                    1016,
                    1048
                ],
                "blk": [
                    747,
                    748,
                    750
                ],
                "blk.ndim": [
                    748
                ],
                "val": [
                    1216,
                    1217,
                    1193,
                    1195,
                    1196,
                    749,
                    750,
                    1201
                ],
                "value.values": [
                    749
                ],
                "blk._can_hold_element": [
                    750
                ],
                "com.is_null_slice": [
                    993,
                    905,
                    1138,
                    1106,
                    1396,
                    1237,
                    758,
                    1366,
                    1948
                ],
                "nindexer": [
                    818,
                    764,
                    820,
                    815
                ],
                "_": [
                    2136,
                    770,
                    1123
                ],
                "convert_missing_indexer": [
                    770,
                    823
                ],
                "len_non_info_axes": [
                    786,
                    783
                ],
                "_ax": [
                    784
                ],
                "_i": [
                    784,
                    2234,
                    2236
                ],
                "l": [
                    786
                ],
                "_infer_fill_value": [
                    796
                ],
                "new_indexer": [
                    801,
                    1038,
                    1039,
                    1040,
                    1459,
                    798
                ],
                "convert_from_missing_indexer_tuple": [
                    798
                ],
                "index": [
                    1028,
                    1029,
                    809,
                    810,
                    1037,
                    1038,
                    2193,
                    882,
                    2194,
                    2358,
                    855,
                    2362,
                    859,
                    2206
                ],
                "labels": [
                    1795,
                    1670,
                    1798,
                    1803,
                    1805,
                    1806,
                    1684,
                    1685,
                    926,
                    928,
                    1824,
                    1698,
                    1825,
                    1830,
                    810,
                    811,
                    1838,
                    815,
                    1583,
                    1584,
                    2354,
                    948,
                    2357,
                    954,
                    1726,
                    961,
                    963,
                    1734,
                    1735,
                    968,
                    1613,
                    846,
                    974,
                    1614,
                    850,
                    851,
                    979,
                    853,
                    1753,
                    1754,
                    2267,
                    2021,
                    2022,
                    2029,
                    2033,
                    1780,
                    2036,
                    1654,
                    1783,
                    1657,
                    1788,
                    1661
                ],
                "index.insert": [
                    810,
                    1029
                ],
                "_data": [
                    1048,
                    1074,
                    811
                ],
                "self.obj.reindex": [
                    811
                ],
                "self.obj._maybe_update_cacher": [
                    1017,
                    1051,
                    812,
                    1075
                ],
                "self.obj._is_copy": [
                    813
                ],
                "nindexer.append": [
                    818,
                    815
                ],
                "labels.get_loc": [
                    1803,
                    1838,
                    815
                ],
                "missing": [
                    823,
                    825,
                    1530,
                    1532,
                    1533
                ],
                "self._setitem_with_indexer_missing": [
                    826
                ],
                "item_labels": [
                    997,
                    829,
                    846,
                    999
                ],
                "ABCSeries": [
                    2304,
                    1060,
                    1700,
                    2245,
                    840,
                    1002,
                    2193,
                    1078
                ],
                "self._align_series": [
                    841,
                    931,
                    1006
                ],
                "info_idx": [
                    843,
                    844,
                    845,
                    846
                ],
                "axes": [
                    2234,
                    851
                ],
                "item": [
                    896,
                    928,
                    929,
                    930,
                    932,
                    937,
                    974,
                    975,
                    979,
                    980,
                    853,
                    886,
                    854,
                    917,
                    2357,
                    954,
                    2358,
                    957
                ],
                "obj": [
                    1410,
                    1413,
                    2358,
                    1749,
                    854,
                    1751,
                    855,
                    1110,
                    1753,
                    2016,
                    2145,
                    2019,
                    1124,
                    869,
                    2021,
                    2152,
                    1134,
                    1392,
                    2289,
                    2290,
                    883,
                    884,
                    885,
                    886,
                    2291,
                    1400,
                    1401,
                    1405
                ],
                "obj.index": [
                    2145,
                    855
                ],
                "plane_indexer": [
                    897,
                    859,
                    961,
                    2354,
                    858,
                    891,
                    893
                ],
                "lplane_indexer": [
                    897,
                    866,
                    961,
                    859,
                    2364,
                    893
                ],
                "length_of_indexer": [
                    859,
                    893
                ],
                "np.iterable": [
                    865,
                    2354
                ],
                "np": [
                    2304,
                    865,
                    1700,
                    2245,
                    2340,
                    1095,
                    935,
                    1129,
                    1993,
                    2249,
                    1102,
                    943,
                    2354,
                    947,
                    1878,
                    2166,
                    1179,
                    2205
                ],
                "ravel": [
                    1104,
                    877
                ],
                "index._convert_slice_indexer": [
                    882
                ],
                "obj._consolidate_inplace": [
                    883
                ],
                "obj.copy": [
                    2019,
                    884,
                    1751
                ],
                "obj._data": [
                    2152,
                    885
                ],
                "obj._data.setitem": [
                    885
                ],
                "plane_axis": [
                    892,
                    893
                ],
                "s": [
                    896,
                    908,
                    911,
                    912,
                    913,
                    914,
                    917
                ],
                "pi": [
                    904,
                    897,
                    906,
                    913
                ],
                "com.is_full_slice": [
                    905
                ],
                "v": [
                    931,
                    935,
                    937,
                    908,
                    974,
                    975,
                    913
                ],
                "s._consolidate_inplace": [
                    911
                ],
                "s.copy": [
                    912
                ],
                "s._data": [
                    913
                ],
                "s._data.setitem": [
                    913
                ],
                "s._maybe_update_cacher": [
                    914
                ],
                "ABCDataFrame": [
                    1704,
                    1354,
                    1008,
                    1169,
                    924
                ],
                "sub_indexer": [
                    930,
                    932,
                    925
                ],
                "multiindex_indexer": [
                    932,
                    926,
                    1127
                ],
                "np.nan": [
                    935
                ],
                "setter": [
                    963,
                    937,
                    975,
                    980,
                    957
                ],
                "np.ndim": [
                    943
                ],
                "np.array": [
                    947,
                    1878
                ],
                "value.shape": [
                    948
                ],
                "tolist": [
                    957
                ],
                "_can_do_equal_len": [
                    960
                ],
                "maybe_convert_ix": [
                    984
                ],
                "item_labels.is_unique": [
                    997
                ],
                "Series": [
                    1072,
                    1043,
                    1006
                ],
                "self._align_frame": [
                    1009
                ],
                "self.obj._check_is_chained_assignment_possible": [
                    1012
                ],
                "self.obj._consolidate_inplace": [
                    1015
                ],
                "self.obj._data.setitem": [
                    1016
                ],
                "self.obj.index": [
                    1307,
                    1028,
                    1199
                ],
                "new_index": [
                    1049,
                    1029,
                    1038
                ],
                "index.is_unique": [
                    1037
                ],
                "index.get_indexer": [
                    1038
                ],
                "new_values": [
                    1049,
                    1043,
                    1047
                ],
                "_values": [
                    1216,
                    1124,
                    1157,
                    1193,
                    1195,
                    1165,
                    1201,
                    1043,
                    2202,
                    1148
                ],
                "self.obj._values": [
                    1044,
                    1047
                ],
                "concat_compat": [
                    1047
                ],
                "self.obj._constructor": [
                    1048
                ],
                "self.obj.name": [
                    1049
                ],
                "self.obj.columns": [
                    1056,
                    1072,
                    1069,
                    1062
                ],
                "value.reindex": [
                    1062
                ],
                "value.name": [
                    1063
                ],
                "self.obj.append": [
                    1074
                ],
                "np.ndarray": [
                    2304,
                    1700,
                    2245,
                    1095,
                    1102,
                    2166,
                    1179
                ],
                "Index": [
                    1856,
                    2304,
                    2245,
                    1095,
                    2166,
                    1142,
                    1144
                ],
                "i.ravel": [
                    1102
                ],
                "aligners": [
                    1106,
                    1107,
                    1119
                ],
                "sum_aligners": [
                    1123,
                    1107,
                    1108
                ],
                "single_aligner": [
                    1138,
                    1108,
                    1151,
                    1119
                ],
                "is_frame": [
                    1170,
                    1198,
                    1109,
                    1118
                ],
                "is_sequence": [
                    1137,
                    1178,
                    1123
                ],
                "ser": [
                    1155,
                    1124,
                    1156,
                    1157,
                    1129,
                    1162,
                    1131,
                    1163,
                    1165,
                    1145,
                    1146,
                    1148
                ],
                "ser.reindex": [
                    1148,
                    1124,
                    1157,
                    1165
                ],
                "obj.axes": [
                    1124,
                    1134
                ],
                "len_indexer": [
                    1128,
                    1129
                ],
                "T": [
                    1129
                ],
                "reshape": [
                    1129
                ],
                "np.tile": [
                    1129
                ],
                "new_ix": [
                    1140,
                    1141,
                    1142,
                    1144,
                    1145,
                    1148
                ],
                "ser.index.equals": [
                    1145,
                    1162,
                    1155
                ],
                "ser.index": [
                    1145,
                    1162,
                    1155
                ],
                "ser._values.copy": [
                    1146,
                    1163,
                    1156
                ],
                "ser._values": [
                    1146,
                    1163,
                    1156
                ],
                "is_scalar": [
                    1798,
                    1159,
                    2354,
                    1785,
                    1405,
                    1630
                ],
                "cols": [
                    1184,
                    1190,
                    1192,
                    1195,
                    1174,
                    1183
                ],
                "sindexers": [
                    1188,
                    1175
                ],
                "ix": [
                    1184,
                    1176,
                    1178,
                    1179,
                    1180,
                    1182
                ],
                "ix.ravel": [
                    1180
                ],
                "sindexers.append": [
                    1188
                ],
                "df.index.equals": [
                    1192,
                    1200
                ],
                "df.index": [
                    1192,
                    1208,
                    1209,
                    1200
                ],
                "df": [
                    1216,
                    2343,
                    1192,
                    1193,
                    1195,
                    1200,
                    1201,
                    1208,
                    1209
                ],
                "df.columns.equals": [
                    1192
                ],
                "df.columns": [
                    1192
                ],
                "df.copy": [
                    1193,
                    1201
                ],
                "df.reindex": [
                    1216,
                    1195
                ],
                "ax.nlevels": [
                    1209
                ],
                "df.index.nlevels": [
                    1209
                ],
                "self._getitem_lowerdim": [
                    1941,
                    1223
                ],
                "self._has_valid_tuple": [
                    1939,
                    1228
                ],
                "self._multi_take_opportunity": [
                    1231
                ],
                "self._multi_take": [
                    1232
                ],
                "retval": [
                    1952,
                    1955,
                    1963,
                    1235,
                    1240,
                    1945,
                    1242
                ],
                "_getitem_axis": [
                    1240,
                    1401,
                    1952
                ],
                "com.is_bool_indexer": [
                    1829,
                    1609,
                    1995,
                    1266,
                    1690,
                    1855
                ],
                "o": [
                    1443,
                    1444,
                    1288,
                    1291,
                    1293
                ],
                "d": [
                    1289,
                    1293
                ],
                "self._get_listlike_indexer": [
                    1490,
                    1290,
                    1835
                ],
                "o._AXIS_ORDERS": [
                    1291
                ],
                "o._reindex_with_indexers": [
                    1293
                ],
                "self._get_label": [
                    1300,
                    1742
                ],
                "self.obj.index.nlevels": [
                    1307
                ],
                "ek": [
                    1308
                ],
                "self._getitem_axis": [
                    1337,
                    1573,
                    1388,
                    1317
                ],
                "self._is_nested_tuple_indexer": [
                    1320
                ],
                "self._getitem_nested_tuple": [
                    1321
                ],
                "ax0": [
                    1324,
                    1327
                ],
                "result": [
                    2208,
                    1381,
                    1382,
                    1383,
                    1328,
                    1329,
                    1330,
                    2192,
                    2194,
                    2195,
                    2202,
                    2205,
                    2206
                ],
                "self._handle_lowerdim_multi_index_axis0": [
                    1328,
                    1381
                ],
                "is_label_like": [
                    1336
                ],
                "section": [
                    1369,
                    1354,
                    1367,
                    1337,
                    1340,
                    1341,
                    1343
                ],
                "section.ndim": [
                    1343
                ],
                "new_key": [
                    1346,
                    1666,
                    1349,
                    1672,
                    1674,
                    1675,
                    1356,
                    1358,
                    1359,
                    1361,
                    1362,
                    1366,
                    1369
                ],
                "a": [
                    2115,
                    1358,
                    1359
                ],
                "b": [
                    1358,
                    1359
                ],
                "current_ndim": [
                    1400,
                    1410
                ],
                "obj.ndim": [
                    1400,
                    1410
                ],
                "o._get_axis": [
                    1444
                ],
                "keyarr": [
                    1449,
                    1457,
                    1490,
                    1459,
                    1492,
                    1461,
                    1462
                ],
                "ax._convert_listlike_indexer": [
                    1449
                ],
                "self._validate_read_indexer": [
                    1452,
                    1461
                ],
                "raise_missing": [
                    1539,
                    1452,
                    1461
                ],
                "ax.is_unique": [
                    1912,
                    1642,
                    1455
                ],
                "ax.get_indexer_for": [
                    1456
                ],
                "ax.reindex": [
                    1457
                ],
                "ax._reindex_non_unique": [
                    1459
                ],
                "self.obj._reindex_with_indexers": [
                    1491
                ],
                "axis_name": [
                    1534,
                    1535
                ],
                "self.obj._get_axis_name": [
                    1534
                ],
                "not_found": [
                    1540,
                    1541
                ],
                "ax.is_categorical": [
                    1548
                ],
                "ax.is_interval": [
                    1548
                ],
                "self._is_scalar_access": [
                    1561
                ],
                "self.obj._get_value": [
                    1563,
                    2060
                ],
                "self._takeable": [
                    2074,
                    1563,
                    2060
                ],
                "self._getitem_tuple": [
                    1567
                ],
                "maybe_callable": [
                    1572,
                    1573
                ],
                "check_bool_indexer": [
                    1584,
                    1830
                ],
                "inds": [
                    1832,
                    1585,
                    1586,
                    1831
                ],
                "key.nonzero": [
                    1585,
                    1831
                ],
                "self.obj._take_with_is_copy": [
                    1586,
                    1983
                ],
                "_LocationIndexer": [
                    1598,
                    1590,
                    1847
                ],
                "_takeable": [
                    2109,
                    1852,
                    2079,
                    1591
                ],
                "labels._convert_scalar_indexer": [
                    1788,
                    1614,
                    2036
                ],
                "Appender": [
                    1589,
                    1846,
                    2107,
                    2077,
                    1598
                ],
                "_LocationIndexer._validate_key.__doc__": [
                    1598
                ],
                "_LocationIndexer._validate_key": [
                    1598
                ],
                "ax._supports_partial_string_indexing": [
                    1637
                ],
                "_supports_partial_string_indexing": [
                    1657,
                    1670
                ],
                "labels.levels": [
                    1657,
                    1661,
                    1670
                ],
                "component": [
                    1672,
                    1674,
                    1667,
                    1669
                ],
                "new_key.append": [
                    1672,
                    1674
                ],
                "item_from_zerodim": [
                    1680,
                    2005
                ],
                "is_iterator": [
                    1681
                ],
                "self._get_partial_string_timestamp_match_key": [
                    1685
                ],
                "self._get_slice_axis": [
                    1689,
                    1990
                ],
                "self._getbool_axis": [
                    1691,
                    1997
                ],
                "key.ndim": [
                    1728,
                    1700,
                    1711
                ],
                "self._getitem_iterable": [
                    1731
                ],
                "locs": [
                    1737,
                    1735
                ],
                "labels.get_locs": [
                    1825,
                    1735
                ],
                "self.obj.iloc": [
                    1738
                ],
                "need_slice": [
                    2018,
                    1750
                ],
                "slice_obj": [
                    2022,
                    2018,
                    1755,
                    1750
                ],
                "obj._get_axis": [
                    1753,
                    2021
                ],
                "labels.slice_indexer": [
                    1754
                ],
                "slice_obj.start": [
                    1755
                ],
                "slice_obj.stop": [
                    1755
                ],
                "slice_obj.step": [
                    1755
                ],
                "self.obj._slice": [
                    2023,
                    1759
                ],
                "self.obj.take": [
                    1763
                ],
                "labels._convert_slice_indexer": [
                    2033,
                    2022,
                    1783
                ],
                "is_int_index": [
                    1795,
                    1796
                ],
                "labels.is_integer": [
                    1795
                ],
                "is_int_positional": [
                    1816,
                    1796,
                    1812
                ],
                "labels.nlevels": [
                    1806
                ],
                "IndexingMixin.loc.__doc__": [
                    1589
                ],
                "IndexingMixin.loc": [
                    1589
                ],
                "IndexingMixin": [
                    2077,
                    2107,
                    1589,
                    1846
                ],
                "key.index": [
                    1856,
                    1857,
                    2193
                ],
                "key.index.inferred_type": [
                    1857
                ],
                "self._validate_integer": [
                    1872,
                    2010
                ],
                "arr": [
                    1886,
                    1882,
                    1883,
                    1878
                ],
                "len_axis": [
                    1934,
                    1933,
                    1886,
                    1879
                ],
                "is_numeric_dtype": [
                    1882
                ],
                "arr.dtype": [
                    1882
                ],
                "arr.max": [
                    1886
                ],
                "arr.min": [
                    1886
                ],
                "self._has_valid_positional_setitem_indexer": [
                    1892
                ],
                "retval.ndim": [
                    1955
                ],
                "np.asarray": [
                    1993,
                    2205
                ],
                "self._get_list_axis": [
                    2001
                ],
                "self.obj._ixs": [
                    2012
                ],
                "is_float": [
                    2035
                ],
                "IndexingMixin.iloc.__doc__": [
                    1846
                ],
                "IndexingMixin.iloc": [
                    1846
                ],
                "self._convert_key": [
                    2073,
                    2059
                ],
                "self.obj._set_value": [
                    2074
                ],
                "_ScalarAccessIndexer": [
                    2108,
                    2078
                ],
                "ax.is_integer": [
                    2091
                ],
                "ax.holds_integer": [
                    2098
                ],
                "ax.is_floating": [
                    2098
                ],
                "IndexingMixin.at.__doc__": [
                    2077
                ],
                "IndexingMixin.at": [
                    2077
                ],
                "IndexingMixin.iat.__doc__": [
                    2107
                ],
                "IndexingMixin.iat": [
                    2107
                ],
                "Hashable": [
                    2121,
                    2135
                ],
                "_tup": [
                    2136,
                    2137,
                    2138,
                    2135
                ],
                "List": [
                    2135
                ],
                "Union": [
                    2121,
                    2135
                ],
                "ndim": [
                    2136
                ],
                "loc": [
                    2137
                ],
                "idx._convert_slice_indexer": [
                    2147
                ],
                "obj._data.items": [
                    2152
                ],
                "idx._supports_partial_string_indexing": [
                    2157
                ],
                "idx._get_string_slice": [
                    2159
                ],
                "key.index.equals": [
                    2193
                ],
                "result.reindex": [
                    2194
                ],
                "mask": [
                    2195,
                    2196
                ],
                "isna": [
                    2195
                ],
                "result._values": [
                    2195
                ],
                "mask.any": [
                    2196
                ],
                "result.astype": [
                    2202
                ],
                "check_array_indexer": [
                    2206
                ],
                "_idx": [
                    2234,
                    2236
                ],
                "get_loc": [
                    2234
                ],
                "get_indexer": [
                    2236
                ],
                "ixify": [
                    2248,
                    2243,
                    2246
                ],
                "args": [
                    2249,
                    2251,
                    2244
                ],
                "np.ix_": [
                    2249
                ],
                "is_list_like": [
                    2266,
                    2322,
                    2318
                ],
                "obj.start": [
                    2289
                ],
                "obj.stop": [
                    2290
                ],
                "obj.step": [
                    2291
                ],
                "kinds": [
                    2304,
                    2305
                ],
                "slice_": [
                    2305,
                    2306,
                    2339,
                    2343,
                    2344,
                    2322,
                    2323,
                    2325,
                    2328,
                    2330,
                    2331
                ],
                "part": [
                    2330,
                    2318,
                    2319
                ],
                "pred": [
                    2330
                ],
                "dtypes": [
                    2340,
                    2342,
                    2343
                ],
                "np.number": [
                    2340
                ],
                "include_bool": [
                    2341
                ],
                "dtypes.append": [
                    2342
                ],
                "columns": [
                    2343
                ],
                "df.select_dtypes": [
                    2343
                ],
                "values_len": [
                    2360,
                    2362,
                    2364
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_63/pandas/tests/indexing/test_scalar.py",
                "test_function": "test_series_at_raises_type_error",
                "test_function_code": "    def test_series_at_raises_type_error(self):\n        # at should not fallback\n        # GH 7814\n        # GH#31724 .at should match .loc\n        ser = Series([1, 2, 3], index=list(\"abc\"))\n        result = ser.at[\"a\"]\n        assert result == 1\n        result = ser.loc[\"a\"]\n        assert result == 1\n\n        msg = (\n            \"cannot do label indexing on <class 'pandas.core.indexes.base.Index'> \"\n            r\"with these indexers \\[0\\] of <class 'int'>\"\n        )\n        with pytest.raises(TypeError, match=msg):\n            ser.at[0]\n        with pytest.raises(TypeError, match=msg):\n            ser.loc[0]",
                "test_error": "ValueError: At based indexing on an non-integer index can only have non-integer indexers",
                "full_test_error": "self = <pandas.tests.indexing.test_scalar.TestScalar2 object at 0x115df5d00>\n\n    def test_series_at_raises_type_error(self):\n        # at should not fallback\n        # GH 7814\n        # GH#31724 .at should match .loc\n        ser = Series([1, 2, 3], index=list(\"abc\"))\n        result = ser.at[\"a\"]\n        assert result == 1\n        result = ser.loc[\"a\"]\n        assert result == 1\n    \n        msg = (\n            \"cannot do label indexing on <class 'pandas.core.indexes.base.Index'> \"\n            r\"with these indexers \\[0\\] of <class 'int'>\"\n        )\n        with pytest.raises(TypeError, match=msg):\n>           ser.at[0]\n\npandas/tests/indexing/test_scalar.py:147: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/indexing.py:2059: in __getitem__\n    key = self._convert_key(key)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.indexing._AtIndexer object at 0x115edb630>, key = (0,)\nis_setter = False\n\n    def _convert_key(self, key, is_setter: bool = False):\n        \"\"\"\n        Require they keys to be the same type as the index. (so we don't\n        fallback)\n        \"\"\"\n        # allow arbitrary setting\n        if is_setter:\n            return list(key)\n    \n        for ax, i in zip(self.obj.axes, key):\n            if ax.is_integer():\n                if not is_integer(i):\n                    raise ValueError(\n                        \"At based indexing on an integer index \"\n                        \"can only have integer indexers\"\n                    )\n            else:\n                if is_integer(i) and not (ax.holds_integer() or ax.is_floating()):\n>                   raise ValueError(\n                        \"At based indexing on an non-integer \"\n                        \"index can only have non-integer \"\n                        \"indexers\"\n                    )\nE                   ValueError: At based indexing on an non-integer index can only have non-integer indexers\n\npandas/core/indexing.py:2099: ValueError",
                "traceback": "pandas/core/indexing.py:2059: in __getitem__\n    key = self._convert_key(key)",
                "test_error_location": "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.indexing._AtIndexer object at 0x115edb630>, key = (0,)\nis_setter = False\n\n    def _convert_key(self, key, is_setter: bool = False):\n        \"\"\"\n        Require they keys to be the same type as the index. (so we don't\n        fallback)\n        \"\"\"\n        # allow arbitrary setting\n        if is_setter:\n            return list(key)\n    \n        for ax, i in zip(self.obj.axes, key):\n            if ax.is_integer():\n                if not is_integer(i):\n                    raise ValueError(\n                        \"At based indexing on an integer index \"\n                        \"can only have integer indexers\"\n                    )\n            else:\n                if is_integer(i) and not (ax.holds_integer() or ax.is_floating()):\n>                   raise ValueError(\n                        \"At based indexing on an non-integer \"\n                        \"index can only have non-integer \"\n                        \"indexers\"\n                    )\nE                   ValueError: At based indexing on an non-integer index can only have non-integer indexers\n\npandas/core/indexing.py:2099: ValueError",
                "test_function_decorators": []
            }
        ]
    }
}