{
    "1.1.1": "@Appender(_index_shared_docs[\"get_indexer_non_unique\"] % _index_doc_kwargs)\ndef get_indexer_non_unique(self, target):\n    target = ensure_index(target)\n    pself, ptarget = self._maybe_promote(target)\n    if pself is not self or ptarget is not target:\n        return pself.get_indexer_non_unique(ptarget)\n\n    if is_categorical(target):\n        tgt_values = np.asarray(target)\n    elif self.is_all_dates:\n        tgt_values = target.asi8\n    else:\n        tgt_values = target._ndarray_values\n\n    indexer, missing = self._engine.get_indexer_non_unique(tgt_values)\n    return ensure_platform_int(indexer), missing\n",
    "1.1.2": null,
    "1.2.1": "class Index(IndexOpsMixin, PandasObject)",
    "1.2.2": "Immutable ndarray implementing an ordered, sliceable set. The basic object\nstoring axis labels for all pandas objects.\n\nParameters\n----------\ndata : array-like (1-dimensional)\ndtype : NumPy dtype (default: object)\n    If dtype is None, we find the dtype that best fits the data.\n    If an actual dtype is provided, we coerce to that dtype if it's safe.\n    Otherwise, an error will be raised.\ncopy : bool\n    Make a copy of input ndarray.\nname : object\n    Name to be stored in the index.\ntupleize_cols : bool (default: True)\n    When True, attempt to create a MultiIndex if possible.\n\nSee Also\n--------\nRangeIndex : Index implementing a monotonic integer range.\nCategoricalIndex : Index of :class:`Categorical` s.\nMultiIndex : A multi-level, or hierarchical, Index.\nIntervalIndex : An Index of :class:`Interval` s.\nDatetimeIndex, TimedeltaIndex, PeriodIndex\nInt64Index, UInt64Index,  Float64Index\n\nNotes\n-----\nAn Index instance can **only** contain hashable objects\n\nExamples\n--------\n>>> pd.Index([1, 2, 3])\nInt64Index([1, 2, 3], dtype='int64')\n\n>>> pd.Index(list('abc'))\nIndex(['a', 'b', 'c'], dtype='object')",
    "1.2.3": [
        "asi8(self)",
        "_engine(self)",
        "is_categorical(self) -> bool",
        "is_all_dates(self) -> bool",
        "get_indexer_non_unique(self, target)",
        "_maybe_promote(self, other)"
    ],
    "1.3.1": "/Volumes/JerrySSD/bgp_envs/repos/pandas_106/pandas/core/indexes/base.py",
    "1.3.2": [
        "ensure_index(index_like, copy=False)",
        "asi8(self)",
        "_engine(self)",
        "is_categorical(self) -> bool",
        "is_all_dates(self) -> bool",
        "get_indexer_non_unique(self, target)",
        "_maybe_promote(self, other)"
    ],
    "1.4.1": [
        "def test_drop_with_non_unique_datetime_index_and_invalid_keys():\n    # GH 30399\n\n    # define dataframe with unique datetime index\n    df = pd.DataFrame(\n        np.random.randn(5, 3),\n        columns=[\"a\", \"b\", \"c\"],\n        index=pd.date_range(\"2012\", freq=\"H\", periods=5),\n    )\n    # create dataframe with non-unique datetime index\n    df = df.iloc[[0, 2, 2, 3]].copy()\n\n    with pytest.raises(KeyError, match=\"not found in axis\"):\n        df.drop([\"a\", \"b\"])  # Dropping with labels not exist in the index"
    ],
    "1.4.2": [
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_106/pandas/tests/indexes/multi/test_drop.py"
    ],
    "2.1.1": [
        [
            "E   TypeError: 'NoneType' object is not iterable"
        ]
    ],
    "2.1.2": [
        [
            "def test_drop_with_non_unique_datetime_index_and_invalid_keys():\n        # GH 30399\n    \n        # define dataframe with unique datetime index\n        df = pd.DataFrame(\n            np.random.randn(5, 3),\n            columns=[\"a\", \"b\", \"c\"],\n            index=pd.date_range(\"2012\", freq=\"H\", periods=5),\n        )\n        # create dataframe with non-unique datetime index\n        df = df.iloc[[0, 2, 2, 3]].copy()\n    \n        with pytest.raises(KeyError, match=\"not found in axis\"):\n>           df.drop([\"a\", \"b\"])  # Dropping with labels not exist in the index\n\npandas/tests/indexes/multi/test_drop.py:157: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/frame.py:3817: in drop\n    return super().drop(\npandas/core/generic.py:3894: in drop\n    obj = obj._drop_axis(labels, axis, level=level, errors=errors)\npandas/core/generic.py:3943: in _drop_axis\n    labels_missing = (axis.get_indexer_for(labels) == -1).any()\npandas/core/indexes/base.py:4576: in get_indexer_for\n    indexer, _ = self.get_indexer_non_unique(target, **kwargs)\npandas/core/indexes/base.py:4559: in get_indexer_non_unique\n    indexer, missing = self._engine.get_indexer_non_unique(tgt_values)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n>   stargets = set(targets)",
            "\npandas/_libs/index.pyx:307: TypeError"
        ]
    ],
    "2.1.3": null,
    "2.1.4": null,
    "2.1.5": [
        [
            {
                "target": "array(['a', 'b'], dtype=object)",
                "self._maybe_promote": "<bound method DatetimeIndex._maybe_promote of DatetimeIndex(['2012-01-01 00:00:00', '2012-01-01 02:00:00',\n               '2012-01-01 02:00:00', '2012-01-01 03:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                "self": "DatetimeIndex(['2012-01-01 00:00:00', '2012-01-01 02:00:00',\n               '2012-01-01 02:00:00', '2012-01-01 03:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                "self.is_all_dates": "True",
                "self._engine": "<pandas._libs.index.DatetimeEngine object at 0x114807310>"
            },
            {
                "target": "Index(['a', 'b'], dtype='object')",
                "pself": "DatetimeIndex(['2012-01-01 00:00:00', '2012-01-01 02:00:00',\n               '2012-01-01 02:00:00', '2012-01-01 03:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                "ptarget": "Index(['a', 'b'], dtype='object')",
                "pself.get_indexer_non_unique": "<bound method Index.get_indexer_non_unique of DatetimeIndex(['2012-01-01 00:00:00', '2012-01-01 02:00:00',\n               '2012-01-01 02:00:00', '2012-01-01 03:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                "tgt_values": "array(['a', 'b'], dtype=object)",
                "target.is_all_dates": "False",
                "target._ndarray_values": "array(['a', 'b'], dtype=object)",
                "indexer": "array([-1, -1])",
                "missing": "array([0, 1])"
            }
        ]
    ],
    "2.1.6": [
        [
            {
                "target": "ndarray",
                "self._maybe_promote": "method",
                "self": "DatetimeIndex",
                "self.is_all_dates": "bool",
                "self._engine": "DatetimeEngine"
            },
            {
                "target": "Index",
                "pself": "DatetimeIndex",
                "ptarget": "Index",
                "pself.get_indexer_non_unique": "method",
                "tgt_values": "ndarray",
                "target.is_all_dates": "bool",
                "target._ndarray_values": "ndarray",
                "indexer": "ndarray",
                "missing": "ndarray"
            }
        ]
    ],
    "3.1.1": null,
    "3.1.2": null
}