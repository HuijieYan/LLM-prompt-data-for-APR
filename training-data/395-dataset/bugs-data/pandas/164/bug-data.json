{
    "pandas:164": {
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_164/pandas/core/tools/datetimes.py": {
            "buggy_functions": [
                {
                    "function_name": "_convert_listlike_datetimes",
                    "function_code": "def _convert_listlike_datetimes(\n    arg,\n    box,\n    format,\n    name=None,\n    tz=None,\n    unit=None,\n    errors=None,\n    infer_datetime_format=None,\n    dayfirst=None,\n    yearfirst=None,\n    exact=None,\n):\n    \"\"\"\n    Helper function for to_datetime. Performs the conversions of 1D listlike\n    of dates\n\n    Parameters\n    ----------\n    arg : list, tuple, ndarray, Series, Index\n        date to be parced\n    box : boolean\n        True boxes result as an Index-like, False returns an ndarray\n    name : object\n        None or string for the Index name\n    tz : object\n        None or 'utc'\n    unit : string\n        None or string of the frequency of the passed data\n    errors : string\n        error handing behaviors from to_datetime, 'raise', 'coerce', 'ignore'\n    infer_datetime_format : boolean\n        inferring format behavior from to_datetime\n    dayfirst : boolean\n        dayfirst parsing behavior from to_datetime\n    yearfirst : boolean\n        yearfirst parsing behavior from to_datetime\n    exact : boolean\n        exact format matching behavior from to_datetime\n\n    Returns\n    -------\n    ndarray of parsed dates\n        Returns:\n\n        - Index-like if box=True\n        - ndarray of Timestamps if box=False\n    \"\"\"\n    from pandas import DatetimeIndex\n    from pandas.core.arrays import DatetimeArray\n    from pandas.core.arrays.datetimes import (\n        maybe_convert_dtype,\n        objects_to_datetime64ns,\n    )\n\n    if isinstance(arg, (list, tuple)):\n        arg = np.array(arg, dtype=\"O\")\n\n    # these are shortcutable\n    if is_datetime64tz_dtype(arg):\n        if not isinstance(arg, (DatetimeArray, DatetimeIndex)):\n            return DatetimeIndex(arg, tz=tz, name=name)\n        if tz == \"utc\":\n            arg = arg.tz_convert(None).tz_localize(tz)\n        return arg\n\n    elif is_datetime64_ns_dtype(arg):\n        if box and not isinstance(arg, (DatetimeArray, DatetimeIndex)):\n            try:\n                return DatetimeIndex(arg, tz=tz, name=name)\n            except ValueError:\n                pass\n\n        return arg\n\n    elif unit is not None:\n        if format is not None:\n            raise ValueError(\"cannot specify both format and unit\")\n        arg = getattr(arg, \"values\", arg)\n        result, tz_parsed = tslib.array_with_unit_to_datetime(arg, unit, errors=errors)\n        if box:\n            if errors == \"ignore\":\n                from pandas import Index\n\n                result = Index(result, name=name)\n            else:\n                result = DatetimeIndex(result, name=name)\n            # GH 23758: We may still need to localize the result with tz\n            # GH 25546: Apply tz_parsed first (from arg), then tz (from caller)\n            # result will be naive but in UTC\n            try:\n                result = result.tz_localize(\"UTC\").tz_convert(tz_parsed)\n            except AttributeError:\n                # Regular Index from 'ignore' path\n                return result\n            if tz is not None:\n                if result.tz is None:\n                    result = result.tz_localize(tz)\n                else:\n                    result = result.tz_convert(tz)\n        return result\n    elif getattr(arg, \"ndim\", 1) > 1:\n        raise TypeError(\n            \"arg must be a string, datetime, list, tuple, 1-d array, or Series\"\n        )\n\n    # warn if passing timedelta64, raise for PeriodDtype\n    # NB: this must come after unit transformation\n    orig_arg = arg\n    arg, _ = maybe_convert_dtype(arg, copy=False)\n\n    arg = ensure_object(arg)\n    require_iso8601 = False\n\n    if infer_datetime_format and format is None:\n        format = _guess_datetime_format_for_array(arg, dayfirst=dayfirst)\n\n    if format is not None:\n        # There is a special fast-path for iso8601 formatted\n        # datetime strings, so in those cases don't use the inferred\n        # format because this path makes process slower in this\n        # special case\n        format_is_iso8601 = _format_is_iso(format)\n        if format_is_iso8601:\n            require_iso8601 = not infer_datetime_format\n            format = None\n\n    tz_parsed = None\n    result = None\n\n    if format is not None:\n        try:\n            # shortcut formatting here\n            if format == \"%Y%m%d\":\n                try:\n                    # pass orig_arg as float-dtype may have been converted to\n                    # datetime64[ns]\n                    orig_arg = ensure_object(orig_arg)\n                    result = _attempt_YYYYMMDD(orig_arg, errors=errors)\n                except (ValueError, TypeError, tslibs.OutOfBoundsDatetime):\n                    raise ValueError(\"cannot convert the input to '%Y%m%d' date format\")\n\n            # fallback\n            if result is None:\n                try:\n                    result, timezones = array_strptime(\n                        arg, format, exact=exact, errors=errors\n                    )\n                    if \"%Z\" in format or \"%z\" in format:\n                        return _return_parsed_timezone_results(\n                            result, timezones, box, tz, name\n                        )\n                except tslibs.OutOfBoundsDatetime:\n                    if errors == \"raise\":\n                        raise\n                    elif errors == \"coerce\":\n                        result = np.empty(arg.shape, dtype=\"M8[ns]\")\n                        iresult = result.view(\"i8\")\n                        iresult.fill(tslibs.iNaT)\n                    else:\n                        result = arg\n                except ValueError:\n                    # if format was inferred, try falling back\n                    # to array_to_datetime - terminate here\n                    # for specified formats\n                    if not infer_datetime_format:\n                        if errors == \"raise\":\n                            raise\n                        elif errors == \"coerce\":\n                            result = np.empty(arg.shape, dtype=\"M8[ns]\")\n                            iresult = result.view(\"i8\")\n                            iresult.fill(tslibs.iNaT)\n                        else:\n                            result = arg\n        except ValueError as e:\n            # Fallback to try to convert datetime objects if timezone-aware\n            #  datetime objects are found without passing `utc=True`\n            try:\n                values, tz = conversion.datetime_to_datetime64(arg)\n                return DatetimeIndex._simple_new(values, name=name, tz=tz)\n            except (ValueError, TypeError):\n                raise e\n\n    if result is None:\n        assert format is None or infer_datetime_format\n        utc = tz == \"utc\"\n        result, tz_parsed = objects_to_datetime64ns(\n            arg,\n            dayfirst=dayfirst,\n            yearfirst=yearfirst,\n            utc=utc,\n            errors=errors,\n            require_iso8601=require_iso8601,\n            allow_object=True,\n        )\n\n    if tz_parsed is not None:\n        if box:\n            # We can take a shortcut since the datetime64 numpy array\n            # is in UTC\n            return DatetimeIndex._simple_new(result, name=name, tz=tz_parsed)\n        else:\n            # Convert the datetime64 numpy array to an numpy array\n            # of datetime objects\n            result = [Timestamp(ts, tz=tz_parsed).to_pydatetime() for ts in result]\n            return np.array(result, dtype=object)\n\n    if box:\n        utc = tz == \"utc\"\n        return _box_as_indexlike(result, utc=utc, name=name)\n    return result\n",
                    "decorators": [],
                    "docstring": "Helper function for to_datetime. Performs the conversions of 1D listlike\nof dates\n\nParameters\n----------\narg : list, tuple, ndarray, Series, Index\n    date to be parced\nbox : boolean\n    True boxes result as an Index-like, False returns an ndarray\nname : object\n    None or string for the Index name\ntz : object\n    None or 'utc'\nunit : string\n    None or string of the frequency of the passed data\nerrors : string\n    error handing behaviors from to_datetime, 'raise', 'coerce', 'ignore'\ninfer_datetime_format : boolean\n    inferring format behavior from to_datetime\ndayfirst : boolean\n    dayfirst parsing behavior from to_datetime\nyearfirst : boolean\n    yearfirst parsing behavior from to_datetime\nexact : boolean\n    exact format matching behavior from to_datetime\n\nReturns\n-------\nndarray of parsed dates\n    Returns:\n\n    - Index-like if box=True\n    - ndarray of Timestamps if box=False",
                    "start_line": 265,
                    "variables": {
                        "isinstance": [
                            320,
                            332,
                            325
                        ],
                        "arg": [
                            411,
                            421,
                            425,
                            434,
                            438,
                            443,
                            320,
                            321,
                            324,
                            325,
                            326,
                            452,
                            328,
                            329,
                            331,
                            332,
                            334,
                            338,
                            343,
                            344,
                            366,
                            373,
                            374,
                            376,
                            380
                        ],
                        "list": [
                            320
                        ],
                        "tuple": [
                            320
                        ],
                        "np.array": [
                            321,
                            470
                        ],
                        "np": [
                            321,
                            434,
                            421,
                            470
                        ],
                        "is_datetime64tz_dtype": [
                            324
                        ],
                        "DatetimeArray": [
                            332,
                            325
                        ],
                        "DatetimeIndex": [
                            325,
                            326,
                            332,
                            334,
                            465,
                            444,
                            351
                        ],
                        "tz": [
                            450,
                            326,
                            327,
                            328,
                            360,
                            362,
                            364,
                            334,
                            473,
                            443,
                            444,
                            415
                        ],
                        "name": [
                            326,
                            351,
                            334,
                            465,
                            474,
                            444,
                            349,
                            415
                        ],
                        "tz_localize": [
                            328
                        ],
                        "arg.tz_convert": [
                            328
                        ],
                        "is_datetime64_ns_dtype": [
                            331
                        ],
                        "box": [
                            332,
                            462,
                            472,
                            345,
                            415
                        ],
                        "ValueError": [
                            426,
                            335,
                            404,
                            405,
                            342,
                            439,
                            445
                        ],
                        "unit": [
                            344,
                            340
                        ],
                        "format": [
                            449,
                            387,
                            390,
                            395,
                            398,
                            411,
                            341,
                            379,
                            380,
                            413,
                            382
                        ],
                        "getattr": [
                            366,
                            343
                        ],
                        "result": [
                            393,
                            403,
                            408,
                            410,
                            415,
                            421,
                            422,
                            425,
                            434,
                            435,
                            438,
                            448,
                            451,
                            465,
                            469,
                            470,
                            344,
                            474,
                            475,
                            349,
                            351,
                            356,
                            359,
                            361,
                            362,
                            364,
                            365
                        ],
                        "tz_parsed": [
                            451,
                            356,
                            392,
                            461,
                            465,
                            469,
                            344
                        ],
                        "tslib.array_with_unit_to_datetime": [
                            344
                        ],
                        "tslib": [
                            344
                        ],
                        "errors": [
                            418,
                            420,
                            456,
                            431,
                            433,
                            403,
                            344,
                            346,
                            411
                        ],
                        "Index": [
                            349
                        ],
                        "tz_convert": [
                            356
                        ],
                        "result.tz_localize": [
                            362,
                            356
                        ],
                        "AttributeError": [
                            357
                        ],
                        "result.tz": [
                            361
                        ],
                        "result.tz_convert": [
                            364
                        ],
                        "TypeError": [
                            404,
                            445,
                            367
                        ],
                        "orig_arg": [
                            402,
                            403,
                            373
                        ],
                        "_": [
                            374
                        ],
                        "maybe_convert_dtype": [
                            374
                        ],
                        "ensure_object": [
                            376,
                            402
                        ],
                        "require_iso8601": [
                            377,
                            457,
                            389
                        ],
                        "infer_datetime_format": [
                            449,
                            379,
                            389,
                            430
                        ],
                        "_guess_datetime_format_for_array": [
                            380
                        ],
                        "dayfirst": [
                            380,
                            453
                        ],
                        "format_is_iso8601": [
                            387,
                            388
                        ],
                        "_format_is_iso": [
                            387
                        ],
                        "_attempt_YYYYMMDD": [
                            403
                        ],
                        "tslibs.OutOfBoundsDatetime": [
                            417,
                            404
                        ],
                        "tslibs": [
                            417,
                            436,
                            404,
                            423
                        ],
                        "timezones": [
                            410,
                            415
                        ],
                        "array_strptime": [
                            410
                        ],
                        "exact": [
                            411
                        ],
                        "_return_parsed_timezone_results": [
                            414
                        ],
                        "np.empty": [
                            434,
                            421
                        ],
                        "arg.shape": [
                            434,
                            421
                        ],
                        "iresult": [
                            435,
                            436,
                            422,
                            423
                        ],
                        "result.view": [
                            435,
                            422
                        ],
                        "iresult.fill": [
                            436,
                            423
                        ],
                        "tslibs.iNaT": [
                            436,
                            423
                        ],
                        "values": [
                            443,
                            444
                        ],
                        "conversion.datetime_to_datetime64": [
                            443
                        ],
                        "conversion": [
                            443
                        ],
                        "DatetimeIndex._simple_new": [
                            465,
                            444
                        ],
                        "e": [
                            446
                        ],
                        "utc": [
                            473,
                            450,
                            474,
                            455
                        ],
                        "objects_to_datetime64ns": [
                            451
                        ],
                        "yearfirst": [
                            454
                        ],
                        "to_pydatetime": [
                            469
                        ],
                        "Timestamp": [
                            469
                        ],
                        "ts": [
                            469
                        ],
                        "object": [
                            470
                        ],
                        "_box_as_indexlike": [
                            474
                        ]
                    },
                    "filtered_variables": {
                        "arg": [
                            411,
                            421,
                            425,
                            434,
                            438,
                            443,
                            320,
                            321,
                            324,
                            325,
                            326,
                            452,
                            328,
                            329,
                            331,
                            332,
                            334,
                            338,
                            343,
                            344,
                            366,
                            373,
                            374,
                            376,
                            380
                        ],
                        "np.array": [
                            321,
                            470
                        ],
                        "np": [
                            321,
                            434,
                            421,
                            470
                        ],
                        "is_datetime64tz_dtype": [
                            324
                        ],
                        "DatetimeArray": [
                            332,
                            325
                        ],
                        "DatetimeIndex": [
                            325,
                            326,
                            332,
                            334,
                            465,
                            444,
                            351
                        ],
                        "tz": [
                            450,
                            326,
                            327,
                            328,
                            360,
                            362,
                            364,
                            334,
                            473,
                            443,
                            444,
                            415
                        ],
                        "name": [
                            326,
                            351,
                            334,
                            465,
                            474,
                            444,
                            349,
                            415
                        ],
                        "tz_localize": [
                            328
                        ],
                        "arg.tz_convert": [
                            328
                        ],
                        "is_datetime64_ns_dtype": [
                            331
                        ],
                        "box": [
                            332,
                            462,
                            472,
                            345,
                            415
                        ],
                        "unit": [
                            344,
                            340
                        ],
                        "result": [
                            393,
                            403,
                            408,
                            410,
                            415,
                            421,
                            422,
                            425,
                            434,
                            435,
                            438,
                            448,
                            451,
                            465,
                            469,
                            470,
                            344,
                            474,
                            475,
                            349,
                            351,
                            356,
                            359,
                            361,
                            362,
                            364,
                            365
                        ],
                        "tz_parsed": [
                            451,
                            356,
                            392,
                            461,
                            465,
                            469,
                            344
                        ],
                        "tslib.array_with_unit_to_datetime": [
                            344
                        ],
                        "tslib": [
                            344
                        ],
                        "errors": [
                            418,
                            420,
                            456,
                            431,
                            433,
                            403,
                            344,
                            346,
                            411
                        ],
                        "Index": [
                            349
                        ],
                        "tz_convert": [
                            356
                        ],
                        "result.tz_localize": [
                            362,
                            356
                        ],
                        "result.tz": [
                            361
                        ],
                        "result.tz_convert": [
                            364
                        ],
                        "orig_arg": [
                            402,
                            403,
                            373
                        ],
                        "_": [
                            374
                        ],
                        "maybe_convert_dtype": [
                            374
                        ],
                        "ensure_object": [
                            376,
                            402
                        ],
                        "require_iso8601": [
                            377,
                            457,
                            389
                        ],
                        "infer_datetime_format": [
                            449,
                            379,
                            389,
                            430
                        ],
                        "_guess_datetime_format_for_array": [
                            380
                        ],
                        "dayfirst": [
                            380,
                            453
                        ],
                        "format_is_iso8601": [
                            387,
                            388
                        ],
                        "_format_is_iso": [
                            387
                        ],
                        "_attempt_YYYYMMDD": [
                            403
                        ],
                        "tslibs.OutOfBoundsDatetime": [
                            417,
                            404
                        ],
                        "tslibs": [
                            417,
                            436,
                            404,
                            423
                        ],
                        "timezones": [
                            410,
                            415
                        ],
                        "array_strptime": [
                            410
                        ],
                        "exact": [
                            411
                        ],
                        "_return_parsed_timezone_results": [
                            414
                        ],
                        "np.empty": [
                            434,
                            421
                        ],
                        "arg.shape": [
                            434,
                            421
                        ],
                        "iresult": [
                            435,
                            436,
                            422,
                            423
                        ],
                        "result.view": [
                            435,
                            422
                        ],
                        "iresult.fill": [
                            436,
                            423
                        ],
                        "tslibs.iNaT": [
                            436,
                            423
                        ],
                        "values": [
                            443,
                            444
                        ],
                        "conversion.datetime_to_datetime64": [
                            443
                        ],
                        "conversion": [
                            443
                        ],
                        "DatetimeIndex._simple_new": [
                            465,
                            444
                        ],
                        "e": [
                            446
                        ],
                        "utc": [
                            473,
                            450,
                            474,
                            455
                        ],
                        "objects_to_datetime64ns": [
                            451
                        ],
                        "yearfirst": [
                            454
                        ],
                        "to_pydatetime": [
                            469
                        ],
                        "Timestamp": [
                            469
                        ],
                        "ts": [
                            469
                        ],
                        "_box_as_indexlike": [
                            474
                        ]
                    },
                    "diff_line_number": 336,
                    "class_data": null,
                    "variable_values": [
                        [
                            {
                                "arg": {
                                    "variable_value": "<DatetimeArray>\n['2015-04-05 00:00:00', '2015-04-06 00:00:00', '2015-04-07 00:00:00']\nLength: 3, dtype: datetime64[ns]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetime64tz_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "DatetimeArray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "DatetimeIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tz": {
                                    "variable_value": "'utc'",
                                    "variable_type": "str",
                                    "variable_shape": "3"
                                },
                                "name": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "tz_localize": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "arg.tz_convert": {
                                    "variable_value": "<bound method DatetimeArray.tz_convert of <DatetimeArray>\n['2015-04-05 00:00:00', '2015-04-06 00:00:00', '2015-04-07 00:00:00']\nLength: 3, dtype: datetime64[ns]>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "is_datetime64_ns_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "box": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "unit": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tz_parsed": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tslib.array_with_unit_to_datetime": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tslib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "errors": {
                                    "variable_value": "'raise'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tz_convert": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result.tz_localize": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result.tz": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result.tz_convert": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "orig_arg": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "maybe_convert_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "require_iso8601": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "infer_datetime_format": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "_guess_datetime_format_for_array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dayfirst": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "format_is_iso8601": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_format_is_iso": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_attempt_YYYYMMDD": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tslibs.OutOfBoundsDatetime": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tslibs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timezones": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "array_strptime": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "exact": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "_return_parsed_timezone_results": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.empty": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "arg.shape": {
                                    "variable_value": "(3,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "iresult": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "iresult.fill": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tslibs.iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "conversion.datetime_to_datetime64": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "DatetimeIndex._simple_new": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "e": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "utc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "objects_to_datetime64ns": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "yearfirst": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "to_pydatetime": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Timestamp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ts": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_box_as_indexlike": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "arg": {
                                    "variable_value": "<DatetimeArray>\n['2015-04-05 00:00:00', '2015-04-06 00:00:00', '2015-04-07 00:00:00']\nLength: 3, dtype: datetime64[ns]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetime64tz_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "DatetimeArray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "DatetimeIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tz": {
                                    "variable_value": "'utc'",
                                    "variable_type": "str",
                                    "variable_shape": "3"
                                },
                                "name": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "tz_localize": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "arg.tz_convert": {
                                    "variable_value": "<bound method DatetimeArray.tz_convert of <DatetimeArray>\n['2015-04-05 00:00:00', '2015-04-06 00:00:00', '2015-04-07 00:00:00']\nLength: 3, dtype: datetime64[ns]>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "is_datetime64_ns_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "box": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "arg.tz_localize": {
                                    "variable_value": "<bound method DatetimeArray.tz_localize of <DatetimeArray>\n['2015-04-05 00:00:00', '2015-04-06 00:00:00', '2015-04-07 00:00:00']\nLength: 3, dtype: datetime64[ns]>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "unit": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tz_parsed": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tslib.array_with_unit_to_datetime": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tslib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "errors": {
                                    "variable_value": "'raise'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tz_convert": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result.tz_localize": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result.tz": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result.tz_convert": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "orig_arg": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "maybe_convert_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ensure_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "require_iso8601": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "infer_datetime_format": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "_guess_datetime_format_for_array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dayfirst": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "format_is_iso8601": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_format_is_iso": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_attempt_YYYYMMDD": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tslibs.OutOfBoundsDatetime": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tslibs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timezones": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "array_strptime": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "exact": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "_return_parsed_timezone_results": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.empty": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "arg.shape": {
                                    "variable_value": "(3,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "iresult": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "iresult.fill": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tslibs.iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "conversion.datetime_to_datetime64": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "conversion": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "DatetimeIndex._simple_new": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "e": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "utc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "objects_to_datetime64ns": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "yearfirst": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "to_pydatetime": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Timestamp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ts": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_box_as_indexlike": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {}
                        ]
                    ]
                }
            ],
            "inscope_functions": [
                "def _guess_datetime_format_for_array(arr, **kwargs):\n    # Try to guess the format based on the first non-NaN element\n    non_nan_elements = notna(arr).nonzero()[0]\n    if len(non_nan_elements):\n        return _guess_datetime_format(arr[non_nan_elements[0]], **kwargs)",
                "def should_cache(\n    arg: ArrayConvertible, unique_share: float = 0.7, check_count: Optional[int] = None\n) -> bool:\n    \"\"\"\n    Decides whether to do caching.\n\n    If the percent of unique elements among `check_count` elements less\n    than `unique_share * 100` then we can do caching.\n\n    Parameters\n    ----------\n    arg: listlike, tuple, 1-d array, Series\n    unique_share: float, default=0.7, optional\n        0 < unique_share < 1\n    check_count: int, optional\n        0 <= check_count <= len(arg)\n\n    Returns\n    -------\n    do_caching: bool\n\n    Notes\n    -----\n    By default for a sequence of less than 50 items in size, we don't do\n    caching; for the number of elements less than 5000, we take ten percent of\n    all elements to check for a uniqueness share; if the sequence size is more\n    than 5000, then we check only the first 500 elements.\n    All constants were chosen empirically by.\n    \"\"\"\n    do_caching = True\n\n    # default realization\n    if check_count is None:\n        # in this case, the gain from caching is negligible\n        if len(arg) <= 50:\n            return False\n\n        if len(arg) <= 5000:\n            check_count = int(len(arg) * 0.1)\n        else:\n            check_count = 500\n    else:\n        assert (\n            0 <= check_count <= len(arg)\n        ), \"check_count must be in next bounds: [0; len(arg)]\"\n        if check_count == 0:\n            return False\n\n    assert 0 < unique_share < 1, \"unique_share must be in next bounds: (0; 1)\"\n\n    unique_elements = unique(arg[:check_count])\n    if len(unique_elements) > check_count * unique_share:\n        do_caching = False\n    return do_caching",
                "def _maybe_cache(arg, format, cache, convert_listlike):\n    \"\"\"\n    Create a cache of unique dates from an array of dates\n\n    Parameters\n    ----------\n    arg : listlike, tuple, 1-d array, Series\n    format : string\n        Strftime format to parse time\n    cache : boolean\n        True attempts to create a cache of converted values\n    convert_listlike : function\n        Conversion function to apply on dates\n\n    Returns\n    -------\n    cache_array : Series\n        Cache of converted, unique dates. Can be empty\n    \"\"\"\n    from pandas import Series\n\n    cache_array = Series()\n    if cache:\n        # Perform a quicker unique check\n        if not should_cache(arg):\n            return cache_array\n\n        unique_dates = unique(arg)\n        if len(unique_dates) < len(arg):\n            cache_dates = convert_listlike(unique_dates, True, format)\n            cache_array = Series(cache_dates, index=unique_dates)\n    return cache_array",
                "def _box_as_indexlike(\n    dt_array: ArrayLike, utc: Optional[bool] = None, name: Optional[str] = None\n) -> Union[ABCIndex, ABCDatetimeIndex]:\n    \"\"\"\n    Properly boxes the ndarray of datetimes to DatetimeIndex\n    if it is possible or to generic Index instead\n\n    Parameters\n    ----------\n    dt_array: 1-d array\n        array of datetimes to be boxed\n    tz : object\n        None or 'utc'\n    name : string, default None\n        Name for a resulting index\n\n    Returns\n    -------\n    result : datetime of converted dates\n        - DatetimeIndex if convertible to sole datetime64 type\n        - general Index otherwise\n    \"\"\"\n    from pandas import DatetimeIndex, Index\n\n    if is_datetime64_dtype(dt_array):\n        tz = \"utc\" if utc else None\n        return DatetimeIndex(dt_array, tz=tz, name=name)\n    return Index(dt_array, name=name)",
                "def _convert_and_box_cache(\n    arg: DatetimeScalarOrArrayConvertible,\n    cache_array: ABCSeries,\n    box: bool,\n    name: Optional[str] = None,\n) -> Union[ABCIndex, np.ndarray]:\n    \"\"\"\n    Convert array of dates with a cache and box the result\n\n    Parameters\n    ----------\n    arg : integer, float, string, datetime, list, tuple, 1-d array, Series\n    cache_array : Series\n        Cache of converted, unique dates\n    box : boolean\n        True boxes result as an Index-like, False returns an ndarray\n    name : string, default None\n        Name for a DatetimeIndex\n\n    Returns\n    -------\n    result : datetime of converted dates\n        - Index-like if box=True\n        - ndarray if box=False\n    \"\"\"\n    from pandas import Series\n\n    result = Series(arg).map(cache_array)\n    if box:\n        return _box_as_indexlike(result, utc=None, name=name)\n    return result.values",
                "def _return_parsed_timezone_results(result, timezones, box, tz, name):\n    \"\"\"\n    Return results from array_strptime if a %z or %Z directive was passed.\n\n    Parameters\n    ----------\n    result : ndarray\n        int64 date representations of the dates\n    timezones : ndarray\n        pytz timezone objects\n    box : boolean\n        True boxes result as an Index-like, False returns an ndarray\n    tz : object\n        None or pytz timezone object\n    name : string, default None\n        Name for a DatetimeIndex\n\n    Returns\n    -------\n    tz_result : ndarray of parsed dates with timezone\n        Returns:\n\n        - Index-like if box=True\n        - ndarray of Timestamps if box=False\n    \"\"\"\n    if tz is not None:\n        raise ValueError(\n            \"Cannot pass a tz argument when \"\n            \"parsing strings with timezone \"\n            \"information.\"\n        )\n    tz_results = np.array(\n        [Timestamp(res).tz_localize(zone) for res, zone in zip(result, timezones)]\n    )\n    if box:\n        from pandas import Index\n\n        return Index(tz_results, name=name)\n    return tz_results",
                "def _convert_listlike_datetimes(\n    arg,\n    box,\n    format,\n    name=None,\n    tz=None,\n    unit=None,\n    errors=None,\n    infer_datetime_format=None,\n    dayfirst=None,\n    yearfirst=None,\n    exact=None,\n):\n    \"\"\"\n    Helper function for to_datetime. Performs the conversions of 1D listlike\n    of dates\n\n    Parameters\n    ----------\n    arg : list, tuple, ndarray, Series, Index\n        date to be parced\n    box : boolean\n        True boxes result as an Index-like, False returns an ndarray\n    name : object\n        None or string for the Index name\n    tz : object\n        None or 'utc'\n    unit : string\n        None or string of the frequency of the passed data\n    errors : string\n        error handing behaviors from to_datetime, 'raise', 'coerce', 'ignore'\n    infer_datetime_format : boolean\n        inferring format behavior from to_datetime\n    dayfirst : boolean\n        dayfirst parsing behavior from to_datetime\n    yearfirst : boolean\n        yearfirst parsing behavior from to_datetime\n    exact : boolean\n        exact format matching behavior from to_datetime\n\n    Returns\n    -------\n    ndarray of parsed dates\n        Returns:\n\n        - Index-like if box=True\n        - ndarray of Timestamps if box=False\n    \"\"\"\n    from pandas import DatetimeIndex\n    from pandas.core.arrays import DatetimeArray\n    from pandas.core.arrays.datetimes import (\n        maybe_convert_dtype,\n        objects_to_datetime64ns,\n    )\n\n    if isinstance(arg, (list, tuple)):\n        arg = np.array(arg, dtype=\"O\")\n\n    # these are shortcutable\n    if is_datetime64tz_dtype(arg):\n        if not isinstance(arg, (DatetimeArray, DatetimeIndex)):\n            return DatetimeIndex(arg, tz=tz, name=name)\n        if tz == \"utc\":\n            arg = arg.tz_convert(None).tz_localize(tz)\n        return arg\n\n    elif is_datetime64_ns_dtype(arg):\n        if box and not isinstance(arg, (DatetimeArray, DatetimeIndex)):\n            try:\n                return DatetimeIndex(arg, tz=tz, name=name)\n            except ValueError:\n                pass\n\n        return arg\n\n    elif unit is not None:\n        if format is not None:\n            raise ValueError(\"cannot specify both format and unit\")\n        arg = getattr(arg, \"values\", arg)\n        result, tz_parsed = tslib.array_with_unit_to_datetime(arg, unit, errors=errors)\n        if box:\n            if errors == \"ignore\":\n                from pandas import Index\n\n                result = Index(result, name=name)\n            else:\n                result = DatetimeIndex(result, name=name)\n            # GH 23758: We may still need to localize the result with tz\n            # GH 25546: Apply tz_parsed first (from arg), then tz (from caller)\n            # result will be naive but in UTC\n            try:\n                result = result.tz_localize(\"UTC\").tz_convert(tz_parsed)\n            except AttributeError:\n                # Regular Index from 'ignore' path\n                return result\n            if tz is not None:\n                if result.tz is None:\n                    result = result.tz_localize(tz)\n                else:\n                    result = result.tz_convert(tz)\n        return result\n    elif getattr(arg, \"ndim\", 1) > 1:\n        raise TypeError(\n            \"arg must be a string, datetime, list, tuple, 1-d array, or Series\"\n        )\n\n    # warn if passing timedelta64, raise for PeriodDtype\n    # NB: this must come after unit transformation\n    orig_arg = arg\n    arg, _ = maybe_convert_dtype(arg, copy=False)\n\n    arg = ensure_object(arg)\n    require_iso8601 = False\n\n    if infer_datetime_format and format is None:\n        format = _guess_datetime_format_for_array(arg, dayfirst=dayfirst)\n\n    if format is not None:\n        # There is a special fast-path for iso8601 formatted\n        # datetime strings, so in those cases don't use the inferred\n        # format because this path makes process slower in this\n        # special case\n        format_is_iso8601 = _format_is_iso(format)\n        if format_is_iso8601:\n            require_iso8601 = not infer_datetime_format\n            format = None\n\n    tz_parsed = None\n    result = None\n\n    if format is not None:\n        try:\n            # shortcut formatting here\n            if format == \"%Y%m%d\":\n                try:\n                    # pass orig_arg as float-dtype may have been converted to\n                    # datetime64[ns]\n                    orig_arg = ensure_object(orig_arg)\n                    result = _attempt_YYYYMMDD(orig_arg, errors=errors)\n                except (ValueError, TypeError, tslibs.OutOfBoundsDatetime):\n                    raise ValueError(\"cannot convert the input to '%Y%m%d' date format\")\n\n            # fallback\n            if result is None:\n                try:\n                    result, timezones = array_strptime(\n                        arg, format, exact=exact, errors=errors\n                    )\n                    if \"%Z\" in format or \"%z\" in format:\n                        return _return_parsed_timezone_results(\n                            result, timezones, box, tz, name\n                        )\n                except tslibs.OutOfBoundsDatetime:\n                    if errors == \"raise\":\n                        raise\n                    elif errors == \"coerce\":\n                        result = np.empty(arg.shape, dtype=\"M8[ns]\")\n                        iresult = result.view(\"i8\")\n                        iresult.fill(tslibs.iNaT)\n                    else:\n                        result = arg\n                except ValueError:\n                    # if format was inferred, try falling back\n                    # to array_to_datetime - terminate here\n                    # for specified formats\n                    if not infer_datetime_format:\n                        if errors == \"raise\":\n                            raise\n                        elif errors == \"coerce\":\n                            result = np.empty(arg.shape, dtype=\"M8[ns]\")\n                            iresult = result.view(\"i8\")\n                            iresult.fill(tslibs.iNaT)\n                        else:\n                            result = arg\n        except ValueError as e:\n            # Fallback to try to convert datetime objects if timezone-aware\n            #  datetime objects are found without passing `utc=True`\n            try:\n                values, tz = conversion.datetime_to_datetime64(arg)\n                return DatetimeIndex._simple_new(values, name=name, tz=tz)\n            except (ValueError, TypeError):\n                raise e\n\n    if result is None:\n        assert format is None or infer_datetime_format\n        utc = tz == \"utc\"\n        result, tz_parsed = objects_to_datetime64ns(\n            arg,\n            dayfirst=dayfirst,\n            yearfirst=yearfirst,\n            utc=utc,\n            errors=errors,\n            require_iso8601=require_iso8601,\n            allow_object=True,\n        )\n\n    if tz_parsed is not None:\n        if box:\n            # We can take a shortcut since the datetime64 numpy array\n            # is in UTC\n            return DatetimeIndex._simple_new(result, name=name, tz=tz_parsed)\n        else:\n            # Convert the datetime64 numpy array to an numpy array\n            # of datetime objects\n            result = [Timestamp(ts, tz=tz_parsed).to_pydatetime() for ts in result]\n            return np.array(result, dtype=object)\n\n    if box:\n        utc = tz == \"utc\"\n        return _box_as_indexlike(result, utc=utc, name=name)\n    return result",
                "def _adjust_to_origin(arg, origin, unit):\n    \"\"\"\n    Helper function for to_datetime.\n    Adjust input argument to the specified origin\n\n    Parameters\n    ----------\n    arg : list, tuple, ndarray, Series, Index\n        date to be adjusted\n    origin : 'julian' or Timestamp\n        origin offset for the arg\n    unit : string\n        passed unit from to_datetime, must be 'D'\n\n    Returns\n    -------\n    ndarray or scalar of adjusted date(s)\n    \"\"\"\n    if origin == \"julian\":\n        original = arg\n        j0 = Timestamp(0).to_julian_date()\n        if unit != \"D\":\n            raise ValueError(\"unit must be 'D' for origin='julian'\")\n        try:\n            arg = arg - j0\n        except TypeError:\n            raise ValueError(\"incompatible 'arg' type for given 'origin'='julian'\")\n\n        # preemptively check this for a nice range\n        j_max = Timestamp.max.to_julian_date() - j0\n        j_min = Timestamp.min.to_julian_date() - j0\n        if np.any(arg > j_max) or np.any(arg < j_min):\n            raise tslibs.OutOfBoundsDatetime(\n                \"{original} is Out of Bounds for \"\n                \"origin='julian'\".format(original=original)\n            )\n    else:\n        # arg must be numeric\n        if not (\n            (is_scalar(arg) and (is_integer(arg) or is_float(arg)))\n            or is_numeric_dtype(np.asarray(arg))\n        ):\n            raise ValueError(\n                \"'{arg}' is not compatible with origin='{origin}'; \"\n                \"it must be numeric with a unit specified \".format(\n                    arg=arg, origin=origin\n                )\n            )\n\n        # we are going to offset back to unix / epoch time\n        try:\n            offset = Timestamp(origin)\n        except tslibs.OutOfBoundsDatetime:\n            raise tslibs.OutOfBoundsDatetime(\n                \"origin {origin} is Out of Bounds\".format(origin=origin)\n            )\n        except ValueError:\n            raise ValueError(\n                \"origin {origin} cannot be converted \"\n                \"to a Timestamp\".format(origin=origin)\n            )\n\n        if offset.tz is not None:\n            raise ValueError(\"origin offset {} must be tz-naive\".format(offset))\n        offset -= Timestamp(0)\n\n        # convert the offset to the unit of the arg\n        # this should be lossless in terms of precision\n        offset = offset // tslibs.Timedelta(1, unit=unit)\n\n        # scalars & ndarray-like can handle the addition\n        if is_list_like(arg) and not isinstance(\n            arg, (ABCSeries, ABCIndexClass, np.ndarray)\n        ):\n            arg = np.asarray(arg)\n        arg = arg + offset\n    return arg",
                "@deprecate_kwarg(old_arg_name=\"box\", new_arg_name=None)\ndef to_datetime(\n    arg,\n    errors=\"raise\",\n    dayfirst=False,\n    yearfirst=False,\n    utc=None,\n    box=True,\n    format=None,\n    exact=True,\n    unit=None,\n    infer_datetime_format=False,\n    origin=\"unix\",\n    cache=True,\n):\n    \"\"\"\n    Convert argument to datetime.\n\n    Parameters\n    ----------\n    arg : integer, float, string, datetime, list, tuple, 1-d array, Series\n           or DataFrame/dict-like\n\n    errors : {'ignore', 'raise', 'coerce'}, default 'raise'\n\n        - If 'raise', then invalid parsing will raise an exception\n        - If 'coerce', then invalid parsing will be set as NaT\n        - If 'ignore', then invalid parsing will return the input\n    dayfirst : boolean, default False\n        Specify a date parse order if `arg` is str or its list-likes.\n        If True, parses dates with the day first, eg 10/11/12 is parsed as\n        2012-11-10.\n        Warning: dayfirst=True is not strict, but will prefer to parse\n        with day first (this is a known bug, based on dateutil behavior).\n    yearfirst : boolean, default False\n        Specify a date parse order if `arg` is str or its list-likes.\n\n        - If True parses dates with the year first, eg 10/11/12 is parsed as\n          2010-11-12.\n        - If both dayfirst and yearfirst are True, yearfirst is preceded (same\n          as dateutil).\n\n        Warning: yearfirst=True is not strict, but will prefer to parse\n        with year first (this is a known bug, based on dateutil behavior).\n\n        .. versionadded:: 0.16.1\n\n    utc : boolean, default None\n        Return UTC DatetimeIndex if True (converting any tz-aware\n        datetime.datetime objects as well).\n    box : boolean, default True\n\n        - If True returns a DatetimeIndex or Index-like object\n        - If False returns ndarray of values.\n\n        .. deprecated:: 0.25.0\n            Use :meth:`Series.to_numpy` or :meth:`Timestamp.to_datetime64`\n            instead to get an ndarray of values or numpy.datetime64,\n            respectively.\n\n    format : string, default None\n        strftime to parse time, eg \"%d/%m/%Y\", note that \"%f\" will parse\n        all the way up to nanoseconds.\n        See strftime documentation for more information on choices:\n        https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior\n    exact : boolean, True by default\n\n        - If True, require an exact format match.\n        - If False, allow the format to match anywhere in the target string.\n\n    unit : string, default 'ns'\n        unit of the arg (D,s,ms,us,ns) denote the unit, which is an\n        integer or float number. This will be based off the origin.\n        Example, with unit='ms' and origin='unix' (the default), this\n        would calculate the number of milliseconds to the unix epoch start.\n    infer_datetime_format : boolean, default False\n        If True and no `format` is given, attempt to infer the format of the\n        datetime strings, and if it can be inferred, switch to a faster\n        method of parsing them. In some cases this can increase the parsing\n        speed by ~5-10x.\n    origin : scalar, default is 'unix'\n        Define the reference date. The numeric values would be parsed as number\n        of units (defined by `unit`) since this reference date.\n\n        - If 'unix' (or POSIX) time; origin is set to 1970-01-01.\n        - If 'julian', unit must be 'D', and origin is set to beginning of\n          Julian Calendar. Julian day number 0 is assigned to the day starting\n          at noon on January 1, 4713 BC.\n        - If Timestamp convertible, origin is set to Timestamp identified by\n          origin.\n\n        .. versionadded:: 0.20.0\n    cache : boolean, default True\n        If True, use a cache of unique, converted dates to apply the datetime\n        conversion. May produce significant speed-up when parsing duplicate\n        date strings, especially ones with timezone offsets.\n\n        .. versionadded:: 0.23.0\n\n        .. versionchanged:: 0.25.0\n            - changed default value from False to True\n\n    Returns\n    -------\n    ret : datetime if parsing succeeded.\n        Return type depends on input:\n\n        - list-like: DatetimeIndex\n        - Series: Series of datetime64 dtype\n        - scalar: Timestamp\n\n        In case when it is not possible to return designated types (e.g. when\n        any element of input is before Timestamp.min or after Timestamp.max)\n        return will have datetime.datetime type (or corresponding\n        array/Series).\n\n    See Also\n    --------\n    DataFrame.astype : Cast argument to a specified dtype.\n    to_timedelta : Convert argument to timedelta.\n\n    Examples\n    --------\n    Assembling a datetime from multiple columns of a DataFrame. The keys can be\n    common abbreviations like ['year', 'month', 'day', 'minute', 'second',\n    'ms', 'us', 'ns']) or plurals of the same\n\n    >>> df = pd.DataFrame({'year': [2015, 2016],\n    ...                    'month': [2, 3],\n    ...                    'day': [4, 5]})\n    >>> pd.to_datetime(df)\n    0   2015-02-04\n    1   2016-03-05\n    dtype: datetime64[ns]\n\n    If a date does not meet the `timestamp limitations\n    <http://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html\n    #timeseries-timestamp-limits>`_, passing errors='ignore'\n    will return the original input instead of raising any exception.\n\n    Passing errors='coerce' will force an out-of-bounds date to NaT,\n    in addition to forcing non-dates (or non-parseable dates) to NaT.\n\n    >>> pd.to_datetime('13000101', format='%Y%m%d', errors='ignore')\n    datetime.datetime(1300, 1, 1, 0, 0)\n    >>> pd.to_datetime('13000101', format='%Y%m%d', errors='coerce')\n    NaT\n\n    Passing infer_datetime_format=True can often-times speedup a parsing\n    if its not an ISO8601 format exactly, but in a regular format.\n\n    >>> s = pd.Series(['3/11/2000', '3/12/2000', '3/13/2000'] * 1000)\n    >>> s.head()\n    0    3/11/2000\n    1    3/12/2000\n    2    3/13/2000\n    3    3/11/2000\n    4    3/12/2000\n    dtype: object\n\n    >>> %timeit pd.to_datetime(s,infer_datetime_format=True)  # doctest: +SKIP\n    100 loops, best of 3: 10.4 ms per loop\n\n    >>> %timeit pd.to_datetime(s,infer_datetime_format=False)  # doctest: +SKIP\n    1 loop, best of 3: 471 ms per loop\n\n    Using a unix epoch time\n\n    >>> pd.to_datetime(1490195805, unit='s')\n    Timestamp('2017-03-22 15:16:45')\n    >>> pd.to_datetime(1490195805433502912, unit='ns')\n    Timestamp('2017-03-22 15:16:45.433502912')\n\n    .. warning:: For float arg, precision rounding might happen. To prevent\n        unexpected behavior use a fixed-width exact type.\n\n    Using a non-unix epoch origin\n\n    >>> pd.to_datetime([1, 2, 3], unit='D',\n    ...                origin=pd.Timestamp('1960-01-01'))\n    DatetimeIndex(['1960-01-02', '1960-01-03', '1960-01-04'], \\\ndtype='datetime64[ns]', freq=None)\n    \"\"\"\n    if arg is None:\n        return None\n\n    if origin != \"unix\":\n        arg = _adjust_to_origin(arg, origin, unit)\n\n    tz = \"utc\" if utc else None\n    convert_listlike = partial(\n        _convert_listlike_datetimes,\n        tz=tz,\n        unit=unit,\n        dayfirst=dayfirst,\n        yearfirst=yearfirst,\n        errors=errors,\n        exact=exact,\n        infer_datetime_format=infer_datetime_format,\n    )\n\n    if isinstance(arg, Timestamp):\n        result = arg\n        if tz is not None:\n            if arg.tz is not None:\n                result = result.tz_convert(tz)\n            else:\n                result = result.tz_localize(tz)\n    elif isinstance(arg, ABCSeries):\n        cache_array = _maybe_cache(arg, format, cache, convert_listlike)\n        if not cache_array.empty:\n            result = arg.map(cache_array)\n        else:\n            values = convert_listlike(arg._values, True, format)\n            result = arg._constructor(values, index=arg.index, name=arg.name)\n    elif isinstance(arg, (ABCDataFrame, abc.MutableMapping)):\n        result = _assemble_from_unit_mappings(arg, errors, box, tz)\n    elif isinstance(arg, ABCIndexClass):\n        cache_array = _maybe_cache(arg, format, cache, convert_listlike)\n        if not cache_array.empty:\n            result = _convert_and_box_cache(arg, cache_array, box, name=arg.name)\n        else:\n            convert_listlike = partial(convert_listlike, name=arg.name)\n            result = convert_listlike(arg, box, format)\n    elif is_list_like(arg):\n        cache_array = _maybe_cache(arg, format, cache, convert_listlike)\n        if not cache_array.empty:\n            result = _convert_and_box_cache(arg, cache_array, box)\n        else:\n            result = convert_listlike(arg, box, format)\n    else:\n        result = convert_listlike(np.array([arg]), box, format)[0]\n\n    return result",
                "def _assemble_from_unit_mappings(arg, errors, box, tz):\n    \"\"\"\n    assemble the unit specified fields from the arg (DataFrame)\n    Return a Series for actual parsing\n\n    Parameters\n    ----------\n    arg : DataFrame\n    errors : {'ignore', 'raise', 'coerce'}, default 'raise'\n\n        - If 'raise', then invalid parsing will raise an exception\n        - If 'coerce', then invalid parsing will be set as NaT\n        - If 'ignore', then invalid parsing will return the input\n    box : boolean\n\n        - If True, return a DatetimeIndex\n        - If False, return an array\n    tz : None or 'utc'\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import to_timedelta, to_numeric, DataFrame\n\n    arg = DataFrame(arg)\n    if not arg.columns.is_unique:\n        raise ValueError(\"cannot assemble with duplicate keys\")\n\n    # replace passed unit with _unit_map\n    def f(value):\n        if value in _unit_map:\n            return _unit_map[value]\n\n        # m is case significant\n        if value.lower() in _unit_map:\n            return _unit_map[value.lower()]\n\n        return value\n\n    unit = {k: f(k) for k in arg.keys()}\n    unit_rev = {v: k for k, v in unit.items()}\n\n    # we require at least Ymd\n    required = [\"year\", \"month\", \"day\"]\n    req = sorted(list(set(required) - set(unit_rev.keys())))\n    if len(req):\n        raise ValueError(\n            \"to assemble mappings requires at least that \"\n            \"[year, month, day] be specified: [{required}] \"\n            \"is missing\".format(required=\",\".join(req))\n        )\n\n    # keys we don't recognize\n    excess = sorted(list(set(unit_rev.keys()) - set(_unit_map.values())))\n    if len(excess):\n        raise ValueError(\n            \"extra keys have been passed \"\n            \"to the datetime assemblage: \"\n            \"[{excess}]\".format(excess=\",\".join(excess))\n        )\n\n    def coerce(values):\n        # we allow coercion to if errors allows\n        values = to_numeric(values, errors=errors)\n\n        # prevent overflow in case of int8 or int16\n        if is_integer_dtype(values):\n            values = values.astype(\"int64\", copy=False)\n        return values\n\n    values = (\n        coerce(arg[unit_rev[\"year\"]]) * 10000\n        + coerce(arg[unit_rev[\"month\"]]) * 100\n        + coerce(arg[unit_rev[\"day\"]])\n    )\n    try:\n        values = to_datetime(values, format=\"%Y%m%d\", errors=errors, utc=tz)\n    except (TypeError, ValueError) as e:\n        raise ValueError(\"cannot assemble the datetimes: {error}\".format(error=e))\n\n    for u in [\"h\", \"m\", \"s\", \"ms\", \"us\", \"ns\"]:\n        value = unit_rev.get(u)\n        if value is not None and value in arg:\n            try:\n                values += to_timedelta(coerce(arg[value]), unit=u, errors=errors)\n            except (TypeError, ValueError) as e:\n                raise ValueError(\n                    \"cannot assemble the datetimes [{value}]: \"\n                    \"{error}\".format(value=value, error=e)\n                )\n    if not box:\n        return values.values\n    return values",
                "def _attempt_YYYYMMDD(arg, errors):\n    \"\"\"\n    try to parse the YYYYMMDD/%Y%m%d format, try to deal with NaT-like,\n    arg is a passed in as an object dtype, but could really be ints/strings\n    with nan-like/or floats (e.g. with nan)\n\n    Parameters\n    ----------\n    arg : passed value\n    errors : 'raise','ignore','coerce'\n    \"\"\"\n\n    def calc(carg):\n        # calculate the actual result\n        carg = carg.astype(object)\n        parsed = parsing.try_parse_year_month_day(\n            carg / 10000, carg / 100 % 100, carg % 100\n        )\n        return tslib.array_to_datetime(parsed, errors=errors)[0]\n\n    def calc_with_mask(carg, mask):\n        result = np.empty(carg.shape, dtype=\"M8[ns]\")\n        iresult = result.view(\"i8\")\n        iresult[~mask] = tslibs.iNaT\n\n        masked_result = calc(carg[mask].astype(np.float64).astype(np.int64))\n        result[mask] = masked_result.astype(\"M8[ns]\")\n        return result\n\n    # try intlike / strings that are ints\n    try:\n        return calc(arg.astype(np.int64))\n    except (ValueError, OverflowError):\n        pass\n\n    # a float with actual np.nan\n    try:\n        carg = arg.astype(np.float64)\n        return calc_with_mask(carg, notna(carg))\n    except (ValueError, OverflowError):\n        pass\n\n    # string with NaN-like\n    try:\n        mask = ~algorithms.isin(arg, list(tslib.nat_strings))\n        return calc_with_mask(arg, mask)\n    except (ValueError, OverflowError):\n        pass\n\n    return None",
                "def _guess_time_format_for_array(arr):\n    # Try to guess the format based on the first non-NaN element\n    non_nan_elements = notna(arr).nonzero()[0]\n    if len(non_nan_elements):\n        element = arr[non_nan_elements[0]]\n        for time_format in _time_formats:\n            try:\n                datetime.strptime(element, time_format)\n                return time_format\n            except ValueError:\n                pass\n\n    return None",
                "def to_time(arg, format=None, infer_time_format=False, errors=\"raise\"):\n    \"\"\"\n    Parse time strings to time objects using fixed strptime formats (\"%H:%M\",\n    \"%H%M\", \"%I:%M%p\", \"%I%M%p\", \"%H:%M:%S\", \"%H%M%S\", \"%I:%M:%S%p\",\n    \"%I%M%S%p\")\n\n    Use infer_time_format if all the strings are in the same format to speed\n    up conversion.\n\n    Parameters\n    ----------\n    arg : string in time format, datetime.time, list, tuple, 1-d array,  Series\n    format : str, default None\n        Format used to convert arg into a time object.  If None, fixed formats\n        are used.\n    infer_time_format: bool, default False\n        Infer the time format based on the first non-NaN element.  If all\n        strings are in the same format, this will speed up conversion.\n    errors : {'ignore', 'raise', 'coerce'}, default 'raise'\n        - If 'raise', then invalid parsing will raise an exception\n        - If 'coerce', then invalid parsing will be set as None\n        - If 'ignore', then invalid parsing will return the input\n\n    Returns\n    -------\n    datetime.time\n    \"\"\"\n\n    def _convert_listlike(arg, format):\n\n        if isinstance(arg, (list, tuple)):\n            arg = np.array(arg, dtype=\"O\")\n\n        elif getattr(arg, \"ndim\", 1) > 1:\n            raise TypeError(\n                \"arg must be a string, datetime, list, tuple, 1-d array, or Series\"\n            )\n\n        arg = ensure_object(arg)\n\n        if infer_time_format and format is None:\n            format = _guess_time_format_for_array(arg)\n\n        times = []\n        if format is not None:\n            for element in arg:\n                try:\n                    times.append(datetime.strptime(element, format).time())\n                except (ValueError, TypeError):\n                    if errors == \"raise\":\n                        msg = (\n                            \"Cannot convert {element} to a time with given \"\n                            \"format {format}\"\n                        ).format(element=element, format=format)\n                        raise ValueError(msg)\n                    elif errors == \"ignore\":\n                        return arg\n                    else:\n                        times.append(None)\n        else:\n            formats = _time_formats[:]\n            format_found = False\n            for element in arg:\n                time_object = None\n                for time_format in formats:\n                    try:\n                        time_object = datetime.strptime(element, time_format).time()\n                        if not format_found:\n                            # Put the found format in front\n                            fmt = formats.pop(formats.index(time_format))\n                            formats.insert(0, fmt)\n                            format_found = True\n                        break\n                    except (ValueError, TypeError):\n                        continue\n\n                if time_object is not None:\n                    times.append(time_object)\n                elif errors == \"raise\":\n                    raise ValueError(\n                        \"Cannot convert arg {arg} to a time\".format(arg=arg)\n                    )\n                elif errors == \"ignore\":\n                    return arg\n                else:\n                    times.append(None)\n\n        return times\n\n    if arg is None:\n        return arg\n    elif isinstance(arg, time):\n        return arg\n    elif isinstance(arg, ABCSeries):\n        values = _convert_listlike(arg._values, format)\n        return arg._constructor(values, index=arg.index, name=arg.name)\n    elif isinstance(arg, ABCIndexClass):\n        return _convert_listlike(arg, format)\n    elif is_list_like(arg):\n        return _convert_listlike(arg, format)\n\n    return _convert_listlike(np.array([arg]), format)[0]",
                "def f(value):\n    if value in _unit_map:\n        return _unit_map[value]\n\n    # m is case significant\n    if value.lower() in _unit_map:\n        return _unit_map[value.lower()]\n\n    return value",
                "def coerce(values):\n    # we allow coercion to if errors allows\n    values = to_numeric(values, errors=errors)\n\n    # prevent overflow in case of int8 or int16\n    if is_integer_dtype(values):\n        values = values.astype(\"int64\", copy=False)\n    return values",
                "def calc(carg):\n    # calculate the actual result\n    carg = carg.astype(object)\n    parsed = parsing.try_parse_year_month_day(\n        carg / 10000, carg / 100 % 100, carg % 100\n    )\n    return tslib.array_to_datetime(parsed, errors=errors)[0]",
                "def calc_with_mask(carg, mask):\n    result = np.empty(carg.shape, dtype=\"M8[ns]\")\n    iresult = result.view(\"i8\")\n    iresult[~mask] = tslibs.iNaT\n\n    masked_result = calc(carg[mask].astype(np.float64).astype(np.int64))\n    result[mask] = masked_result.astype(\"M8[ns]\")\n    return result",
                "def _convert_listlike(arg, format):\n\n    if isinstance(arg, (list, tuple)):\n        arg = np.array(arg, dtype=\"O\")\n\n    elif getattr(arg, \"ndim\", 1) > 1:\n        raise TypeError(\n            \"arg must be a string, datetime, list, tuple, 1-d array, or Series\"\n        )\n\n    arg = ensure_object(arg)\n\n    if infer_time_format and format is None:\n        format = _guess_time_format_for_array(arg)\n\n    times = []\n    if format is not None:\n        for element in arg:\n            try:\n                times.append(datetime.strptime(element, format).time())\n            except (ValueError, TypeError):\n                if errors == \"raise\":\n                    msg = (\n                        \"Cannot convert {element} to a time with given \"\n                        \"format {format}\"\n                    ).format(element=element, format=format)\n                    raise ValueError(msg)\n                elif errors == \"ignore\":\n                    return arg\n                else:\n                    times.append(None)\n    else:\n        formats = _time_formats[:]\n        format_found = False\n        for element in arg:\n            time_object = None\n            for time_format in formats:\n                try:\n                    time_object = datetime.strptime(element, time_format).time()\n                    if not format_found:\n                        # Put the found format in front\n                        fmt = formats.pop(formats.index(time_format))\n                        formats.insert(0, fmt)\n                        format_found = True\n                    break\n                except (ValueError, TypeError):\n                    continue\n\n            if time_object is not None:\n                times.append(time_object)\n            elif errors == \"raise\":\n                raise ValueError(\n                    \"Cannot convert arg {arg} to a time\".format(arg=arg)\n                )\n            elif errors == \"ignore\":\n                return arg\n            else:\n                times.append(None)\n\n    return times"
            ],
            "inscope_function_signatures": [
                "_guess_datetime_format_for_array(arr, **kwargs)",
                "should_cache(arg: ArrayConvertible, unique_share: float=0.7, check_count: Optional[int]=None) -> bool",
                "_maybe_cache(arg, format, cache, convert_listlike)",
                "_box_as_indexlike(dt_array: ArrayLike, utc: Optional[bool]=None, name: Optional[str]=None) -> Union[ABCIndex, ABCDatetimeIndex]",
                "_convert_and_box_cache(arg: DatetimeScalarOrArrayConvertible, cache_array: ABCSeries, box: bool, name: Optional[str]=None) -> Union[ABCIndex, np.ndarray]",
                "_return_parsed_timezone_results(result, timezones, box, tz, name)",
                "_convert_listlike_datetimes(arg, box, format, name=None, tz=None, unit=None, errors=None, infer_datetime_format=None, dayfirst=None, yearfirst=None, exact=None)",
                "_adjust_to_origin(arg, origin, unit)",
                "to_datetime(arg, errors='raise', dayfirst=False, yearfirst=False, utc=None, box=True, format=None, exact=True, unit=None, infer_datetime_format=False, origin='unix', cache=True)",
                "_assemble_from_unit_mappings(arg, errors, box, tz)",
                "_attempt_YYYYMMDD(arg, errors)",
                "_guess_time_format_for_array(arr)",
                "to_time(arg, format=None, infer_time_format=False, errors='raise')",
                "f(value)",
                "coerce(values)",
                "calc(carg)",
                "calc_with_mask(carg, mask)",
                "_convert_listlike(arg, format)"
            ],
            "variables_in_file": {
                "ArrayConvertible": [
                    72,
                    47
                ],
                "Union": [
                    163,
                    196,
                    47,
                    54,
                    56
                ],
                "list": [
                    320,
                    864,
                    1025,
                    873,
                    47,
                    57,
                    959
                ],
                "tuple": [
                    320,
                    57,
                    1025,
                    47
                ],
                "ArrayLike": [
                    57,
                    162,
                    47
                ],
                "ABCSeries": [
                    1088,
                    193,
                    550,
                    47,
                    57,
                    765
                ],
                "Scalar": [
                    54,
                    55
                ],
                "int": [
                    72,
                    109,
                    54
                ],
                "float": [
                    72,
                    54
                ],
                "str": [
                    162,
                    195,
                    54
                ],
                "DatetimeScalar": [
                    57,
                    55
                ],
                "TypeVar": [
                    55
                ],
                "datetime": [
                    1042,
                    987,
                    1061,
                    55
                ],
                "DatetimeScalarOrArrayConvertible": [
                    56,
                    192
                ],
                "non_nan_elements": [
                    66,
                    67,
                    68,
                    982,
                    983,
                    984
                ],
                "nonzero": [
                    66,
                    982
                ],
                "notna": [
                    953,
                    66,
                    982
                ],
                "arr": [
                    984,
                    66,
                    68,
                    982
                ],
                "len": [
                    865,
                    67,
                    105,
                    874,
                    108,
                    109,
                    114,
                    983,
                    122,
                    155
                ],
                "_guess_datetime_format": [
                    68
                ],
                "kwargs": [
                    68
                ],
                "Optional": [
                    72,
                    162,
                    195
                ],
                "do_caching": [
                    124,
                    123,
                    100
                ],
                "check_count": [
                    103,
                    109,
                    111,
                    114,
                    116,
                    121,
                    122
                ],
                "arg": [
                    1025,
                    1026,
                    1028,
                    517,
                    518,
                    1033,
                    523,
                    1036,
                    1040,
                    1051,
                    1057,
                    549,
                    550,
                    552,
                    553,
                    554,
                    1075,
                    1078,
                    1084,
                    1085,
                    1086,
                    1087,
                    1088,
                    1089,
                    1090,
                    1091,
                    1092,
                    1093,
                    1094,
                    1096,
                    105,
                    108,
                    109,
                    114,
                    121,
                    151,
                    154,
                    155,
                    218,
                    740,
                    744,
                    758,
                    759,
                    761,
                    765,
                    766,
                    768,
                    770,
                    771,
                    772,
                    773,
                    774,
                    775,
                    777,
                    779,
                    780,
                    781,
                    782,
                    784,
                    786,
                    788,
                    320,
                    321,
                    324,
                    325,
                    326,
                    328,
                    329,
                    331,
                    332,
                    844,
                    334,
                    845,
                    338,
                    343,
                    344,
                    859,
                    366,
                    373,
                    374,
                    376,
                    891,
                    892,
                    893,
                    380,
                    902,
                    904,
                    411,
                    421,
                    425,
                    434,
                    946,
                    438,
                    952,
                    443,
                    959,
                    960,
                    452,
                    497,
                    502,
                    509
                ],
                "unique_share": [
                    122,
                    119
                ],
                "unique_elements": [
                    121,
                    122
                ],
                "unique": [
                    121,
                    154
                ],
                "bool": [
                    73,
                    162,
                    194
                ],
                "cache_array": [
                    768,
                    775,
                    776,
                    777,
                    766,
                    782,
                    783,
                    784,
                    148,
                    152,
                    218,
                    157,
                    158,
                    767
                ],
                "Series": [
                    218,
                    148,
                    157
                ],
                "cache": [
                    782,
                    149,
                    766,
                    775
                ],
                "should_cache": [
                    151
                ],
                "unique_dates": [
                    154,
                    155,
                    156,
                    157
                ],
                "cache_dates": [
                    156,
                    157
                ],
                "convert_listlike": [
                    770,
                    775,
                    747,
                    779,
                    780,
                    782,
                    786,
                    788,
                    156,
                    766
                ],
                "format": [
                    770,
                    387,
                    382,
                    898,
                    390,
                    775,
                    521,
                    395,
                    780,
                    907,
                    398,
                    782,
                    1035,
                    1036,
                    786,
                    1039,
                    532,
                    788,
                    1042,
                    1045,
                    536,
                    1048,
                    411,
                    156,
                    541,
                    413,
                    1075,
                    449,
                    1089,
                    1092,
                    1094,
                    1096,
                    341,
                    867,
                    876,
                    379,
                    380,
                    766,
                    511
                ],
                "is_datetime64_dtype": [
                    185
                ],
                "dt_array": [
                    185,
                    187,
                    188
                ],
                "tz": [
                    896,
                    773,
                    415,
                    186,
                    443,
                    187,
                    444,
                    450,
                    326,
                    327,
                    328,
                    334,
                    473,
                    360,
                    362,
                    746,
                    364,
                    749,
                    760,
                    249,
                    762,
                    764
                ],
                "utc": [
                    450,
                    455,
                    746,
                    474,
                    473,
                    186
                ],
                "DatetimeIndex": [
                    325,
                    326,
                    332,
                    334,
                    465,
                    187,
                    444,
                    351
                ],
                "name": [
                    261,
                    326,
                    415,
                    334,
                    465,
                    188,
                    474,
                    444,
                    187,
                    220,
                    349,
                    351
                ],
                "Index": [
                    349,
                    188,
                    261
                ],
                "ABCIndex": [
                    163,
                    196
                ],
                "ABCDatetimeIndex": [
                    163
                ],
                "result": [
                    256,
                    768,
                    771,
                    773,
                    393,
                    777,
                    780,
                    784,
                    786,
                    403,
                    788,
                    790,
                    408,
                    410,
                    415,
                    421,
                    422,
                    936,
                    425,
                    937,
                    941,
                    942,
                    434,
                    435,
                    438,
                    448,
                    451,
                    465,
                    469,
                    470,
                    344,
                    218,
                    474,
                    220,
                    349,
                    221,
                    351,
                    475,
                    356,
                    359,
                    361,
                    362,
                    364,
                    365,
                    759,
                    762,
                    764
                ],
                "map": [
                    218
                ],
                "box": [
                    258,
                    773,
                    777,
                    332,
                    780,
                    462,
                    910,
                    784,
                    786,
                    788,
                    472,
                    345,
                    219,
                    415
                ],
                "_box_as_indexlike": [
                    474,
                    220
                ],
                "result.values": [
                    221
                ],
                "np.ndarray": [
                    196,
                    550
                ],
                "np": [
                    321,
                    1026,
                    196,
                    421,
                    518,
                    550,
                    552,
                    936,
                    1096,
                    940,
                    434,
                    946,
                    788,
                    470,
                    952,
                    509,
                    255
                ],
                "ValueError": [
                    897,
                    898,
                    520,
                    905,
                    906,
                    1043,
                    404,
                    405,
                    534,
                    535,
                    1049,
                    541,
                    426,
                    1068,
                    1074,
                    947,
                    439,
                    954,
                    445,
                    961,
                    846,
                    335,
                    342,
                    989,
                    866,
                    875,
                    500,
                    504,
                    250
                ],
                "tz_results": [
                    261,
                    262,
                    255
                ],
                "np.array": [
                    321,
                    1026,
                    1096,
                    788,
                    470,
                    255
                ],
                "tz_localize": [
                    256,
                    328
                ],
                "Timestamp": [
                    256,
                    529,
                    498,
                    469,
                    758,
                    507,
                    508,
                    542
                ],
                "res": [
                    256
                ],
                "zone": [
                    256
                ],
                "zip": [
                    256
                ],
                "timezones": [
                    256,
                    410,
                    415
                ],
                "isinstance": [
                    320,
                    1025,
                    1088,
                    1091,
                    772,
                    549,
                    325,
                    774,
                    332,
                    758,
                    765,
                    1086
                ],
                "is_datetime64tz_dtype": [
                    324
                ],
                "DatetimeArray": [
                    332,
                    325
                ],
                "arg.tz_convert": [
                    328
                ],
                "is_datetime64_ns_dtype": [
                    331
                ],
                "unit": [
                    546,
                    744,
                    750,
                    499,
                    340,
                    344,
                    859,
                    860
                ],
                "getattr": [
                    1028,
                    366,
                    343
                ],
                "tz_parsed": [
                    451,
                    356,
                    392,
                    461,
                    465,
                    469,
                    344
                ],
                "tslib.array_with_unit_to_datetime": [
                    344
                ],
                "tslib": [
                    344,
                    933,
                    959
                ],
                "errors": [
                    896,
                    773,
                    904,
                    403,
                    1044,
                    1050,
                    411,
                    418,
                    420,
                    933,
                    431,
                    433,
                    1073,
                    1077,
                    456,
                    344,
                    346,
                    753,
                    883
                ],
                "tz_convert": [
                    356
                ],
                "result.tz_localize": [
                    362,
                    356,
                    764
                ],
                "AttributeError": [
                    357
                ],
                "result.tz": [
                    361
                ],
                "result.tz_convert": [
                    762,
                    364
                ],
                "TypeError": [
                    897,
                    1029,
                    905,
                    1068,
                    367,
                    1043,
                    404,
                    503,
                    445
                ],
                "orig_arg": [
                    402,
                    403,
                    373
                ],
                "_": [
                    374
                ],
                "maybe_convert_dtype": [
                    374
                ],
                "ensure_object": [
                    376,
                    1033,
                    402
                ],
                "require_iso8601": [
                    377,
                    457,
                    389
                ],
                "infer_datetime_format": [
                    449,
                    389,
                    430,
                    755,
                    379
                ],
                "_guess_datetime_format_for_array": [
                    380
                ],
                "dayfirst": [
                    380,
                    453,
                    751
                ],
                "format_is_iso8601": [
                    387,
                    388
                ],
                "_format_is_iso": [
                    387
                ],
                "_attempt_YYYYMMDD": [
                    403
                ],
                "tslibs.OutOfBoundsDatetime": [
                    417,
                    530,
                    531,
                    404,
                    510
                ],
                "tslibs": [
                    417,
                    546,
                    423,
                    938,
                    530,
                    531,
                    436,
                    404,
                    510
                ],
                "array_strptime": [
                    410
                ],
                "exact": [
                    754,
                    411
                ],
                "_return_parsed_timezone_results": [
                    414
                ],
                "np.empty": [
                    936,
                    434,
                    421
                ],
                "arg.shape": [
                    434,
                    421
                ],
                "iresult": [
                    422,
                    423,
                    937,
                    938,
                    435,
                    436
                ],
                "result.view": [
                    937,
                    435,
                    422
                ],
                "iresult.fill": [
                    436,
                    423
                ],
                "tslibs.iNaT": [
                    938,
                    436,
                    423
                ],
                "values": [
                    896,
                    1089,
                    770,
                    771,
                    1090,
                    904,
                    911,
                    912,
                    883,
                    886,
                    887,
                    888,
                    890,
                    443,
                    444
                ],
                "conversion.datetime_to_datetime64": [
                    443
                ],
                "conversion": [
                    443
                ],
                "DatetimeIndex._simple_new": [
                    465,
                    444
                ],
                "e": [
                    898,
                    908,
                    446
                ],
                "objects_to_datetime64ns": [
                    451
                ],
                "yearfirst": [
                    752,
                    454
                ],
                "to_pydatetime": [
                    469
                ],
                "ts": [
                    469
                ],
                "object": [
                    929,
                    470
                ],
                "origin": [
                    743,
                    744,
                    523,
                    496,
                    529,
                    532,
                    537
                ],
                "original": [
                    512,
                    497
                ],
                "j0": [
                    498,
                    507,
                    508,
                    502
                ],
                "to_julian_date": [
                    498
                ],
                "j_max": [
                    507,
                    509
                ],
                "Timestamp.max.to_julian_date": [
                    507
                ],
                "Timestamp.max": [
                    507
                ],
                "j_min": [
                    508,
                    509
                ],
                "Timestamp.min.to_julian_date": [
                    508
                ],
                "Timestamp.min": [
                    508
                ],
                "np.any": [
                    509
                ],
                "is_scalar": [
                    517
                ],
                "is_integer": [
                    517
                ],
                "is_float": [
                    517
                ],
                "is_numeric_dtype": [
                    518
                ],
                "np.asarray": [
                    552,
                    518
                ],
                "offset": [
                    546,
                    553,
                    529,
                    540,
                    541,
                    542
                ],
                "offset.tz": [
                    540
                ],
                "tslibs.Timedelta": [
                    546
                ],
                "is_list_like": [
                    781,
                    1093,
                    549
                ],
                "ABCIndexClass": [
                    1091,
                    550,
                    774
                ],
                "_adjust_to_origin": [
                    744
                ],
                "partial": [
                    779,
                    747
                ],
                "_convert_listlike_datetimes": [
                    748
                ],
                "arg.tz": [
                    761
                ],
                "_maybe_cache": [
                    782,
                    766,
                    775
                ],
                "cache_array.empty": [
                    776,
                    783,
                    767
                ],
                "arg.map": [
                    768
                ],
                "arg._values": [
                    1089,
                    770
                ],
                "arg._constructor": [
                    1090,
                    771
                ],
                "arg.index": [
                    1090,
                    771
                ],
                "arg.name": [
                    779,
                    777,
                    1090,
                    771
                ],
                "ABCDataFrame": [
                    772
                ],
                "abc.MutableMapping": [
                    772
                ],
                "abc": [
                    772
                ],
                "_assemble_from_unit_mappings": [
                    773
                ],
                "_convert_and_box_cache": [
                    784,
                    777
                ],
                "deprecate_kwarg": [
                    557
                ],
                "_unit_map": [
                    873,
                    850,
                    851,
                    854,
                    855,
                    794
                ],
                "DataFrame": [
                    844
                ],
                "arg.columns.is_unique": [
                    845
                ],
                "arg.columns": [
                    845
                ],
                "value": [
                    901,
                    902,
                    904,
                    908,
                    850,
                    851,
                    854,
                    855,
                    857
                ],
                "value.lower": [
                    854,
                    855
                ],
                "k": [
                    859,
                    860
                ],
                "f": [
                    859
                ],
                "arg.keys": [
                    859
                ],
                "unit_rev": [
                    864,
                    901,
                    892,
                    873,
                    891,
                    860,
                    893
                ],
                "v": [
                    860
                ],
                "unit.items": [
                    860
                ],
                "required": [
                    864,
                    863
                ],
                "req": [
                    864,
                    865,
                    869
                ],
                "sorted": [
                    864,
                    873
                ],
                "set": [
                    864,
                    873
                ],
                "unit_rev.keys": [
                    864,
                    873
                ],
                "join": [
                    869,
                    878
                ],
                "excess": [
                    873,
                    874,
                    878
                ],
                "_unit_map.values": [
                    873
                ],
                "to_numeric": [
                    883
                ],
                "is_integer_dtype": [
                    886
                ],
                "values.astype": [
                    887
                ],
                "coerce": [
                    904,
                    891,
                    892,
                    893
                ],
                "to_datetime": [
                    896
                ],
                "u": [
                    904,
                    900,
                    901
                ],
                "unit_rev.get": [
                    901
                ],
                "to_timedelta": [
                    904
                ],
                "values.values": [
                    911
                ],
                "carg": [
                    929,
                    931,
                    936,
                    940,
                    952,
                    953
                ],
                "carg.astype": [
                    929
                ],
                "parsed": [
                    930,
                    933
                ],
                "parsing.try_parse_year_month_day": [
                    930
                ],
                "parsing": [
                    930
                ],
                "tslib.array_to_datetime": [
                    933
                ],
                "carg.shape": [
                    936
                ],
                "mask": [
                    960,
                    938,
                    940,
                    941,
                    959
                ],
                "masked_result": [
                    940,
                    941
                ],
                "calc": [
                    946,
                    940
                ],
                "astype": [
                    940
                ],
                "np.float64": [
                    952,
                    940
                ],
                "np.int64": [
                    946,
                    940
                ],
                "masked_result.astype": [
                    941
                ],
                "arg.astype": [
                    952,
                    946
                ],
                "OverflowError": [
                    961,
                    954,
                    947
                ],
                "calc_with_mask": [
                    960,
                    953
                ],
                "algorithms.isin": [
                    959
                ],
                "algorithms": [
                    959
                ],
                "tslib.nat_strings": [
                    959
                ],
                "_time_formats": [
                    968,
                    985,
                    1055
                ],
                "element": [
                    1057,
                    1061,
                    1040,
                    1042,
                    984,
                    1048,
                    987
                ],
                "time_format": [
                    1059,
                    1061,
                    1064,
                    985,
                    987,
                    988
                ],
                "datetime.strptime": [
                    1042,
                    987,
                    1061
                ],
                "infer_time_format": [
                    1035
                ],
                "_guess_time_format_for_array": [
                    1036
                ],
                "times": [
                    1038,
                    1072,
                    1042,
                    1080,
                    1082,
                    1053
                ],
                "times.append": [
                    1072,
                    1042,
                    1080,
                    1053
                ],
                "time": [
                    1042,
                    1061,
                    1086
                ],
                "msg": [
                    1049,
                    1045
                ],
                "formats": [
                    1064,
                    1065,
                    1059,
                    1055
                ],
                "format_found": [
                    1056,
                    1066,
                    1062
                ],
                "time_object": [
                    1072,
                    1058,
                    1061,
                    1071
                ],
                "fmt": [
                    1064,
                    1065
                ],
                "formats.pop": [
                    1064
                ],
                "formats.index": [
                    1064
                ],
                "formats.insert": [
                    1065
                ],
                "_convert_listlike": [
                    1096,
                    1089,
                    1092,
                    1094
                ]
            },
            "filtered_variables_in_file": {
                "ArrayConvertible": [
                    72,
                    47
                ],
                "Union": [
                    163,
                    196,
                    47,
                    54,
                    56
                ],
                "ArrayLike": [
                    57,
                    162,
                    47
                ],
                "ABCSeries": [
                    1088,
                    193,
                    550,
                    47,
                    57,
                    765
                ],
                "Scalar": [
                    54,
                    55
                ],
                "DatetimeScalar": [
                    57,
                    55
                ],
                "TypeVar": [
                    55
                ],
                "datetime": [
                    1042,
                    987,
                    1061,
                    55
                ],
                "DatetimeScalarOrArrayConvertible": [
                    56,
                    192
                ],
                "non_nan_elements": [
                    66,
                    67,
                    68,
                    982,
                    983,
                    984
                ],
                "nonzero": [
                    66,
                    982
                ],
                "notna": [
                    953,
                    66,
                    982
                ],
                "arr": [
                    984,
                    66,
                    68,
                    982
                ],
                "_guess_datetime_format": [
                    68
                ],
                "kwargs": [
                    68
                ],
                "Optional": [
                    72,
                    162,
                    195
                ],
                "do_caching": [
                    124,
                    123,
                    100
                ],
                "check_count": [
                    103,
                    109,
                    111,
                    114,
                    116,
                    121,
                    122
                ],
                "arg": [
                    1025,
                    1026,
                    1028,
                    517,
                    518,
                    1033,
                    523,
                    1036,
                    1040,
                    1051,
                    1057,
                    549,
                    550,
                    552,
                    553,
                    554,
                    1075,
                    1078,
                    1084,
                    1085,
                    1086,
                    1087,
                    1088,
                    1089,
                    1090,
                    1091,
                    1092,
                    1093,
                    1094,
                    1096,
                    105,
                    108,
                    109,
                    114,
                    121,
                    151,
                    154,
                    155,
                    218,
                    740,
                    744,
                    758,
                    759,
                    761,
                    765,
                    766,
                    768,
                    770,
                    771,
                    772,
                    773,
                    774,
                    775,
                    777,
                    779,
                    780,
                    781,
                    782,
                    784,
                    786,
                    788,
                    320,
                    321,
                    324,
                    325,
                    326,
                    328,
                    329,
                    331,
                    332,
                    844,
                    334,
                    845,
                    338,
                    343,
                    344,
                    859,
                    366,
                    373,
                    374,
                    376,
                    891,
                    892,
                    893,
                    380,
                    902,
                    904,
                    411,
                    421,
                    425,
                    434,
                    946,
                    438,
                    952,
                    443,
                    959,
                    960,
                    452,
                    497,
                    502,
                    509
                ],
                "unique_share": [
                    122,
                    119
                ],
                "unique_elements": [
                    121,
                    122
                ],
                "unique": [
                    121,
                    154
                ],
                "cache_array": [
                    768,
                    775,
                    776,
                    777,
                    766,
                    782,
                    783,
                    784,
                    148,
                    152,
                    218,
                    157,
                    158,
                    767
                ],
                "Series": [
                    218,
                    148,
                    157
                ],
                "cache": [
                    782,
                    149,
                    766,
                    775
                ],
                "should_cache": [
                    151
                ],
                "unique_dates": [
                    154,
                    155,
                    156,
                    157
                ],
                "cache_dates": [
                    156,
                    157
                ],
                "convert_listlike": [
                    770,
                    775,
                    747,
                    779,
                    780,
                    782,
                    786,
                    788,
                    156,
                    766
                ],
                "is_datetime64_dtype": [
                    185
                ],
                "dt_array": [
                    185,
                    187,
                    188
                ],
                "tz": [
                    896,
                    773,
                    415,
                    186,
                    443,
                    187,
                    444,
                    450,
                    326,
                    327,
                    328,
                    334,
                    473,
                    360,
                    362,
                    746,
                    364,
                    749,
                    760,
                    249,
                    762,
                    764
                ],
                "utc": [
                    450,
                    455,
                    746,
                    474,
                    473,
                    186
                ],
                "DatetimeIndex": [
                    325,
                    326,
                    332,
                    334,
                    465,
                    187,
                    444,
                    351
                ],
                "name": [
                    261,
                    326,
                    415,
                    334,
                    465,
                    188,
                    474,
                    444,
                    187,
                    220,
                    349,
                    351
                ],
                "Index": [
                    349,
                    188,
                    261
                ],
                "ABCIndex": [
                    163,
                    196
                ],
                "ABCDatetimeIndex": [
                    163
                ],
                "result": [
                    256,
                    768,
                    771,
                    773,
                    393,
                    777,
                    780,
                    784,
                    786,
                    403,
                    788,
                    790,
                    408,
                    410,
                    415,
                    421,
                    422,
                    936,
                    425,
                    937,
                    941,
                    942,
                    434,
                    435,
                    438,
                    448,
                    451,
                    465,
                    469,
                    470,
                    344,
                    218,
                    474,
                    220,
                    349,
                    221,
                    351,
                    475,
                    356,
                    359,
                    361,
                    362,
                    364,
                    365,
                    759,
                    762,
                    764
                ],
                "box": [
                    258,
                    773,
                    777,
                    332,
                    780,
                    462,
                    910,
                    784,
                    786,
                    788,
                    472,
                    345,
                    219,
                    415
                ],
                "_box_as_indexlike": [
                    474,
                    220
                ],
                "result.values": [
                    221
                ],
                "np.ndarray": [
                    196,
                    550
                ],
                "np": [
                    321,
                    1026,
                    196,
                    421,
                    518,
                    550,
                    552,
                    936,
                    1096,
                    940,
                    434,
                    946,
                    788,
                    470,
                    952,
                    509,
                    255
                ],
                "tz_results": [
                    261,
                    262,
                    255
                ],
                "np.array": [
                    321,
                    1026,
                    1096,
                    788,
                    470,
                    255
                ],
                "tz_localize": [
                    256,
                    328
                ],
                "Timestamp": [
                    256,
                    529,
                    498,
                    469,
                    758,
                    507,
                    508,
                    542
                ],
                "res": [
                    256
                ],
                "zone": [
                    256
                ],
                "timezones": [
                    256,
                    410,
                    415
                ],
                "is_datetime64tz_dtype": [
                    324
                ],
                "DatetimeArray": [
                    332,
                    325
                ],
                "arg.tz_convert": [
                    328
                ],
                "is_datetime64_ns_dtype": [
                    331
                ],
                "unit": [
                    546,
                    744,
                    750,
                    499,
                    340,
                    344,
                    859,
                    860
                ],
                "tz_parsed": [
                    451,
                    356,
                    392,
                    461,
                    465,
                    469,
                    344
                ],
                "tslib.array_with_unit_to_datetime": [
                    344
                ],
                "tslib": [
                    344,
                    933,
                    959
                ],
                "errors": [
                    896,
                    773,
                    904,
                    403,
                    1044,
                    1050,
                    411,
                    418,
                    420,
                    933,
                    431,
                    433,
                    1073,
                    1077,
                    456,
                    344,
                    346,
                    753,
                    883
                ],
                "tz_convert": [
                    356
                ],
                "result.tz_localize": [
                    362,
                    356,
                    764
                ],
                "result.tz": [
                    361
                ],
                "result.tz_convert": [
                    762,
                    364
                ],
                "orig_arg": [
                    402,
                    403,
                    373
                ],
                "_": [
                    374
                ],
                "maybe_convert_dtype": [
                    374
                ],
                "ensure_object": [
                    376,
                    1033,
                    402
                ],
                "require_iso8601": [
                    377,
                    457,
                    389
                ],
                "infer_datetime_format": [
                    449,
                    389,
                    430,
                    755,
                    379
                ],
                "_guess_datetime_format_for_array": [
                    380
                ],
                "dayfirst": [
                    380,
                    453,
                    751
                ],
                "format_is_iso8601": [
                    387,
                    388
                ],
                "_format_is_iso": [
                    387
                ],
                "_attempt_YYYYMMDD": [
                    403
                ],
                "tslibs.OutOfBoundsDatetime": [
                    417,
                    530,
                    531,
                    404,
                    510
                ],
                "tslibs": [
                    417,
                    546,
                    423,
                    938,
                    530,
                    531,
                    436,
                    404,
                    510
                ],
                "array_strptime": [
                    410
                ],
                "exact": [
                    754,
                    411
                ],
                "_return_parsed_timezone_results": [
                    414
                ],
                "np.empty": [
                    936,
                    434,
                    421
                ],
                "arg.shape": [
                    434,
                    421
                ],
                "iresult": [
                    422,
                    423,
                    937,
                    938,
                    435,
                    436
                ],
                "result.view": [
                    937,
                    435,
                    422
                ],
                "iresult.fill": [
                    436,
                    423
                ],
                "tslibs.iNaT": [
                    938,
                    436,
                    423
                ],
                "values": [
                    896,
                    1089,
                    770,
                    771,
                    1090,
                    904,
                    911,
                    912,
                    883,
                    886,
                    887,
                    888,
                    890,
                    443,
                    444
                ],
                "conversion.datetime_to_datetime64": [
                    443
                ],
                "conversion": [
                    443
                ],
                "DatetimeIndex._simple_new": [
                    465,
                    444
                ],
                "e": [
                    898,
                    908,
                    446
                ],
                "objects_to_datetime64ns": [
                    451
                ],
                "yearfirst": [
                    752,
                    454
                ],
                "to_pydatetime": [
                    469
                ],
                "ts": [
                    469
                ],
                "origin": [
                    743,
                    744,
                    523,
                    496,
                    529,
                    532,
                    537
                ],
                "original": [
                    512,
                    497
                ],
                "j0": [
                    498,
                    507,
                    508,
                    502
                ],
                "to_julian_date": [
                    498
                ],
                "j_max": [
                    507,
                    509
                ],
                "Timestamp.max.to_julian_date": [
                    507
                ],
                "Timestamp.max": [
                    507
                ],
                "j_min": [
                    508,
                    509
                ],
                "Timestamp.min.to_julian_date": [
                    508
                ],
                "Timestamp.min": [
                    508
                ],
                "np.any": [
                    509
                ],
                "is_scalar": [
                    517
                ],
                "is_integer": [
                    517
                ],
                "is_float": [
                    517
                ],
                "is_numeric_dtype": [
                    518
                ],
                "np.asarray": [
                    552,
                    518
                ],
                "offset": [
                    546,
                    553,
                    529,
                    540,
                    541,
                    542
                ],
                "offset.tz": [
                    540
                ],
                "tslibs.Timedelta": [
                    546
                ],
                "is_list_like": [
                    781,
                    1093,
                    549
                ],
                "ABCIndexClass": [
                    1091,
                    550,
                    774
                ],
                "_adjust_to_origin": [
                    744
                ],
                "partial": [
                    779,
                    747
                ],
                "_convert_listlike_datetimes": [
                    748
                ],
                "arg.tz": [
                    761
                ],
                "_maybe_cache": [
                    782,
                    766,
                    775
                ],
                "cache_array.empty": [
                    776,
                    783,
                    767
                ],
                "arg.map": [
                    768
                ],
                "arg._values": [
                    1089,
                    770
                ],
                "arg._constructor": [
                    1090,
                    771
                ],
                "arg.index": [
                    1090,
                    771
                ],
                "arg.name": [
                    779,
                    777,
                    1090,
                    771
                ],
                "ABCDataFrame": [
                    772
                ],
                "abc.MutableMapping": [
                    772
                ],
                "abc": [
                    772
                ],
                "_assemble_from_unit_mappings": [
                    773
                ],
                "_convert_and_box_cache": [
                    784,
                    777
                ],
                "deprecate_kwarg": [
                    557
                ],
                "_unit_map": [
                    873,
                    850,
                    851,
                    854,
                    855,
                    794
                ],
                "DataFrame": [
                    844
                ],
                "arg.columns.is_unique": [
                    845
                ],
                "arg.columns": [
                    845
                ],
                "value": [
                    901,
                    902,
                    904,
                    908,
                    850,
                    851,
                    854,
                    855,
                    857
                ],
                "value.lower": [
                    854,
                    855
                ],
                "k": [
                    859,
                    860
                ],
                "f": [
                    859
                ],
                "arg.keys": [
                    859
                ],
                "unit_rev": [
                    864,
                    901,
                    892,
                    873,
                    891,
                    860,
                    893
                ],
                "v": [
                    860
                ],
                "unit.items": [
                    860
                ],
                "required": [
                    864,
                    863
                ],
                "req": [
                    864,
                    865,
                    869
                ],
                "unit_rev.keys": [
                    864,
                    873
                ],
                "join": [
                    869,
                    878
                ],
                "excess": [
                    873,
                    874,
                    878
                ],
                "_unit_map.values": [
                    873
                ],
                "to_numeric": [
                    883
                ],
                "is_integer_dtype": [
                    886
                ],
                "values.astype": [
                    887
                ],
                "coerce": [
                    904,
                    891,
                    892,
                    893
                ],
                "to_datetime": [
                    896
                ],
                "u": [
                    904,
                    900,
                    901
                ],
                "unit_rev.get": [
                    901
                ],
                "to_timedelta": [
                    904
                ],
                "values.values": [
                    911
                ],
                "carg": [
                    929,
                    931,
                    936,
                    940,
                    952,
                    953
                ],
                "carg.astype": [
                    929
                ],
                "parsed": [
                    930,
                    933
                ],
                "parsing.try_parse_year_month_day": [
                    930
                ],
                "parsing": [
                    930
                ],
                "tslib.array_to_datetime": [
                    933
                ],
                "carg.shape": [
                    936
                ],
                "mask": [
                    960,
                    938,
                    940,
                    941,
                    959
                ],
                "masked_result": [
                    940,
                    941
                ],
                "calc": [
                    946,
                    940
                ],
                "astype": [
                    940
                ],
                "np.float64": [
                    952,
                    940
                ],
                "np.int64": [
                    946,
                    940
                ],
                "masked_result.astype": [
                    941
                ],
                "arg.astype": [
                    952,
                    946
                ],
                "calc_with_mask": [
                    960,
                    953
                ],
                "algorithms.isin": [
                    959
                ],
                "algorithms": [
                    959
                ],
                "tslib.nat_strings": [
                    959
                ],
                "_time_formats": [
                    968,
                    985,
                    1055
                ],
                "element": [
                    1057,
                    1061,
                    1040,
                    1042,
                    984,
                    1048,
                    987
                ],
                "time_format": [
                    1059,
                    1061,
                    1064,
                    985,
                    987,
                    988
                ],
                "datetime.strptime": [
                    1042,
                    987,
                    1061
                ],
                "infer_time_format": [
                    1035
                ],
                "_guess_time_format_for_array": [
                    1036
                ],
                "times": [
                    1038,
                    1072,
                    1042,
                    1080,
                    1082,
                    1053
                ],
                "times.append": [
                    1072,
                    1042,
                    1080,
                    1053
                ],
                "time": [
                    1042,
                    1061,
                    1086
                ],
                "msg": [
                    1049,
                    1045
                ],
                "formats": [
                    1064,
                    1065,
                    1059,
                    1055
                ],
                "format_found": [
                    1056,
                    1066,
                    1062
                ],
                "time_object": [
                    1072,
                    1058,
                    1061,
                    1071
                ],
                "fmt": [
                    1064,
                    1065
                ],
                "formats.pop": [
                    1064
                ],
                "formats.index": [
                    1064
                ],
                "formats.insert": [
                    1065
                ],
                "_convert_listlike": [
                    1096,
                    1089,
                    1092,
                    1094
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_164/pandas/tests/indexes/datetimes/test_tools.py",
                "test_function": "test_to_datetime_dta_tz",
                "test_function_code": "    @pytest.mark.parametrize(\"klass\", [DatetimeIndex, DatetimeArray])\n    def test_to_datetime_dta_tz(self, klass):\n        # GH#27733\n        dti = date_range(\"2015-04-05\", periods=3).rename(\"foo\")\n        expected = dti.tz_localize(\"UTC\")\n\n        obj = klass(dti)\n        expected = klass(expected)\n\n        result = to_datetime(obj, utc=True)\n        tm.assert_equal(result, expected)",
                "test_error": "AssertionError: Index are different  Attribute \"dtype\" are different [left]:  datetime64[ns] [right]: datetime64[ns, UTC]",
                "full_test_error": "self = <pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc object at 0x114704bb0>\nklass = <class 'pandas.core.indexes.datetimes.DatetimeIndex'>\n\n    @pytest.mark.parametrize(\"klass\", [DatetimeIndex, DatetimeArray])\n    def test_to_datetime_dta_tz(self, klass):\n        # GH#27733\n        dti = date_range(\"2015-04-05\", periods=3).rename(\"foo\")\n        expected = dti.tz_localize(\"UTC\")\n    \n        obj = klass(dti)\n        expected = klass(expected)\n    \n        result = to_datetime(obj, utc=True)\n>       tm.assert_equal(result, expected)\n\npandas/tests/indexes/datetimes/test_tools.py:1633: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nl = DatetimeIndex(['2015-04-05', '2015-04-06', '2015-04-07'], dtype='datetime64[ns]', name='foo', freq='D')\nr = DatetimeIndex(['2015-04-05 00:00:00+00:00', '2015-04-06 00:00:00+00:00',\n               '2015-04-07 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', name='foo', freq='D')\nobj = 'Index'\n\n    def _check_types(l, r, obj=\"Index\"):\n        if exact:\n            assert_class_equal(l, r, exact=exact, obj=obj)\n    \n            # Skip exact dtype checking when `check_categorical` is False\n            if check_categorical:\n>               assert_attr_equal(\"dtype\", l, r, obj=obj)\nE               AssertionError: Index are different\nE               \nE               Attribute \"dtype\" are different\nE               [left]:  datetime64[ns]\nE               [right]: datetime64[ns, UTC]\n\npandas/util/testing.py:616: AssertionError",
                "traceback": "l = DatetimeIndex(['2015-04-05', '2015-04-06', '2015-04-07'], dtype='datetime64[ns]', name='foo', freq='D')\nr = DatetimeIndex(['2015-04-05 00:00:00+00:00', '2015-04-06 00:00:00+00:00',\n               '2015-04-07 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', name='foo', freq='D')\nobj = 'Index'\n\n    def _check_types(l, r, obj=\"Index\"):\n        if exact:\n            assert_class_equal(l, r, exact=exact, obj=obj)\n    \n            # Skip exact dtype checking when `check_categorical` is False\n            if check_categorical:\n>               assert_attr_equal(\"dtype\", l, r, obj=obj)\nE               AssertionError: Index are different",
                "test_error_location": "E               \nE               Attribute \"dtype\" are different\nE               [left]:  datetime64[ns]\nE               [right]: datetime64[ns, UTC]\n\npandas/util/testing.py:616: AssertionError",
                "test_function_decorators": [
                    "pytest.mark.parametrize('klass', [DatetimeIndex, DatetimeArray])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_164/pandas/tests/indexes/datetimes/test_tools.py",
                "test_function": "test_to_datetime_dta_tz",
                "test_function_code": "    @pytest.mark.parametrize(\"klass\", [DatetimeIndex, DatetimeArray])\n    def test_to_datetime_dta_tz(self, klass):\n        # GH#27733\n        dti = date_range(\"2015-04-05\", periods=3).rename(\"foo\")\n        expected = dti.tz_localize(\"UTC\")\n\n        obj = klass(dti)\n        expected = klass(expected)\n\n        result = to_datetime(obj, utc=True)\n        tm.assert_equal(result, expected)",
                "test_error": "AssertionError: DatetimeArray are different  Attribute \"tz\" are different [left]:  None [right]: UTC",
                "full_test_error": "self = <pandas.tests.indexes.datetimes.test_tools.TestToDatetimeMisc object at 0x1149668e0>\nklass = <class 'pandas.core.arrays.datetimes.DatetimeArray'>\n\n    @pytest.mark.parametrize(\"klass\", [DatetimeIndex, DatetimeArray])\n    def test_to_datetime_dta_tz(self, klass):\n        # GH#27733\n        dti = date_range(\"2015-04-05\", periods=3).rename(\"foo\")\n        expected = dti.tz_localize(\"UTC\")\n    \n        obj = klass(dti)\n        expected = klass(expected)\n    \n        result = to_datetime(obj, utc=True)\n>       tm.assert_equal(result, expected)\nE       AssertionError: DatetimeArray are different\nE       \nE       Attribute \"tz\" are different\nE       [left]:  None\nE       [right]: UTC\n\npandas/tests/indexes/datetimes/test_tools.py:1633: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('klass', [DatetimeIndex, DatetimeArray])"
                ]
            }
        ]
    }
}