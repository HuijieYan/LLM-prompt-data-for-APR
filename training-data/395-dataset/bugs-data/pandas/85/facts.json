{
    "1.1.1": "@Appender(_index_shared_docs[\"_get_grouper_for_level\"])\ndef _get_grouper_for_level(self, mapper, level):\n    indexer = self.codes[level]\n    level_index = self.levels[level]\n\n    if mapper is not None:\n        # Handle group mapping function and return\n        level_values = self.levels[level].take(indexer)\n        grouper = level_values.map(mapper)\n        return grouper, None, None\n\n    codes, uniques = algos.factorize(indexer, sort=True)\n\n    if len(uniques) > 0 and uniques[0] == -1:\n        # Handle NAs\n        mask = indexer != -1\n        ok_codes, uniques = algos.factorize(indexer[mask], sort=True)\n\n        codes = np.empty(len(indexer), dtype=indexer.dtype)\n        codes[mask] = ok_codes\n        codes[~mask] = -1\n\n    if len(uniques) < len(level_index):\n        # Remove unobserved levels from level_index\n        level_index = level_index.take(uniques)\n\n    if len(level_index):\n        grouper = level_index.take(codes)\n    else:\n        grouper = level_index.take(codes, fill_value=True)\n\n    return grouper, codes, level_index\n",
    "1.1.2": null,
    "1.2.1": "class MultiIndex(Index)",
    "1.2.2": "A multi-level, or hierarchical, index object for pandas objects.\n\nParameters\n----------\nlevels : sequence of arrays\n    The unique labels for each level.\ncodes : sequence of arrays\n    Integers for each level designating which label at each location.\n\n    .. versionadded:: 0.24.0\nsortorder : optional int\n    Level of sortedness (must be lexicographically sorted by that\n    level).\nnames : optional sequence of objects\n    Names for each of the index levels. (name is accepted for compat).\ncopy : bool, default False\n    Copy the meta-data.\nverify_integrity : bool, default True\n    Check that the levels/codes are consistent and valid.\n\nAttributes\n----------\nnames\nlevels\ncodes\nnlevels\nlevshape\n\nMethods\n-------\nfrom_arrays\nfrom_tuples\nfrom_product\nfrom_frame\nset_levels\nset_codes\nto_frame\nto_flat_index\nis_lexsorted\nsortlevel\ndroplevel\nswaplevel\nreorder_levels\nremove_unused_levels\nget_locs\n\nSee Also\n--------\nMultiIndex.from_arrays  : Convert list of arrays to MultiIndex.\nMultiIndex.from_product : Create a MultiIndex from the cartesian product\n                          of iterables.\nMultiIndex.from_tuples  : Convert list of tuples to a MultiIndex.\nMultiIndex.from_frame   : Make a MultiIndex from a DataFrame.\nIndex : The base pandas Index type.\n\nNotes\n-----\nSee the `user guide\n<https://pandas.pydata.org/pandas-docs/stable/user_guide/advanced.html>`_\nfor more.\n\nExamples\n--------\nA new ``MultiIndex`` is typically constructed using one of the helper\nmethods :meth:`MultiIndex.from_arrays`, :meth:`MultiIndex.from_product`\nand :meth:`MultiIndex.from_tuples`. For example (using ``.from_arrays``):\n\n>>> arrays = [[1, 1, 2, 2], ['red', 'blue', 'red', 'blue']]\n>>> pd.MultiIndex.from_arrays(arrays, names=('number', 'color'))\nMultiIndex([(1,  'red'),\n            (1, 'blue'),\n            (2,  'red'),\n            (2, 'blue')],\n           names=['number', 'color'])\n\nSee further examples for how to construct a MultiIndex in the doc strings\nof the mentioned helper methods.",
    "1.2.3": [
        "levels(self)",
        "codes(self)",
        "dtype(self) -> np.dtype",
        "take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs)"
    ],
    "1.3.1": "/Volumes/JerrySSD/bgp_envs/repos/pandas_85/pandas/core/indexes/multi.py",
    "1.3.2": [
        "levels(self)",
        "codes(self)",
        "dtype(self) -> np.dtype",
        "take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs)"
    ],
    "1.4.1": [
        "@pytest.mark.parametrize(\"category\", [False, True])\ndef test_apply_multi_level_name(category):\n    # https://github.com/pandas-dev/pandas/issues/31068\n    b = [1, 2] * 5\n    if category:\n        b = pd.Categorical(b, categories=[1, 2, 3])\n    df = pd.DataFrame(\n        {\"A\": np.arange(10), \"B\": b, \"C\": list(range(10)), \"D\": list(range(10))}\n    ).set_index([\"A\", \"B\"])\n    result = df.groupby(\"B\").apply(lambda x: x.sum())\n    expected = pd.DataFrame(\n        {\"C\": [20, 25], \"D\": [20, 25]}, index=pd.Index([1, 2], name=\"B\")\n    )\n    tm.assert_frame_equal(result, expected)\n    assert df.index.names == [\"A\", \"B\"]"
    ],
    "1.4.2": [
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_85/pandas/tests/groupby/test_apply.py"
    ],
    "2.1.1": [
        [
            "E           RuntimeError: Cannot set name on a level of a MultiIndex. Use 'MultiIndex.set_names' instead."
        ]
    ],
    "2.1.2": [
        [
            "category = False\n\n    @pytest.mark.parametrize(\"category\", [False, True])\n    def test_apply_multi_level_name(category):\n        # https://github.com/pandas-dev/pandas/issues/31068\n        b = [1, 2] * 5\n        if category:\n            b = pd.Categorical(b, categories=[1, 2, 3])\n        df = pd.DataFrame(\n            {\"A\": np.arange(10), \"B\": b, \"C\": list(range(10)), \"D\": list(range(10))}\n        ).set_index([\"A\", \"B\"])\n>       result = df.groupby(\"B\").apply(lambda x: x.sum())\n\npandas/tests/groupby/test_apply.py:789: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/groupby/groupby.py:735: in apply\n    result = self._python_apply_general(f)\npandas/core/groupby/groupby.py:753: in _python_apply_general\n    return self._wrap_applied_output(\npandas/core/groupby/generic.py:1202: in _wrap_applied_output\n    key_index.name = key_names[0]\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Int64Index([1, 2], dtype='int64', name='B'), value = 'B'\n\n    @name.setter\n    def name(self, value):\n        if self._no_setting_name:\n            # Used in MultiIndex.levels to avoid silently ignoring name updates.\n>           raise RuntimeError(\n                \"Cannot set name on a level of a MultiIndex. Use \"\n                \"'MultiIndex.set_names' instead.\"\n            )",
            "\npandas/core/indexes/base.py:1168: RuntimeError"
        ]
    ],
    "2.1.3": [
        [
            {
                "self.codes": "FrozenList([[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0, 1, 0, 1, 0, 1, 0, 1, 0, 1]])",
                "self": "MultiIndex([(0, 1),\n            (1, 2),\n            (2, 1),\n            (3, 2),\n            (4, 1),\n            (5, 2),\n            (6, 1),\n            (7, 2),\n            (8, 1),\n            (9, 2)],\n           names=['A', 'B'])",
                "level": "1",
                "self.levels": "FrozenList([[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2]])"
            },
            {
                "indexer": "array([0, 1, 0, 1, 0, 1, 0, 1, 0, 1], dtype=int8)",
                "level_index": "Int64Index([1, 2], dtype='int64', name='B')",
                "grouper": "Int64Index([1, 2, 1, 2, 1, 2, 1, 2, 1, 2], dtype='int64', name='B')",
                "codes": "array([0, 1, 0, 1, 0, 1, 0, 1, 0, 1])",
                "uniques": "array([0, 1])",
                "indexer.dtype": "dtype('int8')",
                "level_index.take": "<bound method Index.take of Int64Index([1, 2], dtype='int64', name='B')>"
            }
        ],
        [
            {
                "self.codes": "FrozenList([[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0, 1, 0, 1, 0, 1, 0, 1, 0, 1]])",
                "self": "MultiIndex([(0, 1),\n            (1, 2),\n            (2, 1),\n            (3, 2),\n            (4, 1),\n            (5, 2),\n            (6, 1),\n            (7, 2),\n            (8, 1),\n            (9, 2)],\n           names=['A', 'B'])",
                "level": "1",
                "self.levels": "FrozenList([[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3]])"
            },
            {
                "indexer": "array([0, 1, 0, 1, 0, 1, 0, 1, 0, 1], dtype=int8)",
                "level_index": "CategoricalIndex([1, 2], categories=[1, 2, 3], ordered=False, name='B', dtype='category')",
                "grouper": "CategoricalIndex([1, 2, 1, 2, 1, 2, 1, 2, 1, 2], categories=[1, 2, 3], ordered=False, name='B', dtype='category')",
                "codes": "array([0, 1, 0, 1, 0, 1, 0, 1, 0, 1])",
                "uniques": "array([0, 1])",
                "indexer.dtype": "dtype('int8')",
                "level_index.take": "<bound method ExtensionIndex.take of CategoricalIndex([1, 2], categories=[1, 2, 3], ordered=False, name='B', dtype='category')>"
            }
        ]
    ],
    "2.1.4": [
        [
            {
                "self.codes": "FrozenList",
                "self": "MultiIndex",
                "level": "int",
                "self.levels": "FrozenList"
            },
            {
                "indexer": "ndarray",
                "level_index": "Int64Index",
                "grouper": "Int64Index",
                "codes": "ndarray",
                "uniques": "ndarray",
                "indexer.dtype": "dtype",
                "level_index.take": "method"
            }
        ],
        [
            {
                "self.codes": "FrozenList",
                "self": "MultiIndex",
                "level": "int",
                "self.levels": "FrozenList"
            },
            {
                "indexer": "ndarray",
                "level_index": "CategoricalIndex",
                "grouper": "CategoricalIndex",
                "codes": "ndarray",
                "uniques": "ndarray",
                "indexer.dtype": "dtype",
                "level_index.take": "method"
            }
        ]
    ],
    "2.1.5": [
        [
            {
                "self.codes": "FrozenList([[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0, 1, 0, 1, 0, 1, 0, 1, 0, 1]])",
                "self": "MultiIndex([(0, 1),\n            (1, 2),\n            (2, 1),\n            (3, 2),\n            (4, 1),\n            (5, 2),\n            (6, 1),\n            (7, 2),\n            (8, 1),\n            (9, 2)],\n           names=['A', 'B'])",
                "level": "1",
                "self.levels": "FrozenList([[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2]])"
            },
            {
                "indexer": "array([0, 1, 0, 1, 0, 1, 0, 1, 0, 1], dtype=int8)",
                "level_index": "Int64Index([1, 2], dtype='int64', name='B')",
                "grouper": "Int64Index([1, 2, 1, 2, 1, 2, 1, 2, 1, 2], dtype='int64', name='B')",
                "codes": "array([0, 1, 0, 1, 0, 1, 0, 1, 0, 1])",
                "uniques": "array([0, 1])",
                "indexer.dtype": "dtype('int8')",
                "level_index.take": "<bound method Index.take of Int64Index([1, 2], dtype='int64', name='B')>",
                "level_index.copy": "<bound method Index.copy of Int64Index([1, 2], dtype='int64', name='B')>"
            }
        ],
        [
            {
                "self.codes": "FrozenList([[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0, 1, 0, 1, 0, 1, 0, 1, 0, 1]])",
                "self": "MultiIndex([(0, 1),\n            (1, 2),\n            (2, 1),\n            (3, 2),\n            (4, 1),\n            (5, 2),\n            (6, 1),\n            (7, 2),\n            (8, 1),\n            (9, 2)],\n           names=['A', 'B'])",
                "level": "1",
                "self.levels": "FrozenList([[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3]])"
            },
            {
                "indexer": "array([0, 1, 0, 1, 0, 1, 0, 1, 0, 1], dtype=int8)",
                "level_index": "CategoricalIndex([1, 2], categories=[1, 2, 3], ordered=False, name='B', dtype='category')",
                "grouper": "CategoricalIndex([1, 2, 1, 2, 1, 2, 1, 2, 1, 2], categories=[1, 2, 3], ordered=False, name='B', dtype='category')",
                "codes": "array([0, 1, 0, 1, 0, 1, 0, 1, 0, 1])",
                "uniques": "array([0, 1])",
                "indexer.dtype": "dtype('int8')",
                "level_index.take": "<bound method ExtensionIndex.take of CategoricalIndex([1, 2], categories=[1, 2, 3], ordered=False, name='B', dtype='category')>",
                "level_index.copy": "<bound method Index.copy of CategoricalIndex([1, 2], categories=[1, 2, 3], ordered=False, name='B', dtype='category')>"
            }
        ]
    ],
    "2.1.6": [
        [
            {
                "self.codes": "FrozenList",
                "self": "MultiIndex",
                "level": "int",
                "self.levels": "FrozenList"
            },
            {
                "indexer": "ndarray",
                "level_index": "Int64Index",
                "grouper": "Int64Index",
                "codes": "ndarray",
                "uniques": "ndarray",
                "indexer.dtype": "dtype",
                "level_index.take": "method",
                "level_index.copy": "method"
            }
        ],
        [
            {
                "self.codes": "FrozenList",
                "self": "MultiIndex",
                "level": "int",
                "self.levels": "FrozenList"
            },
            {
                "indexer": "ndarray",
                "level_index": "CategoricalIndex",
                "grouper": "CategoricalIndex",
                "codes": "ndarray",
                "uniques": "ndarray",
                "indexer.dtype": "dtype",
                "level_index.take": "method",
                "level_index.copy": "method"
            }
        ]
    ],
    "3.1.1": [
        "\n"
    ],
    "3.1.2": [
        "\n"
    ]
}