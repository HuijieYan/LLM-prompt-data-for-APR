```python
def astype_nansafe(arr, dtype, copy: bool = True, skipna: bool = False):
        """
        Cast the elements of an array to a given dtype in a nan-safe manner.

        Parameters
        ----------
        arr : ndarray
        dtype : np.dtype
        copy : bool, default True
            If False, a view will be attempted but may fail, if
            e.g. the item sizes don't align.
        skipna: bool, default False
            Whether or not we should skip NaN when casting as a string-type.

        Raises
        ------
        ValueError
            The dtype was a datetime64/timedelta64 dtype, but it had no unit.
        """

        # dispatch on extension dtype if needed
        if pd.api.types.is_object_dtype(dtype):
            return dtype.construct_array_type()._from_sequence(arr, dtype=dtype, copy=copy)

        if not isinstance(dtype, np.dtype):
            dtype = pd.api.types.pandas_dtype(dtype)

        if pd.api.types.is_string_dtype(dtype):
            return lib.astype_str(arr.ravel(), **kwargs).reshape(arr.shape)

        elif pd.api.types.is_datetime64_any_dtype(arr):

            is_object_dtype = pd.api.types.is_object_dtype(dtype)
            if is_object_dtype:
                return tslib.array_to_dateutil(arr.view('i8')).view(dtype)

            if pd.api.types.is_integer_dtype(dtype) and (dtype.kind != "i" or dtype.itemsize != 8):
                raise ValueError("Cannot convert to a datetime64 or timedelta64 dtype with a different unit than the "
                                 "input.

                # allow frequency conversions
                if dtype.kind == "M":
                    return arr.astype(dtype)
                raise TypeError(f"Cannot convert to '{dtype}' with a different period")

        elif pd.api.types.is_timedelta64_any_dtype(arr):

            is_object_dtype = pd.api.types.is_object_dtype(dtype)
            if is_object_dtype:
                return tslib.array_to_dateutil(arr.view('i8')).view(dtype)

            if 'm' in dtype.kind:
                result = arr.astype(dtype).astype(dtype or np.float64)
                result[isna(arr)] = np.nan
                return result
            raise ValueError(f"Cannot convert to '{dtype}' with a different unit")

        elif pd.api.types.is_floating_dtype(arr) and pd.api.types.is_integer_dtype(dtype):
            if not pd.api.types.is_floating_dtype(dtype) or dtype.kind == "f":
                raise ValueError("Cannot convert non-finite values (NA or inf) to integer")

        elif pd.api.types.is_object_dtype(arr) and not pd.api.types.is_object_dtype(dtype):
            return lib.astype_unsafe(arr.ravel(), dtype).reshape(arr.shape)

        # if we have a datetime/timedelta array of objects
        # then coerce to a proper dtype and recall astype_nansafe
        if pd.api.types.is_datetime64_any_dtype(dtype):
            return astype_nansafe(to_datetime(arr), dtype, copy=copy)
        if pd.api.types.is_timedelta64_any_dtype(dtype):
            return astype_nansafe(to_timedelta(arr), dtype, copy=copy)

        if dtype.name in ("datetime64", "timedelta64"):
            msg = (
                f"The '{dtype.name}' dtype has no unit. Please pass in "
                f"'{dtype.name}[ns]' instead."
            )
            raise ValueError(msg)

        if copy or pd.api.types.is_object_dtype(arr) or pd.api.types.is_object_dtype(dtype):
            # Explicit copy, or required since NumPy can't view from / to object.
            return arr.astype(dtype, copy=True)

        return arr.view(dtype)
```