{
    "1.1.1": "def __setitem__(self, key, value):\n    # na value: need special casing to set directly on numpy arrays\n    needs_float_conversion = False\n    if is_scalar(value) and isna(value):\n        if is_integer_dtype(self.dtype.subtype):\n            # can't set NaN on a numpy integer array\n            needs_float_conversion = True\n        elif is_datetime64_any_dtype(self.dtype.subtype):\n            # need proper NaT to set directly on the numpy array\n            value = np.datetime64(\"NaT\")\n        elif is_timedelta64_dtype(self.dtype.subtype):\n            # need proper NaT to set directly on the numpy array\n            value = np.timedelta64(\"NaT\")\n        value_left, value_right = value, value\n\n    # scalar interval\n    elif is_interval_dtype(value) or isinstance(value, Interval):\n        self._check_closed_matches(value, name=\"value\")\n        value_left, value_right = value.left, value.right\n\n    else:\n        # list-like of intervals\n        try:\n            array = IntervalArray(value)\n            value_left, value_right = array.left, array.right\n        except TypeError as err:\n            # wrong type: not interval or NA\n            msg = f\"'value' should be an interval type, got {type(value)} instead.\"\n            raise TypeError(msg) from err\n\n    key = check_array_indexer(self, key)\n    # Need to ensure that left and right are updated atomically, so we're\n    # forced to copy, update the copy, and swap in the new values.\n    left = self.left.copy(deep=True)\n    if needs_float_conversion:\n        left = left.astype(\"float\")\n    left.values[key] = value_left\n    self._left = left\n\n    right = self.right.copy(deep=True)\n    if needs_float_conversion:\n        right = right.astype(\"float\")\n    right.values[key] = value_right\n    self._right = right\n",
    "1.1.2": null,
    "1.2.1": "@Appender(_interval_shared_docs['class'] % dict(klass='IntervalArray', summary='Pandas array for interval data that are closed on the same side.', versionadded='0.24.0', name='', extra_attributes='', extra_methods='', examples=textwrap.dedent('    Examples\\n    --------\\n    A new ``IntervalArray`` can be constructed directly from an array-like of\\n    ``Interval`` objects:\\n\\n    >>> pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)])\\n    <IntervalArray>\\n    [(0, 1], (1, 5]]\\n    Length: 2, closed: right, dtype: interval[int64]\\n\\n    It may also be constructed using one of the constructor\\n    methods: :meth:`IntervalArray.from_arrays`,\\n    :meth:`IntervalArray.from_breaks`, and :meth:`IntervalArray.from_tuples`.\\n    ')))\nclass IntervalArray(IntervalMixin, ExtensionArray)",
    "1.2.2": null,
    "1.2.3": [
        "dtype(self)",
        "astype(self, dtype, copy=True)",
        "copy(self)",
        "isna(self)",
        "left(self)",
        "right(self)"
    ],
    "1.3.1": "/Volumes/JerrySSD/bgp_envs/repos/pandas_29/pandas/core/arrays/interval.py",
    "1.3.2": [
        "dtype(self)",
        "astype(self, dtype, copy=True)",
        "copy(self)",
        "isna(self)",
        "left(self)",
        "right(self)"
    ],
    "1.4.1": [
        "    def test_set_na(self, left_right_dtypes):\n        left, right = left_right_dtypes\n        result = IntervalArray.from_arrays(left, right)\n\n        if result.dtype.subtype.kind in [\"i\", \"u\"]:\n            msg = \"Cannot set float NaN to integer-backed IntervalArray\"\n            with pytest.raises(ValueError, match=msg):\n                result[0] = np.NaN\n            return\n\n        result[0] = np.nan\n\n        expected_left = Index([left._na_value] + list(left[1:]))\n        expected_right = Index([right._na_value] + list(right[1:]))\n        expected = IntervalArray.from_arrays(expected_left, expected_right)\n\n        tm.assert_extension_array_equal(result, expected)",
        "    @pytest.mark.parametrize(\n        \"data, maindtype, answerdict\",\n        [\n            (\n                [1, 2, 3],\n                np.dtype(\"int32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int32\"\n                    ),\n                },\n            ),\n            (\n                [1, 2, 3],\n                np.dtype(\"int64\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int64\"\n                    ),\n                },\n            ),\n            (\n                [\"x\", \"y\", \"z\"],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [True, False, np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True,),\n                    ): pd.BooleanDtype(),\n                    ((True, False), (True, False), (True, False), (False,)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [\"h\", \"i\", np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (  # GH32117\n                [\"h\", \"i\", 1],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [10, np.nan, 20],\n                np.dtype(\"float\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                },\n            ),\n            (\n                [np.nan, 100.5, 200],\n                np.dtype(\"float\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"float\"),\n                },\n            ),\n            (\n                [3, 4, 5],\n                \"Int8\",\n                {((True, False), (True, False), (True, False), (True, False)): \"Int8\"},\n            ),\n            (\n                [[1, 2], [3, 4], [5]],\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [4, 5, 6],\n                np.dtype(\"uint32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"UInt32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"uint32\"\n                    ),\n                },\n            ),\n            (\n                [-10, 12, 13],\n                np.dtype(\"i1\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int8\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"i1\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.0],\n                object,\n                {\n                    ((True,), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True,), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.5],\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [\"a\", \"b\"],\n                pd.CategoricalDtype(),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.CategoricalDtype(),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                pd.DatetimeTZDtype(tz=\"UTC\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.DatetimeTZDtype(tz=\"UTC\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                \"datetime64[ns]\",\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"datetime64[ns]\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"datetime64[ns]\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                pd.period_range(\"1/1/2011\", freq=\"M\", periods=3),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.PeriodDtype(\"M\"),\n                },\n            ),\n            (\n                pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)]),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.IntervalDtype(\"int64\"),\n                },\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\"params\", product(*[(True, False)] * 4))\n    def test_convert_dtypes(self, data, maindtype, params, answerdict):\n        if maindtype is not None:\n            series = pd.Series(data, dtype=maindtype)\n        else:\n            series = pd.Series(data)\n        answers = {k: a for (kk, a) in answerdict.items() for k in product(*kk)}\n\n        ns = series.convert_dtypes(*params)\n        expected_dtype = answers[tuple(params)]\n        expected = pd.Series(series.values, dtype=expected_dtype)\n        tm.assert_series_equal(ns, expected)\n\n        # Test that it is a copy\n        copy = series.copy(deep=True)\n        if is_interval_dtype(ns.dtype) and ns.dtype.subtype.kind in [\"i\", \"u\"]:\n            msg = \"Cannot set float NaN to integer-backed IntervalArray\"\n            with pytest.raises(ValueError, match=msg):\n                ns[ns.notna()] = np.nan\n        else:\n            ns[ns.notna()] = np.nan\n\n        # Make sure original not changed\n        tm.assert_series_equal(series, copy)",
        "    @pytest.mark.parametrize(\n        \"data, maindtype, answerdict\",\n        [\n            (\n                [1, 2, 3],\n                np.dtype(\"int32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int32\"\n                    ),\n                },\n            ),\n            (\n                [1, 2, 3],\n                np.dtype(\"int64\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int64\"\n                    ),\n                },\n            ),\n            (\n                [\"x\", \"y\", \"z\"],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [True, False, np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True,),\n                    ): pd.BooleanDtype(),\n                    ((True, False), (True, False), (True, False), (False,)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [\"h\", \"i\", np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (  # GH32117\n                [\"h\", \"i\", 1],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [10, np.nan, 20],\n                np.dtype(\"float\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                },\n            ),\n            (\n                [np.nan, 100.5, 200],\n                np.dtype(\"float\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"float\"),\n                },\n            ),\n            (\n                [3, 4, 5],\n                \"Int8\",\n                {((True, False), (True, False), (True, False), (True, False)): \"Int8\"},\n            ),\n            (\n                [[1, 2], [3, 4], [5]],\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [4, 5, 6],\n                np.dtype(\"uint32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"UInt32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"uint32\"\n                    ),\n                },\n            ),\n            (\n                [-10, 12, 13],\n                np.dtype(\"i1\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int8\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"i1\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.0],\n                object,\n                {\n                    ((True,), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True,), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.5],\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [\"a\", \"b\"],\n                pd.CategoricalDtype(),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.CategoricalDtype(),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                pd.DatetimeTZDtype(tz=\"UTC\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.DatetimeTZDtype(tz=\"UTC\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                \"datetime64[ns]\",\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"datetime64[ns]\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"datetime64[ns]\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                pd.period_range(\"1/1/2011\", freq=\"M\", periods=3),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.PeriodDtype(\"M\"),\n                },\n            ),\n            (\n                pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)]),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.IntervalDtype(\"int64\"),\n                },\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\"params\", product(*[(True, False)] * 4))\n    def test_convert_dtypes(self, data, maindtype, params, answerdict):\n        if maindtype is not None:\n            series = pd.Series(data, dtype=maindtype)\n        else:\n            series = pd.Series(data)\n        answers = {k: a for (kk, a) in answerdict.items() for k in product(*kk)}\n\n        ns = series.convert_dtypes(*params)\n        expected_dtype = answers[tuple(params)]\n        expected = pd.Series(series.values, dtype=expected_dtype)\n        tm.assert_series_equal(ns, expected)\n\n        # Test that it is a copy\n        copy = series.copy(deep=True)\n        if is_interval_dtype(ns.dtype) and ns.dtype.subtype.kind in [\"i\", \"u\"]:\n            msg = \"Cannot set float NaN to integer-backed IntervalArray\"\n            with pytest.raises(ValueError, match=msg):\n                ns[ns.notna()] = np.nan\n        else:\n            ns[ns.notna()] = np.nan\n\n        # Make sure original not changed\n        tm.assert_series_equal(series, copy)",
        "    @pytest.mark.parametrize(\n        \"data, maindtype, answerdict\",\n        [\n            (\n                [1, 2, 3],\n                np.dtype(\"int32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int32\"\n                    ),\n                },\n            ),\n            (\n                [1, 2, 3],\n                np.dtype(\"int64\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int64\"\n                    ),\n                },\n            ),\n            (\n                [\"x\", \"y\", \"z\"],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [True, False, np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True,),\n                    ): pd.BooleanDtype(),\n                    ((True, False), (True, False), (True, False), (False,)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [\"h\", \"i\", np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (  # GH32117\n                [\"h\", \"i\", 1],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [10, np.nan, 20],\n                np.dtype(\"float\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                },\n            ),\n            (\n                [np.nan, 100.5, 200],\n                np.dtype(\"float\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"float\"),\n                },\n            ),\n            (\n                [3, 4, 5],\n                \"Int8\",\n                {((True, False), (True, False), (True, False), (True, False)): \"Int8\"},\n            ),\n            (\n                [[1, 2], [3, 4], [5]],\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [4, 5, 6],\n                np.dtype(\"uint32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"UInt32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"uint32\"\n                    ),\n                },\n            ),\n            (\n                [-10, 12, 13],\n                np.dtype(\"i1\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int8\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"i1\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.0],\n                object,\n                {\n                    ((True,), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True,), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.5],\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [\"a\", \"b\"],\n                pd.CategoricalDtype(),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.CategoricalDtype(),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                pd.DatetimeTZDtype(tz=\"UTC\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.DatetimeTZDtype(tz=\"UTC\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                \"datetime64[ns]\",\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"datetime64[ns]\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"datetime64[ns]\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                pd.period_range(\"1/1/2011\", freq=\"M\", periods=3),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.PeriodDtype(\"M\"),\n                },\n            ),\n            (\n                pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)]),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.IntervalDtype(\"int64\"),\n                },\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\"params\", product(*[(True, False)] * 4))\n    def test_convert_dtypes(self, data, maindtype, params, answerdict):\n        if maindtype is not None:\n            series = pd.Series(data, dtype=maindtype)\n        else:\n            series = pd.Series(data)\n        answers = {k: a for (kk, a) in answerdict.items() for k in product(*kk)}\n\n        ns = series.convert_dtypes(*params)\n        expected_dtype = answers[tuple(params)]\n        expected = pd.Series(series.values, dtype=expected_dtype)\n        tm.assert_series_equal(ns, expected)\n\n        # Test that it is a copy\n        copy = series.copy(deep=True)\n        if is_interval_dtype(ns.dtype) and ns.dtype.subtype.kind in [\"i\", \"u\"]:\n            msg = \"Cannot set float NaN to integer-backed IntervalArray\"\n            with pytest.raises(ValueError, match=msg):\n                ns[ns.notna()] = np.nan\n        else:\n            ns[ns.notna()] = np.nan\n\n        # Make sure original not changed\n        tm.assert_series_equal(series, copy)",
        "    @pytest.mark.parametrize(\n        \"data, maindtype, answerdict\",\n        [\n            (\n                [1, 2, 3],\n                np.dtype(\"int32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int32\"\n                    ),\n                },\n            ),\n            (\n                [1, 2, 3],\n                np.dtype(\"int64\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int64\"\n                    ),\n                },\n            ),\n            (\n                [\"x\", \"y\", \"z\"],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [True, False, np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True,),\n                    ): pd.BooleanDtype(),\n                    ((True, False), (True, False), (True, False), (False,)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [\"h\", \"i\", np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (  # GH32117\n                [\"h\", \"i\", 1],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [10, np.nan, 20],\n                np.dtype(\"float\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                },\n            ),\n            (\n                [np.nan, 100.5, 200],\n                np.dtype(\"float\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"float\"),\n                },\n            ),\n            (\n                [3, 4, 5],\n                \"Int8\",\n                {((True, False), (True, False), (True, False), (True, False)): \"Int8\"},\n            ),\n            (\n                [[1, 2], [3, 4], [5]],\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [4, 5, 6],\n                np.dtype(\"uint32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"UInt32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"uint32\"\n                    ),\n                },\n            ),\n            (\n                [-10, 12, 13],\n                np.dtype(\"i1\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int8\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"i1\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.0],\n                object,\n                {\n                    ((True,), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True,), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.5],\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [\"a\", \"b\"],\n                pd.CategoricalDtype(),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.CategoricalDtype(),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                pd.DatetimeTZDtype(tz=\"UTC\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.DatetimeTZDtype(tz=\"UTC\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                \"datetime64[ns]\",\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"datetime64[ns]\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"datetime64[ns]\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                pd.period_range(\"1/1/2011\", freq=\"M\", periods=3),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.PeriodDtype(\"M\"),\n                },\n            ),\n            (\n                pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)]),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.IntervalDtype(\"int64\"),\n                },\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\"params\", product(*[(True, False)] * 4))\n    def test_convert_dtypes(self, data, maindtype, params, answerdict):\n        if maindtype is not None:\n            series = pd.Series(data, dtype=maindtype)\n        else:\n            series = pd.Series(data)\n        answers = {k: a for (kk, a) in answerdict.items() for k in product(*kk)}\n\n        ns = series.convert_dtypes(*params)\n        expected_dtype = answers[tuple(params)]\n        expected = pd.Series(series.values, dtype=expected_dtype)\n        tm.assert_series_equal(ns, expected)\n\n        # Test that it is a copy\n        copy = series.copy(deep=True)\n        if is_interval_dtype(ns.dtype) and ns.dtype.subtype.kind in [\"i\", \"u\"]:\n            msg = \"Cannot set float NaN to integer-backed IntervalArray\"\n            with pytest.raises(ValueError, match=msg):\n                ns[ns.notna()] = np.nan\n        else:\n            ns[ns.notna()] = np.nan\n\n        # Make sure original not changed\n        tm.assert_series_equal(series, copy)",
        "    @pytest.mark.parametrize(\n        \"data, maindtype, answerdict\",\n        [\n            (\n                [1, 2, 3],\n                np.dtype(\"int32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int32\"\n                    ),\n                },\n            ),\n            (\n                [1, 2, 3],\n                np.dtype(\"int64\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int64\"\n                    ),\n                },\n            ),\n            (\n                [\"x\", \"y\", \"z\"],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [True, False, np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True,),\n                    ): pd.BooleanDtype(),\n                    ((True, False), (True, False), (True, False), (False,)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [\"h\", \"i\", np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (  # GH32117\n                [\"h\", \"i\", 1],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [10, np.nan, 20],\n                np.dtype(\"float\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                },\n            ),\n            (\n                [np.nan, 100.5, 200],\n                np.dtype(\"float\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"float\"),\n                },\n            ),\n            (\n                [3, 4, 5],\n                \"Int8\",\n                {((True, False), (True, False), (True, False), (True, False)): \"Int8\"},\n            ),\n            (\n                [[1, 2], [3, 4], [5]],\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [4, 5, 6],\n                np.dtype(\"uint32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"UInt32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"uint32\"\n                    ),\n                },\n            ),\n            (\n                [-10, 12, 13],\n                np.dtype(\"i1\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int8\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"i1\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.0],\n                object,\n                {\n                    ((True,), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True,), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.5],\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [\"a\", \"b\"],\n                pd.CategoricalDtype(),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.CategoricalDtype(),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                pd.DatetimeTZDtype(tz=\"UTC\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.DatetimeTZDtype(tz=\"UTC\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                \"datetime64[ns]\",\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"datetime64[ns]\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"datetime64[ns]\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                pd.period_range(\"1/1/2011\", freq=\"M\", periods=3),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.PeriodDtype(\"M\"),\n                },\n            ),\n            (\n                pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)]),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.IntervalDtype(\"int64\"),\n                },\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\"params\", product(*[(True, False)] * 4))\n    def test_convert_dtypes(self, data, maindtype, params, answerdict):\n        if maindtype is not None:\n            series = pd.Series(data, dtype=maindtype)\n        else:\n            series = pd.Series(data)\n        answers = {k: a for (kk, a) in answerdict.items() for k in product(*kk)}\n\n        ns = series.convert_dtypes(*params)\n        expected_dtype = answers[tuple(params)]\n        expected = pd.Series(series.values, dtype=expected_dtype)\n        tm.assert_series_equal(ns, expected)\n\n        # Test that it is a copy\n        copy = series.copy(deep=True)\n        if is_interval_dtype(ns.dtype) and ns.dtype.subtype.kind in [\"i\", \"u\"]:\n            msg = \"Cannot set float NaN to integer-backed IntervalArray\"\n            with pytest.raises(ValueError, match=msg):\n                ns[ns.notna()] = np.nan\n        else:\n            ns[ns.notna()] = np.nan\n\n        # Make sure original not changed\n        tm.assert_series_equal(series, copy)",
        "    @pytest.mark.parametrize(\n        \"data, maindtype, answerdict\",\n        [\n            (\n                [1, 2, 3],\n                np.dtype(\"int32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int32\"\n                    ),\n                },\n            ),\n            (\n                [1, 2, 3],\n                np.dtype(\"int64\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int64\"\n                    ),\n                },\n            ),\n            (\n                [\"x\", \"y\", \"z\"],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [True, False, np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True,),\n                    ): pd.BooleanDtype(),\n                    ((True, False), (True, False), (True, False), (False,)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [\"h\", \"i\", np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (  # GH32117\n                [\"h\", \"i\", 1],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [10, np.nan, 20],\n                np.dtype(\"float\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                },\n            ),\n            (\n                [np.nan, 100.5, 200],\n                np.dtype(\"float\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"float\"),\n                },\n            ),\n            (\n                [3, 4, 5],\n                \"Int8\",\n                {((True, False), (True, False), (True, False), (True, False)): \"Int8\"},\n            ),\n            (\n                [[1, 2], [3, 4], [5]],\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [4, 5, 6],\n                np.dtype(\"uint32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"UInt32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"uint32\"\n                    ),\n                },\n            ),\n            (\n                [-10, 12, 13],\n                np.dtype(\"i1\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int8\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"i1\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.0],\n                object,\n                {\n                    ((True,), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True,), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.5],\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [\"a\", \"b\"],\n                pd.CategoricalDtype(),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.CategoricalDtype(),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                pd.DatetimeTZDtype(tz=\"UTC\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.DatetimeTZDtype(tz=\"UTC\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                \"datetime64[ns]\",\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"datetime64[ns]\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"datetime64[ns]\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                pd.period_range(\"1/1/2011\", freq=\"M\", periods=3),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.PeriodDtype(\"M\"),\n                },\n            ),\n            (\n                pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)]),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.IntervalDtype(\"int64\"),\n                },\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\"params\", product(*[(True, False)] * 4))\n    def test_convert_dtypes(self, data, maindtype, params, answerdict):\n        if maindtype is not None:\n            series = pd.Series(data, dtype=maindtype)\n        else:\n            series = pd.Series(data)\n        answers = {k: a for (kk, a) in answerdict.items() for k in product(*kk)}\n\n        ns = series.convert_dtypes(*params)\n        expected_dtype = answers[tuple(params)]\n        expected = pd.Series(series.values, dtype=expected_dtype)\n        tm.assert_series_equal(ns, expected)\n\n        # Test that it is a copy\n        copy = series.copy(deep=True)\n        if is_interval_dtype(ns.dtype) and ns.dtype.subtype.kind in [\"i\", \"u\"]:\n            msg = \"Cannot set float NaN to integer-backed IntervalArray\"\n            with pytest.raises(ValueError, match=msg):\n                ns[ns.notna()] = np.nan\n        else:\n            ns[ns.notna()] = np.nan\n\n        # Make sure original not changed\n        tm.assert_series_equal(series, copy)",
        "    @pytest.mark.parametrize(\n        \"data, maindtype, answerdict\",\n        [\n            (\n                [1, 2, 3],\n                np.dtype(\"int32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int32\"\n                    ),\n                },\n            ),\n            (\n                [1, 2, 3],\n                np.dtype(\"int64\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int64\"\n                    ),\n                },\n            ),\n            (\n                [\"x\", \"y\", \"z\"],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [True, False, np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True,),\n                    ): pd.BooleanDtype(),\n                    ((True, False), (True, False), (True, False), (False,)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [\"h\", \"i\", np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (  # GH32117\n                [\"h\", \"i\", 1],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [10, np.nan, 20],\n                np.dtype(\"float\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                },\n            ),\n            (\n                [np.nan, 100.5, 200],\n                np.dtype(\"float\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"float\"),\n                },\n            ),\n            (\n                [3, 4, 5],\n                \"Int8\",\n                {((True, False), (True, False), (True, False), (True, False)): \"Int8\"},\n            ),\n            (\n                [[1, 2], [3, 4], [5]],\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [4, 5, 6],\n                np.dtype(\"uint32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"UInt32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"uint32\"\n                    ),\n                },\n            ),\n            (\n                [-10, 12, 13],\n                np.dtype(\"i1\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int8\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"i1\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.0],\n                object,\n                {\n                    ((True,), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True,), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.5],\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [\"a\", \"b\"],\n                pd.CategoricalDtype(),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.CategoricalDtype(),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                pd.DatetimeTZDtype(tz=\"UTC\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.DatetimeTZDtype(tz=\"UTC\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                \"datetime64[ns]\",\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"datetime64[ns]\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"datetime64[ns]\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                pd.period_range(\"1/1/2011\", freq=\"M\", periods=3),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.PeriodDtype(\"M\"),\n                },\n            ),\n            (\n                pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)]),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.IntervalDtype(\"int64\"),\n                },\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\"params\", product(*[(True, False)] * 4))\n    def test_convert_dtypes(self, data, maindtype, params, answerdict):\n        if maindtype is not None:\n            series = pd.Series(data, dtype=maindtype)\n        else:\n            series = pd.Series(data)\n        answers = {k: a for (kk, a) in answerdict.items() for k in product(*kk)}\n\n        ns = series.convert_dtypes(*params)\n        expected_dtype = answers[tuple(params)]\n        expected = pd.Series(series.values, dtype=expected_dtype)\n        tm.assert_series_equal(ns, expected)\n\n        # Test that it is a copy\n        copy = series.copy(deep=True)\n        if is_interval_dtype(ns.dtype) and ns.dtype.subtype.kind in [\"i\", \"u\"]:\n            msg = \"Cannot set float NaN to integer-backed IntervalArray\"\n            with pytest.raises(ValueError, match=msg):\n                ns[ns.notna()] = np.nan\n        else:\n            ns[ns.notna()] = np.nan\n\n        # Make sure original not changed\n        tm.assert_series_equal(series, copy)",
        "    @pytest.mark.parametrize(\n        \"data, maindtype, answerdict\",\n        [\n            (\n                [1, 2, 3],\n                np.dtype(\"int32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int32\"\n                    ),\n                },\n            ),\n            (\n                [1, 2, 3],\n                np.dtype(\"int64\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int64\"\n                    ),\n                },\n            ),\n            (\n                [\"x\", \"y\", \"z\"],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [True, False, np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True,),\n                    ): pd.BooleanDtype(),\n                    ((True, False), (True, False), (True, False), (False,)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [\"h\", \"i\", np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (  # GH32117\n                [\"h\", \"i\", 1],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [10, np.nan, 20],\n                np.dtype(\"float\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                },\n            ),\n            (\n                [np.nan, 100.5, 200],\n                np.dtype(\"float\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"float\"),\n                },\n            ),\n            (\n                [3, 4, 5],\n                \"Int8\",\n                {((True, False), (True, False), (True, False), (True, False)): \"Int8\"},\n            ),\n            (\n                [[1, 2], [3, 4], [5]],\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [4, 5, 6],\n                np.dtype(\"uint32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"UInt32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"uint32\"\n                    ),\n                },\n            ),\n            (\n                [-10, 12, 13],\n                np.dtype(\"i1\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int8\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"i1\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.0],\n                object,\n                {\n                    ((True,), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True,), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.5],\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [\"a\", \"b\"],\n                pd.CategoricalDtype(),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.CategoricalDtype(),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                pd.DatetimeTZDtype(tz=\"UTC\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.DatetimeTZDtype(tz=\"UTC\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                \"datetime64[ns]\",\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"datetime64[ns]\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"datetime64[ns]\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                pd.period_range(\"1/1/2011\", freq=\"M\", periods=3),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.PeriodDtype(\"M\"),\n                },\n            ),\n            (\n                pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)]),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.IntervalDtype(\"int64\"),\n                },\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\"params\", product(*[(True, False)] * 4))\n    def test_convert_dtypes(self, data, maindtype, params, answerdict):\n        if maindtype is not None:\n            series = pd.Series(data, dtype=maindtype)\n        else:\n            series = pd.Series(data)\n        answers = {k: a for (kk, a) in answerdict.items() for k in product(*kk)}\n\n        ns = series.convert_dtypes(*params)\n        expected_dtype = answers[tuple(params)]\n        expected = pd.Series(series.values, dtype=expected_dtype)\n        tm.assert_series_equal(ns, expected)\n\n        # Test that it is a copy\n        copy = series.copy(deep=True)\n        if is_interval_dtype(ns.dtype) and ns.dtype.subtype.kind in [\"i\", \"u\"]:\n            msg = \"Cannot set float NaN to integer-backed IntervalArray\"\n            with pytest.raises(ValueError, match=msg):\n                ns[ns.notna()] = np.nan\n        else:\n            ns[ns.notna()] = np.nan\n\n        # Make sure original not changed\n        tm.assert_series_equal(series, copy)",
        "    @pytest.mark.parametrize(\n        \"data, maindtype, answerdict\",\n        [\n            (\n                [1, 2, 3],\n                np.dtype(\"int32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int32\"\n                    ),\n                },\n            ),\n            (\n                [1, 2, 3],\n                np.dtype(\"int64\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int64\"\n                    ),\n                },\n            ),\n            (\n                [\"x\", \"y\", \"z\"],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [True, False, np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True,),\n                    ): pd.BooleanDtype(),\n                    ((True, False), (True, False), (True, False), (False,)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [\"h\", \"i\", np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (  # GH32117\n                [\"h\", \"i\", 1],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [10, np.nan, 20],\n                np.dtype(\"float\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                },\n            ),\n            (\n                [np.nan, 100.5, 200],\n                np.dtype(\"float\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"float\"),\n                },\n            ),\n            (\n                [3, 4, 5],\n                \"Int8\",\n                {((True, False), (True, False), (True, False), (True, False)): \"Int8\"},\n            ),\n            (\n                [[1, 2], [3, 4], [5]],\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [4, 5, 6],\n                np.dtype(\"uint32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"UInt32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"uint32\"\n                    ),\n                },\n            ),\n            (\n                [-10, 12, 13],\n                np.dtype(\"i1\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int8\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"i1\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.0],\n                object,\n                {\n                    ((True,), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True,), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.5],\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [\"a\", \"b\"],\n                pd.CategoricalDtype(),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.CategoricalDtype(),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                pd.DatetimeTZDtype(tz=\"UTC\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.DatetimeTZDtype(tz=\"UTC\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                \"datetime64[ns]\",\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"datetime64[ns]\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"datetime64[ns]\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                pd.period_range(\"1/1/2011\", freq=\"M\", periods=3),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.PeriodDtype(\"M\"),\n                },\n            ),\n            (\n                pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)]),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.IntervalDtype(\"int64\"),\n                },\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\"params\", product(*[(True, False)] * 4))\n    def test_convert_dtypes(self, data, maindtype, params, answerdict):\n        if maindtype is not None:\n            series = pd.Series(data, dtype=maindtype)\n        else:\n            series = pd.Series(data)\n        answers = {k: a for (kk, a) in answerdict.items() for k in product(*kk)}\n\n        ns = series.convert_dtypes(*params)\n        expected_dtype = answers[tuple(params)]\n        expected = pd.Series(series.values, dtype=expected_dtype)\n        tm.assert_series_equal(ns, expected)\n\n        # Test that it is a copy\n        copy = series.copy(deep=True)\n        if is_interval_dtype(ns.dtype) and ns.dtype.subtype.kind in [\"i\", \"u\"]:\n            msg = \"Cannot set float NaN to integer-backed IntervalArray\"\n            with pytest.raises(ValueError, match=msg):\n                ns[ns.notna()] = np.nan\n        else:\n            ns[ns.notna()] = np.nan\n\n        # Make sure original not changed\n        tm.assert_series_equal(series, copy)",
        "    @pytest.mark.parametrize(\n        \"data, maindtype, answerdict\",\n        [\n            (\n                [1, 2, 3],\n                np.dtype(\"int32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int32\"\n                    ),\n                },\n            ),\n            (\n                [1, 2, 3],\n                np.dtype(\"int64\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int64\"\n                    ),\n                },\n            ),\n            (\n                [\"x\", \"y\", \"z\"],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [True, False, np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True,),\n                    ): pd.BooleanDtype(),\n                    ((True, False), (True, False), (True, False), (False,)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [\"h\", \"i\", np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (  # GH32117\n                [\"h\", \"i\", 1],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [10, np.nan, 20],\n                np.dtype(\"float\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                },\n            ),\n            (\n                [np.nan, 100.5, 200],\n                np.dtype(\"float\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"float\"),\n                },\n            ),\n            (\n                [3, 4, 5],\n                \"Int8\",\n                {((True, False), (True, False), (True, False), (True, False)): \"Int8\"},\n            ),\n            (\n                [[1, 2], [3, 4], [5]],\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [4, 5, 6],\n                np.dtype(\"uint32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"UInt32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"uint32\"\n                    ),\n                },\n            ),\n            (\n                [-10, 12, 13],\n                np.dtype(\"i1\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int8\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"i1\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.0],\n                object,\n                {\n                    ((True,), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True,), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.5],\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [\"a\", \"b\"],\n                pd.CategoricalDtype(),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.CategoricalDtype(),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                pd.DatetimeTZDtype(tz=\"UTC\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.DatetimeTZDtype(tz=\"UTC\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                \"datetime64[ns]\",\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"datetime64[ns]\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"datetime64[ns]\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                pd.period_range(\"1/1/2011\", freq=\"M\", periods=3),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.PeriodDtype(\"M\"),\n                },\n            ),\n            (\n                pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)]),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.IntervalDtype(\"int64\"),\n                },\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\"params\", product(*[(True, False)] * 4))\n    def test_convert_dtypes(self, data, maindtype, params, answerdict):\n        if maindtype is not None:\n            series = pd.Series(data, dtype=maindtype)\n        else:\n            series = pd.Series(data)\n        answers = {k: a for (kk, a) in answerdict.items() for k in product(*kk)}\n\n        ns = series.convert_dtypes(*params)\n        expected_dtype = answers[tuple(params)]\n        expected = pd.Series(series.values, dtype=expected_dtype)\n        tm.assert_series_equal(ns, expected)\n\n        # Test that it is a copy\n        copy = series.copy(deep=True)\n        if is_interval_dtype(ns.dtype) and ns.dtype.subtype.kind in [\"i\", \"u\"]:\n            msg = \"Cannot set float NaN to integer-backed IntervalArray\"\n            with pytest.raises(ValueError, match=msg):\n                ns[ns.notna()] = np.nan\n        else:\n            ns[ns.notna()] = np.nan\n\n        # Make sure original not changed\n        tm.assert_series_equal(series, copy)",
        "    @pytest.mark.parametrize(\n        \"data, maindtype, answerdict\",\n        [\n            (\n                [1, 2, 3],\n                np.dtype(\"int32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int32\"\n                    ),\n                },\n            ),\n            (\n                [1, 2, 3],\n                np.dtype(\"int64\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int64\"\n                    ),\n                },\n            ),\n            (\n                [\"x\", \"y\", \"z\"],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [True, False, np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True,),\n                    ): pd.BooleanDtype(),\n                    ((True, False), (True, False), (True, False), (False,)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [\"h\", \"i\", np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (  # GH32117\n                [\"h\", \"i\", 1],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [10, np.nan, 20],\n                np.dtype(\"float\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                },\n            ),\n            (\n                [np.nan, 100.5, 200],\n                np.dtype(\"float\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"float\"),\n                },\n            ),\n            (\n                [3, 4, 5],\n                \"Int8\",\n                {((True, False), (True, False), (True, False), (True, False)): \"Int8\"},\n            ),\n            (\n                [[1, 2], [3, 4], [5]],\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [4, 5, 6],\n                np.dtype(\"uint32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"UInt32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"uint32\"\n                    ),\n                },\n            ),\n            (\n                [-10, 12, 13],\n                np.dtype(\"i1\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int8\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"i1\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.0],\n                object,\n                {\n                    ((True,), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True,), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.5],\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [\"a\", \"b\"],\n                pd.CategoricalDtype(),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.CategoricalDtype(),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                pd.DatetimeTZDtype(tz=\"UTC\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.DatetimeTZDtype(tz=\"UTC\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                \"datetime64[ns]\",\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"datetime64[ns]\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"datetime64[ns]\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                pd.period_range(\"1/1/2011\", freq=\"M\", periods=3),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.PeriodDtype(\"M\"),\n                },\n            ),\n            (\n                pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)]),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.IntervalDtype(\"int64\"),\n                },\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\"params\", product(*[(True, False)] * 4))\n    def test_convert_dtypes(self, data, maindtype, params, answerdict):\n        if maindtype is not None:\n            series = pd.Series(data, dtype=maindtype)\n        else:\n            series = pd.Series(data)\n        answers = {k: a for (kk, a) in answerdict.items() for k in product(*kk)}\n\n        ns = series.convert_dtypes(*params)\n        expected_dtype = answers[tuple(params)]\n        expected = pd.Series(series.values, dtype=expected_dtype)\n        tm.assert_series_equal(ns, expected)\n\n        # Test that it is a copy\n        copy = series.copy(deep=True)\n        if is_interval_dtype(ns.dtype) and ns.dtype.subtype.kind in [\"i\", \"u\"]:\n            msg = \"Cannot set float NaN to integer-backed IntervalArray\"\n            with pytest.raises(ValueError, match=msg):\n                ns[ns.notna()] = np.nan\n        else:\n            ns[ns.notna()] = np.nan\n\n        # Make sure original not changed\n        tm.assert_series_equal(series, copy)",
        "    @pytest.mark.parametrize(\n        \"data, maindtype, answerdict\",\n        [\n            (\n                [1, 2, 3],\n                np.dtype(\"int32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int32\"\n                    ),\n                },\n            ),\n            (\n                [1, 2, 3],\n                np.dtype(\"int64\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int64\"\n                    ),\n                },\n            ),\n            (\n                [\"x\", \"y\", \"z\"],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [True, False, np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True,),\n                    ): pd.BooleanDtype(),\n                    ((True, False), (True, False), (True, False), (False,)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [\"h\", \"i\", np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (  # GH32117\n                [\"h\", \"i\", 1],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [10, np.nan, 20],\n                np.dtype(\"float\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                },\n            ),\n            (\n                [np.nan, 100.5, 200],\n                np.dtype(\"float\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"float\"),\n                },\n            ),\n            (\n                [3, 4, 5],\n                \"Int8\",\n                {((True, False), (True, False), (True, False), (True, False)): \"Int8\"},\n            ),\n            (\n                [[1, 2], [3, 4], [5]],\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [4, 5, 6],\n                np.dtype(\"uint32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"UInt32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"uint32\"\n                    ),\n                },\n            ),\n            (\n                [-10, 12, 13],\n                np.dtype(\"i1\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int8\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"i1\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.0],\n                object,\n                {\n                    ((True,), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True,), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.5],\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [\"a\", \"b\"],\n                pd.CategoricalDtype(),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.CategoricalDtype(),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                pd.DatetimeTZDtype(tz=\"UTC\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.DatetimeTZDtype(tz=\"UTC\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                \"datetime64[ns]\",\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"datetime64[ns]\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"datetime64[ns]\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                pd.period_range(\"1/1/2011\", freq=\"M\", periods=3),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.PeriodDtype(\"M\"),\n                },\n            ),\n            (\n                pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)]),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.IntervalDtype(\"int64\"),\n                },\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\"params\", product(*[(True, False)] * 4))\n    def test_convert_dtypes(self, data, maindtype, params, answerdict):\n        if maindtype is not None:\n            series = pd.Series(data, dtype=maindtype)\n        else:\n            series = pd.Series(data)\n        answers = {k: a for (kk, a) in answerdict.items() for k in product(*kk)}\n\n        ns = series.convert_dtypes(*params)\n        expected_dtype = answers[tuple(params)]\n        expected = pd.Series(series.values, dtype=expected_dtype)\n        tm.assert_series_equal(ns, expected)\n\n        # Test that it is a copy\n        copy = series.copy(deep=True)\n        if is_interval_dtype(ns.dtype) and ns.dtype.subtype.kind in [\"i\", \"u\"]:\n            msg = \"Cannot set float NaN to integer-backed IntervalArray\"\n            with pytest.raises(ValueError, match=msg):\n                ns[ns.notna()] = np.nan\n        else:\n            ns[ns.notna()] = np.nan\n\n        # Make sure original not changed\n        tm.assert_series_equal(series, copy)",
        "    @pytest.mark.parametrize(\n        \"data, maindtype, answerdict\",\n        [\n            (\n                [1, 2, 3],\n                np.dtype(\"int32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int32\"\n                    ),\n                },\n            ),\n            (\n                [1, 2, 3],\n                np.dtype(\"int64\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int64\"\n                    ),\n                },\n            ),\n            (\n                [\"x\", \"y\", \"z\"],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [True, False, np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True,),\n                    ): pd.BooleanDtype(),\n                    ((True, False), (True, False), (True, False), (False,)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [\"h\", \"i\", np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (  # GH32117\n                [\"h\", \"i\", 1],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [10, np.nan, 20],\n                np.dtype(\"float\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                },\n            ),\n            (\n                [np.nan, 100.5, 200],\n                np.dtype(\"float\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"float\"),\n                },\n            ),\n            (\n                [3, 4, 5],\n                \"Int8\",\n                {((True, False), (True, False), (True, False), (True, False)): \"Int8\"},\n            ),\n            (\n                [[1, 2], [3, 4], [5]],\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [4, 5, 6],\n                np.dtype(\"uint32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"UInt32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"uint32\"\n                    ),\n                },\n            ),\n            (\n                [-10, 12, 13],\n                np.dtype(\"i1\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int8\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"i1\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.0],\n                object,\n                {\n                    ((True,), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True,), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.5],\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [\"a\", \"b\"],\n                pd.CategoricalDtype(),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.CategoricalDtype(),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                pd.DatetimeTZDtype(tz=\"UTC\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.DatetimeTZDtype(tz=\"UTC\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                \"datetime64[ns]\",\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"datetime64[ns]\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"datetime64[ns]\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                pd.period_range(\"1/1/2011\", freq=\"M\", periods=3),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.PeriodDtype(\"M\"),\n                },\n            ),\n            (\n                pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)]),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.IntervalDtype(\"int64\"),\n                },\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\"params\", product(*[(True, False)] * 4))\n    def test_convert_dtypes(self, data, maindtype, params, answerdict):\n        if maindtype is not None:\n            series = pd.Series(data, dtype=maindtype)\n        else:\n            series = pd.Series(data)\n        answers = {k: a for (kk, a) in answerdict.items() for k in product(*kk)}\n\n        ns = series.convert_dtypes(*params)\n        expected_dtype = answers[tuple(params)]\n        expected = pd.Series(series.values, dtype=expected_dtype)\n        tm.assert_series_equal(ns, expected)\n\n        # Test that it is a copy\n        copy = series.copy(deep=True)\n        if is_interval_dtype(ns.dtype) and ns.dtype.subtype.kind in [\"i\", \"u\"]:\n            msg = \"Cannot set float NaN to integer-backed IntervalArray\"\n            with pytest.raises(ValueError, match=msg):\n                ns[ns.notna()] = np.nan\n        else:\n            ns[ns.notna()] = np.nan\n\n        # Make sure original not changed\n        tm.assert_series_equal(series, copy)",
        "    @pytest.mark.parametrize(\n        \"data, maindtype, answerdict\",\n        [\n            (\n                [1, 2, 3],\n                np.dtype(\"int32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int32\"\n                    ),\n                },\n            ),\n            (\n                [1, 2, 3],\n                np.dtype(\"int64\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int64\"\n                    ),\n                },\n            ),\n            (\n                [\"x\", \"y\", \"z\"],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [True, False, np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True,),\n                    ): pd.BooleanDtype(),\n                    ((True, False), (True, False), (True, False), (False,)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [\"h\", \"i\", np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (  # GH32117\n                [\"h\", \"i\", 1],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [10, np.nan, 20],\n                np.dtype(\"float\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                },\n            ),\n            (\n                [np.nan, 100.5, 200],\n                np.dtype(\"float\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"float\"),\n                },\n            ),\n            (\n                [3, 4, 5],\n                \"Int8\",\n                {((True, False), (True, False), (True, False), (True, False)): \"Int8\"},\n            ),\n            (\n                [[1, 2], [3, 4], [5]],\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [4, 5, 6],\n                np.dtype(\"uint32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"UInt32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"uint32\"\n                    ),\n                },\n            ),\n            (\n                [-10, 12, 13],\n                np.dtype(\"i1\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int8\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"i1\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.0],\n                object,\n                {\n                    ((True,), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True,), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.5],\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [\"a\", \"b\"],\n                pd.CategoricalDtype(),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.CategoricalDtype(),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                pd.DatetimeTZDtype(tz=\"UTC\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.DatetimeTZDtype(tz=\"UTC\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                \"datetime64[ns]\",\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"datetime64[ns]\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"datetime64[ns]\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                pd.period_range(\"1/1/2011\", freq=\"M\", periods=3),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.PeriodDtype(\"M\"),\n                },\n            ),\n            (\n                pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)]),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.IntervalDtype(\"int64\"),\n                },\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\"params\", product(*[(True, False)] * 4))\n    def test_convert_dtypes(self, data, maindtype, params, answerdict):\n        if maindtype is not None:\n            series = pd.Series(data, dtype=maindtype)\n        else:\n            series = pd.Series(data)\n        answers = {k: a for (kk, a) in answerdict.items() for k in product(*kk)}\n\n        ns = series.convert_dtypes(*params)\n        expected_dtype = answers[tuple(params)]\n        expected = pd.Series(series.values, dtype=expected_dtype)\n        tm.assert_series_equal(ns, expected)\n\n        # Test that it is a copy\n        copy = series.copy(deep=True)\n        if is_interval_dtype(ns.dtype) and ns.dtype.subtype.kind in [\"i\", \"u\"]:\n            msg = \"Cannot set float NaN to integer-backed IntervalArray\"\n            with pytest.raises(ValueError, match=msg):\n                ns[ns.notna()] = np.nan\n        else:\n            ns[ns.notna()] = np.nan\n\n        # Make sure original not changed\n        tm.assert_series_equal(series, copy)",
        "    @pytest.mark.parametrize(\n        \"data, maindtype, answerdict\",\n        [\n            (\n                [1, 2, 3],\n                np.dtype(\"int32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int32\"\n                    ),\n                },\n            ),\n            (\n                [1, 2, 3],\n                np.dtype(\"int64\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int64\"\n                    ),\n                },\n            ),\n            (\n                [\"x\", \"y\", \"z\"],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [True, False, np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True,),\n                    ): pd.BooleanDtype(),\n                    ((True, False), (True, False), (True, False), (False,)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [\"h\", \"i\", np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (  # GH32117\n                [\"h\", \"i\", 1],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [10, np.nan, 20],\n                np.dtype(\"float\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                },\n            ),\n            (\n                [np.nan, 100.5, 200],\n                np.dtype(\"float\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"float\"),\n                },\n            ),\n            (\n                [3, 4, 5],\n                \"Int8\",\n                {((True, False), (True, False), (True, False), (True, False)): \"Int8\"},\n            ),\n            (\n                [[1, 2], [3, 4], [5]],\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [4, 5, 6],\n                np.dtype(\"uint32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"UInt32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"uint32\"\n                    ),\n                },\n            ),\n            (\n                [-10, 12, 13],\n                np.dtype(\"i1\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int8\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"i1\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.0],\n                object,\n                {\n                    ((True,), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True,), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.5],\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [\"a\", \"b\"],\n                pd.CategoricalDtype(),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.CategoricalDtype(),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                pd.DatetimeTZDtype(tz=\"UTC\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.DatetimeTZDtype(tz=\"UTC\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                \"datetime64[ns]\",\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"datetime64[ns]\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"datetime64[ns]\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                pd.period_range(\"1/1/2011\", freq=\"M\", periods=3),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.PeriodDtype(\"M\"),\n                },\n            ),\n            (\n                pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)]),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.IntervalDtype(\"int64\"),\n                },\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\"params\", product(*[(True, False)] * 4))\n    def test_convert_dtypes(self, data, maindtype, params, answerdict):\n        if maindtype is not None:\n            series = pd.Series(data, dtype=maindtype)\n        else:\n            series = pd.Series(data)\n        answers = {k: a for (kk, a) in answerdict.items() for k in product(*kk)}\n\n        ns = series.convert_dtypes(*params)\n        expected_dtype = answers[tuple(params)]\n        expected = pd.Series(series.values, dtype=expected_dtype)\n        tm.assert_series_equal(ns, expected)\n\n        # Test that it is a copy\n        copy = series.copy(deep=True)\n        if is_interval_dtype(ns.dtype) and ns.dtype.subtype.kind in [\"i\", \"u\"]:\n            msg = \"Cannot set float NaN to integer-backed IntervalArray\"\n            with pytest.raises(ValueError, match=msg):\n                ns[ns.notna()] = np.nan\n        else:\n            ns[ns.notna()] = np.nan\n\n        # Make sure original not changed\n        tm.assert_series_equal(series, copy)",
        "    @pytest.mark.parametrize(\n        \"data, maindtype, answerdict\",\n        [\n            (\n                [1, 2, 3],\n                np.dtype(\"int32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int32\"\n                    ),\n                },\n            ),\n            (\n                [1, 2, 3],\n                np.dtype(\"int64\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int64\"\n                    ),\n                },\n            ),\n            (\n                [\"x\", \"y\", \"z\"],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [True, False, np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True,),\n                    ): pd.BooleanDtype(),\n                    ((True, False), (True, False), (True, False), (False,)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [\"h\", \"i\", np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (  # GH32117\n                [\"h\", \"i\", 1],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [10, np.nan, 20],\n                np.dtype(\"float\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                },\n            ),\n            (\n                [np.nan, 100.5, 200],\n                np.dtype(\"float\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"float\"),\n                },\n            ),\n            (\n                [3, 4, 5],\n                \"Int8\",\n                {((True, False), (True, False), (True, False), (True, False)): \"Int8\"},\n            ),\n            (\n                [[1, 2], [3, 4], [5]],\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [4, 5, 6],\n                np.dtype(\"uint32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"UInt32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"uint32\"\n                    ),\n                },\n            ),\n            (\n                [-10, 12, 13],\n                np.dtype(\"i1\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int8\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"i1\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.0],\n                object,\n                {\n                    ((True,), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True,), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.5],\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [\"a\", \"b\"],\n                pd.CategoricalDtype(),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.CategoricalDtype(),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                pd.DatetimeTZDtype(tz=\"UTC\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.DatetimeTZDtype(tz=\"UTC\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                \"datetime64[ns]\",\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"datetime64[ns]\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"datetime64[ns]\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                pd.period_range(\"1/1/2011\", freq=\"M\", periods=3),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.PeriodDtype(\"M\"),\n                },\n            ),\n            (\n                pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)]),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.IntervalDtype(\"int64\"),\n                },\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\"params\", product(*[(True, False)] * 4))\n    def test_convert_dtypes(self, data, maindtype, params, answerdict):\n        if maindtype is not None:\n            series = pd.Series(data, dtype=maindtype)\n        else:\n            series = pd.Series(data)\n        answers = {k: a for (kk, a) in answerdict.items() for k in product(*kk)}\n\n        ns = series.convert_dtypes(*params)\n        expected_dtype = answers[tuple(params)]\n        expected = pd.Series(series.values, dtype=expected_dtype)\n        tm.assert_series_equal(ns, expected)\n\n        # Test that it is a copy\n        copy = series.copy(deep=True)\n        if is_interval_dtype(ns.dtype) and ns.dtype.subtype.kind in [\"i\", \"u\"]:\n            msg = \"Cannot set float NaN to integer-backed IntervalArray\"\n            with pytest.raises(ValueError, match=msg):\n                ns[ns.notna()] = np.nan\n        else:\n            ns[ns.notna()] = np.nan\n\n        # Make sure original not changed\n        tm.assert_series_equal(series, copy)"
    ],
    "1.4.2": [
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_29/pandas/tests/arrays/interval/test_interval.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_29/pandas/tests/series/methods/test_convert_dtypes.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_29/pandas/tests/series/methods/test_convert_dtypes.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_29/pandas/tests/series/methods/test_convert_dtypes.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_29/pandas/tests/series/methods/test_convert_dtypes.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_29/pandas/tests/series/methods/test_convert_dtypes.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_29/pandas/tests/series/methods/test_convert_dtypes.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_29/pandas/tests/series/methods/test_convert_dtypes.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_29/pandas/tests/series/methods/test_convert_dtypes.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_29/pandas/tests/series/methods/test_convert_dtypes.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_29/pandas/tests/series/methods/test_convert_dtypes.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_29/pandas/tests/series/methods/test_convert_dtypes.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_29/pandas/tests/series/methods/test_convert_dtypes.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_29/pandas/tests/series/methods/test_convert_dtypes.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_29/pandas/tests/series/methods/test_convert_dtypes.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_29/pandas/tests/series/methods/test_convert_dtypes.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_29/pandas/tests/series/methods/test_convert_dtypes.py"
    ],
    "2.1.1": [
        [
            "E               Failed: DID NOT RAISE <class 'ValueError'>"
        ],
        [
            "E               Failed: DID NOT RAISE <class 'ValueError'>"
        ],
        [
            "E               Failed: DID NOT RAISE <class 'ValueError'>"
        ],
        [
            "E               Failed: DID NOT RAISE <class 'ValueError'>"
        ],
        [
            "E               Failed: DID NOT RAISE <class 'ValueError'>"
        ],
        [
            "E               Failed: DID NOT RAISE <class 'ValueError'>"
        ],
        [
            "E               Failed: DID NOT RAISE <class 'ValueError'>"
        ],
        [
            "E               Failed: DID NOT RAISE <class 'ValueError'>"
        ],
        [
            "E               Failed: DID NOT RAISE <class 'ValueError'>"
        ],
        [
            "E               Failed: DID NOT RAISE <class 'ValueError'>"
        ],
        [
            "E               Failed: DID NOT RAISE <class 'ValueError'>"
        ],
        [
            "E               Failed: DID NOT RAISE <class 'ValueError'>"
        ],
        [
            "E               Failed: DID NOT RAISE <class 'ValueError'>"
        ],
        [
            "E               Failed: DID NOT RAISE <class 'ValueError'>"
        ],
        [
            "E               Failed: DID NOT RAISE <class 'ValueError'>"
        ],
        [
            "E               Failed: DID NOT RAISE <class 'ValueError'>"
        ],
        [
            "E               Failed: DID NOT RAISE <class 'ValueError'>"
        ]
    ],
    "2.1.2": [
        [
            "self = <pandas.tests.arrays.interval.test_interval.TestSetitem object at 0x10f8bf280>\nleft_right_dtypes = (Int64Index([0, 2, 4], dtype='int64'), Int64Index([1, 3, 5], dtype='int64'))\n\n    def test_set_na(self, left_right_dtypes):\n        left, right = left_right_dtypes\n        result = IntervalArray.from_arrays(left, right)\n    \n        if result.dtype.subtype.kind in [\"i\", \"u\"]:\n            msg = \"Cannot set float NaN to integer-backed IntervalArray\"\n            with pytest.raises(ValueError, match=msg):\n>               result[0] = np.NaN",
            "\npandas/tests/arrays/interval/test_interval.py:111: Failed"
        ],
        [
            "self = <pandas.tests.series.methods.test_convert_dtypes.TestSeriesConvertDtypes object at 0x10fa83a60>\ndata = <IntervalArray>\n[(0, 1], (1, 5]]\nLength: 2, closed: right, dtype: interval[int64]\nmaindtype = None, params = (True, True, True, True)\nanswerdict = {((True, False), (True, False), (True, False), (True, False)): interval[int64]}\n\n    @pytest.mark.parametrize(\n        \"data, maindtype, answerdict\",\n        [\n            (\n                [1, 2, 3],\n                np.dtype(\"int32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int32\"\n                    ),\n                },\n            ),\n            (\n                [1, 2, 3],\n                np.dtype(\"int64\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int64\"\n                    ),\n                },\n            ),\n            (\n                [\"x\", \"y\", \"z\"],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [True, False, np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True,),\n                    ): pd.BooleanDtype(),\n                    ((True, False), (True, False), (True, False), (False,)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [\"h\", \"i\", np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (  # GH32117\n                [\"h\", \"i\", 1],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [10, np.nan, 20],\n                np.dtype(\"float\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                },\n            ),\n            (\n                [np.nan, 100.5, 200],\n                np.dtype(\"float\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"float\"),\n                },\n            ),\n            (\n                [3, 4, 5],\n                \"Int8\",\n                {((True, False), (True, False), (True, False), (True, False)): \"Int8\"},\n            ),\n            (\n                [[1, 2], [3, 4], [5]],\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [4, 5, 6],\n                np.dtype(\"uint32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"UInt32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"uint32\"\n                    ),\n                },\n            ),\n            (\n                [-10, 12, 13],\n                np.dtype(\"i1\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int8\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"i1\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.0],\n                object,\n                {\n                    ((True,), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True,), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.5],\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [\"a\", \"b\"],\n                pd.CategoricalDtype(),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.CategoricalDtype(),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                pd.DatetimeTZDtype(tz=\"UTC\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.DatetimeTZDtype(tz=\"UTC\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                \"datetime64[ns]\",\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"datetime64[ns]\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"datetime64[ns]\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                pd.period_range(\"1/1/2011\", freq=\"M\", periods=3),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.PeriodDtype(\"M\"),\n                },\n            ),\n            (\n                pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)]),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.IntervalDtype(\"int64\"),\n                },\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\"params\", product(*[(True, False)] * 4))\n    def test_convert_dtypes(self, data, maindtype, params, answerdict):\n        if maindtype is not None:\n            series = pd.Series(data, dtype=maindtype)\n        else:\n            series = pd.Series(data)\n        answers = {k: a for (kk, a) in answerdict.items() for k in product(*kk)}\n    \n        ns = series.convert_dtypes(*params)\n        expected_dtype = answers[tuple(params)]\n        expected = pd.Series(series.values, dtype=expected_dtype)\n        tm.assert_series_equal(ns, expected)\n    \n        # Test that it is a copy\n        copy = series.copy(deep=True)\n        if is_interval_dtype(ns.dtype) and ns.dtype.subtype.kind in [\"i\", \"u\"]:\n            msg = \"Cannot set float NaN to integer-backed IntervalArray\"\n            with pytest.raises(ValueError, match=msg):\n>               ns[ns.notna()] = np.nan",
            "\npandas/tests/series/methods/test_convert_dtypes.py:274: Failed"
        ],
        [
            "self = <pandas.tests.series.methods.test_convert_dtypes.TestSeriesConvertDtypes object at 0x10fb5d160>\ndata = <IntervalArray>\n[(0, 1], (1, 5]]\nLength: 2, closed: right, dtype: interval[int64]\nmaindtype = None, params = (True, True, True, False)\nanswerdict = {((True, False), (True, False), (True, False), (True, False)): interval[int64]}\n\n    @pytest.mark.parametrize(\n        \"data, maindtype, answerdict\",\n        [\n            (\n                [1, 2, 3],\n                np.dtype(\"int32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int32\"\n                    ),\n                },\n            ),\n            (\n                [1, 2, 3],\n                np.dtype(\"int64\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int64\"\n                    ),\n                },\n            ),\n            (\n                [\"x\", \"y\", \"z\"],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [True, False, np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True,),\n                    ): pd.BooleanDtype(),\n                    ((True, False), (True, False), (True, False), (False,)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [\"h\", \"i\", np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (  # GH32117\n                [\"h\", \"i\", 1],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [10, np.nan, 20],\n                np.dtype(\"float\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                },\n            ),\n            (\n                [np.nan, 100.5, 200],\n                np.dtype(\"float\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"float\"),\n                },\n            ),\n            (\n                [3, 4, 5],\n                \"Int8\",\n                {((True, False), (True, False), (True, False), (True, False)): \"Int8\"},\n            ),\n            (\n                [[1, 2], [3, 4], [5]],\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [4, 5, 6],\n                np.dtype(\"uint32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"UInt32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"uint32\"\n                    ),\n                },\n            ),\n            (\n                [-10, 12, 13],\n                np.dtype(\"i1\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int8\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"i1\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.0],\n                object,\n                {\n                    ((True,), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True,), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.5],\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [\"a\", \"b\"],\n                pd.CategoricalDtype(),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.CategoricalDtype(),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                pd.DatetimeTZDtype(tz=\"UTC\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.DatetimeTZDtype(tz=\"UTC\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                \"datetime64[ns]\",\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"datetime64[ns]\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"datetime64[ns]\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                pd.period_range(\"1/1/2011\", freq=\"M\", periods=3),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.PeriodDtype(\"M\"),\n                },\n            ),\n            (\n                pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)]),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.IntervalDtype(\"int64\"),\n                },\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\"params\", product(*[(True, False)] * 4))\n    def test_convert_dtypes(self, data, maindtype, params, answerdict):\n        if maindtype is not None:\n            series = pd.Series(data, dtype=maindtype)\n        else:\n            series = pd.Series(data)\n        answers = {k: a for (kk, a) in answerdict.items() for k in product(*kk)}\n    \n        ns = series.convert_dtypes(*params)\n        expected_dtype = answers[tuple(params)]\n        expected = pd.Series(series.values, dtype=expected_dtype)\n        tm.assert_series_equal(ns, expected)\n    \n        # Test that it is a copy\n        copy = series.copy(deep=True)\n        if is_interval_dtype(ns.dtype) and ns.dtype.subtype.kind in [\"i\", \"u\"]:\n            msg = \"Cannot set float NaN to integer-backed IntervalArray\"\n            with pytest.raises(ValueError, match=msg):\n>               ns[ns.notna()] = np.nan",
            "\npandas/tests/series/methods/test_convert_dtypes.py:274: Failed"
        ],
        [
            "self = <pandas.tests.series.methods.test_convert_dtypes.TestSeriesConvertDtypes object at 0x10fb74ee0>\ndata = <IntervalArray>\n[(0, 1], (1, 5]]\nLength: 2, closed: right, dtype: interval[int64]\nmaindtype = None, params = (True, True, False, True)\nanswerdict = {((True, False), (True, False), (True, False), (True, False)): interval[int64]}\n\n    @pytest.mark.parametrize(\n        \"data, maindtype, answerdict\",\n        [\n            (\n                [1, 2, 3],\n                np.dtype(\"int32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int32\"\n                    ),\n                },\n            ),\n            (\n                [1, 2, 3],\n                np.dtype(\"int64\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int64\"\n                    ),\n                },\n            ),\n            (\n                [\"x\", \"y\", \"z\"],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [True, False, np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True,),\n                    ): pd.BooleanDtype(),\n                    ((True, False), (True, False), (True, False), (False,)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [\"h\", \"i\", np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (  # GH32117\n                [\"h\", \"i\", 1],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [10, np.nan, 20],\n                np.dtype(\"float\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                },\n            ),\n            (\n                [np.nan, 100.5, 200],\n                np.dtype(\"float\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"float\"),\n                },\n            ),\n            (\n                [3, 4, 5],\n                \"Int8\",\n                {((True, False), (True, False), (True, False), (True, False)): \"Int8\"},\n            ),\n            (\n                [[1, 2], [3, 4], [5]],\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [4, 5, 6],\n                np.dtype(\"uint32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"UInt32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"uint32\"\n                    ),\n                },\n            ),\n            (\n                [-10, 12, 13],\n                np.dtype(\"i1\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int8\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"i1\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.0],\n                object,\n                {\n                    ((True,), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True,), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.5],\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [\"a\", \"b\"],\n                pd.CategoricalDtype(),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.CategoricalDtype(),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                pd.DatetimeTZDtype(tz=\"UTC\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.DatetimeTZDtype(tz=\"UTC\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                \"datetime64[ns]\",\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"datetime64[ns]\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"datetime64[ns]\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                pd.period_range(\"1/1/2011\", freq=\"M\", periods=3),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.PeriodDtype(\"M\"),\n                },\n            ),\n            (\n                pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)]),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.IntervalDtype(\"int64\"),\n                },\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\"params\", product(*[(True, False)] * 4))\n    def test_convert_dtypes(self, data, maindtype, params, answerdict):\n        if maindtype is not None:\n            series = pd.Series(data, dtype=maindtype)\n        else:\n            series = pd.Series(data)\n        answers = {k: a for (kk, a) in answerdict.items() for k in product(*kk)}\n    \n        ns = series.convert_dtypes(*params)\n        expected_dtype = answers[tuple(params)]\n        expected = pd.Series(series.values, dtype=expected_dtype)\n        tm.assert_series_equal(ns, expected)\n    \n        # Test that it is a copy\n        copy = series.copy(deep=True)\n        if is_interval_dtype(ns.dtype) and ns.dtype.subtype.kind in [\"i\", \"u\"]:\n            msg = \"Cannot set float NaN to integer-backed IntervalArray\"\n            with pytest.raises(ValueError, match=msg):\n>               ns[ns.notna()] = np.nan",
            "\npandas/tests/series/methods/test_convert_dtypes.py:274: Failed"
        ],
        [
            "self = <pandas.tests.series.methods.test_convert_dtypes.TestSeriesConvertDtypes object at 0x10fbab0a0>\ndata = <IntervalArray>\n[(0, 1], (1, 5]]\nLength: 2, closed: right, dtype: interval[int64]\nmaindtype = None, params = (True, True, False, False)\nanswerdict = {((True, False), (True, False), (True, False), (True, False)): interval[int64]}\n\n    @pytest.mark.parametrize(\n        \"data, maindtype, answerdict\",\n        [\n            (\n                [1, 2, 3],\n                np.dtype(\"int32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int32\"\n                    ),\n                },\n            ),\n            (\n                [1, 2, 3],\n                np.dtype(\"int64\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int64\"\n                    ),\n                },\n            ),\n            (\n                [\"x\", \"y\", \"z\"],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [True, False, np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True,),\n                    ): pd.BooleanDtype(),\n                    ((True, False), (True, False), (True, False), (False,)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [\"h\", \"i\", np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (  # GH32117\n                [\"h\", \"i\", 1],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [10, np.nan, 20],\n                np.dtype(\"float\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                },\n            ),\n            (\n                [np.nan, 100.5, 200],\n                np.dtype(\"float\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"float\"),\n                },\n            ),\n            (\n                [3, 4, 5],\n                \"Int8\",\n                {((True, False), (True, False), (True, False), (True, False)): \"Int8\"},\n            ),\n            (\n                [[1, 2], [3, 4], [5]],\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [4, 5, 6],\n                np.dtype(\"uint32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"UInt32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"uint32\"\n                    ),\n                },\n            ),\n            (\n                [-10, 12, 13],\n                np.dtype(\"i1\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int8\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"i1\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.0],\n                object,\n                {\n                    ((True,), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True,), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.5],\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [\"a\", \"b\"],\n                pd.CategoricalDtype(),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.CategoricalDtype(),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                pd.DatetimeTZDtype(tz=\"UTC\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.DatetimeTZDtype(tz=\"UTC\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                \"datetime64[ns]\",\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"datetime64[ns]\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"datetime64[ns]\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                pd.period_range(\"1/1/2011\", freq=\"M\", periods=3),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.PeriodDtype(\"M\"),\n                },\n            ),\n            (\n                pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)]),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.IntervalDtype(\"int64\"),\n                },\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\"params\", product(*[(True, False)] * 4))\n    def test_convert_dtypes(self, data, maindtype, params, answerdict):\n        if maindtype is not None:\n            series = pd.Series(data, dtype=maindtype)\n        else:\n            series = pd.Series(data)\n        answers = {k: a for (kk, a) in answerdict.items() for k in product(*kk)}\n    \n        ns = series.convert_dtypes(*params)\n        expected_dtype = answers[tuple(params)]\n        expected = pd.Series(series.values, dtype=expected_dtype)\n        tm.assert_series_equal(ns, expected)\n    \n        # Test that it is a copy\n        copy = series.copy(deep=True)\n        if is_interval_dtype(ns.dtype) and ns.dtype.subtype.kind in [\"i\", \"u\"]:\n            msg = \"Cannot set float NaN to integer-backed IntervalArray\"\n            with pytest.raises(ValueError, match=msg):\n>               ns[ns.notna()] = np.nan",
            "\npandas/tests/series/methods/test_convert_dtypes.py:274: Failed"
        ],
        [
            "self = <pandas.tests.series.methods.test_convert_dtypes.TestSeriesConvertDtypes object at 0x10fb3f3d0>\ndata = <IntervalArray>\n[(0, 1], (1, 5]]\nLength: 2, closed: right, dtype: interval[int64]\nmaindtype = None, params = (True, False, True, True)\nanswerdict = {((True, False), (True, False), (True, False), (True, False)): interval[int64]}\n\n    @pytest.mark.parametrize(\n        \"data, maindtype, answerdict\",\n        [\n            (\n                [1, 2, 3],\n                np.dtype(\"int32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int32\"\n                    ),\n                },\n            ),\n            (\n                [1, 2, 3],\n                np.dtype(\"int64\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int64\"\n                    ),\n                },\n            ),\n            (\n                [\"x\", \"y\", \"z\"],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [True, False, np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True,),\n                    ): pd.BooleanDtype(),\n                    ((True, False), (True, False), (True, False), (False,)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [\"h\", \"i\", np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (  # GH32117\n                [\"h\", \"i\", 1],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [10, np.nan, 20],\n                np.dtype(\"float\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                },\n            ),\n            (\n                [np.nan, 100.5, 200],\n                np.dtype(\"float\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"float\"),\n                },\n            ),\n            (\n                [3, 4, 5],\n                \"Int8\",\n                {((True, False), (True, False), (True, False), (True, False)): \"Int8\"},\n            ),\n            (\n                [[1, 2], [3, 4], [5]],\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [4, 5, 6],\n                np.dtype(\"uint32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"UInt32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"uint32\"\n                    ),\n                },\n            ),\n            (\n                [-10, 12, 13],\n                np.dtype(\"i1\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int8\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"i1\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.0],\n                object,\n                {\n                    ((True,), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True,), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.5],\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [\"a\", \"b\"],\n                pd.CategoricalDtype(),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.CategoricalDtype(),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                pd.DatetimeTZDtype(tz=\"UTC\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.DatetimeTZDtype(tz=\"UTC\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                \"datetime64[ns]\",\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"datetime64[ns]\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"datetime64[ns]\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                pd.period_range(\"1/1/2011\", freq=\"M\", periods=3),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.PeriodDtype(\"M\"),\n                },\n            ),\n            (\n                pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)]),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.IntervalDtype(\"int64\"),\n                },\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\"params\", product(*[(True, False)] * 4))\n    def test_convert_dtypes(self, data, maindtype, params, answerdict):\n        if maindtype is not None:\n            series = pd.Series(data, dtype=maindtype)\n        else:\n            series = pd.Series(data)\n        answers = {k: a for (kk, a) in answerdict.items() for k in product(*kk)}\n    \n        ns = series.convert_dtypes(*params)\n        expected_dtype = answers[tuple(params)]\n        expected = pd.Series(series.values, dtype=expected_dtype)\n        tm.assert_series_equal(ns, expected)\n    \n        # Test that it is a copy\n        copy = series.copy(deep=True)\n        if is_interval_dtype(ns.dtype) and ns.dtype.subtype.kind in [\"i\", \"u\"]:\n            msg = \"Cannot set float NaN to integer-backed IntervalArray\"\n            with pytest.raises(ValueError, match=msg):\n>               ns[ns.notna()] = np.nan",
            "\npandas/tests/series/methods/test_convert_dtypes.py:274: Failed"
        ],
        [
            "self = <pandas.tests.series.methods.test_convert_dtypes.TestSeriesConvertDtypes object at 0x10fbeb730>\ndata = <IntervalArray>\n[(0, 1], (1, 5]]\nLength: 2, closed: right, dtype: interval[int64]\nmaindtype = None, params = (True, False, True, False)\nanswerdict = {((True, False), (True, False), (True, False), (True, False)): interval[int64]}\n\n    @pytest.mark.parametrize(\n        \"data, maindtype, answerdict\",\n        [\n            (\n                [1, 2, 3],\n                np.dtype(\"int32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int32\"\n                    ),\n                },\n            ),\n            (\n                [1, 2, 3],\n                np.dtype(\"int64\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int64\"\n                    ),\n                },\n            ),\n            (\n                [\"x\", \"y\", \"z\"],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [True, False, np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True,),\n                    ): pd.BooleanDtype(),\n                    ((True, False), (True, False), (True, False), (False,)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [\"h\", \"i\", np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (  # GH32117\n                [\"h\", \"i\", 1],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [10, np.nan, 20],\n                np.dtype(\"float\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                },\n            ),\n            (\n                [np.nan, 100.5, 200],\n                np.dtype(\"float\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"float\"),\n                },\n            ),\n            (\n                [3, 4, 5],\n                \"Int8\",\n                {((True, False), (True, False), (True, False), (True, False)): \"Int8\"},\n            ),\n            (\n                [[1, 2], [3, 4], [5]],\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [4, 5, 6],\n                np.dtype(\"uint32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"UInt32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"uint32\"\n                    ),\n                },\n            ),\n            (\n                [-10, 12, 13],\n                np.dtype(\"i1\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int8\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"i1\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.0],\n                object,\n                {\n                    ((True,), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True,), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.5],\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [\"a\", \"b\"],\n                pd.CategoricalDtype(),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.CategoricalDtype(),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                pd.DatetimeTZDtype(tz=\"UTC\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.DatetimeTZDtype(tz=\"UTC\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                \"datetime64[ns]\",\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"datetime64[ns]\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"datetime64[ns]\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                pd.period_range(\"1/1/2011\", freq=\"M\", periods=3),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.PeriodDtype(\"M\"),\n                },\n            ),\n            (\n                pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)]),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.IntervalDtype(\"int64\"),\n                },\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\"params\", product(*[(True, False)] * 4))\n    def test_convert_dtypes(self, data, maindtype, params, answerdict):\n        if maindtype is not None:\n            series = pd.Series(data, dtype=maindtype)\n        else:\n            series = pd.Series(data)\n        answers = {k: a for (kk, a) in answerdict.items() for k in product(*kk)}\n    \n        ns = series.convert_dtypes(*params)\n        expected_dtype = answers[tuple(params)]\n        expected = pd.Series(series.values, dtype=expected_dtype)\n        tm.assert_series_equal(ns, expected)\n    \n        # Test that it is a copy\n        copy = series.copy(deep=True)\n        if is_interval_dtype(ns.dtype) and ns.dtype.subtype.kind in [\"i\", \"u\"]:\n            msg = \"Cannot set float NaN to integer-backed IntervalArray\"\n            with pytest.raises(ValueError, match=msg):\n>               ns[ns.notna()] = np.nan",
            "\npandas/tests/series/methods/test_convert_dtypes.py:274: Failed"
        ],
        [
            "self = <pandas.tests.series.methods.test_convert_dtypes.TestSeriesConvertDtypes object at 0x10fbc5ca0>\ndata = <IntervalArray>\n[(0, 1], (1, 5]]\nLength: 2, closed: right, dtype: interval[int64]\nmaindtype = None, params = (True, False, False, True)\nanswerdict = {((True, False), (True, False), (True, False), (True, False)): interval[int64]}\n\n    @pytest.mark.parametrize(\n        \"data, maindtype, answerdict\",\n        [\n            (\n                [1, 2, 3],\n                np.dtype(\"int32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int32\"\n                    ),\n                },\n            ),\n            (\n                [1, 2, 3],\n                np.dtype(\"int64\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int64\"\n                    ),\n                },\n            ),\n            (\n                [\"x\", \"y\", \"z\"],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [True, False, np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True,),\n                    ): pd.BooleanDtype(),\n                    ((True, False), (True, False), (True, False), (False,)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [\"h\", \"i\", np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (  # GH32117\n                [\"h\", \"i\", 1],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [10, np.nan, 20],\n                np.dtype(\"float\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                },\n            ),\n            (\n                [np.nan, 100.5, 200],\n                np.dtype(\"float\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"float\"),\n                },\n            ),\n            (\n                [3, 4, 5],\n                \"Int8\",\n                {((True, False), (True, False), (True, False), (True, False)): \"Int8\"},\n            ),\n            (\n                [[1, 2], [3, 4], [5]],\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [4, 5, 6],\n                np.dtype(\"uint32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"UInt32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"uint32\"\n                    ),\n                },\n            ),\n            (\n                [-10, 12, 13],\n                np.dtype(\"i1\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int8\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"i1\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.0],\n                object,\n                {\n                    ((True,), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True,), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.5],\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [\"a\", \"b\"],\n                pd.CategoricalDtype(),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.CategoricalDtype(),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                pd.DatetimeTZDtype(tz=\"UTC\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.DatetimeTZDtype(tz=\"UTC\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                \"datetime64[ns]\",\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"datetime64[ns]\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"datetime64[ns]\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                pd.period_range(\"1/1/2011\", freq=\"M\", periods=3),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.PeriodDtype(\"M\"),\n                },\n            ),\n            (\n                pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)]),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.IntervalDtype(\"int64\"),\n                },\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\"params\", product(*[(True, False)] * 4))\n    def test_convert_dtypes(self, data, maindtype, params, answerdict):\n        if maindtype is not None:\n            series = pd.Series(data, dtype=maindtype)\n        else:\n            series = pd.Series(data)\n        answers = {k: a for (kk, a) in answerdict.items() for k in product(*kk)}\n    \n        ns = series.convert_dtypes(*params)\n        expected_dtype = answers[tuple(params)]\n        expected = pd.Series(series.values, dtype=expected_dtype)\n        tm.assert_series_equal(ns, expected)\n    \n        # Test that it is a copy\n        copy = series.copy(deep=True)\n        if is_interval_dtype(ns.dtype) and ns.dtype.subtype.kind in [\"i\", \"u\"]:\n            msg = \"Cannot set float NaN to integer-backed IntervalArray\"\n            with pytest.raises(ValueError, match=msg):\n>               ns[ns.notna()] = np.nan",
            "\npandas/tests/series/methods/test_convert_dtypes.py:274: Failed"
        ],
        [
            "self = <pandas.tests.series.methods.test_convert_dtypes.TestSeriesConvertDtypes object at 0x10fc3de50>\ndata = <IntervalArray>\n[(0, 1], (1, 5]]\nLength: 2, closed: right, dtype: interval[int64]\nmaindtype = None, params = (True, False, False, False)\nanswerdict = {((True, False), (True, False), (True, False), (True, False)): interval[int64]}\n\n    @pytest.mark.parametrize(\n        \"data, maindtype, answerdict\",\n        [\n            (\n                [1, 2, 3],\n                np.dtype(\"int32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int32\"\n                    ),\n                },\n            ),\n            (\n                [1, 2, 3],\n                np.dtype(\"int64\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int64\"\n                    ),\n                },\n            ),\n            (\n                [\"x\", \"y\", \"z\"],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [True, False, np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True,),\n                    ): pd.BooleanDtype(),\n                    ((True, False), (True, False), (True, False), (False,)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [\"h\", \"i\", np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (  # GH32117\n                [\"h\", \"i\", 1],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [10, np.nan, 20],\n                np.dtype(\"float\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                },\n            ),\n            (\n                [np.nan, 100.5, 200],\n                np.dtype(\"float\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"float\"),\n                },\n            ),\n            (\n                [3, 4, 5],\n                \"Int8\",\n                {((True, False), (True, False), (True, False), (True, False)): \"Int8\"},\n            ),\n            (\n                [[1, 2], [3, 4], [5]],\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [4, 5, 6],\n                np.dtype(\"uint32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"UInt32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"uint32\"\n                    ),\n                },\n            ),\n            (\n                [-10, 12, 13],\n                np.dtype(\"i1\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int8\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"i1\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.0],\n                object,\n                {\n                    ((True,), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True,), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.5],\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [\"a\", \"b\"],\n                pd.CategoricalDtype(),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.CategoricalDtype(),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                pd.DatetimeTZDtype(tz=\"UTC\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.DatetimeTZDtype(tz=\"UTC\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                \"datetime64[ns]\",\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"datetime64[ns]\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"datetime64[ns]\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                pd.period_range(\"1/1/2011\", freq=\"M\", periods=3),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.PeriodDtype(\"M\"),\n                },\n            ),\n            (\n                pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)]),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.IntervalDtype(\"int64\"),\n                },\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\"params\", product(*[(True, False)] * 4))\n    def test_convert_dtypes(self, data, maindtype, params, answerdict):\n        if maindtype is not None:\n            series = pd.Series(data, dtype=maindtype)\n        else:\n            series = pd.Series(data)\n        answers = {k: a for (kk, a) in answerdict.items() for k in product(*kk)}\n    \n        ns = series.convert_dtypes(*params)\n        expected_dtype = answers[tuple(params)]\n        expected = pd.Series(series.values, dtype=expected_dtype)\n        tm.assert_series_equal(ns, expected)\n    \n        # Test that it is a copy\n        copy = series.copy(deep=True)\n        if is_interval_dtype(ns.dtype) and ns.dtype.subtype.kind in [\"i\", \"u\"]:\n            msg = \"Cannot set float NaN to integer-backed IntervalArray\"\n            with pytest.raises(ValueError, match=msg):\n>               ns[ns.notna()] = np.nan",
            "\npandas/tests/series/methods/test_convert_dtypes.py:274: Failed"
        ],
        [
            "self = <pandas.tests.series.methods.test_convert_dtypes.TestSeriesConvertDtypes object at 0x10faae250>\ndata = <IntervalArray>\n[(0, 1], (1, 5]]\nLength: 2, closed: right, dtype: interval[int64]\nmaindtype = None, params = (False, True, True, True)\nanswerdict = {((True, False), (True, False), (True, False), (True, False)): interval[int64]}\n\n    @pytest.mark.parametrize(\n        \"data, maindtype, answerdict\",\n        [\n            (\n                [1, 2, 3],\n                np.dtype(\"int32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int32\"\n                    ),\n                },\n            ),\n            (\n                [1, 2, 3],\n                np.dtype(\"int64\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int64\"\n                    ),\n                },\n            ),\n            (\n                [\"x\", \"y\", \"z\"],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [True, False, np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True,),\n                    ): pd.BooleanDtype(),\n                    ((True, False), (True, False), (True, False), (False,)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [\"h\", \"i\", np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (  # GH32117\n                [\"h\", \"i\", 1],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [10, np.nan, 20],\n                np.dtype(\"float\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                },\n            ),\n            (\n                [np.nan, 100.5, 200],\n                np.dtype(\"float\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"float\"),\n                },\n            ),\n            (\n                [3, 4, 5],\n                \"Int8\",\n                {((True, False), (True, False), (True, False), (True, False)): \"Int8\"},\n            ),\n            (\n                [[1, 2], [3, 4], [5]],\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [4, 5, 6],\n                np.dtype(\"uint32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"UInt32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"uint32\"\n                    ),\n                },\n            ),\n            (\n                [-10, 12, 13],\n                np.dtype(\"i1\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int8\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"i1\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.0],\n                object,\n                {\n                    ((True,), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True,), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.5],\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [\"a\", \"b\"],\n                pd.CategoricalDtype(),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.CategoricalDtype(),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                pd.DatetimeTZDtype(tz=\"UTC\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.DatetimeTZDtype(tz=\"UTC\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                \"datetime64[ns]\",\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"datetime64[ns]\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"datetime64[ns]\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                pd.period_range(\"1/1/2011\", freq=\"M\", periods=3),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.PeriodDtype(\"M\"),\n                },\n            ),\n            (\n                pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)]),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.IntervalDtype(\"int64\"),\n                },\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\"params\", product(*[(True, False)] * 4))\n    def test_convert_dtypes(self, data, maindtype, params, answerdict):\n        if maindtype is not None:\n            series = pd.Series(data, dtype=maindtype)\n        else:\n            series = pd.Series(data)\n        answers = {k: a for (kk, a) in answerdict.items() for k in product(*kk)}\n    \n        ns = series.convert_dtypes(*params)\n        expected_dtype = answers[tuple(params)]\n        expected = pd.Series(series.values, dtype=expected_dtype)\n        tm.assert_series_equal(ns, expected)\n    \n        # Test that it is a copy\n        copy = series.copy(deep=True)\n        if is_interval_dtype(ns.dtype) and ns.dtype.subtype.kind in [\"i\", \"u\"]:\n            msg = \"Cannot set float NaN to integer-backed IntervalArray\"\n            with pytest.raises(ValueError, match=msg):\n>               ns[ns.notna()] = np.nan",
            "\npandas/tests/series/methods/test_convert_dtypes.py:274: Failed"
        ],
        [
            "self = <pandas.tests.series.methods.test_convert_dtypes.TestSeriesConvertDtypes object at 0x10fc2c670>\ndata = <IntervalArray>\n[(0, 1], (1, 5]]\nLength: 2, closed: right, dtype: interval[int64]\nmaindtype = None, params = (False, True, True, False)\nanswerdict = {((True, False), (True, False), (True, False), (True, False)): interval[int64]}\n\n    @pytest.mark.parametrize(\n        \"data, maindtype, answerdict\",\n        [\n            (\n                [1, 2, 3],\n                np.dtype(\"int32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int32\"\n                    ),\n                },\n            ),\n            (\n                [1, 2, 3],\n                np.dtype(\"int64\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int64\"\n                    ),\n                },\n            ),\n            (\n                [\"x\", \"y\", \"z\"],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [True, False, np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True,),\n                    ): pd.BooleanDtype(),\n                    ((True, False), (True, False), (True, False), (False,)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [\"h\", \"i\", np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (  # GH32117\n                [\"h\", \"i\", 1],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [10, np.nan, 20],\n                np.dtype(\"float\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                },\n            ),\n            (\n                [np.nan, 100.5, 200],\n                np.dtype(\"float\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"float\"),\n                },\n            ),\n            (\n                [3, 4, 5],\n                \"Int8\",\n                {((True, False), (True, False), (True, False), (True, False)): \"Int8\"},\n            ),\n            (\n                [[1, 2], [3, 4], [5]],\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [4, 5, 6],\n                np.dtype(\"uint32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"UInt32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"uint32\"\n                    ),\n                },\n            ),\n            (\n                [-10, 12, 13],\n                np.dtype(\"i1\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int8\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"i1\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.0],\n                object,\n                {\n                    ((True,), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True,), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.5],\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [\"a\", \"b\"],\n                pd.CategoricalDtype(),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.CategoricalDtype(),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                pd.DatetimeTZDtype(tz=\"UTC\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.DatetimeTZDtype(tz=\"UTC\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                \"datetime64[ns]\",\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"datetime64[ns]\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"datetime64[ns]\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                pd.period_range(\"1/1/2011\", freq=\"M\", periods=3),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.PeriodDtype(\"M\"),\n                },\n            ),\n            (\n                pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)]),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.IntervalDtype(\"int64\"),\n                },\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\"params\", product(*[(True, False)] * 4))\n    def test_convert_dtypes(self, data, maindtype, params, answerdict):\n        if maindtype is not None:\n            series = pd.Series(data, dtype=maindtype)\n        else:\n            series = pd.Series(data)\n        answers = {k: a for (kk, a) in answerdict.items() for k in product(*kk)}\n    \n        ns = series.convert_dtypes(*params)\n        expected_dtype = answers[tuple(params)]\n        expected = pd.Series(series.values, dtype=expected_dtype)\n        tm.assert_series_equal(ns, expected)\n    \n        # Test that it is a copy\n        copy = series.copy(deep=True)\n        if is_interval_dtype(ns.dtype) and ns.dtype.subtype.kind in [\"i\", \"u\"]:\n            msg = \"Cannot set float NaN to integer-backed IntervalArray\"\n            with pytest.raises(ValueError, match=msg):\n>               ns[ns.notna()] = np.nan",
            "\npandas/tests/series/methods/test_convert_dtypes.py:274: Failed"
        ],
        [
            "self = <pandas.tests.series.methods.test_convert_dtypes.TestSeriesConvertDtypes object at 0x10fc5dd30>\ndata = <IntervalArray>\n[(0, 1], (1, 5]]\nLength: 2, closed: right, dtype: interval[int64]\nmaindtype = None, params = (False, True, False, True)\nanswerdict = {((True, False), (True, False), (True, False), (True, False)): interval[int64]}\n\n    @pytest.mark.parametrize(\n        \"data, maindtype, answerdict\",\n        [\n            (\n                [1, 2, 3],\n                np.dtype(\"int32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int32\"\n                    ),\n                },\n            ),\n            (\n                [1, 2, 3],\n                np.dtype(\"int64\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int64\"\n                    ),\n                },\n            ),\n            (\n                [\"x\", \"y\", \"z\"],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [True, False, np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True,),\n                    ): pd.BooleanDtype(),\n                    ((True, False), (True, False), (True, False), (False,)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [\"h\", \"i\", np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (  # GH32117\n                [\"h\", \"i\", 1],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [10, np.nan, 20],\n                np.dtype(\"float\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                },\n            ),\n            (\n                [np.nan, 100.5, 200],\n                np.dtype(\"float\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"float\"),\n                },\n            ),\n            (\n                [3, 4, 5],\n                \"Int8\",\n                {((True, False), (True, False), (True, False), (True, False)): \"Int8\"},\n            ),\n            (\n                [[1, 2], [3, 4], [5]],\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [4, 5, 6],\n                np.dtype(\"uint32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"UInt32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"uint32\"\n                    ),\n                },\n            ),\n            (\n                [-10, 12, 13],\n                np.dtype(\"i1\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int8\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"i1\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.0],\n                object,\n                {\n                    ((True,), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True,), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.5],\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [\"a\", \"b\"],\n                pd.CategoricalDtype(),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.CategoricalDtype(),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                pd.DatetimeTZDtype(tz=\"UTC\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.DatetimeTZDtype(tz=\"UTC\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                \"datetime64[ns]\",\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"datetime64[ns]\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"datetime64[ns]\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                pd.period_range(\"1/1/2011\", freq=\"M\", periods=3),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.PeriodDtype(\"M\"),\n                },\n            ),\n            (\n                pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)]),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.IntervalDtype(\"int64\"),\n                },\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\"params\", product(*[(True, False)] * 4))\n    def test_convert_dtypes(self, data, maindtype, params, answerdict):\n        if maindtype is not None:\n            series = pd.Series(data, dtype=maindtype)\n        else:\n            series = pd.Series(data)\n        answers = {k: a for (kk, a) in answerdict.items() for k in product(*kk)}\n    \n        ns = series.convert_dtypes(*params)\n        expected_dtype = answers[tuple(params)]\n        expected = pd.Series(series.values, dtype=expected_dtype)\n        tm.assert_series_equal(ns, expected)\n    \n        # Test that it is a copy\n        copy = series.copy(deep=True)\n        if is_interval_dtype(ns.dtype) and ns.dtype.subtype.kind in [\"i\", \"u\"]:\n            msg = \"Cannot set float NaN to integer-backed IntervalArray\"\n            with pytest.raises(ValueError, match=msg):\n>               ns[ns.notna()] = np.nan",
            "\npandas/tests/series/methods/test_convert_dtypes.py:274: Failed"
        ],
        [
            "self = <pandas.tests.series.methods.test_convert_dtypes.TestSeriesConvertDtypes object at 0x10fb174f0>\ndata = <IntervalArray>\n[(0, 1], (1, 5]]\nLength: 2, closed: right, dtype: interval[int64]\nmaindtype = None, params = (False, True, False, False)\nanswerdict = {((True, False), (True, False), (True, False), (True, False)): interval[int64]}\n\n    @pytest.mark.parametrize(\n        \"data, maindtype, answerdict\",\n        [\n            (\n                [1, 2, 3],\n                np.dtype(\"int32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int32\"\n                    ),\n                },\n            ),\n            (\n                [1, 2, 3],\n                np.dtype(\"int64\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int64\"\n                    ),\n                },\n            ),\n            (\n                [\"x\", \"y\", \"z\"],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [True, False, np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True,),\n                    ): pd.BooleanDtype(),\n                    ((True, False), (True, False), (True, False), (False,)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [\"h\", \"i\", np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (  # GH32117\n                [\"h\", \"i\", 1],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [10, np.nan, 20],\n                np.dtype(\"float\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                },\n            ),\n            (\n                [np.nan, 100.5, 200],\n                np.dtype(\"float\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"float\"),\n                },\n            ),\n            (\n                [3, 4, 5],\n                \"Int8\",\n                {((True, False), (True, False), (True, False), (True, False)): \"Int8\"},\n            ),\n            (\n                [[1, 2], [3, 4], [5]],\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [4, 5, 6],\n                np.dtype(\"uint32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"UInt32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"uint32\"\n                    ),\n                },\n            ),\n            (\n                [-10, 12, 13],\n                np.dtype(\"i1\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int8\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"i1\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.0],\n                object,\n                {\n                    ((True,), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True,), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.5],\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [\"a\", \"b\"],\n                pd.CategoricalDtype(),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.CategoricalDtype(),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                pd.DatetimeTZDtype(tz=\"UTC\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.DatetimeTZDtype(tz=\"UTC\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                \"datetime64[ns]\",\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"datetime64[ns]\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"datetime64[ns]\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                pd.period_range(\"1/1/2011\", freq=\"M\", periods=3),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.PeriodDtype(\"M\"),\n                },\n            ),\n            (\n                pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)]),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.IntervalDtype(\"int64\"),\n                },\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\"params\", product(*[(True, False)] * 4))\n    def test_convert_dtypes(self, data, maindtype, params, answerdict):\n        if maindtype is not None:\n            series = pd.Series(data, dtype=maindtype)\n        else:\n            series = pd.Series(data)\n        answers = {k: a for (kk, a) in answerdict.items() for k in product(*kk)}\n    \n        ns = series.convert_dtypes(*params)\n        expected_dtype = answers[tuple(params)]\n        expected = pd.Series(series.values, dtype=expected_dtype)\n        tm.assert_series_equal(ns, expected)\n    \n        # Test that it is a copy\n        copy = series.copy(deep=True)\n        if is_interval_dtype(ns.dtype) and ns.dtype.subtype.kind in [\"i\", \"u\"]:\n            msg = \"Cannot set float NaN to integer-backed IntervalArray\"\n            with pytest.raises(ValueError, match=msg):\n>               ns[ns.notna()] = np.nan",
            "\npandas/tests/series/methods/test_convert_dtypes.py:274: Failed"
        ],
        [
            "self = <pandas.tests.series.methods.test_convert_dtypes.TestSeriesConvertDtypes object at 0x10fbe1460>\ndata = <IntervalArray>\n[(0, 1], (1, 5]]\nLength: 2, closed: right, dtype: interval[int64]\nmaindtype = None, params = (False, False, True, True)\nanswerdict = {((True, False), (True, False), (True, False), (True, False)): interval[int64]}\n\n    @pytest.mark.parametrize(\n        \"data, maindtype, answerdict\",\n        [\n            (\n                [1, 2, 3],\n                np.dtype(\"int32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int32\"\n                    ),\n                },\n            ),\n            (\n                [1, 2, 3],\n                np.dtype(\"int64\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int64\"\n                    ),\n                },\n            ),\n            (\n                [\"x\", \"y\", \"z\"],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [True, False, np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True,),\n                    ): pd.BooleanDtype(),\n                    ((True, False), (True, False), (True, False), (False,)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [\"h\", \"i\", np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (  # GH32117\n                [\"h\", \"i\", 1],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [10, np.nan, 20],\n                np.dtype(\"float\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                },\n            ),\n            (\n                [np.nan, 100.5, 200],\n                np.dtype(\"float\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"float\"),\n                },\n            ),\n            (\n                [3, 4, 5],\n                \"Int8\",\n                {((True, False), (True, False), (True, False), (True, False)): \"Int8\"},\n            ),\n            (\n                [[1, 2], [3, 4], [5]],\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [4, 5, 6],\n                np.dtype(\"uint32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"UInt32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"uint32\"\n                    ),\n                },\n            ),\n            (\n                [-10, 12, 13],\n                np.dtype(\"i1\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int8\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"i1\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.0],\n                object,\n                {\n                    ((True,), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True,), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.5],\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [\"a\", \"b\"],\n                pd.CategoricalDtype(),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.CategoricalDtype(),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                pd.DatetimeTZDtype(tz=\"UTC\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.DatetimeTZDtype(tz=\"UTC\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                \"datetime64[ns]\",\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"datetime64[ns]\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"datetime64[ns]\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                pd.period_range(\"1/1/2011\", freq=\"M\", periods=3),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.PeriodDtype(\"M\"),\n                },\n            ),\n            (\n                pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)]),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.IntervalDtype(\"int64\"),\n                },\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\"params\", product(*[(True, False)] * 4))\n    def test_convert_dtypes(self, data, maindtype, params, answerdict):\n        if maindtype is not None:\n            series = pd.Series(data, dtype=maindtype)\n        else:\n            series = pd.Series(data)\n        answers = {k: a for (kk, a) in answerdict.items() for k in product(*kk)}\n    \n        ns = series.convert_dtypes(*params)\n        expected_dtype = answers[tuple(params)]\n        expected = pd.Series(series.values, dtype=expected_dtype)\n        tm.assert_series_equal(ns, expected)\n    \n        # Test that it is a copy\n        copy = series.copy(deep=True)\n        if is_interval_dtype(ns.dtype) and ns.dtype.subtype.kind in [\"i\", \"u\"]:\n            msg = \"Cannot set float NaN to integer-backed IntervalArray\"\n            with pytest.raises(ValueError, match=msg):\n>               ns[ns.notna()] = np.nan",
            "\npandas/tests/series/methods/test_convert_dtypes.py:274: Failed"
        ],
        [
            "self = <pandas.tests.series.methods.test_convert_dtypes.TestSeriesConvertDtypes object at 0x10fa481f0>\ndata = <IntervalArray>\n[(0, 1], (1, 5]]\nLength: 2, closed: right, dtype: interval[int64]\nmaindtype = None, params = (False, False, True, False)\nanswerdict = {((True, False), (True, False), (True, False), (True, False)): interval[int64]}\n\n    @pytest.mark.parametrize(\n        \"data, maindtype, answerdict\",\n        [\n            (\n                [1, 2, 3],\n                np.dtype(\"int32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int32\"\n                    ),\n                },\n            ),\n            (\n                [1, 2, 3],\n                np.dtype(\"int64\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int64\"\n                    ),\n                },\n            ),\n            (\n                [\"x\", \"y\", \"z\"],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [True, False, np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True,),\n                    ): pd.BooleanDtype(),\n                    ((True, False), (True, False), (True, False), (False,)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [\"h\", \"i\", np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (  # GH32117\n                [\"h\", \"i\", 1],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [10, np.nan, 20],\n                np.dtype(\"float\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                },\n            ),\n            (\n                [np.nan, 100.5, 200],\n                np.dtype(\"float\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"float\"),\n                },\n            ),\n            (\n                [3, 4, 5],\n                \"Int8\",\n                {((True, False), (True, False), (True, False), (True, False)): \"Int8\"},\n            ),\n            (\n                [[1, 2], [3, 4], [5]],\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [4, 5, 6],\n                np.dtype(\"uint32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"UInt32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"uint32\"\n                    ),\n                },\n            ),\n            (\n                [-10, 12, 13],\n                np.dtype(\"i1\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int8\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"i1\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.0],\n                object,\n                {\n                    ((True,), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True,), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.5],\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [\"a\", \"b\"],\n                pd.CategoricalDtype(),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.CategoricalDtype(),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                pd.DatetimeTZDtype(tz=\"UTC\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.DatetimeTZDtype(tz=\"UTC\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                \"datetime64[ns]\",\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"datetime64[ns]\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"datetime64[ns]\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                pd.period_range(\"1/1/2011\", freq=\"M\", periods=3),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.PeriodDtype(\"M\"),\n                },\n            ),\n            (\n                pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)]),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.IntervalDtype(\"int64\"),\n                },\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\"params\", product(*[(True, False)] * 4))\n    def test_convert_dtypes(self, data, maindtype, params, answerdict):\n        if maindtype is not None:\n            series = pd.Series(data, dtype=maindtype)\n        else:\n            series = pd.Series(data)\n        answers = {k: a for (kk, a) in answerdict.items() for k in product(*kk)}\n    \n        ns = series.convert_dtypes(*params)\n        expected_dtype = answers[tuple(params)]\n        expected = pd.Series(series.values, dtype=expected_dtype)\n        tm.assert_series_equal(ns, expected)\n    \n        # Test that it is a copy\n        copy = series.copy(deep=True)\n        if is_interval_dtype(ns.dtype) and ns.dtype.subtype.kind in [\"i\", \"u\"]:\n            msg = \"Cannot set float NaN to integer-backed IntervalArray\"\n            with pytest.raises(ValueError, match=msg):\n>               ns[ns.notna()] = np.nan",
            "\npandas/tests/series/methods/test_convert_dtypes.py:274: Failed"
        ],
        [
            "self = <pandas.tests.series.methods.test_convert_dtypes.TestSeriesConvertDtypes object at 0x10fcb0970>\ndata = <IntervalArray>\n[(0, 1], (1, 5]]\nLength: 2, closed: right, dtype: interval[int64]\nmaindtype = None, params = (False, False, False, True)\nanswerdict = {((True, False), (True, False), (True, False), (True, False)): interval[int64]}\n\n    @pytest.mark.parametrize(\n        \"data, maindtype, answerdict\",\n        [\n            (\n                [1, 2, 3],\n                np.dtype(\"int32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int32\"\n                    ),\n                },\n            ),\n            (\n                [1, 2, 3],\n                np.dtype(\"int64\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int64\"\n                    ),\n                },\n            ),\n            (\n                [\"x\", \"y\", \"z\"],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [True, False, np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True,),\n                    ): pd.BooleanDtype(),\n                    ((True, False), (True, False), (True, False), (False,)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [\"h\", \"i\", np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (  # GH32117\n                [\"h\", \"i\", 1],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [10, np.nan, 20],\n                np.dtype(\"float\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                },\n            ),\n            (\n                [np.nan, 100.5, 200],\n                np.dtype(\"float\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"float\"),\n                },\n            ),\n            (\n                [3, 4, 5],\n                \"Int8\",\n                {((True, False), (True, False), (True, False), (True, False)): \"Int8\"},\n            ),\n            (\n                [[1, 2], [3, 4], [5]],\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [4, 5, 6],\n                np.dtype(\"uint32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"UInt32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"uint32\"\n                    ),\n                },\n            ),\n            (\n                [-10, 12, 13],\n                np.dtype(\"i1\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int8\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"i1\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.0],\n                object,\n                {\n                    ((True,), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True,), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.5],\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [\"a\", \"b\"],\n                pd.CategoricalDtype(),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.CategoricalDtype(),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                pd.DatetimeTZDtype(tz=\"UTC\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.DatetimeTZDtype(tz=\"UTC\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                \"datetime64[ns]\",\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"datetime64[ns]\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"datetime64[ns]\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                pd.period_range(\"1/1/2011\", freq=\"M\", periods=3),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.PeriodDtype(\"M\"),\n                },\n            ),\n            (\n                pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)]),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.IntervalDtype(\"int64\"),\n                },\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\"params\", product(*[(True, False)] * 4))\n    def test_convert_dtypes(self, data, maindtype, params, answerdict):\n        if maindtype is not None:\n            series = pd.Series(data, dtype=maindtype)\n        else:\n            series = pd.Series(data)\n        answers = {k: a for (kk, a) in answerdict.items() for k in product(*kk)}\n    \n        ns = series.convert_dtypes(*params)\n        expected_dtype = answers[tuple(params)]\n        expected = pd.Series(series.values, dtype=expected_dtype)\n        tm.assert_series_equal(ns, expected)\n    \n        # Test that it is a copy\n        copy = series.copy(deep=True)\n        if is_interval_dtype(ns.dtype) and ns.dtype.subtype.kind in [\"i\", \"u\"]:\n            msg = \"Cannot set float NaN to integer-backed IntervalArray\"\n            with pytest.raises(ValueError, match=msg):\n>               ns[ns.notna()] = np.nan",
            "\npandas/tests/series/methods/test_convert_dtypes.py:274: Failed"
        ],
        [
            "self = <pandas.tests.series.methods.test_convert_dtypes.TestSeriesConvertDtypes object at 0x10fcb0340>\ndata = <IntervalArray>\n[(0, 1], (1, 5]]\nLength: 2, closed: right, dtype: interval[int64]\nmaindtype = None, params = (False, False, False, False)\nanswerdict = {((True, False), (True, False), (True, False), (True, False)): interval[int64]}\n\n    @pytest.mark.parametrize(\n        \"data, maindtype, answerdict\",\n        [\n            (\n                [1, 2, 3],\n                np.dtype(\"int32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int32\"\n                    ),\n                },\n            ),\n            (\n                [1, 2, 3],\n                np.dtype(\"int64\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"int64\"\n                    ),\n                },\n            ),\n            (\n                [\"x\", \"y\", \"z\"],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [True, False, np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True,),\n                    ): pd.BooleanDtype(),\n                    ((True, False), (True, False), (True, False), (False,)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                [\"h\", \"i\", np.nan],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True,),\n                        (True, False),\n                        (True, False),\n                    ): pd.StringDtype(),\n                    ((True, False), (False,), (True, False), (True, False)): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (  # GH32117\n                [\"h\", \"i\", 1],\n                np.dtype(\"O\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [10, np.nan, 20],\n                np.dtype(\"float\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                },\n            ),\n            (\n                [np.nan, 100.5, 200],\n                np.dtype(\"float\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"float\"),\n                },\n            ),\n            (\n                [3, 4, 5],\n                \"Int8\",\n                {((True, False), (True, False), (True, False), (True, False)): \"Int8\"},\n            ),\n            (\n                [[1, 2], [3, 4], [5]],\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"O\"),\n                },\n            ),\n            (\n                [4, 5, 6],\n                np.dtype(\"uint32\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"UInt32\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"uint32\"\n                    ),\n                },\n            ),\n            (\n                [-10, 12, 13],\n                np.dtype(\"i1\"),\n                {\n                    ((True, False), (True, False), (True,), (True, False)): \"Int8\",\n                    ((True, False), (True, False), (False,), (True, False)): np.dtype(\n                        \"i1\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.0],\n                object,\n                {\n                    ((True,), (True, False), (True,), (True, False)): \"Int64\",\n                    ((True,), (True, False), (False,), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [1, 2.5],\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"float\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False)): np.dtype(\n                        \"object\"\n                    ),\n                },\n            ),\n            (\n                [\"a\", \"b\"],\n                pd.CategoricalDtype(),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.CategoricalDtype(),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                pd.DatetimeTZDtype(tz=\"UTC\"),\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.DatetimeTZDtype(tz=\"UTC\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                \"datetime64[ns]\",\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): np.dtype(\"datetime64[ns]\"),\n                },\n            ),\n            (\n                pd.to_datetime([\"2020-01-14 10:00\", \"2020-01-15 11:11\"]),\n                object,\n                {\n                    ((True,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"datetime64[ns]\"\n                    ),\n                    ((False,), (True, False), (True, False), (True, False),): np.dtype(\n                        \"O\"\n                    ),\n                },\n            ),\n            (\n                pd.period_range(\"1/1/2011\", freq=\"M\", periods=3),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.PeriodDtype(\"M\"),\n                },\n            ),\n            (\n                pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)]),\n                None,\n                {\n                    (\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                        (True, False),\n                    ): pd.IntervalDtype(\"int64\"),\n                },\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\"params\", product(*[(True, False)] * 4))\n    def test_convert_dtypes(self, data, maindtype, params, answerdict):\n        if maindtype is not None:\n            series = pd.Series(data, dtype=maindtype)\n        else:\n            series = pd.Series(data)\n        answers = {k: a for (kk, a) in answerdict.items() for k in product(*kk)}\n    \n        ns = series.convert_dtypes(*params)\n        expected_dtype = answers[tuple(params)]\n        expected = pd.Series(series.values, dtype=expected_dtype)\n        tm.assert_series_equal(ns, expected)\n    \n        # Test that it is a copy\n        copy = series.copy(deep=True)\n        if is_interval_dtype(ns.dtype) and ns.dtype.subtype.kind in [\"i\", \"u\"]:\n            msg = \"Cannot set float NaN to integer-backed IntervalArray\"\n            with pytest.raises(ValueError, match=msg):\n>               ns[ns.notna()] = np.nan",
            "\npandas/tests/series/methods/test_convert_dtypes.py:274: Failed"
        ]
    ],
    "2.1.3": [
        [
            {
                "value": "nan",
                "self.dtype": "interval[int64]",
                "self": "<IntervalArray>\n[(0, 1], (2, 3], (4, 5]]\nLength: 3, closed: right, dtype: interval[int64]",
                "key": "0",
                "self.left": "Int64Index([0, 2, 4], dtype='int64')",
                "self._left": "Int64Index([0, 2, 4], dtype='int64')",
                "self.right": "Int64Index([1, 3, 5], dtype='int64')",
                "self._right": "Int64Index([1, 3, 5], dtype='int64')"
            },
            {
                "needs_float_conversion": "True",
                "self.dtype": "interval[float64]",
                "self": "<IntervalArray>\n[nan, (2.0, 3.0], (4.0, 5.0]]\nLength: 3, closed: right, dtype: interval[float64]",
                "value_left": "nan",
                "value_right": "nan",
                "left": "Float64Index([nan, 2.0, 4.0], dtype='float64')",
                "self.left": "Float64Index([nan, 2.0, 4.0], dtype='float64')",
                "left.astype": "<bound method Float64Index.astype of Float64Index([nan, 2.0, 4.0], dtype='float64')>",
                "left.values": "array([nan,  2.,  4.])",
                "self._left": "Float64Index([nan, 2.0, 4.0], dtype='float64')",
                "right": "Float64Index([nan, 3.0, 5.0], dtype='float64')",
                "self.right": "Float64Index([nan, 3.0, 5.0], dtype='float64')",
                "right.astype": "<bound method Float64Index.astype of Float64Index([nan, 3.0, 5.0], dtype='float64')>",
                "right.values": "array([nan,  3.,  5.])",
                "self._right": "Float64Index([nan, 3.0, 5.0], dtype='float64')"
            }
        ],
        [
            {
                "value": "nan",
                "self.dtype": "interval[float64]",
                "self": "<IntervalArray>\n[(0.0, 1.0], (1.0, 2.0], (2.0, 3.0]]\nLength: 3, closed: right, dtype: interval[float64]",
                "key": "0",
                "self.left": "Float64Index([0.0, 1.0, 2.0], dtype='float64')",
                "self._left": "Float64Index([0.0, 1.0, 2.0], dtype='float64')",
                "self.right": "Float64Index([1.0, 2.0, 3.0], dtype='float64')",
                "self._right": "Float64Index([1.0, 2.0, 3.0], dtype='float64')"
            },
            {
                "needs_float_conversion": "False",
                "self": "<IntervalArray>\n[nan, (1.0, 2.0], (2.0, 3.0]]\nLength: 3, closed: right, dtype: interval[float64]",
                "value_left": "nan",
                "value_right": "nan",
                "left": "Float64Index([nan, 1.0, 2.0], dtype='float64')",
                "self.left": "Float64Index([nan, 1.0, 2.0], dtype='float64')",
                "left.astype": "<bound method Float64Index.astype of Float64Index([nan, 1.0, 2.0], dtype='float64')>",
                "left.values": "array([nan,  1.,  2.])",
                "self._left": "Float64Index([nan, 1.0, 2.0], dtype='float64')",
                "right": "Float64Index([nan, 2.0, 3.0], dtype='float64')",
                "self.right": "Float64Index([nan, 2.0, 3.0], dtype='float64')",
                "right.astype": "<bound method Float64Index.astype of Float64Index([nan, 2.0, 3.0], dtype='float64')>",
                "right.values": "array([nan,  2.,  3.])",
                "self._right": "Float64Index([nan, 2.0, 3.0], dtype='float64')"
            }
        ],
        [
            {
                "value": "nan",
                "self.dtype": "interval[timedelta64[ns]]",
                "self": "<IntervalArray>\n[(0 days 00:00:00, 1 days 00:00:00], (1 days 00:00:00, 2 days 00:00:00], (2 days 00:00:00, 3 days 00:00:00]]\nLength: 3, closed: right, dtype: interval[timedelta64[ns]]",
                "key": "0",
                "self.left": "TimedeltaIndex(['0 days', '1 days', '2 days'], dtype='timedelta64[ns]', freq='D')",
                "self._left": "TimedeltaIndex(['0 days', '1 days', '2 days'], dtype='timedelta64[ns]', freq='D')",
                "self.right": "TimedeltaIndex(['1 days', '2 days', '3 days'], dtype='timedelta64[ns]', freq='D')",
                "self._right": "TimedeltaIndex(['1 days', '2 days', '3 days'], dtype='timedelta64[ns]', freq='D')"
            },
            {
                "needs_float_conversion": "False",
                "value": "numpy.timedelta64('NaT')",
                "self": "<IntervalArray>\n[nan, (1 days 00:00:00, 2 days 00:00:00], (2 days 00:00:00, 3 days 00:00:00]]\nLength: 3, closed: right, dtype: interval[timedelta64[ns]]",
                "value_left": "numpy.timedelta64('NaT')",
                "value_right": "numpy.timedelta64('NaT')",
                "left": "TimedeltaIndex([NaT, '1 days', '2 days'], dtype='timedelta64[ns]', freq='D')",
                "self.left": "TimedeltaIndex([NaT, '1 days', '2 days'], dtype='timedelta64[ns]', freq='D')",
                "left.astype": "<bound method TimedeltaIndex.astype of TimedeltaIndex([NaT, '1 days', '2 days'], dtype='timedelta64[ns]', freq='D')>",
                "left.values": "array([          'NaT',  86400000000000, 172800000000000],\n      dtype='timedelta64[ns]')",
                "self._left": "TimedeltaIndex([NaT, '1 days', '2 days'], dtype='timedelta64[ns]', freq='D')",
                "right": "TimedeltaIndex([NaT, '2 days', '3 days'], dtype='timedelta64[ns]', freq='D')",
                "self.right": "TimedeltaIndex([NaT, '2 days', '3 days'], dtype='timedelta64[ns]', freq='D')",
                "right.astype": "<bound method TimedeltaIndex.astype of TimedeltaIndex([NaT, '2 days', '3 days'], dtype='timedelta64[ns]', freq='D')>",
                "right.values": "array([          'NaT', 172800000000000, 259200000000000],\n      dtype='timedelta64[ns]')",
                "self._right": "TimedeltaIndex([NaT, '2 days', '3 days'], dtype='timedelta64[ns]', freq='D')"
            }
        ],
        [
            {
                "value": "nan",
                "self.dtype": "interval[datetime64[ns]]",
                "self": "<IntervalArray>\n[(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03], (2017-01-03, 2017-01-04]]\nLength: 3, closed: right, dtype: interval[datetime64[ns]]",
                "key": "0",
                "self.left": "DatetimeIndex(['2017-01-01', '2017-01-02', '2017-01-03'], dtype='datetime64[ns]', freq='D')",
                "self._left": "DatetimeIndex(['2017-01-01', '2017-01-02', '2017-01-03'], dtype='datetime64[ns]', freq='D')",
                "self.right": "DatetimeIndex(['2017-01-02', '2017-01-03', '2017-01-04'], dtype='datetime64[ns]', freq='D')",
                "self._right": "DatetimeIndex(['2017-01-02', '2017-01-03', '2017-01-04'], dtype='datetime64[ns]', freq='D')"
            },
            {
                "needs_float_conversion": "False",
                "value": "numpy.datetime64('NaT')",
                "self": "<IntervalArray>\n[nan, (2017-01-02, 2017-01-03], (2017-01-03, 2017-01-04]]\nLength: 3, closed: right, dtype: interval[datetime64[ns]]",
                "value_left": "numpy.datetime64('NaT')",
                "value_right": "numpy.datetime64('NaT')",
                "left": "DatetimeIndex(['NaT', '2017-01-02', '2017-01-03'], dtype='datetime64[ns]', freq='D')",
                "self.left": "DatetimeIndex(['NaT', '2017-01-02', '2017-01-03'], dtype='datetime64[ns]', freq='D')",
                "left.astype": "<bound method ExtensionIndex.astype of DatetimeIndex(['NaT', '2017-01-02', '2017-01-03'], dtype='datetime64[ns]', freq='D')>",
                "left.values": "array([                          'NaT', '2017-01-02T00:00:00.000000000',\n       '2017-01-03T00:00:00.000000000'], dtype='datetime64[ns]')",
                "self._left": "DatetimeIndex(['NaT', '2017-01-02', '2017-01-03'], dtype='datetime64[ns]', freq='D')",
                "right": "DatetimeIndex(['NaT', '2017-01-03', '2017-01-04'], dtype='datetime64[ns]', freq='D')",
                "self.right": "DatetimeIndex(['NaT', '2017-01-03', '2017-01-04'], dtype='datetime64[ns]', freq='D')",
                "right.astype": "<bound method ExtensionIndex.astype of DatetimeIndex(['NaT', '2017-01-03', '2017-01-04'], dtype='datetime64[ns]', freq='D')>",
                "right.values": "array([                          'NaT', '2017-01-03T00:00:00.000000000',\n       '2017-01-04T00:00:00.000000000'], dtype='datetime64[ns]')",
                "self._right": "DatetimeIndex(['NaT', '2017-01-03', '2017-01-04'], dtype='datetime64[ns]', freq='D')"
            }
        ],
        [
            {
                "value": "nan",
                "self.dtype": "interval[datetime64[ns, US/Eastern]]",
                "self": "<IntervalArray>\n[(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03], (2017-01-03, 2017-01-04]]\nLength: 3, closed: right, dtype: interval[datetime64[ns, US/Eastern]]",
                "key": "0",
                "self.left": "DatetimeIndex(['2017-01-01 00:00:00-05:00', '2017-01-02 00:00:00-05:00',\n               '2017-01-03 00:00:00-05:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='D')",
                "self._left": "DatetimeIndex(['2017-01-01 00:00:00-05:00', '2017-01-02 00:00:00-05:00',\n               '2017-01-03 00:00:00-05:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='D')",
                "self.right": "DatetimeIndex(['2017-01-02 00:00:00-05:00', '2017-01-03 00:00:00-05:00',\n               '2017-01-04 00:00:00-05:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='D')",
                "self._right": "DatetimeIndex(['2017-01-02 00:00:00-05:00', '2017-01-03 00:00:00-05:00',\n               '2017-01-04 00:00:00-05:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='D')"
            },
            {
                "needs_float_conversion": "False",
                "value": "numpy.datetime64('NaT')",
                "self": "<IntervalArray>\n[nan, (2017-01-02, 2017-01-03], (2017-01-03, 2017-01-04]]\nLength: 3, closed: right, dtype: interval[datetime64[ns, US/Eastern]]",
                "value_left": "numpy.datetime64('NaT')",
                "value_right": "numpy.datetime64('NaT')",
                "left": "DatetimeIndex(['NaT', '2017-01-02 00:00:00-05:00',\n               '2017-01-03 00:00:00-05:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='D')",
                "self.left": "DatetimeIndex(['NaT', '2017-01-02 00:00:00-05:00',\n               '2017-01-03 00:00:00-05:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='D')",
                "left.astype": "<bound method ExtensionIndex.astype of DatetimeIndex(['NaT', '2017-01-02 00:00:00-05:00',\n               '2017-01-03 00:00:00-05:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='D')>",
                "left.values": "array([                          'NaT', '2017-01-02T05:00:00.000000000',\n       '2017-01-03T05:00:00.000000000'], dtype='datetime64[ns]')",
                "self._left": "DatetimeIndex(['NaT', '2017-01-02 00:00:00-05:00',\n               '2017-01-03 00:00:00-05:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='D')",
                "right": "DatetimeIndex(['NaT', '2017-01-03 00:00:00-05:00',\n               '2017-01-04 00:00:00-05:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='D')",
                "self.right": "DatetimeIndex(['NaT', '2017-01-03 00:00:00-05:00',\n               '2017-01-04 00:00:00-05:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='D')",
                "right.astype": "<bound method ExtensionIndex.astype of DatetimeIndex(['NaT', '2017-01-03 00:00:00-05:00',\n               '2017-01-04 00:00:00-05:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='D')>",
                "right.values": "array([                          'NaT', '2017-01-03T05:00:00.000000000',\n       '2017-01-04T05:00:00.000000000'], dtype='datetime64[ns]')",
                "self._right": "DatetimeIndex(['NaT', '2017-01-03 00:00:00-05:00',\n               '2017-01-04 00:00:00-05:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='D')"
            }
        ],
        [
            {
                "value": "nan",
                "self.dtype": "interval[int64]",
                "self": "<IntervalArray>\n[(0, 1], (1, 5]]\nLength: 2, closed: right, dtype: interval[int64]",
                "key": "array([ True,  True])",
                "self.left": "Int64Index([0, 1], dtype='int64')",
                "self._left": "Int64Index([0, 1], dtype='int64')",
                "self.right": "Int64Index([1, 5], dtype='int64')",
                "self._right": "Int64Index([1, 5], dtype='int64')"
            },
            {
                "needs_float_conversion": "True",
                "self.dtype": "interval[float64]",
                "self": "<IntervalArray>\n[nan, nan]\nLength: 2, closed: right, dtype: interval[float64]",
                "value_left": "nan",
                "value_right": "nan",
                "left": "Float64Index([nan, nan], dtype='float64')",
                "self.left": "Float64Index([nan, nan], dtype='float64')",
                "left.astype": "<bound method Float64Index.astype of Float64Index([nan, nan], dtype='float64')>",
                "left.values": "array([nan, nan])",
                "self._left": "Float64Index([nan, nan], dtype='float64')",
                "right": "Float64Index([nan, nan], dtype='float64')",
                "self.right": "Float64Index([nan, nan], dtype='float64')",
                "right.astype": "<bound method Float64Index.astype of Float64Index([nan, nan], dtype='float64')>",
                "right.values": "array([nan, nan])",
                "self._right": "Float64Index([nan, nan], dtype='float64')"
            }
        ],
        [
            {
                "value": "nan",
                "self.dtype": "interval[int64]",
                "self": "<IntervalArray>\n[(0, 1], (1, 5]]\nLength: 2, closed: right, dtype: interval[int64]",
                "key": "array([ True,  True])",
                "self.left": "Int64Index([0, 1], dtype='int64')",
                "self._left": "Int64Index([0, 1], dtype='int64')",
                "self.right": "Int64Index([1, 5], dtype='int64')",
                "self._right": "Int64Index([1, 5], dtype='int64')"
            },
            {
                "needs_float_conversion": "True",
                "self.dtype": "interval[float64]",
                "self": "<IntervalArray>\n[nan, nan]\nLength: 2, closed: right, dtype: interval[float64]",
                "value_left": "nan",
                "value_right": "nan",
                "left": "Float64Index([nan, nan], dtype='float64')",
                "self.left": "Float64Index([nan, nan], dtype='float64')",
                "left.astype": "<bound method Float64Index.astype of Float64Index([nan, nan], dtype='float64')>",
                "left.values": "array([nan, nan])",
                "self._left": "Float64Index([nan, nan], dtype='float64')",
                "right": "Float64Index([nan, nan], dtype='float64')",
                "self.right": "Float64Index([nan, nan], dtype='float64')",
                "right.astype": "<bound method Float64Index.astype of Float64Index([nan, nan], dtype='float64')>",
                "right.values": "array([nan, nan])",
                "self._right": "Float64Index([nan, nan], dtype='float64')"
            }
        ],
        [
            {
                "value": "nan",
                "self.dtype": "interval[int64]",
                "self": "<IntervalArray>\n[(0, 1], (1, 5]]\nLength: 2, closed: right, dtype: interval[int64]",
                "key": "array([ True,  True])",
                "self.left": "Int64Index([0, 1], dtype='int64')",
                "self._left": "Int64Index([0, 1], dtype='int64')",
                "self.right": "Int64Index([1, 5], dtype='int64')",
                "self._right": "Int64Index([1, 5], dtype='int64')"
            },
            {
                "needs_float_conversion": "True",
                "self.dtype": "interval[float64]",
                "self": "<IntervalArray>\n[nan, nan]\nLength: 2, closed: right, dtype: interval[float64]",
                "value_left": "nan",
                "value_right": "nan",
                "left": "Float64Index([nan, nan], dtype='float64')",
                "self.left": "Float64Index([nan, nan], dtype='float64')",
                "left.astype": "<bound method Float64Index.astype of Float64Index([nan, nan], dtype='float64')>",
                "left.values": "array([nan, nan])",
                "self._left": "Float64Index([nan, nan], dtype='float64')",
                "right": "Float64Index([nan, nan], dtype='float64')",
                "self.right": "Float64Index([nan, nan], dtype='float64')",
                "right.astype": "<bound method Float64Index.astype of Float64Index([nan, nan], dtype='float64')>",
                "right.values": "array([nan, nan])",
                "self._right": "Float64Index([nan, nan], dtype='float64')"
            }
        ],
        [
            {
                "value": "nan",
                "self.dtype": "interval[int64]",
                "self": "<IntervalArray>\n[(0, 1], (1, 5]]\nLength: 2, closed: right, dtype: interval[int64]",
                "key": "array([ True,  True])",
                "self.left": "Int64Index([0, 1], dtype='int64')",
                "self._left": "Int64Index([0, 1], dtype='int64')",
                "self.right": "Int64Index([1, 5], dtype='int64')",
                "self._right": "Int64Index([1, 5], dtype='int64')"
            },
            {
                "needs_float_conversion": "True",
                "self.dtype": "interval[float64]",
                "self": "<IntervalArray>\n[nan, nan]\nLength: 2, closed: right, dtype: interval[float64]",
                "value_left": "nan",
                "value_right": "nan",
                "left": "Float64Index([nan, nan], dtype='float64')",
                "self.left": "Float64Index([nan, nan], dtype='float64')",
                "left.astype": "<bound method Float64Index.astype of Float64Index([nan, nan], dtype='float64')>",
                "left.values": "array([nan, nan])",
                "self._left": "Float64Index([nan, nan], dtype='float64')",
                "right": "Float64Index([nan, nan], dtype='float64')",
                "self.right": "Float64Index([nan, nan], dtype='float64')",
                "right.astype": "<bound method Float64Index.astype of Float64Index([nan, nan], dtype='float64')>",
                "right.values": "array([nan, nan])",
                "self._right": "Float64Index([nan, nan], dtype='float64')"
            }
        ],
        [
            {
                "value": "nan",
                "self.dtype": "interval[int64]",
                "self": "<IntervalArray>\n[(0, 1], (1, 5]]\nLength: 2, closed: right, dtype: interval[int64]",
                "key": "array([ True,  True])",
                "self.left": "Int64Index([0, 1], dtype='int64')",
                "self._left": "Int64Index([0, 1], dtype='int64')",
                "self.right": "Int64Index([1, 5], dtype='int64')",
                "self._right": "Int64Index([1, 5], dtype='int64')"
            },
            {
                "needs_float_conversion": "True",
                "self.dtype": "interval[float64]",
                "self": "<IntervalArray>\n[nan, nan]\nLength: 2, closed: right, dtype: interval[float64]",
                "value_left": "nan",
                "value_right": "nan",
                "left": "Float64Index([nan, nan], dtype='float64')",
                "self.left": "Float64Index([nan, nan], dtype='float64')",
                "left.astype": "<bound method Float64Index.astype of Float64Index([nan, nan], dtype='float64')>",
                "left.values": "array([nan, nan])",
                "self._left": "Float64Index([nan, nan], dtype='float64')",
                "right": "Float64Index([nan, nan], dtype='float64')",
                "self.right": "Float64Index([nan, nan], dtype='float64')",
                "right.astype": "<bound method Float64Index.astype of Float64Index([nan, nan], dtype='float64')>",
                "right.values": "array([nan, nan])",
                "self._right": "Float64Index([nan, nan], dtype='float64')"
            }
        ],
        [
            {
                "value": "nan",
                "self.dtype": "interval[int64]",
                "self": "<IntervalArray>\n[(0, 1], (1, 5]]\nLength: 2, closed: right, dtype: interval[int64]",
                "key": "array([ True,  True])",
                "self.left": "Int64Index([0, 1], dtype='int64')",
                "self._left": "Int64Index([0, 1], dtype='int64')",
                "self.right": "Int64Index([1, 5], dtype='int64')",
                "self._right": "Int64Index([1, 5], dtype='int64')"
            },
            {
                "needs_float_conversion": "True",
                "self.dtype": "interval[float64]",
                "self": "<IntervalArray>\n[nan, nan]\nLength: 2, closed: right, dtype: interval[float64]",
                "value_left": "nan",
                "value_right": "nan",
                "left": "Float64Index([nan, nan], dtype='float64')",
                "self.left": "Float64Index([nan, nan], dtype='float64')",
                "left.astype": "<bound method Float64Index.astype of Float64Index([nan, nan], dtype='float64')>",
                "left.values": "array([nan, nan])",
                "self._left": "Float64Index([nan, nan], dtype='float64')",
                "right": "Float64Index([nan, nan], dtype='float64')",
                "self.right": "Float64Index([nan, nan], dtype='float64')",
                "right.astype": "<bound method Float64Index.astype of Float64Index([nan, nan], dtype='float64')>",
                "right.values": "array([nan, nan])",
                "self._right": "Float64Index([nan, nan], dtype='float64')"
            }
        ],
        [
            {
                "value": "nan",
                "self.dtype": "interval[int64]",
                "self": "<IntervalArray>\n[(0, 1], (1, 5]]\nLength: 2, closed: right, dtype: interval[int64]",
                "key": "array([ True,  True])",
                "self.left": "Int64Index([0, 1], dtype='int64')",
                "self._left": "Int64Index([0, 1], dtype='int64')",
                "self.right": "Int64Index([1, 5], dtype='int64')",
                "self._right": "Int64Index([1, 5], dtype='int64')"
            },
            {
                "needs_float_conversion": "True",
                "self.dtype": "interval[float64]",
                "self": "<IntervalArray>\n[nan, nan]\nLength: 2, closed: right, dtype: interval[float64]",
                "value_left": "nan",
                "value_right": "nan",
                "left": "Float64Index([nan, nan], dtype='float64')",
                "self.left": "Float64Index([nan, nan], dtype='float64')",
                "left.astype": "<bound method Float64Index.astype of Float64Index([nan, nan], dtype='float64')>",
                "left.values": "array([nan, nan])",
                "self._left": "Float64Index([nan, nan], dtype='float64')",
                "right": "Float64Index([nan, nan], dtype='float64')",
                "self.right": "Float64Index([nan, nan], dtype='float64')",
                "right.astype": "<bound method Float64Index.astype of Float64Index([nan, nan], dtype='float64')>",
                "right.values": "array([nan, nan])",
                "self._right": "Float64Index([nan, nan], dtype='float64')"
            }
        ],
        [
            {
                "value": "nan",
                "self.dtype": "interval[int64]",
                "self": "<IntervalArray>\n[(0, 1], (1, 5]]\nLength: 2, closed: right, dtype: interval[int64]",
                "key": "array([ True,  True])",
                "self.left": "Int64Index([0, 1], dtype='int64')",
                "self._left": "Int64Index([0, 1], dtype='int64')",
                "self.right": "Int64Index([1, 5], dtype='int64')",
                "self._right": "Int64Index([1, 5], dtype='int64')"
            },
            {
                "needs_float_conversion": "True",
                "self.dtype": "interval[float64]",
                "self": "<IntervalArray>\n[nan, nan]\nLength: 2, closed: right, dtype: interval[float64]",
                "value_left": "nan",
                "value_right": "nan",
                "left": "Float64Index([nan, nan], dtype='float64')",
                "self.left": "Float64Index([nan, nan], dtype='float64')",
                "left.astype": "<bound method Float64Index.astype of Float64Index([nan, nan], dtype='float64')>",
                "left.values": "array([nan, nan])",
                "self._left": "Float64Index([nan, nan], dtype='float64')",
                "right": "Float64Index([nan, nan], dtype='float64')",
                "self.right": "Float64Index([nan, nan], dtype='float64')",
                "right.astype": "<bound method Float64Index.astype of Float64Index([nan, nan], dtype='float64')>",
                "right.values": "array([nan, nan])",
                "self._right": "Float64Index([nan, nan], dtype='float64')"
            }
        ],
        [
            {
                "value": "nan",
                "self.dtype": "interval[int64]",
                "self": "<IntervalArray>\n[(0, 1], (1, 5]]\nLength: 2, closed: right, dtype: interval[int64]",
                "key": "array([ True,  True])",
                "self.left": "Int64Index([0, 1], dtype='int64')",
                "self._left": "Int64Index([0, 1], dtype='int64')",
                "self.right": "Int64Index([1, 5], dtype='int64')",
                "self._right": "Int64Index([1, 5], dtype='int64')"
            },
            {
                "needs_float_conversion": "True",
                "self.dtype": "interval[float64]",
                "self": "<IntervalArray>\n[nan, nan]\nLength: 2, closed: right, dtype: interval[float64]",
                "value_left": "nan",
                "value_right": "nan",
                "left": "Float64Index([nan, nan], dtype='float64')",
                "self.left": "Float64Index([nan, nan], dtype='float64')",
                "left.astype": "<bound method Float64Index.astype of Float64Index([nan, nan], dtype='float64')>",
                "left.values": "array([nan, nan])",
                "self._left": "Float64Index([nan, nan], dtype='float64')",
                "right": "Float64Index([nan, nan], dtype='float64')",
                "self.right": "Float64Index([nan, nan], dtype='float64')",
                "right.astype": "<bound method Float64Index.astype of Float64Index([nan, nan], dtype='float64')>",
                "right.values": "array([nan, nan])",
                "self._right": "Float64Index([nan, nan], dtype='float64')"
            }
        ],
        [
            {
                "value": "nan",
                "self.dtype": "interval[int64]",
                "self": "<IntervalArray>\n[(0, 1], (1, 5]]\nLength: 2, closed: right, dtype: interval[int64]",
                "key": "array([ True,  True])",
                "self.left": "Int64Index([0, 1], dtype='int64')",
                "self._left": "Int64Index([0, 1], dtype='int64')",
                "self.right": "Int64Index([1, 5], dtype='int64')",
                "self._right": "Int64Index([1, 5], dtype='int64')"
            },
            {
                "needs_float_conversion": "True",
                "self.dtype": "interval[float64]",
                "self": "<IntervalArray>\n[nan, nan]\nLength: 2, closed: right, dtype: interval[float64]",
                "value_left": "nan",
                "value_right": "nan",
                "left": "Float64Index([nan, nan], dtype='float64')",
                "self.left": "Float64Index([nan, nan], dtype='float64')",
                "left.astype": "<bound method Float64Index.astype of Float64Index([nan, nan], dtype='float64')>",
                "left.values": "array([nan, nan])",
                "self._left": "Float64Index([nan, nan], dtype='float64')",
                "right": "Float64Index([nan, nan], dtype='float64')",
                "self.right": "Float64Index([nan, nan], dtype='float64')",
                "right.astype": "<bound method Float64Index.astype of Float64Index([nan, nan], dtype='float64')>",
                "right.values": "array([nan, nan])",
                "self._right": "Float64Index([nan, nan], dtype='float64')"
            }
        ],
        [
            {
                "value": "nan",
                "self.dtype": "interval[int64]",
                "self": "<IntervalArray>\n[(0, 1], (1, 5]]\nLength: 2, closed: right, dtype: interval[int64]",
                "key": "array([ True,  True])",
                "self.left": "Int64Index([0, 1], dtype='int64')",
                "self._left": "Int64Index([0, 1], dtype='int64')",
                "self.right": "Int64Index([1, 5], dtype='int64')",
                "self._right": "Int64Index([1, 5], dtype='int64')"
            },
            {
                "needs_float_conversion": "True",
                "self.dtype": "interval[float64]",
                "self": "<IntervalArray>\n[nan, nan]\nLength: 2, closed: right, dtype: interval[float64]",
                "value_left": "nan",
                "value_right": "nan",
                "left": "Float64Index([nan, nan], dtype='float64')",
                "self.left": "Float64Index([nan, nan], dtype='float64')",
                "left.astype": "<bound method Float64Index.astype of Float64Index([nan, nan], dtype='float64')>",
                "left.values": "array([nan, nan])",
                "self._left": "Float64Index([nan, nan], dtype='float64')",
                "right": "Float64Index([nan, nan], dtype='float64')",
                "self.right": "Float64Index([nan, nan], dtype='float64')",
                "right.astype": "<bound method Float64Index.astype of Float64Index([nan, nan], dtype='float64')>",
                "right.values": "array([nan, nan])",
                "self._right": "Float64Index([nan, nan], dtype='float64')"
            }
        ],
        [
            {
                "value": "nan",
                "self.dtype": "interval[int64]",
                "self": "<IntervalArray>\n[(0, 1], (1, 5]]\nLength: 2, closed: right, dtype: interval[int64]",
                "key": "array([ True,  True])",
                "self.left": "Int64Index([0, 1], dtype='int64')",
                "self._left": "Int64Index([0, 1], dtype='int64')",
                "self.right": "Int64Index([1, 5], dtype='int64')",
                "self._right": "Int64Index([1, 5], dtype='int64')"
            },
            {
                "needs_float_conversion": "True",
                "self.dtype": "interval[float64]",
                "self": "<IntervalArray>\n[nan, nan]\nLength: 2, closed: right, dtype: interval[float64]",
                "value_left": "nan",
                "value_right": "nan",
                "left": "Float64Index([nan, nan], dtype='float64')",
                "self.left": "Float64Index([nan, nan], dtype='float64')",
                "left.astype": "<bound method Float64Index.astype of Float64Index([nan, nan], dtype='float64')>",
                "left.values": "array([nan, nan])",
                "self._left": "Float64Index([nan, nan], dtype='float64')",
                "right": "Float64Index([nan, nan], dtype='float64')",
                "self.right": "Float64Index([nan, nan], dtype='float64')",
                "right.astype": "<bound method Float64Index.astype of Float64Index([nan, nan], dtype='float64')>",
                "right.values": "array([nan, nan])",
                "self._right": "Float64Index([nan, nan], dtype='float64')"
            }
        ],
        [
            {
                "value": "nan",
                "self.dtype": "interval[int64]",
                "self": "<IntervalArray>\n[(0, 1], (1, 5]]\nLength: 2, closed: right, dtype: interval[int64]",
                "key": "array([ True,  True])",
                "self.left": "Int64Index([0, 1], dtype='int64')",
                "self._left": "Int64Index([0, 1], dtype='int64')",
                "self.right": "Int64Index([1, 5], dtype='int64')",
                "self._right": "Int64Index([1, 5], dtype='int64')"
            },
            {
                "needs_float_conversion": "True",
                "self.dtype": "interval[float64]",
                "self": "<IntervalArray>\n[nan, nan]\nLength: 2, closed: right, dtype: interval[float64]",
                "value_left": "nan",
                "value_right": "nan",
                "left": "Float64Index([nan, nan], dtype='float64')",
                "self.left": "Float64Index([nan, nan], dtype='float64')",
                "left.astype": "<bound method Float64Index.astype of Float64Index([nan, nan], dtype='float64')>",
                "left.values": "array([nan, nan])",
                "self._left": "Float64Index([nan, nan], dtype='float64')",
                "right": "Float64Index([nan, nan], dtype='float64')",
                "self.right": "Float64Index([nan, nan], dtype='float64')",
                "right.astype": "<bound method Float64Index.astype of Float64Index([nan, nan], dtype='float64')>",
                "right.values": "array([nan, nan])",
                "self._right": "Float64Index([nan, nan], dtype='float64')"
            }
        ],
        [
            {
                "value": "nan",
                "self.dtype": "interval[int64]",
                "self": "<IntervalArray>\n[(0, 1], (1, 5]]\nLength: 2, closed: right, dtype: interval[int64]",
                "key": "array([ True,  True])",
                "self.left": "Int64Index([0, 1], dtype='int64')",
                "self._left": "Int64Index([0, 1], dtype='int64')",
                "self.right": "Int64Index([1, 5], dtype='int64')",
                "self._right": "Int64Index([1, 5], dtype='int64')"
            },
            {
                "needs_float_conversion": "True",
                "self.dtype": "interval[float64]",
                "self": "<IntervalArray>\n[nan, nan]\nLength: 2, closed: right, dtype: interval[float64]",
                "value_left": "nan",
                "value_right": "nan",
                "left": "Float64Index([nan, nan], dtype='float64')",
                "self.left": "Float64Index([nan, nan], dtype='float64')",
                "left.astype": "<bound method Float64Index.astype of Float64Index([nan, nan], dtype='float64')>",
                "left.values": "array([nan, nan])",
                "self._left": "Float64Index([nan, nan], dtype='float64')",
                "right": "Float64Index([nan, nan], dtype='float64')",
                "self.right": "Float64Index([nan, nan], dtype='float64')",
                "right.astype": "<bound method Float64Index.astype of Float64Index([nan, nan], dtype='float64')>",
                "right.values": "array([nan, nan])",
                "self._right": "Float64Index([nan, nan], dtype='float64')"
            }
        ],
        [
            {
                "value": "nan",
                "self.dtype": "interval[int64]",
                "self": "<IntervalArray>\n[(0, 1], (1, 5]]\nLength: 2, closed: right, dtype: interval[int64]",
                "key": "array([ True,  True])",
                "self.left": "Int64Index([0, 1], dtype='int64')",
                "self._left": "Int64Index([0, 1], dtype='int64')",
                "self.right": "Int64Index([1, 5], dtype='int64')",
                "self._right": "Int64Index([1, 5], dtype='int64')"
            },
            {
                "needs_float_conversion": "True",
                "self.dtype": "interval[float64]",
                "self": "<IntervalArray>\n[nan, nan]\nLength: 2, closed: right, dtype: interval[float64]",
                "value_left": "nan",
                "value_right": "nan",
                "left": "Float64Index([nan, nan], dtype='float64')",
                "self.left": "Float64Index([nan, nan], dtype='float64')",
                "left.astype": "<bound method Float64Index.astype of Float64Index([nan, nan], dtype='float64')>",
                "left.values": "array([nan, nan])",
                "self._left": "Float64Index([nan, nan], dtype='float64')",
                "right": "Float64Index([nan, nan], dtype='float64')",
                "self.right": "Float64Index([nan, nan], dtype='float64')",
                "right.astype": "<bound method Float64Index.astype of Float64Index([nan, nan], dtype='float64')>",
                "right.values": "array([nan, nan])",
                "self._right": "Float64Index([nan, nan], dtype='float64')"
            }
        ],
        [
            {
                "value": "nan",
                "self.dtype": "interval[int64]",
                "self": "<IntervalArray>\n[(0, 1], (1, 5]]\nLength: 2, closed: right, dtype: interval[int64]",
                "key": "array([ True,  True])",
                "self.left": "Int64Index([0, 1], dtype='int64')",
                "self._left": "Int64Index([0, 1], dtype='int64')",
                "self.right": "Int64Index([1, 5], dtype='int64')",
                "self._right": "Int64Index([1, 5], dtype='int64')"
            },
            {
                "needs_float_conversion": "True",
                "self.dtype": "interval[float64]",
                "self": "<IntervalArray>\n[nan, nan]\nLength: 2, closed: right, dtype: interval[float64]",
                "value_left": "nan",
                "value_right": "nan",
                "left": "Float64Index([nan, nan], dtype='float64')",
                "self.left": "Float64Index([nan, nan], dtype='float64')",
                "left.astype": "<bound method Float64Index.astype of Float64Index([nan, nan], dtype='float64')>",
                "left.values": "array([nan, nan])",
                "self._left": "Float64Index([nan, nan], dtype='float64')",
                "right": "Float64Index([nan, nan], dtype='float64')",
                "self.right": "Float64Index([nan, nan], dtype='float64')",
                "right.astype": "<bound method Float64Index.astype of Float64Index([nan, nan], dtype='float64')>",
                "right.values": "array([nan, nan])",
                "self._right": "Float64Index([nan, nan], dtype='float64')"
            }
        ]
    ],
    "2.1.4": [
        [
            {
                "value": "float",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "key": "int",
                "self.left": "Int64Index",
                "self._left": "Int64Index",
                "self.right": "Int64Index",
                "self._right": "Int64Index"
            },
            {
                "needs_float_conversion": "bool",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "value_left": "float",
                "value_right": "float",
                "left": "Float64Index",
                "self.left": "Float64Index",
                "left.astype": "method",
                "left.values": "ndarray",
                "self._left": "Float64Index",
                "right": "Float64Index",
                "self.right": "Float64Index",
                "right.astype": "method",
                "right.values": "ndarray",
                "self._right": "Float64Index"
            }
        ],
        [
            {
                "value": "float",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "key": "int",
                "self.left": "Float64Index",
                "self._left": "Float64Index",
                "self.right": "Float64Index",
                "self._right": "Float64Index"
            },
            {
                "needs_float_conversion": "bool",
                "self": "IntervalArray",
                "value_left": "float",
                "value_right": "float",
                "left": "Float64Index",
                "self.left": "Float64Index",
                "left.astype": "method",
                "left.values": "ndarray",
                "self._left": "Float64Index",
                "right": "Float64Index",
                "self.right": "Float64Index",
                "right.astype": "method",
                "right.values": "ndarray",
                "self._right": "Float64Index"
            }
        ],
        [
            {
                "value": "float",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "key": "int",
                "self.left": "TimedeltaIndex",
                "self._left": "TimedeltaIndex",
                "self.right": "TimedeltaIndex",
                "self._right": "TimedeltaIndex"
            },
            {
                "needs_float_conversion": "bool",
                "value": "timedelta64",
                "self": "IntervalArray",
                "value_left": "timedelta64",
                "value_right": "timedelta64",
                "left": "TimedeltaIndex",
                "self.left": "TimedeltaIndex",
                "left.astype": "method",
                "left.values": "ndarray",
                "self._left": "TimedeltaIndex",
                "right": "TimedeltaIndex",
                "self.right": "TimedeltaIndex",
                "right.astype": "method",
                "right.values": "ndarray",
                "self._right": "TimedeltaIndex"
            }
        ],
        [
            {
                "value": "float",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "key": "int",
                "self.left": "DatetimeIndex",
                "self._left": "DatetimeIndex",
                "self.right": "DatetimeIndex",
                "self._right": "DatetimeIndex"
            },
            {
                "needs_float_conversion": "bool",
                "value": "datetime64",
                "self": "IntervalArray",
                "value_left": "datetime64",
                "value_right": "datetime64",
                "left": "DatetimeIndex",
                "self.left": "DatetimeIndex",
                "left.astype": "method",
                "left.values": "ndarray",
                "self._left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "self.right": "DatetimeIndex",
                "right.astype": "method",
                "right.values": "ndarray",
                "self._right": "DatetimeIndex"
            }
        ],
        [
            {
                "value": "float",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "key": "int",
                "self.left": "DatetimeIndex",
                "self._left": "DatetimeIndex",
                "self.right": "DatetimeIndex",
                "self._right": "DatetimeIndex"
            },
            {
                "needs_float_conversion": "bool",
                "value": "datetime64",
                "self": "IntervalArray",
                "value_left": "datetime64",
                "value_right": "datetime64",
                "left": "DatetimeIndex",
                "self.left": "DatetimeIndex",
                "left.astype": "method",
                "left.values": "ndarray",
                "self._left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "self.right": "DatetimeIndex",
                "right.astype": "method",
                "right.values": "ndarray",
                "self._right": "DatetimeIndex"
            }
        ],
        [
            {
                "value": "float",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "key": "ndarray",
                "self.left": "Int64Index",
                "self._left": "Int64Index",
                "self.right": "Int64Index",
                "self._right": "Int64Index"
            },
            {
                "needs_float_conversion": "bool",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "value_left": "float",
                "value_right": "float",
                "left": "Float64Index",
                "self.left": "Float64Index",
                "left.astype": "method",
                "left.values": "ndarray",
                "self._left": "Float64Index",
                "right": "Float64Index",
                "self.right": "Float64Index",
                "right.astype": "method",
                "right.values": "ndarray",
                "self._right": "Float64Index"
            }
        ],
        [
            {
                "value": "float",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "key": "ndarray",
                "self.left": "Int64Index",
                "self._left": "Int64Index",
                "self.right": "Int64Index",
                "self._right": "Int64Index"
            },
            {
                "needs_float_conversion": "bool",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "value_left": "float",
                "value_right": "float",
                "left": "Float64Index",
                "self.left": "Float64Index",
                "left.astype": "method",
                "left.values": "ndarray",
                "self._left": "Float64Index",
                "right": "Float64Index",
                "self.right": "Float64Index",
                "right.astype": "method",
                "right.values": "ndarray",
                "self._right": "Float64Index"
            }
        ],
        [
            {
                "value": "float",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "key": "ndarray",
                "self.left": "Int64Index",
                "self._left": "Int64Index",
                "self.right": "Int64Index",
                "self._right": "Int64Index"
            },
            {
                "needs_float_conversion": "bool",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "value_left": "float",
                "value_right": "float",
                "left": "Float64Index",
                "self.left": "Float64Index",
                "left.astype": "method",
                "left.values": "ndarray",
                "self._left": "Float64Index",
                "right": "Float64Index",
                "self.right": "Float64Index",
                "right.astype": "method",
                "right.values": "ndarray",
                "self._right": "Float64Index"
            }
        ],
        [
            {
                "value": "float",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "key": "ndarray",
                "self.left": "Int64Index",
                "self._left": "Int64Index",
                "self.right": "Int64Index",
                "self._right": "Int64Index"
            },
            {
                "needs_float_conversion": "bool",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "value_left": "float",
                "value_right": "float",
                "left": "Float64Index",
                "self.left": "Float64Index",
                "left.astype": "method",
                "left.values": "ndarray",
                "self._left": "Float64Index",
                "right": "Float64Index",
                "self.right": "Float64Index",
                "right.astype": "method",
                "right.values": "ndarray",
                "self._right": "Float64Index"
            }
        ],
        [
            {
                "value": "float",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "key": "ndarray",
                "self.left": "Int64Index",
                "self._left": "Int64Index",
                "self.right": "Int64Index",
                "self._right": "Int64Index"
            },
            {
                "needs_float_conversion": "bool",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "value_left": "float",
                "value_right": "float",
                "left": "Float64Index",
                "self.left": "Float64Index",
                "left.astype": "method",
                "left.values": "ndarray",
                "self._left": "Float64Index",
                "right": "Float64Index",
                "self.right": "Float64Index",
                "right.astype": "method",
                "right.values": "ndarray",
                "self._right": "Float64Index"
            }
        ],
        [
            {
                "value": "float",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "key": "ndarray",
                "self.left": "Int64Index",
                "self._left": "Int64Index",
                "self.right": "Int64Index",
                "self._right": "Int64Index"
            },
            {
                "needs_float_conversion": "bool",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "value_left": "float",
                "value_right": "float",
                "left": "Float64Index",
                "self.left": "Float64Index",
                "left.astype": "method",
                "left.values": "ndarray",
                "self._left": "Float64Index",
                "right": "Float64Index",
                "self.right": "Float64Index",
                "right.astype": "method",
                "right.values": "ndarray",
                "self._right": "Float64Index"
            }
        ],
        [
            {
                "value": "float",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "key": "ndarray",
                "self.left": "Int64Index",
                "self._left": "Int64Index",
                "self.right": "Int64Index",
                "self._right": "Int64Index"
            },
            {
                "needs_float_conversion": "bool",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "value_left": "float",
                "value_right": "float",
                "left": "Float64Index",
                "self.left": "Float64Index",
                "left.astype": "method",
                "left.values": "ndarray",
                "self._left": "Float64Index",
                "right": "Float64Index",
                "self.right": "Float64Index",
                "right.astype": "method",
                "right.values": "ndarray",
                "self._right": "Float64Index"
            }
        ],
        [
            {
                "value": "float",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "key": "ndarray",
                "self.left": "Int64Index",
                "self._left": "Int64Index",
                "self.right": "Int64Index",
                "self._right": "Int64Index"
            },
            {
                "needs_float_conversion": "bool",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "value_left": "float",
                "value_right": "float",
                "left": "Float64Index",
                "self.left": "Float64Index",
                "left.astype": "method",
                "left.values": "ndarray",
                "self._left": "Float64Index",
                "right": "Float64Index",
                "self.right": "Float64Index",
                "right.astype": "method",
                "right.values": "ndarray",
                "self._right": "Float64Index"
            }
        ],
        [
            {
                "value": "float",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "key": "ndarray",
                "self.left": "Int64Index",
                "self._left": "Int64Index",
                "self.right": "Int64Index",
                "self._right": "Int64Index"
            },
            {
                "needs_float_conversion": "bool",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "value_left": "float",
                "value_right": "float",
                "left": "Float64Index",
                "self.left": "Float64Index",
                "left.astype": "method",
                "left.values": "ndarray",
                "self._left": "Float64Index",
                "right": "Float64Index",
                "self.right": "Float64Index",
                "right.astype": "method",
                "right.values": "ndarray",
                "self._right": "Float64Index"
            }
        ],
        [
            {
                "value": "float",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "key": "ndarray",
                "self.left": "Int64Index",
                "self._left": "Int64Index",
                "self.right": "Int64Index",
                "self._right": "Int64Index"
            },
            {
                "needs_float_conversion": "bool",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "value_left": "float",
                "value_right": "float",
                "left": "Float64Index",
                "self.left": "Float64Index",
                "left.astype": "method",
                "left.values": "ndarray",
                "self._left": "Float64Index",
                "right": "Float64Index",
                "self.right": "Float64Index",
                "right.astype": "method",
                "right.values": "ndarray",
                "self._right": "Float64Index"
            }
        ],
        [
            {
                "value": "float",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "key": "ndarray",
                "self.left": "Int64Index",
                "self._left": "Int64Index",
                "self.right": "Int64Index",
                "self._right": "Int64Index"
            },
            {
                "needs_float_conversion": "bool",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "value_left": "float",
                "value_right": "float",
                "left": "Float64Index",
                "self.left": "Float64Index",
                "left.astype": "method",
                "left.values": "ndarray",
                "self._left": "Float64Index",
                "right": "Float64Index",
                "self.right": "Float64Index",
                "right.astype": "method",
                "right.values": "ndarray",
                "self._right": "Float64Index"
            }
        ],
        [
            {
                "value": "float",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "key": "ndarray",
                "self.left": "Int64Index",
                "self._left": "Int64Index",
                "self.right": "Int64Index",
                "self._right": "Int64Index"
            },
            {
                "needs_float_conversion": "bool",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "value_left": "float",
                "value_right": "float",
                "left": "Float64Index",
                "self.left": "Float64Index",
                "left.astype": "method",
                "left.values": "ndarray",
                "self._left": "Float64Index",
                "right": "Float64Index",
                "self.right": "Float64Index",
                "right.astype": "method",
                "right.values": "ndarray",
                "self._right": "Float64Index"
            }
        ],
        [
            {
                "value": "float",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "key": "ndarray",
                "self.left": "Int64Index",
                "self._left": "Int64Index",
                "self.right": "Int64Index",
                "self._right": "Int64Index"
            },
            {
                "needs_float_conversion": "bool",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "value_left": "float",
                "value_right": "float",
                "left": "Float64Index",
                "self.left": "Float64Index",
                "left.astype": "method",
                "left.values": "ndarray",
                "self._left": "Float64Index",
                "right": "Float64Index",
                "self.right": "Float64Index",
                "right.astype": "method",
                "right.values": "ndarray",
                "self._right": "Float64Index"
            }
        ],
        [
            {
                "value": "float",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "key": "ndarray",
                "self.left": "Int64Index",
                "self._left": "Int64Index",
                "self.right": "Int64Index",
                "self._right": "Int64Index"
            },
            {
                "needs_float_conversion": "bool",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "value_left": "float",
                "value_right": "float",
                "left": "Float64Index",
                "self.left": "Float64Index",
                "left.astype": "method",
                "left.values": "ndarray",
                "self._left": "Float64Index",
                "right": "Float64Index",
                "self.right": "Float64Index",
                "right.astype": "method",
                "right.values": "ndarray",
                "self._right": "Float64Index"
            }
        ],
        [
            {
                "value": "float",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "key": "ndarray",
                "self.left": "Int64Index",
                "self._left": "Int64Index",
                "self.right": "Int64Index",
                "self._right": "Int64Index"
            },
            {
                "needs_float_conversion": "bool",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "value_left": "float",
                "value_right": "float",
                "left": "Float64Index",
                "self.left": "Float64Index",
                "left.astype": "method",
                "left.values": "ndarray",
                "self._left": "Float64Index",
                "right": "Float64Index",
                "self.right": "Float64Index",
                "right.astype": "method",
                "right.values": "ndarray",
                "self._right": "Float64Index"
            }
        ],
        [
            {
                "value": "float",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "key": "ndarray",
                "self.left": "Int64Index",
                "self._left": "Int64Index",
                "self.right": "Int64Index",
                "self._right": "Int64Index"
            },
            {
                "needs_float_conversion": "bool",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "value_left": "float",
                "value_right": "float",
                "left": "Float64Index",
                "self.left": "Float64Index",
                "left.astype": "method",
                "left.values": "ndarray",
                "self._left": "Float64Index",
                "right": "Float64Index",
                "self.right": "Float64Index",
                "right.astype": "method",
                "right.values": "ndarray",
                "self._right": "Float64Index"
            }
        ]
    ],
    "2.1.5": [
        [
            {
                "value": "nan",
                "self.dtype": "interval[float64]",
                "self": "<IntervalArray>\n[(0.0, 1.0], (1.0, 2.0], (2.0, 3.0]]\nLength: 3, closed: right, dtype: interval[float64]",
                "key": "0",
                "self.left": "Float64Index([0.0, 1.0, 2.0], dtype='float64')",
                "self._left": "Float64Index([0.0, 1.0, 2.0], dtype='float64')",
                "self.right": "Float64Index([1.0, 2.0, 3.0], dtype='float64')",
                "self._right": "Float64Index([1.0, 2.0, 3.0], dtype='float64')"
            },
            {
                "needs_float_conversion": "False",
                "self": "<IntervalArray>\n[nan, (1.0, 2.0], (2.0, 3.0]]\nLength: 3, closed: right, dtype: interval[float64]",
                "value_left": "nan",
                "value_right": "nan",
                "left": "Float64Index([nan, 1.0, 2.0], dtype='float64')",
                "self.left": "Float64Index([nan, 1.0, 2.0], dtype='float64')",
                "left._values": "array([nan,  1.,  2.])",
                "self._left": "Float64Index([nan, 1.0, 2.0], dtype='float64')",
                "right": "Float64Index([nan, 2.0, 3.0], dtype='float64')",
                "self.right": "Float64Index([nan, 2.0, 3.0], dtype='float64')",
                "right._values": "array([nan,  2.,  3.])",
                "self._right": "Float64Index([nan, 2.0, 3.0], dtype='float64')"
            }
        ],
        [
            {
                "value": "nan",
                "self.dtype": "interval[timedelta64[ns]]",
                "self": "<IntervalArray>\n[(0 days 00:00:00, 1 days 00:00:00], (1 days 00:00:00, 2 days 00:00:00], (2 days 00:00:00, 3 days 00:00:00]]\nLength: 3, closed: right, dtype: interval[timedelta64[ns]]",
                "key": "0",
                "self.left": "TimedeltaIndex(['0 days', '1 days', '2 days'], dtype='timedelta64[ns]', freq='D')",
                "self._left": "TimedeltaIndex(['0 days', '1 days', '2 days'], dtype='timedelta64[ns]', freq='D')",
                "self.right": "TimedeltaIndex(['1 days', '2 days', '3 days'], dtype='timedelta64[ns]', freq='D')",
                "self._right": "TimedeltaIndex(['1 days', '2 days', '3 days'], dtype='timedelta64[ns]', freq='D')"
            },
            {
                "needs_float_conversion": "False",
                "value": "numpy.timedelta64('NaT')",
                "self": "<IntervalArray>\n[nan, (1 days 00:00:00, 2 days 00:00:00], (2 days 00:00:00, 3 days 00:00:00]]\nLength: 3, closed: right, dtype: interval[timedelta64[ns]]",
                "value_left": "numpy.timedelta64('NaT')",
                "value_right": "numpy.timedelta64('NaT')",
                "left": "TimedeltaIndex([NaT, '1 days', '2 days'], dtype='timedelta64[ns]', freq=None)",
                "self.left": "TimedeltaIndex([NaT, '1 days', '2 days'], dtype='timedelta64[ns]', freq=None)",
                "left._values": "<TimedeltaArray>\n[NaT, '1 days', '2 days']\nLength: 3, dtype: timedelta64[ns]",
                "self._left": "TimedeltaIndex([NaT, '1 days', '2 days'], dtype='timedelta64[ns]', freq=None)",
                "right": "TimedeltaIndex([NaT, '2 days', '3 days'], dtype='timedelta64[ns]', freq=None)",
                "self.right": "TimedeltaIndex([NaT, '2 days', '3 days'], dtype='timedelta64[ns]', freq=None)",
                "right._values": "<TimedeltaArray>\n[NaT, '2 days', '3 days']\nLength: 3, dtype: timedelta64[ns]",
                "self._right": "TimedeltaIndex([NaT, '2 days', '3 days'], dtype='timedelta64[ns]', freq=None)"
            }
        ],
        [
            {
                "value": "nan",
                "self.dtype": "interval[datetime64[ns]]",
                "self": "<IntervalArray>\n[(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03], (2017-01-03, 2017-01-04]]\nLength: 3, closed: right, dtype: interval[datetime64[ns]]",
                "key": "0",
                "self.left": "DatetimeIndex(['2017-01-01', '2017-01-02', '2017-01-03'], dtype='datetime64[ns]', freq='D')",
                "self._left": "DatetimeIndex(['2017-01-01', '2017-01-02', '2017-01-03'], dtype='datetime64[ns]', freq='D')",
                "self.right": "DatetimeIndex(['2017-01-02', '2017-01-03', '2017-01-04'], dtype='datetime64[ns]', freq='D')",
                "self._right": "DatetimeIndex(['2017-01-02', '2017-01-03', '2017-01-04'], dtype='datetime64[ns]', freq='D')"
            },
            {
                "needs_float_conversion": "False",
                "value": "numpy.datetime64('NaT')",
                "self": "<IntervalArray>\n[nan, (2017-01-02, 2017-01-03], (2017-01-03, 2017-01-04]]\nLength: 3, closed: right, dtype: interval[datetime64[ns]]",
                "value_left": "numpy.datetime64('NaT')",
                "value_right": "numpy.datetime64('NaT')",
                "left": "DatetimeIndex(['NaT', '2017-01-02', '2017-01-03'], dtype='datetime64[ns]', freq=None)",
                "self.left": "DatetimeIndex(['NaT', '2017-01-02', '2017-01-03'], dtype='datetime64[ns]', freq=None)",
                "left._values": "<DatetimeArray>\n['NaT', '2017-01-02 00:00:00', '2017-01-03 00:00:00']\nLength: 3, dtype: datetime64[ns]",
                "self._left": "DatetimeIndex(['NaT', '2017-01-02', '2017-01-03'], dtype='datetime64[ns]', freq=None)",
                "right": "DatetimeIndex(['NaT', '2017-01-03', '2017-01-04'], dtype='datetime64[ns]', freq=None)",
                "self.right": "DatetimeIndex(['NaT', '2017-01-03', '2017-01-04'], dtype='datetime64[ns]', freq=None)",
                "right._values": "<DatetimeArray>\n['NaT', '2017-01-03 00:00:00', '2017-01-04 00:00:00']\nLength: 3, dtype: datetime64[ns]",
                "self._right": "DatetimeIndex(['NaT', '2017-01-03', '2017-01-04'], dtype='datetime64[ns]', freq=None)"
            }
        ],
        [
            {
                "value": "nan",
                "self.dtype": "interval[datetime64[ns, US/Eastern]]",
                "self": "<IntervalArray>\n[(2017-01-01, 2017-01-02], (2017-01-02, 2017-01-03], (2017-01-03, 2017-01-04]]\nLength: 3, closed: right, dtype: interval[datetime64[ns, US/Eastern]]",
                "key": "0",
                "self.left": "DatetimeIndex(['2017-01-01 00:00:00-05:00', '2017-01-02 00:00:00-05:00',\n               '2017-01-03 00:00:00-05:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='D')",
                "self._left": "DatetimeIndex(['2017-01-01 00:00:00-05:00', '2017-01-02 00:00:00-05:00',\n               '2017-01-03 00:00:00-05:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='D')",
                "self.right": "DatetimeIndex(['2017-01-02 00:00:00-05:00', '2017-01-03 00:00:00-05:00',\n               '2017-01-04 00:00:00-05:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='D')",
                "self._right": "DatetimeIndex(['2017-01-02 00:00:00-05:00', '2017-01-03 00:00:00-05:00',\n               '2017-01-04 00:00:00-05:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='D')"
            },
            {
                "needs_float_conversion": "False",
                "value": "numpy.datetime64('NaT')",
                "self": "<IntervalArray>\n[nan, (2017-01-02, 2017-01-03], (2017-01-03, 2017-01-04]]\nLength: 3, closed: right, dtype: interval[datetime64[ns, US/Eastern]]",
                "value_left": "numpy.datetime64('NaT')",
                "value_right": "numpy.datetime64('NaT')",
                "left": "DatetimeIndex(['NaT', '2017-01-02 00:00:00-05:00',\n               '2017-01-03 00:00:00-05:00'],\n              dtype='datetime64[ns, US/Eastern]', freq=None)",
                "self.left": "DatetimeIndex(['NaT', '2017-01-02 00:00:00-05:00',\n               '2017-01-03 00:00:00-05:00'],\n              dtype='datetime64[ns, US/Eastern]', freq=None)",
                "left._values": "<DatetimeArray>\n['NaT', '2017-01-02 00:00:00-05:00', '2017-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                "self._left": "DatetimeIndex(['NaT', '2017-01-02 00:00:00-05:00',\n               '2017-01-03 00:00:00-05:00'],\n              dtype='datetime64[ns, US/Eastern]', freq=None)",
                "right": "DatetimeIndex(['NaT', '2017-01-03 00:00:00-05:00',\n               '2017-01-04 00:00:00-05:00'],\n              dtype='datetime64[ns, US/Eastern]', freq=None)",
                "self.right": "DatetimeIndex(['NaT', '2017-01-03 00:00:00-05:00',\n               '2017-01-04 00:00:00-05:00'],\n              dtype='datetime64[ns, US/Eastern]', freq=None)",
                "right._values": "<DatetimeArray>\n['NaT', '2017-01-03 00:00:00-05:00', '2017-01-04 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                "self._right": "DatetimeIndex(['NaT', '2017-01-03 00:00:00-05:00',\n               '2017-01-04 00:00:00-05:00'],\n              dtype='datetime64[ns, US/Eastern]', freq=None)"
            }
        ]
    ],
    "2.1.6": [
        [
            {
                "value": "float",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "key": "int",
                "self.left": "Float64Index",
                "self._left": "Float64Index",
                "self.right": "Float64Index",
                "self._right": "Float64Index"
            },
            {
                "needs_float_conversion": "bool",
                "self": "IntervalArray",
                "value_left": "float",
                "value_right": "float",
                "left": "Float64Index",
                "self.left": "Float64Index",
                "left._values": "ndarray",
                "self._left": "Float64Index",
                "right": "Float64Index",
                "self.right": "Float64Index",
                "right._values": "ndarray",
                "self._right": "Float64Index"
            }
        ],
        [
            {
                "value": "float",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "key": "int",
                "self.left": "TimedeltaIndex",
                "self._left": "TimedeltaIndex",
                "self.right": "TimedeltaIndex",
                "self._right": "TimedeltaIndex"
            },
            {
                "needs_float_conversion": "bool",
                "value": "timedelta64",
                "self": "IntervalArray",
                "value_left": "timedelta64",
                "value_right": "timedelta64",
                "left": "TimedeltaIndex",
                "self.left": "TimedeltaIndex",
                "left._values": "TimedeltaArray",
                "self._left": "TimedeltaIndex",
                "right": "TimedeltaIndex",
                "self.right": "TimedeltaIndex",
                "right._values": "TimedeltaArray",
                "self._right": "TimedeltaIndex"
            }
        ],
        [
            {
                "value": "float",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "key": "int",
                "self.left": "DatetimeIndex",
                "self._left": "DatetimeIndex",
                "self.right": "DatetimeIndex",
                "self._right": "DatetimeIndex"
            },
            {
                "needs_float_conversion": "bool",
                "value": "datetime64",
                "self": "IntervalArray",
                "value_left": "datetime64",
                "value_right": "datetime64",
                "left": "DatetimeIndex",
                "self.left": "DatetimeIndex",
                "left._values": "DatetimeArray",
                "self._left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "self.right": "DatetimeIndex",
                "right._values": "DatetimeArray",
                "self._right": "DatetimeIndex"
            }
        ],
        [
            {
                "value": "float",
                "self.dtype": "IntervalDtype",
                "self": "IntervalArray",
                "key": "int",
                "self.left": "DatetimeIndex",
                "self._left": "DatetimeIndex",
                "self.right": "DatetimeIndex",
                "self._right": "DatetimeIndex"
            },
            {
                "needs_float_conversion": "bool",
                "value": "datetime64",
                "self": "IntervalArray",
                "value_left": "datetime64",
                "value_right": "datetime64",
                "left": "DatetimeIndex",
                "self.left": "DatetimeIndex",
                "left._values": "DatetimeArray",
                "self._left": "DatetimeIndex",
                "right": "DatetimeIndex",
                "self.right": "DatetimeIndex",
                "right._values": "DatetimeArray",
                "self._right": "DatetimeIndex"
            }
        ]
    ],
    "3.1.1": [
        "\n"
    ],
    "3.1.2": [
        "\n"
    ]
}