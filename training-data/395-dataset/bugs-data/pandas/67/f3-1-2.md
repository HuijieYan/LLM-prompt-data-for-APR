The issue description is:

```text
Code Sample, a copy-pastable example if possible
This code:

>>> df = pd.DataFrame({'date': ['Aug2020', 'November 2020']})
>>> df['parsed'] = df['date'].apply(pd.to_datetime)
>>> end = df.loc[df['parsed'].idxmax()]
>>> end['parsed'].replace(day=2)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'numpy.datetime64' object has no attribute 'replace'
worked in Pandas 0.25.3, but raises since 1.0.0.

I think there might be an issue with unboxing values when there are mixed types in the dataframe:

>>> df = pd.DataFrame({'date': ['Aug2020', 'November 2020']})
>>> new = (
...     df
...     .assign(
...         parsed=lambda x: x['date'].apply(pd.to_datetime),
...         parsed2 = lambda x: x['date'].apply(pd.to_datetime)
...     )
... )
>>> new['parsed'].iloc[0]
Timestamp('2020-08-01 00:00:00')
>>> new.iloc[0]['parsed']
numpy.datetime64('2020-08-01T00:00:00.000000000') # unboxed type
>>> new2 = new.drop(columns=['date'])
>>> new2['parsed'].iloc[0]
Timestamp('2020-08-01 00:00:00')
>>> new2.iloc[0]['parsed']
Timestamp('2020-08-01 00:00:00') # boxed type now that we've dropped the string column
Problem description
to_datetime can "sometimes" result in a np.datetime64 return type.

np.datetime64 is not a valid return type for to_datetime (https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.to_datetime.html), it should always be a datetimelike.

Expected Output
As in previous versions of Pandas:

>>> df = pd.DataFrame({'date': ['Aug2020', 'November 2020']})
>>> df['parsed'] = df['date'].apply(pd.to_datetime)
>>> end = df.loc[df['parsed'].idxmax()]
>>> end['parsed'].replace(day=2)
Timestamp('2020-11-02 00:00:00')
```
