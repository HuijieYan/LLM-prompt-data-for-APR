{
    "pandas:90": {
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_90/pandas/_testing.py": {
            "buggy_functions": [
                {
                    "function_name": "round_trip_pickle",
                    "function_code": "def round_trip_pickle(obj: FrameOrSeries, path: Optional[str] = None) -> FrameOrSeries:\n    \"\"\"\n    Pickle an object and then read it again.\n\n    Parameters\n    ----------\n    obj : pandas object\n        The object to pickle and then re-read.\n    path : str, default None\n        The path where the pickled object is written and then read.\n\n    Returns\n    -------\n    pandas object\n        The original object that was pickled and then re-read.\n    \"\"\"\n    if path is None:\n        path = f\"__{rands(10)}__.pickle\"\n    with ensure_clean(path) as path:\n        pd.to_pickle(obj, path)\n        return pd.read_pickle(path)\n",
                    "decorators": [],
                    "docstring": "Pickle an object and then read it again.\n\nParameters\n----------\nobj : pandas object\n    The object to pickle and then re-read.\npath : str, default None\n    The path where the pickled object is written and then read.\n\nReturns\n-------\npandas object\n    The original object that was pickled and then re-read.",
                    "start_line": 104,
                    "variables": {
                        "FrameOrSeries": [
                            104
                        ],
                        "Optional": [
                            104
                        ],
                        "str": [
                            104
                        ],
                        "path": [
                            120,
                            121,
                            122,
                            123,
                            124
                        ],
                        "rands": [
                            121
                        ],
                        "ensure_clean": [
                            122
                        ],
                        "pd.to_pickle": [
                            123
                        ],
                        "pd": [
                            123,
                            124
                        ],
                        "obj": [
                            123
                        ],
                        "pd.read_pickle": [
                            124
                        ]
                    },
                    "filtered_variables": {
                        "FrameOrSeries": [
                            104
                        ],
                        "Optional": [
                            104
                        ],
                        "path": [
                            120,
                            121,
                            122,
                            123,
                            124
                        ],
                        "rands": [
                            121
                        ],
                        "ensure_clean": [
                            122
                        ],
                        "pd.to_pickle": [
                            123
                        ],
                        "pd": [
                            123,
                            124
                        ],
                        "obj": [
                            123
                        ],
                        "pd.read_pickle": [
                            124
                        ]
                    },
                    "diff_line_number": 104,
                    "class_data": null,
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                }
            ],
            "snippets": [
                {
                    "snippet_code": "from typing import List, Optional, Union, cast\nimport warnings\nimport zipfile\n\nimport numpy as np\nfrom numpy.random import rand, randn\n\nfrom pandas._config.localization import (  # noqa:F401\n    can_set_locale,\n    get_locales,\n    set_locale,\n)\n\nimport pandas._libs.testing as _testing\nfrom pandas._typing import FrameOrSeries\nfrom pandas.compat import _get_lzma_file, _import_lzma",
                    "start_line": 11,
                    "end_line": 26
                }
            ],
            "inscope_functions": [
                "def set_testing_mode():\n    # set the testing mode filters\n    testing_mode = os.environ.get(\"PANDAS_TESTING_MODE\", \"None\")\n    if \"deprecate\" in testing_mode:\n        warnings.simplefilter(\"always\", _testing_mode_warnings)",
                "def reset_testing_mode():\n    # reset the testing mode filters\n    testing_mode = os.environ.get(\"PANDAS_TESTING_MODE\", \"None\")\n    if \"deprecate\" in testing_mode:\n        warnings.simplefilter(\"ignore\", _testing_mode_warnings)",
                "def reset_display_options():\n    \"\"\"\n    Reset the display options for printing and representing objects.\n    \"\"\"\n    pd.reset_option(\"^display.\", silent=True)",
                "def round_trip_pickle(obj: FrameOrSeries, path: Optional[str] = None) -> FrameOrSeries:\n    \"\"\"\n    Pickle an object and then read it again.\n\n    Parameters\n    ----------\n    obj : pandas object\n        The object to pickle and then re-read.\n    path : str, default None\n        The path where the pickled object is written and then read.\n\n    Returns\n    -------\n    pandas object\n        The original object that was pickled and then re-read.\n    \"\"\"\n    if path is None:\n        path = f\"__{rands(10)}__.pickle\"\n    with ensure_clean(path) as path:\n        pd.to_pickle(obj, path)\n        return pd.read_pickle(path)",
                "def round_trip_pathlib(writer, reader, path: Optional[str] = None):\n    \"\"\"\n    Write an object to file specified by a pathlib.Path and read it back\n\n    Parameters\n    ----------\n    writer : callable bound to pandas object\n        IO writing function (e.g. DataFrame.to_csv )\n    reader : callable\n        IO reading function (e.g. pd.read_csv )\n    path : str, default None\n        The path where the object is written and then read.\n\n    Returns\n    -------\n    pandas object\n        The original object that was serialized and then re-read.\n    \"\"\"\n    import pytest\n\n    Path = pytest.importorskip(\"pathlib\").Path\n    if path is None:\n        path = \"___pathlib___\"\n    with ensure_clean(path) as path:\n        writer(Path(path))\n        obj = reader(Path(path))\n    return obj",
                "def round_trip_localpath(writer, reader, path: Optional[str] = None):\n    \"\"\"\n    Write an object to file specified by a py.path LocalPath and read it back.\n\n    Parameters\n    ----------\n    writer : callable bound to pandas object\n        IO writing function (e.g. DataFrame.to_csv )\n    reader : callable\n        IO reading function (e.g. pd.read_csv )\n    path : str, default None\n        The path where the object is written and then read.\n\n    Returns\n    -------\n    pandas object\n        The original object that was serialized and then re-read.\n    \"\"\"\n    import pytest\n\n    LocalPath = pytest.importorskip(\"py.path\").local\n    if path is None:\n        path = \"___localpath___\"\n    with ensure_clean(path) as path:\n        writer(LocalPath(path))\n        obj = reader(LocalPath(path))\n    return obj",
                "@contextmanager\ndef decompress_file(path, compression):\n    \"\"\"\n    Open a compressed file and return a file object.\n\n    Parameters\n    ----------\n    path : str\n        The path where the file is read from.\n\n    compression : {'gzip', 'bz2', 'zip', 'xz', None}\n        Name of the decompression to use\n\n    Returns\n    -------\n    file object\n    \"\"\"\n    if compression is None:\n        f = open(path, \"rb\")\n    elif compression == \"gzip\":\n        f = gzip.open(path, \"rb\")\n    elif compression == \"bz2\":\n        f = bz2.BZ2File(path, \"rb\")\n    elif compression == \"xz\":\n        f = _get_lzma_file(lzma)(path, \"rb\")\n    elif compression == \"zip\":\n        zip_file = zipfile.ZipFile(path)\n        zip_names = zip_file.namelist()\n        if len(zip_names) == 1:\n            f = zip_file.open(zip_names.pop())\n        else:\n            raise ValueError(f\"ZIP file {path} error. Only one file per ZIP.\")\n    else:\n        raise ValueError(f\"Unrecognized compression type: {compression}\")\n\n    try:\n        yield f\n    finally:\n        f.close()\n        if compression == \"zip\":\n            zip_file.close()",
                "def write_to_compressed(compression, path, data, dest=\"test\"):\n    \"\"\"\n    Write data to a compressed file.\n\n    Parameters\n    ----------\n    compression : {'gzip', 'bz2', 'zip', 'xz'}\n        The compression type to use.\n    path : str\n        The file path to write the data.\n    data : str\n        The data to write.\n    dest : str, default \"test\"\n        The destination file (for ZIP only)\n\n    Raises\n    ------\n    ValueError : An invalid compression value was passed in.\n    \"\"\"\n    if compression == \"zip\":\n        import zipfile\n\n        compress_method = zipfile.ZipFile\n    elif compression == \"gzip\":\n        import gzip\n\n        compress_method = gzip.GzipFile\n    elif compression == \"bz2\":\n        import bz2\n\n        compress_method = bz2.BZ2File\n    elif compression == \"xz\":\n        compress_method = _get_lzma_file(lzma)\n    else:\n        raise ValueError(f\"Unrecognized compression type: {compression}\")\n\n    if compression == \"zip\":\n        mode = \"w\"\n        args = (dest, data)\n        method = \"writestr\"\n    else:\n        mode = \"wb\"\n        args = (data,)\n        method = \"write\"\n\n    with compress_method(path, mode=mode) as f:\n        getattr(f, method)(*args)",
                "def assert_almost_equal(\n    left,\n    right,\n    check_dtype: Union[bool, str] = \"equiv\",\n    check_less_precise: Union[bool, int] = False,\n    **kwargs,\n):\n    \"\"\"\n    Check that the left and right objects are approximately equal.\n\n    By approximately equal, we refer to objects that are numbers or that\n    contain numbers which may be equivalent to specific levels of precision.\n\n    Parameters\n    ----------\n    left : object\n    right : object\n    check_dtype : bool or {'equiv'}, default 'equiv'\n        Check dtype if both a and b are the same type. If 'equiv' is passed in,\n        then `RangeIndex` and `Int64Index` are also considered equivalent\n        when doing type checking.\n    check_less_precise : bool or int, default False\n        Specify comparison precision. 5 digits (False) or 3 digits (True)\n        after decimal points are compared. If int, then specify the number\n        of digits to compare.\n\n        When comparing two numbers, if the first number has magnitude less\n        than 1e-5, we compare the two numbers directly and check whether\n        they are equivalent within the specified precision. Otherwise, we\n        compare the **ratio** of the second number to the first number and\n        check whether it is equivalent to 1 within the specified precision.\n    \"\"\"\n    if isinstance(left, pd.Index):\n        assert_index_equal(\n            left,\n            right,\n            check_exact=False,\n            exact=check_dtype,\n            check_less_precise=check_less_precise,\n            **kwargs,\n        )\n\n    elif isinstance(left, pd.Series):\n        assert_series_equal(\n            left,\n            right,\n            check_exact=False,\n            check_dtype=check_dtype,\n            check_less_precise=check_less_precise,\n            **kwargs,\n        )\n\n    elif isinstance(left, pd.DataFrame):\n        assert_frame_equal(\n            left,\n            right,\n            check_exact=False,\n            check_dtype=check_dtype,\n            check_less_precise=check_less_precise,\n            **kwargs,\n        )\n\n    else:\n        # Other sequences.\n        if check_dtype:\n            if is_number(left) and is_number(right):\n                # Do not compare numeric classes, like np.float64 and float.\n                pass\n            elif is_bool(left) and is_bool(right):\n                # Do not compare bool classes, like np.bool_ and bool.\n                pass\n            else:\n                if isinstance(left, np.ndarray) or isinstance(right, np.ndarray):\n                    obj = \"numpy array\"\n                else:\n                    obj = \"Input\"\n                assert_class_equal(left, right, obj=obj)\n        _testing.assert_almost_equal(\n            left,\n            right,\n            check_dtype=check_dtype,\n            check_less_precise=check_less_precise,\n            **kwargs,\n        )",
                "def _check_isinstance(left, right, cls):\n    \"\"\"\n    Helper method for our assert_* methods that ensures that\n    the two objects being compared have the right type before\n    proceeding with the comparison.\n\n    Parameters\n    ----------\n    left : The first object being compared.\n    right : The second object being compared.\n    cls : The class type to check against.\n\n    Raises\n    ------\n    AssertionError : Either `left` or `right` is not an instance of `cls`.\n    \"\"\"\n    cls_name = cls.__name__\n\n    if not isinstance(left, cls):\n        raise AssertionError(\n            f\"{cls_name} Expected type {cls}, found {type(left)} instead\"\n        )\n    if not isinstance(right, cls):\n        raise AssertionError(\n            f\"{cls_name} Expected type {cls}, found {type(right)} instead\"\n        )",
                "def assert_dict_equal(left, right, compare_keys: bool = True):\n\n    _check_isinstance(left, right, dict)\n    _testing.assert_dict_equal(left, right, compare_keys=compare_keys)",
                "def randbool(size=(), p: float = 0.5):\n    return rand(*size) <= p",
                "def rands_array(nchars, size, dtype=\"O\"):\n    \"\"\"\n    Generate an array of byte strings.\n    \"\"\"\n    retval = (\n        np.random.choice(RANDS_CHARS, size=nchars * np.prod(size))\n        .view((np.str_, nchars))\n        .reshape(size)\n    )\n    if dtype is None:\n        return retval\n    else:\n        return retval.astype(dtype)",
                "def randu_array(nchars, size, dtype=\"O\"):\n    \"\"\"\n    Generate an array of unicode strings.\n    \"\"\"\n    retval = (\n        np.random.choice(RANDU_CHARS, size=nchars * np.prod(size))\n        .view((np.unicode_, nchars))\n        .reshape(size)\n    )\n    if dtype is None:\n        return retval\n    else:\n        return retval.astype(dtype)",
                "def rands(nchars):\n    \"\"\"\n    Generate one random byte string.\n\n    See `rands_array` if you want to create an array of random strings.\n\n    \"\"\"\n    return \"\".join(np.random.choice(RANDS_CHARS, nchars))",
                "def randu(nchars):\n    \"\"\"\n    Generate one random unicode string.\n\n    See `randu_array` if you want to create an array of random unicode strings.\n\n    \"\"\"\n    return \"\".join(np.random.choice(RANDU_CHARS, nchars))",
                "def close(fignum=None):\n    from matplotlib.pyplot import get_fignums, close as _close\n\n    if fignum is None:\n        for fignum in get_fignums():\n            _close(fignum)\n    else:\n        _close(fignum)",
                "@contextmanager\ndef ensure_clean(filename=None, return_filelike=False):\n    \"\"\"\n    Gets a temporary path and agrees to remove on close.\n\n    Parameters\n    ----------\n    filename : str (optional)\n        if None, creates a temporary file which is then removed when out of\n        scope. if passed, creates temporary file with filename as ending.\n    return_filelike : bool (default False)\n        if True, returns a file-like which is *always* cleaned. Necessary for\n        savefig and other functions which want to append extensions.\n    \"\"\"\n    filename = filename or \"\"\n    fd = None\n\n    if return_filelike:\n        f = tempfile.TemporaryFile(suffix=filename)\n        try:\n            yield f\n        finally:\n            f.close()\n    else:\n        # don't generate tempfile if using a path with directory specified\n        if len(os.path.dirname(filename)):\n            raise ValueError(\"Can't pass a qualified name to ensure_clean()\")\n\n        try:\n            fd, filename = tempfile.mkstemp(suffix=filename)\n        except UnicodeEncodeError:\n            import pytest\n\n            pytest.skip(\"no unicode file names on this system\")\n\n        try:\n            yield filename\n        finally:\n            try:\n                os.close(fd)\n            except OSError:\n                print(f\"Couldn't close file descriptor: {fd} (file: {filename})\")\n            try:\n                if os.path.exists(filename):\n                    os.remove(filename)\n            except OSError as e:\n                print(f\"Exception on removing file: {e}\")",
                "@contextmanager\ndef ensure_clean_dir():\n    \"\"\"\n    Get a temporary directory path and agrees to remove on close.\n\n    Yields\n    ------\n    Temporary directory path\n    \"\"\"\n    directory_name = tempfile.mkdtemp(suffix=\"\")\n    try:\n        yield directory_name\n    finally:\n        try:\n            rmtree(directory_name)\n        except OSError:\n            pass",
                "@contextmanager\ndef ensure_safe_environment_variables():\n    \"\"\"\n    Get a context manager to safely set environment variables\n\n    All changes will be undone on close, hence environment variables set\n    within this contextmanager will neither persist nor change global state.\n    \"\"\"\n    saved_environ = dict(os.environ)\n    try:\n        yield\n    finally:\n        os.environ.clear()\n        os.environ.update(saved_environ)",
                "def equalContents(arr1, arr2) -> bool:\n    \"\"\"\n    Checks if the set of unique elements of arr1 and arr2 are equivalent.\n    \"\"\"\n    return frozenset(arr1) == frozenset(arr2)",
                "def assert_index_equal(\n    left: Index,\n    right: Index,\n    exact: Union[bool, str] = \"equiv\",\n    check_names: bool = True,\n    check_less_precise: Union[bool, int] = False,\n    check_exact: bool = True,\n    check_categorical: bool = True,\n    obj: str = \"Index\",\n) -> None:\n    \"\"\"\n    Check that left and right Index are equal.\n\n    Parameters\n    ----------\n    left : Index\n    right : Index\n    exact : bool or {'equiv'}, default 'equiv'\n        Whether to check the Index class, dtype and inferred_type\n        are identical. If 'equiv', then RangeIndex can be substituted for\n        Int64Index as well.\n    check_names : bool, default True\n        Whether to check the names attribute.\n    check_less_precise : bool or int, default False\n        Specify comparison precision. Only used when check_exact is False.\n        5 digits (False) or 3 digits (True) after decimal points are compared.\n        If int, then specify the digits to compare.\n    check_exact : bool, default True\n        Whether to compare number exactly.\n    check_categorical : bool, default True\n        Whether to compare internal Categorical exactly.\n    obj : str, default 'Index'\n        Specify object name being compared, internally used to show appropriate\n        assertion message.\n    \"\"\"\n    __tracebackhide__ = True\n\n    def _check_types(l, r, obj=\"Index\"):\n        if exact:\n            assert_class_equal(l, r, exact=exact, obj=obj)\n\n            # Skip exact dtype checking when `check_categorical` is False\n            if check_categorical:\n                assert_attr_equal(\"dtype\", l, r, obj=obj)\n\n            # allow string-like to have different inferred_types\n            if l.inferred_type in (\"string\", \"unicode\"):\n                assert r.inferred_type in (\"string\", \"unicode\")\n            else:\n                assert_attr_equal(\"inferred_type\", l, r, obj=obj)\n\n    def _get_ilevel_values(index, level):\n        # accept level number only\n        unique = index.levels[level]\n        level_codes = index.codes[level]\n        filled = take_1d(unique._values, level_codes, fill_value=unique._na_value)\n        values = unique._shallow_copy(filled, name=index.names[level])\n        return values\n\n    # instance validation\n    _check_isinstance(left, right, Index)\n\n    # class / dtype comparison\n    _check_types(left, right, obj=obj)\n\n    # level comparison\n    if left.nlevels != right.nlevels:\n        msg1 = f\"{obj} levels are different\"\n        msg2 = f\"{left.nlevels}, {left}\"\n        msg3 = f\"{right.nlevels}, {right}\"\n        raise_assert_detail(obj, msg1, msg2, msg3)\n\n    # length comparison\n    if len(left) != len(right):\n        msg1 = f\"{obj} length are different\"\n        msg2 = f\"{len(left)}, {left}\"\n        msg3 = f\"{len(right)}, {right}\"\n        raise_assert_detail(obj, msg1, msg2, msg3)\n\n    # MultiIndex special comparison for little-friendly error messages\n    if left.nlevels > 1:\n        left = cast(MultiIndex, left)\n        right = cast(MultiIndex, right)\n\n        for level in range(left.nlevels):\n            # cannot use get_level_values here because it can change dtype\n            llevel = _get_ilevel_values(left, level)\n            rlevel = _get_ilevel_values(right, level)\n\n            lobj = f\"MultiIndex level [{level}]\"\n            assert_index_equal(\n                llevel,\n                rlevel,\n                exact=exact,\n                check_names=check_names,\n                check_less_precise=check_less_precise,\n                check_exact=check_exact,\n                obj=lobj,\n            )\n            # get_level_values may change dtype\n            _check_types(left.levels[level], right.levels[level], obj=obj)\n\n    # skip exact index checking when `check_categorical` is False\n    if check_exact and check_categorical:\n        if not left.equals(right):\n            diff = np.sum((left.values != right.values).astype(int)) * 100.0 / len(left)\n            msg = f\"{obj} values are different ({np.round(diff, 5)} %)\"\n            raise_assert_detail(obj, msg, left, right)\n    else:\n        _testing.assert_almost_equal(\n            left.values,\n            right.values,\n            check_less_precise=check_less_precise,\n            check_dtype=exact,\n            obj=obj,\n            lobj=left,\n            robj=right,\n        )\n\n    # metadata comparison\n    if check_names:\n        assert_attr_equal(\"names\", left, right, obj=obj)\n    if isinstance(left, pd.PeriodIndex) or isinstance(right, pd.PeriodIndex):\n        assert_attr_equal(\"freq\", left, right, obj=obj)\n    if isinstance(left, pd.IntervalIndex) or isinstance(right, pd.IntervalIndex):\n        assert_interval_array_equal(left.values, right.values)\n\n    if check_categorical:\n        if is_categorical_dtype(left) or is_categorical_dtype(right):\n            assert_categorical_equal(left.values, right.values, obj=f\"{obj} category\")",
                "def assert_class_equal(left, right, exact: Union[bool, str] = True, obj=\"Input\"):\n    \"\"\"\n    Checks classes are equal.\n    \"\"\"\n    __tracebackhide__ = True\n\n    def repr_class(x):\n        if isinstance(x, Index):\n            # return Index as it is to include values in the error message\n            return x\n\n        try:\n            return type(x).__name__\n        except AttributeError:\n            return repr(type(x))\n\n    if exact == \"equiv\":\n        if type(left) != type(right):\n            # allow equivalence of Int64Index/RangeIndex\n            types = {type(left).__name__, type(right).__name__}\n            if len(types - {\"Int64Index\", \"RangeIndex\"}):\n                msg = f\"{obj} classes are not equivalent\"\n                raise_assert_detail(obj, msg, repr_class(left), repr_class(right))\n    elif exact:\n        if type(left) != type(right):\n            msg = f\"{obj} classes are different\"\n            raise_assert_detail(obj, msg, repr_class(left), repr_class(right))",
                "def assert_attr_equal(attr, left, right, obj=\"Attributes\"):\n    \"\"\"checks attributes are equal. Both objects must have attribute.\n\n    Parameters\n    ----------\n    attr : str\n        Attribute name being compared.\n    left : object\n    right : object\n    obj : str, default 'Attributes'\n        Specify object name being compared, internally used to show appropriate\n        assertion message\n    \"\"\"\n    __tracebackhide__ = True\n\n    left_attr = getattr(left, attr)\n    right_attr = getattr(right, attr)\n\n    if left_attr is right_attr:\n        return True\n    elif (\n        is_number(left_attr)\n        and np.isnan(left_attr)\n        and is_number(right_attr)\n        and np.isnan(right_attr)\n    ):\n        # np.nan\n        return True\n\n    try:\n        result = left_attr == right_attr\n    except TypeError:\n        # datetimetz on rhs may raise TypeError\n        result = False\n    if not isinstance(result, bool):\n        result = result.all()\n\n    if result:\n        return True\n    else:\n        msg = f'Attribute \"{attr}\" are different'\n        raise_assert_detail(obj, msg, left_attr, right_attr)",
                "def assert_is_valid_plot_return_object(objs):\n    import matplotlib.pyplot as plt\n\n    if isinstance(objs, (pd.Series, np.ndarray)):\n        for el in objs.ravel():\n            msg = (\n                \"one of 'objs' is not a matplotlib Axes instance, \"\n                f\"type encountered {repr(type(el).__name__)}\"\n            )\n            assert isinstance(el, (plt.Axes, dict)), msg\n    else:\n        msg = (\n            \"objs is neither an ndarray of Artist instances nor a single \"\n            \"ArtistArtist instance, tuple, or dict, 'objs' is a \"\n            f\"{repr(type(objs).__name__)}\"\n        )\n        assert isinstance(objs, (plt.Artist, tuple, dict)), msg",
                "def isiterable(obj):\n    return hasattr(obj, \"__iter__\")",
                "def assert_is_sorted(seq):\n    \"\"\"Assert that the sequence is sorted.\"\"\"\n    if isinstance(seq, (Index, Series)):\n        seq = seq.values\n    # sorting does not change precisions\n    assert_numpy_array_equal(seq, np.sort(np.array(seq)))",
                "def assert_categorical_equal(\n    left, right, check_dtype=True, check_category_order=True, obj=\"Categorical\"\n):\n    \"\"\"Test that Categoricals are equivalent.\n\n    Parameters\n    ----------\n    left : Categorical\n    right : Categorical\n    check_dtype : bool, default True\n        Check that integer dtype of the codes are the same\n    check_category_order : bool, default True\n        Whether the order of the categories should be compared, which\n        implies identical integer codes.  If False, only the resulting\n        values are compared.  The ordered attribute is\n        checked regardless.\n    obj : str, default 'Categorical'\n        Specify object name being compared, internally used to show appropriate\n        assertion message\n    \"\"\"\n    _check_isinstance(left, right, Categorical)\n\n    if check_category_order:\n        assert_index_equal(left.categories, right.categories, obj=f\"{obj}.categories\")\n        assert_numpy_array_equal(\n            left.codes, right.codes, check_dtype=check_dtype, obj=f\"{obj}.codes\",\n        )\n    else:\n        assert_index_equal(\n            left.categories.sort_values(),\n            right.categories.sort_values(),\n            obj=f\"{obj}.categories\",\n        )\n        assert_index_equal(\n            left.categories.take(left.codes),\n            right.categories.take(right.codes),\n            obj=f\"{obj}.values\",\n        )\n\n    assert_attr_equal(\"ordered\", left, right, obj=obj)",
                "def assert_interval_array_equal(left, right, exact=\"equiv\", obj=\"IntervalArray\"):\n    \"\"\"Test that two IntervalArrays are equivalent.\n\n    Parameters\n    ----------\n    left, right : IntervalArray\n        The IntervalArrays to compare.\n    exact : bool or {'equiv'}, default 'equiv'\n        Whether to check the Index class, dtype and inferred_type\n        are identical. If 'equiv', then RangeIndex can be substituted for\n        Int64Index as well.\n    obj : str, default 'IntervalArray'\n        Specify object name being compared, internally used to show appropriate\n        assertion message\n    \"\"\"\n    _check_isinstance(left, right, IntervalArray)\n\n    assert_index_equal(left.left, right.left, exact=exact, obj=f\"{obj}.left\")\n    assert_index_equal(left.right, right.right, exact=exact, obj=f\"{obj}.left\")\n    assert_attr_equal(\"closed\", left, right, obj=obj)",
                "def assert_period_array_equal(left, right, obj=\"PeriodArray\"):\n    _check_isinstance(left, right, PeriodArray)\n\n    assert_numpy_array_equal(left._data, right._data, obj=f\"{obj}.values\")\n    assert_attr_equal(\"freq\", left, right, obj=obj)",
                "def assert_datetime_array_equal(left, right, obj=\"DatetimeArray\"):\n    __tracebackhide__ = True\n    _check_isinstance(left, right, DatetimeArray)\n\n    assert_numpy_array_equal(left._data, right._data, obj=f\"{obj}._data\")\n    assert_attr_equal(\"freq\", left, right, obj=obj)\n    assert_attr_equal(\"tz\", left, right, obj=obj)",
                "def assert_timedelta_array_equal(left, right, obj=\"TimedeltaArray\"):\n    __tracebackhide__ = True\n    _check_isinstance(left, right, TimedeltaArray)\n    assert_numpy_array_equal(left._data, right._data, obj=f\"{obj}._data\")\n    assert_attr_equal(\"freq\", left, right, obj=obj)",
                "def raise_assert_detail(obj, message, left, right, diff=None):\n    __tracebackhide__ = True\n\n    if isinstance(left, np.ndarray):\n        left = pprint_thing(left)\n    elif is_categorical_dtype(left):\n        left = repr(left)\n\n    if isinstance(right, np.ndarray):\n        right = pprint_thing(right)\n    elif is_categorical_dtype(right):\n        right = repr(right)\n\n    msg = f\"\"\"{obj} are different\n\n{message}\n[left]:  {left}\n[right]: {right}\"\"\"\n\n    if diff is not None:\n        msg += f\"\\n[diff]: {diff}\"\n\n    raise AssertionError(msg)",
                "def assert_numpy_array_equal(\n    left,\n    right,\n    strict_nan=False,\n    check_dtype=True,\n    err_msg=None,\n    check_same=None,\n    obj=\"numpy array\",\n):\n    \"\"\"\n    Check that 'np.ndarray' is equivalent.\n\n    Parameters\n    ----------\n    left, right : numpy.ndarray or iterable\n        The two arrays to be compared.\n    strict_nan : bool, default False\n        If True, consider NaN and None to be different.\n    check_dtype : bool, default True\n        Check dtype if both a and b are np.ndarray.\n    err_msg : str, default None\n        If provided, used as assertion message.\n    check_same : None|'copy'|'same', default None\n        Ensure left and right refer/do not refer to the same memory area.\n    obj : str, default 'numpy array'\n        Specify object name being compared, internally used to show appropriate\n        assertion message.\n    \"\"\"\n    __tracebackhide__ = True\n\n    # instance validation\n    # Show a detailed error message when classes are different\n    assert_class_equal(left, right, obj=obj)\n    # both classes must be an np.ndarray\n    _check_isinstance(left, right, np.ndarray)\n\n    def _get_base(obj):\n        return obj.base if getattr(obj, \"base\", None) is not None else obj\n\n    left_base = _get_base(left)\n    right_base = _get_base(right)\n\n    if check_same == \"same\":\n        if left_base is not right_base:\n            raise AssertionError(f\"{repr(left_base)} is not {repr(right_base)}\")\n    elif check_same == \"copy\":\n        if left_base is right_base:\n            raise AssertionError(f\"{repr(left_base)} is {repr(right_base)}\")\n\n    def _raise(left, right, err_msg):\n        if err_msg is None:\n            if left.shape != right.shape:\n                raise_assert_detail(\n                    obj, f\"{obj} shapes are different\", left.shape, right.shape,\n                )\n\n            diff = 0\n            for l, r in zip(left, right):\n                # count up differences\n                if not array_equivalent(l, r, strict_nan=strict_nan):\n                    diff += 1\n\n            diff = diff * 100.0 / left.size\n            msg = f\"{obj} values are different ({np.round(diff, 5)} %)\"\n            raise_assert_detail(obj, msg, left, right)\n\n        raise AssertionError(err_msg)\n\n    # compare shape and values\n    if not array_equivalent(left, right, strict_nan=strict_nan):\n        _raise(left, right, err_msg)\n\n    if check_dtype:\n        if isinstance(left, np.ndarray) and isinstance(right, np.ndarray):\n            assert_attr_equal(\"dtype\", left, right, obj=obj)",
                "def assert_extension_array_equal(\n    left, right, check_dtype=True, check_less_precise=False, check_exact=False\n):\n    \"\"\"Check that left and right ExtensionArrays are equal.\n\n    Parameters\n    ----------\n    left, right : ExtensionArray\n        The two arrays to compare\n    check_dtype : bool, default True\n        Whether to check if the ExtensionArray dtypes are identical.\n    check_less_precise : bool or int, default False\n        Specify comparison precision. Only used when check_exact is False.\n        5 digits (False) or 3 digits (True) after decimal points are compared.\n        If int, then specify the digits to compare.\n    check_exact : bool, default False\n        Whether to compare number exactly.\n\n    Notes\n    -----\n    Missing values are checked separately from valid values.\n    A mask of missing values is computed for each and checked to match.\n    The remaining all-valid values are cast to object dtype and checked.\n    \"\"\"\n    assert isinstance(left, ExtensionArray), \"left is not an ExtensionArray\"\n    assert isinstance(right, ExtensionArray), \"right is not an ExtensionArray\"\n    if check_dtype:\n        assert_attr_equal(\"dtype\", left, right, obj=\"ExtensionArray\")\n\n    if hasattr(left, \"asi8\") and type(right) == type(left):\n        # Avoid slow object-dtype comparisons\n        assert_numpy_array_equal(left.asi8, right.asi8)\n        return\n\n    left_na = np.asarray(left.isna())\n    right_na = np.asarray(right.isna())\n    assert_numpy_array_equal(left_na, right_na, obj=\"ExtensionArray NA mask\")\n\n    left_valid = np.asarray(left[~left_na].astype(object))\n    right_valid = np.asarray(right[~right_na].astype(object))\n    if check_exact:\n        assert_numpy_array_equal(left_valid, right_valid, obj=\"ExtensionArray\")\n    else:\n        _testing.assert_almost_equal(\n            left_valid,\n            right_valid,\n            check_dtype=check_dtype,\n            check_less_precise=check_less_precise,\n            obj=\"ExtensionArray\",\n        )",
                "def assert_series_equal(\n    left,\n    right,\n    check_dtype=True,\n    check_index_type=\"equiv\",\n    check_series_type=True,\n    check_less_precise=False,\n    check_names=True,\n    check_exact=False,\n    check_datetimelike_compat=False,\n    check_categorical=True,\n    obj=\"Series\",\n):\n    \"\"\"\n    Check that left and right Series are equal.\n\n    Parameters\n    ----------\n    left : Series\n    right : Series\n    check_dtype : bool, default True\n        Whether to check the Series dtype is identical.\n    check_index_type : bool or {'equiv'}, default 'equiv'\n        Whether to check the Index class, dtype and inferred_type\n        are identical.\n    check_series_type : bool, default True\n        Whether to check the Series class is identical.\n    check_less_precise : bool or int, default False\n        Specify comparison precision. Only used when check_exact is False.\n        5 digits (False) or 3 digits (True) after decimal points are compared.\n        If int, then specify the digits to compare.\n\n        When comparing two numbers, if the first number has magnitude less\n        than 1e-5, we compare the two numbers directly and check whether\n        they are equivalent within the specified precision. Otherwise, we\n        compare the **ratio** of the second number to the first number and\n        check whether it is equivalent to 1 within the specified precision.\n    check_names : bool, default True\n        Whether to check the Series and Index names attribute.\n    check_exact : bool, default False\n        Whether to compare number exactly.\n    check_datetimelike_compat : bool, default False\n        Compare datetime-like which is comparable ignoring dtype.\n    check_categorical : bool, default True\n        Whether to compare internal Categorical exactly.\n    obj : str, default 'Series'\n        Specify object name being compared, internally used to show appropriate\n        assertion message.\n    \"\"\"\n    __tracebackhide__ = True\n\n    # instance validation\n    _check_isinstance(left, right, Series)\n\n    if check_series_type:\n        # ToDo: There are some tests using rhs is sparse\n        # lhs is dense. Should use assert_class_equal in future\n        assert isinstance(left, type(right))\n        # assert_class_equal(left, right, obj=obj)\n\n    # length comparison\n    if len(left) != len(right):\n        msg1 = f\"{len(left)}, {left.index}\"\n        msg2 = f\"{len(right)}, {right.index}\"\n        raise_assert_detail(obj, \"Series length are different\", msg1, msg2)\n\n    # index comparison\n    assert_index_equal(\n        left.index,\n        right.index,\n        exact=check_index_type,\n        check_names=check_names,\n        check_less_precise=check_less_precise,\n        check_exact=check_exact,\n        check_categorical=check_categorical,\n        obj=f\"{obj}.index\",\n    )\n\n    if check_dtype:\n        # We want to skip exact dtype checking when `check_categorical`\n        # is False. We'll still raise if only one is a `Categorical`,\n        # regardless of `check_categorical`\n        if (\n            is_categorical_dtype(left)\n            and is_categorical_dtype(right)\n            and not check_categorical\n        ):\n            pass\n        else:\n            assert_attr_equal(\"dtype\", left, right, obj=f\"Attributes of {obj}\")\n\n    if check_exact:\n        assert_numpy_array_equal(\n            left._internal_get_values(),\n            right._internal_get_values(),\n            check_dtype=check_dtype,\n            obj=str(obj),\n        )\n    elif check_datetimelike_compat:\n        # we want to check only if we have compat dtypes\n        # e.g. integer and M|m are NOT compat, but we can simply check\n        # the values in that case\n        if needs_i8_conversion(left) or needs_i8_conversion(right):\n\n            # datetimelike may have different objects (e.g. datetime.datetime\n            # vs Timestamp) but will compare equal\n            if not Index(left.values).equals(Index(right.values)):\n                msg = (\n                    f\"[datetimelike_compat=True] {left.values} \"\n                    f\"is not equal to {right.values}.\"\n                )\n                raise AssertionError(msg)\n        else:\n            assert_numpy_array_equal(\n                left._internal_get_values(),\n                right._internal_get_values(),\n                check_dtype=check_dtype,\n            )\n    elif is_interval_dtype(left) or is_interval_dtype(right):\n        assert_interval_array_equal(left.array, right.array)\n    elif is_extension_array_dtype(left.dtype) and is_datetime64tz_dtype(left.dtype):\n        # .values is an ndarray, but ._values is the ExtensionArray.\n        # TODO: Use .array\n        assert is_extension_array_dtype(right.dtype)\n        assert_extension_array_equal(left._values, right._values)\n    elif (\n        is_extension_array_dtype(left)\n        and not is_categorical_dtype(left)\n        and is_extension_array_dtype(right)\n        and not is_categorical_dtype(right)\n    ):\n        assert_extension_array_equal(left.array, right.array)\n    else:\n        _testing.assert_almost_equal(\n            left._internal_get_values(),\n            right._internal_get_values(),\n            check_less_precise=check_less_precise,\n            check_dtype=check_dtype,\n            obj=str(obj),\n        )\n\n    # metadata comparison\n    if check_names:\n        assert_attr_equal(\"name\", left, right, obj=obj)\n\n    if check_categorical:\n        if is_categorical_dtype(left) or is_categorical_dtype(right):\n            assert_categorical_equal(left.values, right.values, obj=f\"{obj} category\")",
                "def assert_frame_equal(\n    left,\n    right,\n    check_dtype=True,\n    check_index_type=\"equiv\",\n    check_column_type=\"equiv\",\n    check_frame_type=True,\n    check_less_precise=False,\n    check_names=True,\n    by_blocks=False,\n    check_exact=False,\n    check_datetimelike_compat=False,\n    check_categorical=True,\n    check_like=False,\n    obj=\"DataFrame\",\n):\n    \"\"\"\n    Check that left and right DataFrame are equal.\n\n    This function is intended to compare two DataFrames and output any\n    differences. Is is mostly intended for use in unit tests.\n    Additional parameters allow varying the strictness of the\n    equality checks performed.\n\n    Parameters\n    ----------\n    left : DataFrame\n        First DataFrame to compare.\n    right : DataFrame\n        Second DataFrame to compare.\n    check_dtype : bool, default True\n        Whether to check the DataFrame dtype is identical.\n    check_index_type : bool or {'equiv'}, default 'equiv'\n        Whether to check the Index class, dtype and inferred_type\n        are identical.\n    check_column_type : bool or {'equiv'}, default 'equiv'\n        Whether to check the columns class, dtype and inferred_type\n        are identical. Is passed as the ``exact`` argument of\n        :func:`assert_index_equal`.\n    check_frame_type : bool, default True\n        Whether to check the DataFrame class is identical.\n    check_less_precise : bool or int, default False\n        Specify comparison precision. Only used when check_exact is False.\n        5 digits (False) or 3 digits (True) after decimal points are compared.\n        If int, then specify the digits to compare.\n\n        When comparing two numbers, if the first number has magnitude less\n        than 1e-5, we compare the two numbers directly and check whether\n        they are equivalent within the specified precision. Otherwise, we\n        compare the **ratio** of the second number to the first number and\n        check whether it is equivalent to 1 within the specified precision.\n    check_names : bool, default True\n        Whether to check that the `names` attribute for both the `index`\n        and `column` attributes of the DataFrame is identical.\n    by_blocks : bool, default False\n        Specify how to compare internal data. If False, compare by columns.\n        If True, compare by blocks.\n    check_exact : bool, default False\n        Whether to compare number exactly.\n    check_datetimelike_compat : bool, default False\n        Compare datetime-like which is comparable ignoring dtype.\n    check_categorical : bool, default True\n        Whether to compare internal Categorical exactly.\n    check_like : bool, default False\n        If True, ignore the order of index & columns.\n        Note: index labels must match their respective rows\n        (same as in columns) - same labels must be with the same data.\n    obj : str, default 'DataFrame'\n        Specify object name being compared, internally used to show appropriate\n        assertion message.\n\n    See Also\n    --------\n    assert_series_equal : Equivalent method for asserting Series equality.\n    DataFrame.equals : Check DataFrame equality.\n\n    Examples\n    --------\n    This example shows comparing two DataFrames that are equal\n    but with columns of differing dtypes.\n\n    >>> from pandas._testing import assert_frame_equal\n    >>> df1 = pd.DataFrame({'a': [1, 2], 'b': [3, 4]})\n    >>> df2 = pd.DataFrame({'a': [1, 2], 'b': [3.0, 4.0]})\n\n    df1 equals itself.\n\n    >>> assert_frame_equal(df1, df1)\n\n    df1 differs from df2 as column 'b' is of a different type.\n\n    >>> assert_frame_equal(df1, df2)\n    Traceback (most recent call last):\n    ...\n    AssertionError: Attributes of DataFrame.iloc[:, 1] (column name=\"b\") are different\n\n    Attribute \"dtype\" are different\n    [left]:  int64\n    [right]: float64\n\n    Ignore differing dtypes in columns with check_dtype.\n\n    >>> assert_frame_equal(df1, df2, check_dtype=False)\n    \"\"\"\n    __tracebackhide__ = True\n\n    # instance validation\n    _check_isinstance(left, right, DataFrame)\n\n    if check_frame_type:\n        assert isinstance(left, type(right))\n        # assert_class_equal(left, right, obj=obj)\n\n    # shape comparison\n    if left.shape != right.shape:\n        raise_assert_detail(\n            obj, f\"{obj} shape mismatch\", f\"{repr(left.shape)}\", f\"{repr(right.shape)}\",\n        )\n\n    if check_like:\n        left, right = left.reindex_like(right), right\n\n    # index comparison\n    assert_index_equal(\n        left.index,\n        right.index,\n        exact=check_index_type,\n        check_names=check_names,\n        check_less_precise=check_less_precise,\n        check_exact=check_exact,\n        check_categorical=check_categorical,\n        obj=f\"{obj}.index\",\n    )\n\n    # column comparison\n    assert_index_equal(\n        left.columns,\n        right.columns,\n        exact=check_column_type,\n        check_names=check_names,\n        check_less_precise=check_less_precise,\n        check_exact=check_exact,\n        check_categorical=check_categorical,\n        obj=f\"{obj}.columns\",\n    )\n\n    # compare by blocks\n    if by_blocks:\n        rblocks = right._to_dict_of_blocks()\n        lblocks = left._to_dict_of_blocks()\n        for dtype in list(set(list(lblocks.keys()) + list(rblocks.keys()))):\n            assert dtype in lblocks\n            assert dtype in rblocks\n            assert_frame_equal(\n                lblocks[dtype], rblocks[dtype], check_dtype=check_dtype, obj=obj\n            )\n\n    # compare by columns\n    else:\n        for i, col in enumerate(left.columns):\n            assert col in right\n            lcol = left.iloc[:, i]\n            rcol = right.iloc[:, i]\n            assert_series_equal(\n                lcol,\n                rcol,\n                check_dtype=check_dtype,\n                check_index_type=check_index_type,\n                check_less_precise=check_less_precise,\n                check_exact=check_exact,\n                check_names=check_names,\n                check_datetimelike_compat=check_datetimelike_compat,\n                check_categorical=check_categorical,\n                obj=f'{obj}.iloc[:, {i}] (column name=\"{col}\")',\n            )",
                "def assert_equal(left, right, **kwargs):\n    \"\"\"\n    Wrapper for tm.assert_*_equal to dispatch to the appropriate test function.\n\n    Parameters\n    ----------\n    left, right : Index, Series, DataFrame, ExtensionArray, or np.ndarray\n        The two items to be compared.\n    **kwargs\n        All keyword arguments are passed through to the underlying assert method.\n    \"\"\"\n    __tracebackhide__ = True\n\n    if isinstance(left, pd.Index):\n        assert_index_equal(left, right, **kwargs)\n    elif isinstance(left, pd.Series):\n        assert_series_equal(left, right, **kwargs)\n    elif isinstance(left, pd.DataFrame):\n        assert_frame_equal(left, right, **kwargs)\n    elif isinstance(left, IntervalArray):\n        assert_interval_array_equal(left, right, **kwargs)\n    elif isinstance(left, PeriodArray):\n        assert_period_array_equal(left, right, **kwargs)\n    elif isinstance(left, DatetimeArray):\n        assert_datetime_array_equal(left, right, **kwargs)\n    elif isinstance(left, TimedeltaArray):\n        assert_timedelta_array_equal(left, right, **kwargs)\n    elif isinstance(left, ExtensionArray):\n        assert_extension_array_equal(left, right, **kwargs)\n    elif isinstance(left, np.ndarray):\n        assert_numpy_array_equal(left, right, **kwargs)\n    elif isinstance(left, str):\n        assert kwargs == {}\n        assert left == right\n    else:\n        raise NotImplementedError(type(left))",
                "def box_expected(expected, box_cls, transpose=True):\n    \"\"\"\n    Helper function to wrap the expected output of a test in a given box_class.\n\n    Parameters\n    ----------\n    expected : np.ndarray, Index, Series\n    box_cls : {Index, Series, DataFrame}\n\n    Returns\n    -------\n    subclass of box_cls\n    \"\"\"\n    if box_cls is pd.Index:\n        expected = pd.Index(expected)\n    elif box_cls is pd.Series:\n        expected = pd.Series(expected)\n    elif box_cls is pd.DataFrame:\n        expected = pd.Series(expected).to_frame()\n        if transpose:\n            # for vector operations, we we need a DataFrame to be a single-row,\n            #  not a single-column, in order to operate against non-DataFrame\n            #  vectors of the same length.\n            expected = expected.T\n    elif box_cls is PeriodArray:\n        # the PeriodArray constructor is not as flexible as period_array\n        expected = period_array(expected)\n    elif box_cls is DatetimeArray:\n        expected = DatetimeArray(expected)\n    elif box_cls is TimedeltaArray:\n        expected = TimedeltaArray(expected)\n    elif box_cls is np.ndarray:\n        expected = np.array(expected)\n    elif box_cls is to_array:\n        expected = to_array(expected)\n    else:\n        raise NotImplementedError(box_cls)\n    return expected",
                "def to_array(obj):\n    # temporary implementation until we get pd.array in place\n    if is_period_dtype(obj):\n        return period_array(obj)\n    elif is_datetime64_dtype(obj) or is_datetime64tz_dtype(obj):\n        return DatetimeArray._from_sequence(obj)\n    elif is_timedelta64_dtype(obj):\n        return TimedeltaArray._from_sequence(obj)\n    else:\n        return np.array(obj)",
                "def assert_sp_array_equal(\n    left,\n    right,\n    check_dtype=True,\n    check_kind=True,\n    check_fill_value=True,\n    consolidate_block_indices=False,\n):\n    \"\"\"Check that the left and right SparseArray are equal.\n\n    Parameters\n    ----------\n    left : SparseArray\n    right : SparseArray\n    check_dtype : bool, default True\n        Whether to check the data dtype is identical.\n    check_kind : bool, default True\n        Whether to just the kind of the sparse index for each column.\n    check_fill_value : bool, default True\n        Whether to check that left.fill_value matches right.fill_value\n    consolidate_block_indices : bool, default False\n        Whether to consolidate contiguous blocks for sparse arrays with\n        a BlockIndex. Some operations, e.g. concat, will end up with\n        block indices that could be consolidated. Setting this to true will\n        create a new BlockIndex for that array, with consolidated\n        block indices.\n    \"\"\"\n\n    _check_isinstance(left, right, pd.arrays.SparseArray)\n\n    assert_numpy_array_equal(left.sp_values, right.sp_values, check_dtype=check_dtype)\n\n    # SparseIndex comparison\n    assert isinstance(left.sp_index, pd._libs.sparse.SparseIndex)\n    assert isinstance(right.sp_index, pd._libs.sparse.SparseIndex)\n\n    if not check_kind:\n        left_index = left.sp_index.to_block_index()\n        right_index = right.sp_index.to_block_index()\n    else:\n        left_index = left.sp_index\n        right_index = right.sp_index\n\n    if consolidate_block_indices and left.kind == \"block\":\n        # we'll probably remove this hack...\n        left_index = left_index.to_int_index().to_block_index()\n        right_index = right_index.to_int_index().to_block_index()\n\n    if not left_index.equals(right_index):\n        raise_assert_detail(\n            \"SparseArray.index\", \"index are not equal\", left_index, right_index\n        )\n    else:\n        # Just ensure a\n        pass\n\n    if check_fill_value:\n        assert_attr_equal(\"fill_value\", left, right)\n    if check_dtype:\n        assert_attr_equal(\"dtype\", left, right)\n    assert_numpy_array_equal(left.to_dense(), right.to_dense(), check_dtype=check_dtype)",
                "def assert_contains_all(iterable, dic):\n    for k in iterable:\n        assert k in dic, f\"Did not contain item: {repr(k)}\"",
                "def assert_copy(iter1, iter2, **eql_kwargs):\n    \"\"\"\n    iter1, iter2: iterables that produce elements\n    comparable with assert_almost_equal\n\n    Checks that the elements are equal, but not\n    the same object. (Does not check that items\n    in sequences are also not the same object)\n    \"\"\"\n    for elem1, elem2 in zip(iter1, iter2):\n        assert_almost_equal(elem1, elem2, **eql_kwargs)\n        msg = (\n            f\"Expected object {repr(type(elem1))} and object {repr(type(elem2))} to be \"\n            \"different objects, but they were the same object.\"\n        )\n        assert elem1 is not elem2, msg",
                "def getCols(k):\n    return string.ascii_uppercase[:k]",
                "def makeStringIndex(k=10, name=None):\n    return Index(rands_array(nchars=10, size=k), name=name)",
                "def makeUnicodeIndex(k=10, name=None):\n    return Index(randu_array(nchars=10, size=k), name=name)",
                "def makeCategoricalIndex(k=10, n=3, name=None, **kwargs):\n    \"\"\" make a length k index or n categories \"\"\"\n    x = rands_array(nchars=4, size=n)\n    return CategoricalIndex(\n        Categorical.from_codes(np.arange(k) % n, categories=x), name=name, **kwargs\n    )",
                "def makeIntervalIndex(k=10, name=None, **kwargs):\n    \"\"\" make a length k IntervalIndex \"\"\"\n    x = np.linspace(0, 100, num=(k + 1))\n    return IntervalIndex.from_breaks(x, name=name, **kwargs)",
                "def makeBoolIndex(k=10, name=None):\n    if k == 1:\n        return Index([True], name=name)\n    elif k == 2:\n        return Index([False, True], name=name)\n    return Index([False, True] + [False] * (k - 2), name=name)",
                "def makeIntIndex(k=10, name=None):\n    return Index(list(range(k)), name=name)",
                "def makeUIntIndex(k=10, name=None):\n    return Index([2 ** 63 + i for i in range(k)], name=name)",
                "def makeRangeIndex(k=10, name=None, **kwargs):\n    return RangeIndex(0, k, 1, name=name, **kwargs)",
                "def makeFloatIndex(k=10, name=None):\n    values = sorted(np.random.random_sample(k)) - np.random.random_sample(1)\n    return Index(values * (10 ** np.random.randint(0, 9)), name=name)",
                "def makeDateIndex(k=10, freq=\"B\", name=None, **kwargs):\n    dt = datetime(2000, 1, 1)\n    dr = bdate_range(dt, periods=k, freq=freq, name=name)\n    return DatetimeIndex(dr, name=name, **kwargs)",
                "def makeTimedeltaIndex(k=10, freq=\"D\", name=None, **kwargs):\n    return pd.timedelta_range(start=\"1 day\", periods=k, freq=freq, name=name, **kwargs)",
                "def makePeriodIndex(k=10, name=None, **kwargs):\n    dt = datetime(2000, 1, 1)\n    dr = pd.period_range(start=dt, periods=k, freq=\"B\", name=name, **kwargs)\n    return dr",
                "def makeMultiIndex(k=10, names=None, **kwargs):\n    return MultiIndex.from_product(((\"foo\", \"bar\"), (1, 2)), names=names, **kwargs)",
                "def _make_timeseries(start=\"2000-01-01\", end=\"2000-12-31\", freq=\"1D\", seed=None):\n    \"\"\"\n    Make a DataFrame with a DatetimeIndex\n\n    Parameters\n    ----------\n    start : str or Timestamp, default \"2000-01-01\"\n        The start of the index. Passed to date_range with `freq`.\n    end : str or Timestamp, default \"2000-12-31\"\n        The end of the index. Passed to date_range with `freq`.\n    freq : str or Freq\n        The frequency to use for the DatetimeIndex\n    seed : int, optional\n        The random state seed.\n\n        * name : object dtype with string names\n        * id : int dtype with\n        * x, y : float dtype\n\n    Examples\n    --------\n    >>> _make_timeseries()\n                  id    name         x         y\n    timestamp\n    2000-01-01   982   Frank  0.031261  0.986727\n    2000-01-02  1025   Edith -0.086358 -0.032920\n    2000-01-03   982   Edith  0.473177  0.298654\n    2000-01-04  1009   Sarah  0.534344 -0.750377\n    2000-01-05   963   Zelda -0.271573  0.054424\n    ...          ...     ...       ...       ...\n    2000-12-27   980  Ingrid -0.132333 -0.422195\n    2000-12-28   972   Frank -0.376007 -0.298687\n    2000-12-29  1009  Ursula -0.865047 -0.503133\n    2000-12-30  1000  Hannah -0.063757 -0.507336\n    2000-12-31   972     Tim -0.869120  0.531685\n    \"\"\"\n    index = pd.date_range(start=start, end=end, freq=freq, name=\"timestamp\")\n    n = len(index)\n    state = np.random.RandomState(seed)\n    columns = {\n        \"name\": state.choice(_names, size=n),\n        \"id\": state.poisson(1000, size=n),\n        \"x\": state.rand(n) * 2 - 1,\n        \"y\": state.rand(n) * 2 - 1,\n    }\n    df = pd.DataFrame(columns, index=index, columns=sorted(columns))\n    if df.index[-1] == end:\n        df = df.iloc[:-1]\n    return df",
                "def all_index_generator(k=10):\n    \"\"\"Generator which can be iterated over to get instances of all the various\n    index classes.\n\n    Parameters\n    ----------\n    k: length of each of the index instances\n    \"\"\"\n    all_make_index_funcs = [\n        makeIntIndex,\n        makeFloatIndex,\n        makeStringIndex,\n        makeUnicodeIndex,\n        makeDateIndex,\n        makePeriodIndex,\n        makeTimedeltaIndex,\n        makeBoolIndex,\n        makeRangeIndex,\n        makeIntervalIndex,\n        makeCategoricalIndex,\n    ]\n    for make_index_func in all_make_index_funcs:\n        yield make_index_func(k=k)",
                "def index_subclass_makers_generator():\n    make_index_funcs = [\n        makeDateIndex,\n        makePeriodIndex,\n        makeTimedeltaIndex,\n        makeRangeIndex,\n        makeIntervalIndex,\n        makeCategoricalIndex,\n        makeMultiIndex,\n    ]\n    for make_index_func in make_index_funcs:\n        yield make_index_func",
                "def all_timeseries_index_generator(k=10):\n    \"\"\"Generator which can be iterated over to get instances of all the classes\n    which represent time-series.\n\n    Parameters\n    ----------\n    k: length of each of the index instances\n    \"\"\"\n    make_index_funcs = [makeDateIndex, makePeriodIndex, makeTimedeltaIndex]\n    for make_index_func in make_index_funcs:\n        yield make_index_func(k=k)",
                "def makeFloatSeries(name=None):\n    index = makeStringIndex(N)\n    return Series(randn(N), index=index, name=name)",
                "def makeStringSeries(name=None):\n    index = makeStringIndex(N)\n    return Series(randn(N), index=index, name=name)",
                "def makeObjectSeries(name=None):\n    data = makeStringIndex(N)\n    data = Index(data, dtype=object)\n    index = makeStringIndex(N)\n    return Series(data, index=index, name=name)",
                "def getSeriesData():\n    index = makeStringIndex(N)\n    return {c: Series(randn(N), index=index) for c in getCols(K)}",
                "def makeTimeSeries(nper=None, freq=\"B\", name=None):\n    if nper is None:\n        nper = N\n    return Series(randn(nper), index=makeDateIndex(nper, freq=freq), name=name)",
                "def makePeriodSeries(nper=None, name=None):\n    if nper is None:\n        nper = N\n    return Series(randn(nper), index=makePeriodIndex(nper), name=name)",
                "def getTimeSeriesData(nper=None, freq=\"B\"):\n    return {c: makeTimeSeries(nper, freq) for c in getCols(K)}",
                "def getPeriodData(nper=None):\n    return {c: makePeriodSeries(nper) for c in getCols(K)}",
                "def makeTimeDataFrame(nper=None, freq=\"B\"):\n    data = getTimeSeriesData(nper, freq)\n    return DataFrame(data)",
                "def makeDataFrame():\n    data = getSeriesData()\n    return DataFrame(data)",
                "def getMixedTypeDict():\n    index = Index([\"a\", \"b\", \"c\", \"d\", \"e\"])\n\n    data = {\n        \"A\": [0.0, 1.0, 2.0, 3.0, 4.0],\n        \"B\": [0.0, 1.0, 0.0, 1.0, 0.0],\n        \"C\": [\"foo1\", \"foo2\", \"foo3\", \"foo4\", \"foo5\"],\n        \"D\": bdate_range(\"1/1/2009\", periods=5),\n    }\n\n    return index, data",
                "def makeMixedDataFrame():\n    return DataFrame(getMixedTypeDict()[1])",
                "def makePeriodFrame(nper=None):\n    data = getPeriodData(nper)\n    return DataFrame(data)",
                "def makeCustomIndex(\n    nentries, nlevels, prefix=\"#\", names=False, ndupe_l=None, idx_type=None\n):\n    \"\"\"Create an index/multindex with given dimensions, levels, names, etc'\n\n    nentries - number of entries in index\n    nlevels - number of levels (> 1 produces multindex)\n    prefix - a string prefix for labels\n    names - (Optional), bool or list of strings. if True will use default\n       names, if false will use no names, if a list is given, the name of\n       each level in the index will be taken from the list.\n    ndupe_l - (Optional), list of ints, the number of rows for which the\n       label will repeated at the corresponding level, you can specify just\n       the first few, the rest will use the default ndupe_l of 1.\n       len(ndupe_l) <= nlevels.\n    idx_type - \"i\"/\"f\"/\"s\"/\"u\"/\"dt\"/\"p\"/\"td\".\n       If idx_type is not None, `idx_nlevels` must be 1.\n       \"i\"/\"f\" creates an integer/float index,\n       \"s\"/\"u\" creates a string/unicode index\n       \"dt\" create a datetime index.\n       \"td\" create a datetime index.\n\n        if unspecified, string labels will be generated.\n    \"\"\"\n\n    if ndupe_l is None:\n        ndupe_l = [1] * nlevels\n    assert is_sequence(ndupe_l) and len(ndupe_l) <= nlevels\n    assert names is None or names is False or names is True or len(names) is nlevels\n    assert idx_type is None or (\n        idx_type in (\"i\", \"f\", \"s\", \"u\", \"dt\", \"p\", \"td\") and nlevels == 1\n    )\n\n    if names is True:\n        # build default names\n        names = [prefix + str(i) for i in range(nlevels)]\n    if names is False:\n        # pass None to index constructor for no name\n        names = None\n\n    # make singleton case uniform\n    if isinstance(names, str) and nlevels == 1:\n        names = [names]\n\n    # specific 1D index type requested?\n    idx_func = dict(\n        i=makeIntIndex,\n        f=makeFloatIndex,\n        s=makeStringIndex,\n        u=makeUnicodeIndex,\n        dt=makeDateIndex,\n        td=makeTimedeltaIndex,\n        p=makePeriodIndex,\n    ).get(idx_type)\n    if idx_func:\n        idx = idx_func(nentries)\n        # but we need to fill in the name\n        if names:\n            idx.name = names[0]\n        return idx\n    elif idx_type is not None:\n        raise ValueError(\n            f\"{repr(idx_type)} is not a legal value for `idx_type`, \"\n            \"use  'i'/'f'/'s'/'u'/'dt'/'p'/'td'.\"\n        )\n\n    if len(ndupe_l) < nlevels:\n        ndupe_l.extend([1] * (nlevels - len(ndupe_l)))\n    assert len(ndupe_l) == nlevels\n\n    assert all(x > 0 for x in ndupe_l)\n\n    tuples = []\n    for i in range(nlevels):\n\n        def keyfunc(x):\n            import re\n\n            numeric_tuple = re.sub(r\"[^\\d_]_?\", \"\", x).split(\"_\")\n            return [int(num) for num in numeric_tuple]\n\n        # build a list of lists to create the index from\n        div_factor = nentries // ndupe_l[i] + 1\n        cnt = Counter()\n        for j in range(div_factor):\n            label = f\"{prefix}_l{i}_g{j}\"\n            cnt[label] = ndupe_l[i]\n        # cute Counter trick\n        result = sorted(cnt.elements(), key=keyfunc)[:nentries]\n        tuples.append(result)\n\n    tuples = list(zip(*tuples))\n\n    # convert tuples to index\n    if nentries == 1:\n        # we have a single level of tuples, i.e. a regular Index\n        index = Index(tuples[0], name=names[0])\n    elif nlevels == 1:\n        name = None if names is None else names[0]\n        index = Index((x[0] for x in tuples), name=name)\n    else:\n        index = MultiIndex.from_tuples(tuples, names=names)\n    return index",
                "def makeCustomDataframe(\n    nrows,\n    ncols,\n    c_idx_names=True,\n    r_idx_names=True,\n    c_idx_nlevels=1,\n    r_idx_nlevels=1,\n    data_gen_f=None,\n    c_ndupe_l=None,\n    r_ndupe_l=None,\n    dtype=None,\n    c_idx_type=None,\n    r_idx_type=None,\n):\n    \"\"\"\n   nrows,  ncols - number of data rows/cols\n   c_idx_names, idx_names  - False/True/list of strings,  yields No names ,\n        default names or uses the provided names for the levels of the\n        corresponding index. You can provide a single string when\n        c_idx_nlevels ==1.\n   c_idx_nlevels - number of levels in columns index. > 1 will yield MultiIndex\n   r_idx_nlevels - number of levels in rows index. > 1 will yield MultiIndex\n   data_gen_f - a function f(row,col) which return the data value\n        at that position, the default generator used yields values of the form\n        \"RxCy\" based on position.\n   c_ndupe_l, r_ndupe_l - list of integers, determines the number\n        of duplicates for each label at a given level of the corresponding\n        index. The default `None` value produces a multiplicity of 1 across\n        all levels, i.e. a unique index. Will accept a partial list of length\n        N < idx_nlevels, for just the first N levels. If ndupe doesn't divide\n        nrows/ncol, the last label might have lower multiplicity.\n   dtype - passed to the DataFrame constructor as is, in case you wish to\n        have more control in conjunction with a custom `data_gen_f`\n   r_idx_type, c_idx_type -  \"i\"/\"f\"/\"s\"/\"u\"/\"dt\"/\"td\".\n       If idx_type is not None, `idx_nlevels` must be 1.\n       \"i\"/\"f\" creates an integer/float index,\n       \"s\"/\"u\" creates a string/unicode index\n       \"dt\" create a datetime index.\n       \"td\" create a timedelta index.\n\n        if unspecified, string labels will be generated.\n\n    Examples:\n\n    # 5 row, 3 columns, default names on both, single index on both axis\n    >> makeCustomDataframe(5,3)\n\n    # make the data a random int between 1 and 100\n    >> mkdf(5,3,data_gen_f=lambda r,c:randint(1,100))\n\n    # 2-level multiindex on rows with each label duplicated\n    # twice on first level, default names on both axis, single\n    # index on both axis\n    >> a=makeCustomDataframe(5,3,r_idx_nlevels=2,r_ndupe_l=[2])\n\n    # DatetimeIndex on row, index with unicode labels on columns\n    # no names on either axis\n    >> a=makeCustomDataframe(5,3,c_idx_names=False,r_idx_names=False,\n                             r_idx_type=\"dt\",c_idx_type=\"u\")\n\n    # 4-level multindex on rows with names provided, 2-level multindex\n    # on columns with default labels and default names.\n    >> a=makeCustomDataframe(5,3,r_idx_nlevels=4,\n                             r_idx_names=[\"FEE\",\"FI\",\"FO\",\"FAM\"],\n                             c_idx_nlevels=2)\n\n    >> a=mkdf(5,3,r_idx_nlevels=2,c_idx_nlevels=4)\n    \"\"\"\n\n    assert c_idx_nlevels > 0\n    assert r_idx_nlevels > 0\n    assert r_idx_type is None or (\n        r_idx_type in (\"i\", \"f\", \"s\", \"u\", \"dt\", \"p\", \"td\") and r_idx_nlevels == 1\n    )\n    assert c_idx_type is None or (\n        c_idx_type in (\"i\", \"f\", \"s\", \"u\", \"dt\", \"p\", \"td\") and c_idx_nlevels == 1\n    )\n\n    columns = makeCustomIndex(\n        ncols,\n        nlevels=c_idx_nlevels,\n        prefix=\"C\",\n        names=c_idx_names,\n        ndupe_l=c_ndupe_l,\n        idx_type=c_idx_type,\n    )\n    index = makeCustomIndex(\n        nrows,\n        nlevels=r_idx_nlevels,\n        prefix=\"R\",\n        names=r_idx_names,\n        ndupe_l=r_ndupe_l,\n        idx_type=r_idx_type,\n    )\n\n    # by default, generate data based on location\n    if data_gen_f is None:\n        data_gen_f = lambda r, c: f\"R{r}C{c}\"\n\n    data = [[data_gen_f(r, c) for c in range(ncols)] for r in range(nrows)]\n\n    return DataFrame(data, index, columns, dtype=dtype)",
                "def _create_missing_idx(nrows, ncols, density, random_state=None):\n    if random_state is None:\n        random_state = np.random\n    else:\n        random_state = np.random.RandomState(random_state)\n\n    # below is cribbed from scipy.sparse\n    size = int(np.round((1 - density) * nrows * ncols))\n    # generate a few more to ensure unique values\n    min_rows = 5\n    fac = 1.02\n    extra_size = min(size + min_rows, fac * size)\n\n    def _gen_unique_rand(rng, _extra_size):\n        ind = rng.rand(int(_extra_size))\n        return np.unique(np.floor(ind * nrows * ncols))[:size]\n\n    ind = _gen_unique_rand(random_state, extra_size)\n    while ind.size < size:\n        extra_size *= 1.05\n        ind = _gen_unique_rand(random_state, extra_size)\n\n    j = np.floor(ind * 1.0 / nrows).astype(int)\n    i = (ind - j * nrows).astype(int)\n    return i.tolist(), j.tolist()",
                "def makeMissingCustomDataframe(\n    nrows,\n    ncols,\n    density=0.9,\n    random_state=None,\n    c_idx_names=True,\n    r_idx_names=True,\n    c_idx_nlevels=1,\n    r_idx_nlevels=1,\n    data_gen_f=None,\n    c_ndupe_l=None,\n    r_ndupe_l=None,\n    dtype=None,\n    c_idx_type=None,\n    r_idx_type=None,\n):\n    \"\"\"\n    Parameters\n    ----------\n    Density : float, optional\n        Float in (0, 1) that gives the percentage of non-missing numbers in\n        the DataFrame.\n    random_state : {np.random.RandomState, int}, optional\n        Random number generator or random seed.\n\n    See makeCustomDataframe for descriptions of the rest of the parameters.\n    \"\"\"\n    df = makeCustomDataframe(\n        nrows,\n        ncols,\n        c_idx_names=c_idx_names,\n        r_idx_names=r_idx_names,\n        c_idx_nlevels=c_idx_nlevels,\n        r_idx_nlevels=r_idx_nlevels,\n        data_gen_f=data_gen_f,\n        c_ndupe_l=c_ndupe_l,\n        r_ndupe_l=r_ndupe_l,\n        dtype=dtype,\n        c_idx_type=c_idx_type,\n        r_idx_type=r_idx_type,\n    )\n\n    i, j = _create_missing_idx(nrows, ncols, density, random_state)\n    df.values[i, j] = np.nan\n    return df",
                "def makeMissingDataframe(density=0.9, random_state=None):\n    df = makeDataFrame()\n    i, j = _create_missing_idx(*df.shape, density=density, random_state=random_state)\n    df.values[i, j] = np.nan\n    return df",
                "def optional_args(decorator):\n    \"\"\"allows a decorator to take optional positional and keyword arguments.\n    Assumes that taking a single, callable, positional argument means that\n    it is decorating a function, i.e. something like this::\n\n        @my_decorator\n        def function(): pass\n\n    Calls decorator with decorator(f, *args, **kwargs)\"\"\"\n\n    @wraps(decorator)\n    def wrapper(*args, **kwargs):\n        def dec(f):\n            return decorator(f, *args, **kwargs)\n\n        is_decorating = not kwargs and len(args) == 1 and callable(args[0])\n        if is_decorating:\n            f = args[0]\n            args = []\n            return dec(f)\n        else:\n            return dec\n\n    return wrapper",
                "def _get_default_network_errors():\n    # Lazy import for http.client because it imports many things from the stdlib\n    import http.client\n\n    return (IOError, http.client.HTTPException, TimeoutError)",
                "def can_connect(url, error_classes=None):\n    \"\"\"Try to connect to the given url. True if succeeds, False if IOError\n    raised\n\n    Parameters\n    ----------\n    url : basestring\n        The URL to try to connect to\n\n    Returns\n    -------\n    connectable : bool\n        Return True if no IOError (unable to connect) or URLError (bad url) was\n        raised\n    \"\"\"\n\n    if error_classes is None:\n        error_classes = _get_default_network_errors()\n\n    try:\n        with urlopen(url):\n            pass\n    except error_classes:\n        return False\n    else:\n        return True",
                "@optional_args\ndef network(\n    t,\n    url=\"http://www.google.com\",\n    raise_on_error=_RAISE_NETWORK_ERROR_DEFAULT,\n    check_before_test=False,\n    error_classes=None,\n    skip_errnos=_network_errno_vals,\n    _skip_on_messages=_network_error_messages,\n):\n    \"\"\"\n    Label a test as requiring network connection and, if an error is\n    encountered, only raise if it does not find a network connection.\n\n    In comparison to ``network``, this assumes an added contract to your test:\n    you must assert that, under normal conditions, your test will ONLY fail if\n    it does not have network connectivity.\n\n    You can call this in 3 ways: as a standard decorator, with keyword\n    arguments, or with a positional argument that is the url to check.\n\n    Parameters\n    ----------\n    t : callable\n        The test requiring network connectivity.\n    url : path\n        The url to test via ``pandas.io.common.urlopen`` to check\n        for connectivity. Defaults to 'http://www.google.com'.\n    raise_on_error : bool\n        If True, never catches errors.\n    check_before_test : bool\n        If True, checks connectivity before running the test case.\n    error_classes : tuple or Exception\n        error classes to ignore. If not in ``error_classes``, raises the error.\n        defaults to IOError. Be careful about changing the error classes here.\n    skip_errnos : iterable of int\n        Any exception that has .errno or .reason.erno set to one\n        of these values will be skipped with an appropriate\n        message.\n    _skip_on_messages: iterable of string\n        any exception e for which one of the strings is\n        a substring of str(e) will be skipped with an appropriate\n        message. Intended to suppress errors where an errno isn't available.\n\n    Notes\n    -----\n    * ``raise_on_error`` supercedes ``check_before_test``\n\n    Returns\n    -------\n    t : callable\n        The decorated test ``t``, with checks for connectivity errors.\n\n    Example\n    -------\n\n    Tests decorated with @network will fail if it's possible to make a network\n    connection to another URL (defaults to google.com)::\n\n      >>> from pandas._testing import network\n      >>> from pandas.io.common import urlopen\n      >>> @network\n      ... def test_network():\n      ...     with urlopen(\"rabbit://bonanza.com\"):\n      ...         pass\n      Traceback\n         ...\n      URLError: <urlopen error unknown url type: rabit>\n\n      You can specify alternative URLs::\n\n        >>> @network(\"http://www.yahoo.com\")\n        ... def test_something_with_yahoo():\n        ...    raise IOError(\"Failure Message\")\n        >>> test_something_with_yahoo()\n        Traceback (most recent call last):\n            ...\n        IOError: Failure Message\n\n    If you set check_before_test, it will check the url first and not run the\n    test on failure::\n\n        >>> @network(\"failing://url.blaher\", check_before_test=True)\n        ... def test_something():\n        ...     print(\"I ran!\")\n        ...     raise ValueError(\"Failure\")\n        >>> test_something()\n        Traceback (most recent call last):\n            ...\n\n    Errors not related to networking will always be raised.\n    \"\"\"\n    from pytest import skip\n\n    if error_classes is None:\n        error_classes = _get_default_network_errors()\n\n    t.network = True\n\n    @wraps(t)\n    def wrapper(*args, **kwargs):\n        if check_before_test and not raise_on_error:\n            if not can_connect(url, error_classes):\n                skip()\n        try:\n            return t(*args, **kwargs)\n        except Exception as err:\n            errno = getattr(err, \"errno\", None)\n            if not errno and hasattr(errno, \"reason\"):\n                errno = getattr(err.reason, \"errno\", None)\n\n            if errno in skip_errnos:\n                skip(f\"Skipping test due to known errno and error {err}\")\n\n            e_str = str(err)\n\n            if any(m.lower() in e_str.lower() for m in _skip_on_messages):\n                skip(\n                    f\"Skipping test because exception message is known and error {err}\"\n                )\n\n            if not isinstance(err, error_classes):\n                raise\n\n            if raise_on_error or can_connect(url, error_classes):\n                raise\n            else:\n                skip(f\"Skipping test due to lack of connectivity and error {err}\")\n\n    return wrapper",
                "@contextmanager\ndef assert_produces_warning(\n    expected_warning=Warning,\n    filter_level=\"always\",\n    clear=None,\n    check_stacklevel=True,\n    raise_on_extra_warnings=True,\n):\n    \"\"\"\n    Context manager for running code expected to either raise a specific\n    warning, or not raise any warnings. Verifies that the code raises the\n    expected warning, and that it does not raise any other unexpected\n    warnings. It is basically a wrapper around ``warnings.catch_warnings``.\n\n    Parameters\n    ----------\n    expected_warning : {Warning, False, None}, default Warning\n        The type of Exception raised. ``exception.Warning`` is the base\n        class for all warnings. To check that no warning is returned,\n        specify ``False`` or ``None``.\n    filter_level : str or None, default \"always\"\n        Specifies whether warnings are ignored, displayed, or turned\n        into errors.\n        Valid values are:\n\n        * \"error\" - turns matching warnings into exceptions\n        * \"ignore\" - discard the warning\n        * \"always\" - always emit a warning\n        * \"default\" - print the warning the first time it is generated\n          from each location\n        * \"module\" - print the warning the first time it is generated\n          from each module\n        * \"once\" - print the warning the first time it is generated\n\n    clear : str, default None\n        If not ``None`` then remove any previously raised warnings from\n        the ``__warningsregistry__`` to ensure that no warning messages are\n        suppressed by this context manager. If ``None`` is specified,\n        the ``__warningsregistry__`` keeps track of which warnings have been\n        shown, and does not show them again.\n    check_stacklevel : bool, default True\n        If True, displays the line that called the function containing\n        the warning to show were the function is called. Otherwise, the\n        line that implements the function is displayed.\n    raise_on_extra_warnings : bool, default True\n        Whether extra warnings not of the type `expected_warning` should\n        cause the test to fail.\n\n    Examples\n    --------\n    >>> import warnings\n    >>> with assert_produces_warning():\n    ...     warnings.warn(UserWarning())\n    ...\n    >>> with assert_produces_warning(False):\n    ...     warnings.warn(RuntimeWarning())\n    ...\n    Traceback (most recent call last):\n        ...\n    AssertionError: Caused unexpected warning(s): ['RuntimeWarning'].\n    >>> with assert_produces_warning(UserWarning):\n    ...     warnings.warn(RuntimeWarning())\n    Traceback (most recent call last):\n        ...\n    AssertionError: Did not see expected warning of class 'UserWarning'.\n\n    ..warn:: This is *not* thread-safe.\n    \"\"\"\n    __tracebackhide__ = True\n\n    with warnings.catch_warnings(record=True) as w:\n\n        if clear is not None:\n            # make sure that we are clearing these warnings\n            # if they have happened before\n            # to guarantee that we will catch them\n            if not is_list_like(clear):\n                clear = [clear]\n            for m in clear:\n                try:\n                    m.__warningregistry__.clear()\n                except AttributeError:\n                    # module may not have __warningregistry__\n                    pass\n\n        saw_warning = False\n        warnings.simplefilter(filter_level)\n        yield w\n        extra_warnings = []\n\n        for actual_warning in w:\n            if expected_warning and issubclass(\n                actual_warning.category, expected_warning\n            ):\n                saw_warning = True\n\n                if check_stacklevel and issubclass(\n                    actual_warning.category, (FutureWarning, DeprecationWarning)\n                ):\n                    from inspect import getframeinfo, stack\n\n                    caller = getframeinfo(stack()[2][0])\n                    msg = (\n                        \"Warning not set with correct stacklevel. \"\n                        f\"File where warning is raised: {actual_warning.filename} != \"\n                        f\"{caller.filename}. Warning message: {actual_warning.message}\"\n                    )\n                    assert actual_warning.filename == caller.filename, msg\n            else:\n                extra_warnings.append(\n                    (\n                        actual_warning.category.__name__,\n                        actual_warning.message,\n                        actual_warning.filename,\n                        actual_warning.lineno,\n                    )\n                )\n        if expected_warning:\n            msg = (\n                f\"Did not see expected warning of class \"\n                f\"{repr(expected_warning.__name__)}\"\n            )\n            assert saw_warning, msg\n        if raise_on_extra_warnings and extra_warnings:\n            raise AssertionError(\n                f\"Caused unexpected warning(s): {repr(extra_warnings)}\"\n            )",
                "@contextmanager\ndef with_csv_dialect(name, **kwargs):\n    \"\"\"\n    Context manager to temporarily register a CSV dialect for parsing CSV.\n\n    Parameters\n    ----------\n    name : str\n        The name of the dialect.\n    kwargs : mapping\n        The parameters for the dialect.\n\n    Raises\n    ------\n    ValueError : the name of the dialect conflicts with a builtin one.\n\n    See Also\n    --------\n    csv : Python's CSV library.\n    \"\"\"\n    import csv\n\n    _BUILTIN_DIALECTS = {\"excel\", \"excel-tab\", \"unix\"}\n\n    if name in _BUILTIN_DIALECTS:\n        raise ValueError(\"Cannot override builtin dialect.\")\n\n    csv.register_dialect(name, **kwargs)\n    yield\n    csv.unregister_dialect(name)",
                "@contextmanager\ndef use_numexpr(use, min_elements=None):\n    from pandas.core.computation import expressions as expr\n\n    if min_elements is None:\n        min_elements = expr._MIN_ELEMENTS\n\n    olduse = expr._USE_NUMEXPR\n    oldmin = expr._MIN_ELEMENTS\n    expr.set_use_numexpr(use)\n    expr._MIN_ELEMENTS = min_elements\n    yield\n    expr._MIN_ELEMENTS = oldmin\n    expr.set_use_numexpr(olduse)",
                "def test_parallel(num_threads=2, kwargs_list=None):\n    \"\"\"Decorator to run the same function multiple times in parallel.\n\n    Parameters\n    ----------\n    num_threads : int, optional\n        The number of times the function is run in parallel.\n    kwargs_list : list of dicts, optional\n        The list of kwargs to update original\n        function kwargs on different threads.\n    Notes\n    -----\n    This decorator does not pass the return value of the decorated function.\n\n    Original from scikit-image:\n\n    https://github.com/scikit-image/scikit-image/pull/1519\n\n    \"\"\"\n\n    assert num_threads > 0\n    has_kwargs_list = kwargs_list is not None\n    if has_kwargs_list:\n        assert len(kwargs_list) == num_threads\n    import threading\n\n    def wrapper(func):\n        @wraps(func)\n        def inner(*args, **kwargs):\n            if has_kwargs_list:\n                update_kwargs = lambda i: dict(kwargs, **kwargs_list[i])\n            else:\n                update_kwargs = lambda i: kwargs\n            threads = []\n            for i in range(num_threads):\n                updated_kwargs = update_kwargs(i)\n                thread = threading.Thread(target=func, args=args, kwargs=updated_kwargs)\n                threads.append(thread)\n            for thread in threads:\n                thread.start()\n            for thread in threads:\n                thread.join()\n\n        return inner\n\n    return wrapper",
                "@contextmanager\ndef set_timezone(tz: str):\n    \"\"\"\n    Context manager for temporarily setting a timezone.\n\n    Parameters\n    ----------\n    tz : str\n        A string representing a valid timezone.\n\n    Examples\n    --------\n\n    >>> from datetime import datetime\n    >>> from dateutil.tz import tzlocal\n    >>> tzlocal().tzname(datetime.now())\n    'IST'\n\n    >>> with set_timezone('US/Eastern'):\n    ...     tzlocal().tzname(datetime.now())\n    ...\n    'EDT'\n    \"\"\"\n\n    import os\n    import time\n\n    def setTZ(tz):\n        if tz is None:\n            try:\n                del os.environ[\"TZ\"]\n            except KeyError:\n                pass\n        else:\n            os.environ[\"TZ\"] = tz\n            time.tzset()\n\n    orig_tz = os.environ.get(\"TZ\")\n    setTZ(tz)\n    try:\n        yield\n    finally:\n        setTZ(orig_tz)",
                "def _make_skipna_wrapper(alternative, skipna_alternative=None):\n    \"\"\"\n    Create a function for calling on an array.\n\n    Parameters\n    ----------\n    alternative : function\n        The function to be called on the array with no NaNs.\n        Only used when 'skipna_alternative' is None.\n    skipna_alternative : function\n        The function to be called on the original array\n\n    Returns\n    -------\n    function\n    \"\"\"\n    if skipna_alternative:\n\n        def skipna_wrapper(x):\n            return skipna_alternative(x.values)\n\n    else:\n\n        def skipna_wrapper(x):\n            nona = x.dropna()\n            if len(nona) == 0:\n                return np.nan\n            return alternative(nona)\n\n    return skipna_wrapper",
                "def convert_rows_list_to_csv_str(rows_list: List[str]):\n    \"\"\"\n    Convert list of CSV rows to single CSV-formatted string for current OS.\n\n    This method is used for creating expected value of to_csv() method.\n\n    Parameters\n    ----------\n    rows_list : List[str]\n        Each element represents the row of csv.\n\n    Returns\n    -------\n    str\n        Expected output of to_csv() in current OS.\n    \"\"\"\n    sep = os.linesep\n    expected = sep.join(rows_list) + sep\n    return expected",
                "def _check_types(l, r, obj=\"Index\"):\n    if exact:\n        assert_class_equal(l, r, exact=exact, obj=obj)\n\n        # Skip exact dtype checking when `check_categorical` is False\n        if check_categorical:\n            assert_attr_equal(\"dtype\", l, r, obj=obj)\n\n        # allow string-like to have different inferred_types\n        if l.inferred_type in (\"string\", \"unicode\"):\n            assert r.inferred_type in (\"string\", \"unicode\")\n        else:\n            assert_attr_equal(\"inferred_type\", l, r, obj=obj)",
                "def _get_ilevel_values(index, level):\n    # accept level number only\n    unique = index.levels[level]\n    level_codes = index.codes[level]\n    filled = take_1d(unique._values, level_codes, fill_value=unique._na_value)\n    values = unique._shallow_copy(filled, name=index.names[level])\n    return values",
                "def repr_class(x):\n    if isinstance(x, Index):\n        # return Index as it is to include values in the error message\n        return x\n\n    try:\n        return type(x).__name__\n    except AttributeError:\n        return repr(type(x))",
                "def _get_base(obj):\n    return obj.base if getattr(obj, \"base\", None) is not None else obj",
                "def _raise(left, right, err_msg):\n    if err_msg is None:\n        if left.shape != right.shape:\n            raise_assert_detail(\n                obj, f\"{obj} shapes are different\", left.shape, right.shape,\n            )\n\n        diff = 0\n        for l, r in zip(left, right):\n            # count up differences\n            if not array_equivalent(l, r, strict_nan=strict_nan):\n                diff += 1\n\n        diff = diff * 100.0 / left.size\n        msg = f\"{obj} values are different ({np.round(diff, 5)} %)\"\n        raise_assert_detail(obj, msg, left, right)\n\n    raise AssertionError(err_msg)",
                "def _gen_unique_rand(rng, _extra_size):\n    ind = rng.rand(int(_extra_size))\n    return np.unique(np.floor(ind * nrows * ncols))[:size]",
                "@wraps(decorator)\ndef wrapper(*args, **kwargs):\n    def dec(f):\n        return decorator(f, *args, **kwargs)\n\n    is_decorating = not kwargs and len(args) == 1 and callable(args[0])\n    if is_decorating:\n        f = args[0]\n        args = []\n        return dec(f)\n    else:\n        return dec",
                "@wraps(t)\ndef wrapper(*args, **kwargs):\n    if check_before_test and not raise_on_error:\n        if not can_connect(url, error_classes):\n            skip()\n    try:\n        return t(*args, **kwargs)\n    except Exception as err:\n        errno = getattr(err, \"errno\", None)\n        if not errno and hasattr(errno, \"reason\"):\n            errno = getattr(err.reason, \"errno\", None)\n\n        if errno in skip_errnos:\n            skip(f\"Skipping test due to known errno and error {err}\")\n\n        e_str = str(err)\n\n        if any(m.lower() in e_str.lower() for m in _skip_on_messages):\n            skip(\n                f\"Skipping test because exception message is known and error {err}\"\n            )\n\n        if not isinstance(err, error_classes):\n            raise\n\n        if raise_on_error or can_connect(url, error_classes):\n            raise\n        else:\n            skip(f\"Skipping test due to lack of connectivity and error {err}\")",
                "def __init__(self, seed):\n    self.seed = seed",
                "def __enter__(self):\n\n    self.start_state = np.random.get_state()\n    np.random.seed(self.seed)",
                "def __exit__(self, exc_type, exc_value, traceback):\n\n    np.random.set_state(self.start_state)",
                "def wrapper(func):\n    @wraps(func)\n    def inner(*args, **kwargs):\n        if has_kwargs_list:\n            update_kwargs = lambda i: dict(kwargs, **kwargs_list[i])\n        else:\n            update_kwargs = lambda i: kwargs\n        threads = []\n        for i in range(num_threads):\n            updated_kwargs = update_kwargs(i)\n            thread = threading.Thread(target=func, args=args, kwargs=updated_kwargs)\n            threads.append(thread)\n        for thread in threads:\n            thread.start()\n        for thread in threads:\n            thread.join()\n\n    return inner",
                "@property\ndef _constructor(self):\n    return SubclassedSeries",
                "@property\ndef _constructor_expanddim(self):\n    return SubclassedDataFrame",
                "@property\ndef _constructor(self):\n    return SubclassedDataFrame",
                "@property\ndef _constructor_sliced(self):\n    return SubclassedSeries",
                "@property\ndef _constructor(self):\n    return SubclassedCategorical",
                "def setTZ(tz):\n    if tz is None:\n        try:\n            del os.environ[\"TZ\"]\n        except KeyError:\n            pass\n    else:\n        os.environ[\"TZ\"] = tz\n        time.tzset()",
                "def keyfunc(x):\n    import re\n\n    numeric_tuple = re.sub(r\"[^\\d_]_?\", \"\", x).split(\"_\")\n    return [int(num) for num in numeric_tuple]",
                "def dec(f):\n    return decorator(f, *args, **kwargs)",
                "@wraps(func)\ndef inner(*args, **kwargs):\n    if has_kwargs_list:\n        update_kwargs = lambda i: dict(kwargs, **kwargs_list[i])\n    else:\n        update_kwargs = lambda i: kwargs\n    threads = []\n    for i in range(num_threads):\n        updated_kwargs = update_kwargs(i)\n        thread = threading.Thread(target=func, args=args, kwargs=updated_kwargs)\n        threads.append(thread)\n    for thread in threads:\n        thread.start()\n    for thread in threads:\n        thread.join()",
                "def skipna_wrapper(x):\n    return skipna_alternative(x.values)",
                "def skipna_wrapper(x):\n    nona = x.dropna()\n    if len(nona) == 0:\n        return np.nan\n    return alternative(nona)"
            ],
            "inscope_function_signatures": [
                "set_testing_mode()",
                "reset_testing_mode()",
                "reset_display_options()",
                "round_trip_pickle(obj: FrameOrSeries, path: Optional[str]=None) -> FrameOrSeries",
                "round_trip_pathlib(writer, reader, path: Optional[str]=None)",
                "round_trip_localpath(writer, reader, path: Optional[str]=None)",
                "decompress_file(path, compression)",
                "write_to_compressed(compression, path, data, dest='test')",
                "assert_almost_equal(left, right, check_dtype: Union[bool, str]='equiv', check_less_precise: Union[bool, int]=False, **kwargs)",
                "_check_isinstance(left, right, cls)",
                "assert_dict_equal(left, right, compare_keys: bool=True)",
                "randbool(size=(), p: float=0.5)",
                "rands_array(nchars, size, dtype='O')",
                "randu_array(nchars, size, dtype='O')",
                "rands(nchars)",
                "randu(nchars)",
                "close(fignum=None)",
                "ensure_clean(filename=None, return_filelike=False)",
                "ensure_clean_dir()",
                "ensure_safe_environment_variables()",
                "equalContents(arr1, arr2) -> bool",
                "assert_index_equal(left: Index, right: Index, exact: Union[bool, str]='equiv', check_names: bool=True, check_less_precise: Union[bool, int]=False, check_exact: bool=True, check_categorical: bool=True, obj: str='Index') -> None",
                "assert_class_equal(left, right, exact: Union[bool, str]=True, obj='Input')",
                "assert_attr_equal(attr, left, right, obj='Attributes')",
                "assert_is_valid_plot_return_object(objs)",
                "isiterable(obj)",
                "assert_is_sorted(seq)",
                "assert_categorical_equal(left, right, check_dtype=True, check_category_order=True, obj='Categorical')",
                "assert_interval_array_equal(left, right, exact='equiv', obj='IntervalArray')",
                "assert_period_array_equal(left, right, obj='PeriodArray')",
                "assert_datetime_array_equal(left, right, obj='DatetimeArray')",
                "assert_timedelta_array_equal(left, right, obj='TimedeltaArray')",
                "raise_assert_detail(obj, message, left, right, diff=None)",
                "assert_numpy_array_equal(left, right, strict_nan=False, check_dtype=True, err_msg=None, check_same=None, obj='numpy array')",
                "assert_extension_array_equal(left, right, check_dtype=True, check_less_precise=False, check_exact=False)",
                "assert_series_equal(left, right, check_dtype=True, check_index_type='equiv', check_series_type=True, check_less_precise=False, check_names=True, check_exact=False, check_datetimelike_compat=False, check_categorical=True, obj='Series')",
                "assert_frame_equal(left, right, check_dtype=True, check_index_type='equiv', check_column_type='equiv', check_frame_type=True, check_less_precise=False, check_names=True, by_blocks=False, check_exact=False, check_datetimelike_compat=False, check_categorical=True, check_like=False, obj='DataFrame')",
                "assert_equal(left, right, **kwargs)",
                "box_expected(expected, box_cls, transpose=True)",
                "to_array(obj)",
                "assert_sp_array_equal(left, right, check_dtype=True, check_kind=True, check_fill_value=True, consolidate_block_indices=False)",
                "assert_contains_all(iterable, dic)",
                "assert_copy(iter1, iter2, **eql_kwargs)",
                "getCols(k)",
                "makeStringIndex(k=10, name=None)",
                "makeUnicodeIndex(k=10, name=None)",
                "makeCategoricalIndex(k=10, n=3, name=None, **kwargs)",
                "makeIntervalIndex(k=10, name=None, **kwargs)",
                "makeBoolIndex(k=10, name=None)",
                "makeIntIndex(k=10, name=None)",
                "makeUIntIndex(k=10, name=None)",
                "makeRangeIndex(k=10, name=None, **kwargs)",
                "makeFloatIndex(k=10, name=None)",
                "makeDateIndex(k=10, freq='B', name=None, **kwargs)",
                "makeTimedeltaIndex(k=10, freq='D', name=None, **kwargs)",
                "makePeriodIndex(k=10, name=None, **kwargs)",
                "makeMultiIndex(k=10, names=None, **kwargs)",
                "_make_timeseries(start='2000-01-01', end='2000-12-31', freq='1D', seed=None)",
                "all_index_generator(k=10)",
                "index_subclass_makers_generator()",
                "all_timeseries_index_generator(k=10)",
                "makeFloatSeries(name=None)",
                "makeStringSeries(name=None)",
                "makeObjectSeries(name=None)",
                "getSeriesData()",
                "makeTimeSeries(nper=None, freq='B', name=None)",
                "makePeriodSeries(nper=None, name=None)",
                "getTimeSeriesData(nper=None, freq='B')",
                "getPeriodData(nper=None)",
                "makeTimeDataFrame(nper=None, freq='B')",
                "makeDataFrame()",
                "getMixedTypeDict()",
                "makeMixedDataFrame()",
                "makePeriodFrame(nper=None)",
                "makeCustomIndex(nentries, nlevels, prefix='#', names=False, ndupe_l=None, idx_type=None)",
                "makeCustomDataframe(nrows, ncols, c_idx_names=True, r_idx_names=True, c_idx_nlevels=1, r_idx_nlevels=1, data_gen_f=None, c_ndupe_l=None, r_ndupe_l=None, dtype=None, c_idx_type=None, r_idx_type=None)",
                "_create_missing_idx(nrows, ncols, density, random_state=None)",
                "makeMissingCustomDataframe(nrows, ncols, density=0.9, random_state=None, c_idx_names=True, r_idx_names=True, c_idx_nlevels=1, r_idx_nlevels=1, data_gen_f=None, c_ndupe_l=None, r_ndupe_l=None, dtype=None, c_idx_type=None, r_idx_type=None)",
                "makeMissingDataframe(density=0.9, random_state=None)",
                "optional_args(decorator)",
                "_get_default_network_errors()",
                "can_connect(url, error_classes=None)",
                "network(t, url='http://www.google.com', raise_on_error=_RAISE_NETWORK_ERROR_DEFAULT, check_before_test=False, error_classes=None, skip_errnos=_network_errno_vals, _skip_on_messages=_network_error_messages)",
                "assert_produces_warning(expected_warning=Warning, filter_level='always', clear=None, check_stacklevel=True, raise_on_extra_warnings=True)",
                "with_csv_dialect(name, **kwargs)",
                "use_numexpr(use, min_elements=None)",
                "test_parallel(num_threads=2, kwargs_list=None)",
                "set_timezone(tz: str)",
                "_make_skipna_wrapper(alternative, skipna_alternative=None)",
                "convert_rows_list_to_csv_str(rows_list: List[str])",
                "_check_types(l, r, obj='Index')",
                "_get_ilevel_values(index, level)",
                "repr_class(x)",
                "_get_base(obj)",
                "_raise(left, right, err_msg)",
                "_gen_unique_rand(rng, _extra_size)",
                "wrapper(*args, **kwargs)",
                "wrapper(*args, **kwargs)",
                "__init__(self, seed)",
                "__enter__(self)",
                "__exit__(self, exc_type, exc_value, traceback)",
                "wrapper(func)",
                "_constructor(self)",
                "_constructor_expanddim(self)",
                "_constructor(self)",
                "_constructor_sliced(self)",
                "_constructor(self)",
                "setTZ(tz)",
                "keyfunc(x)",
                "dec(f)",
                "inner(*args, **kwargs)",
                "skipna_wrapper(x)",
                "skipna_wrapper(x)"
            ],
            "variables_in_file": {
                "lzma": [
                    209,
                    260,
                    70
                ],
                "_import_lzma": [
                    70
                ],
                "N": [
                    1793,
                    1764,
                    1765,
                    72,
                    1769,
                    1770,
                    1774,
                    1776,
                    1781,
                    1782,
                    1787
                ],
                "K": [
                    73,
                    1802,
                    1782,
                    1798
                ],
                "_RAISE_NETWORK_ERROR_DEFAULT": [
                    74,
                    2231
                ],
                "_testing_mode_warnings": [
                    91,
                    84,
                    77
                ],
                "DeprecationWarning": [
                    2459,
                    77
                ],
                "ResourceWarning": [
                    77
                ],
                "testing_mode": [
                    89,
                    82,
                    83,
                    90
                ],
                "os.environ.get": [
                    89,
                    82,
                    2684
                ],
                "os.environ": [
                    548,
                    552,
                    553,
                    2681,
                    82,
                    2677,
                    89,
                    2684
                ],
                "os": [
                    515,
                    516,
                    548,
                    552,
                    553,
                    497,
                    82,
                    2681,
                    2740,
                    2677,
                    89,
                    2684,
                    511
                ],
                "warnings.simplefilter": [
                    2448,
                    91,
                    84
                ],
                "warnings": [
                    2432,
                    91,
                    84,
                    2448
                ],
                "set_testing_mode": [
                    94
                ],
                "pd.reset_option": [
                    101
                ],
                "pd": [
                    775,
                    1424,
                    1425,
                    1426,
                    1427,
                    1428,
                    1429,
                    1695,
                    1704,
                    689,
                    691,
                    309,
                    319,
                    329,
                    1616,
                    1621,
                    1495,
                    1500,
                    1501,
                    101,
                    1386,
                    1388,
                    1390,
                    123,
                    124
                ],
                "FrameOrSeries": [
                    104
                ],
                "Optional": [
                    104,
                    156,
                    127
                ],
                "str": [
                    1183,
                    1404,
                    2724,
                    2341,
                    104,
                    2648,
                    575,
                    1873,
                    1141,
                    1879,
                    280,
                    570,
                    699,
                    156,
                    127
                ],
                "path": [
                    273,
                    148,
                    149,
                    150,
                    151,
                    152,
                    177,
                    178,
                    179,
                    180,
                    181,
                    203,
                    205,
                    207,
                    209,
                    211,
                    216,
                    120,
                    121,
                    122,
                    123,
                    124
                ],
                "rands": [
                    121
                ],
                "ensure_clean": [
                    122,
                    179,
                    150
                ],
                "pd.to_pickle": [
                    123
                ],
                "obj": [
                    641,
                    769,
                    644,
                    903,
                    152,
                    153,
                    792,
                    667,
                    1183,
                    1312,
                    673,
                    674,
                    1188,
                    1192,
                    681,
                    1458,
                    1453,
                    1454,
                    1327,
                    688,
                    1455,
                    690,
                    947,
                    1456,
                    181,
                    182,
                    1457,
                    696,
                    952,
                    826,
                    1339,
                    828,
                    1460,
                    834,
                    1350,
                    839,
                    968,
                    842,
                    720,
                    721,
                    978,
                    979,
                    724,
                    725,
                    1109,
                    1369,
                    989,
                    606,
                    350,
                    352,
                    353,
                    610,
                    862,
                    863,
                    864,
                    870,
                    871,
                    616,
                    1120,
                    878,
                    879,
                    880,
                    887,
                    1134,
                    1141,
                    630,
                    886,
                    634,
                    123,
                    637
                ],
                "pd.read_pickle": [
                    124
                ],
                "Path": [
                    152,
                    147,
                    151
                ],
                "pytest.importorskip": [
                    176,
                    147
                ],
                "pytest": [
                    176,
                    505,
                    147
                ],
                "writer": [
                    180,
                    151
                ],
                "reader": [
                    152,
                    181
                ],
                "LocalPath": [
                    176,
                    180,
                    181
                ],
                "local": [
                    176
                ],
                "compression": [
                    224,
                    259,
                    262,
                    264,
                    202,
                    204,
                    206,
                    208,
                    210,
                    247,
                    218,
                    251,
                    255
                ],
                "f": [
                    2145,
                    2147,
                    490,
                    203,
                    492,
                    205,
                    494,
                    207,
                    209,
                    273,
                    274,
                    2141,
                    214,
                    221,
                    223
                ],
                "open": [
                    203
                ],
                "gzip.open": [
                    205
                ],
                "gzip": [
                    205,
                    254
                ],
                "bz2.BZ2File": [
                    258,
                    207
                ],
                "bz2": [
                    258,
                    207
                ],
                "_get_lzma_file": [
                    209,
                    260
                ],
                "zip_file": [
                    225,
                    211,
                    212,
                    214
                ],
                "zipfile.ZipFile": [
                    250,
                    211
                ],
                "zipfile": [
                    250,
                    211
                ],
                "zip_names": [
                    212,
                    213,
                    214
                ],
                "zip_file.namelist": [
                    212
                ],
                "len": [
                    640,
                    642,
                    643,
                    2717,
                    672,
                    1696,
                    2592,
                    1865,
                    1866,
                    719,
                    1106,
                    1107,
                    1108,
                    213,
                    2143,
                    1904,
                    497,
                    1905,
                    1906
                ],
                "zip_file.open": [
                    214
                ],
                "zip_names.pop": [
                    214
                ],
                "ValueError": [
                    262,
                    1899,
                    498,
                    2546,
                    216,
                    218
                ],
                "f.close": [
                    494,
                    223
                ],
                "zip_file.close": [
                    225
                ],
                "contextmanager": [
                    521,
                    2521,
                    2553,
                    2647,
                    472,
                    185,
                    2362,
                    540
                ],
                "compress_method": [
                    258,
                    260,
                    273,
                    250,
                    254
                ],
                "gzip.GzipFile": [
                    254
                ],
                "mode": [
                    265,
                    269,
                    273
                ],
                "args": [
                    2145,
                    2146,
                    266,
                    2605,
                    270,
                    274,
                    2332,
                    2141,
                    2143
                ],
                "dest": [
                    266
                ],
                "data": [
                    1826,
                    266,
                    1834,
                    1835,
                    1774,
                    270,
                    1775,
                    1777,
                    1807,
                    1808,
                    1812,
                    1813,
                    2042,
                    1819,
                    2044
                ],
                "method": [
                    274,
                    267,
                    271
                ],
                "getattr": [
                    2336,
                    743,
                    744,
                    274,
                    952,
                    2334
                ],
                "Union": [
                    280,
                    281,
                    570,
                    699,
                    572
                ],
                "bool": [
                    762,
                    391,
                    560,
                    699,
                    280,
                    281,
                    570,
                    571,
                    572,
                    573,
                    574
                ],
                "int": [
                    672,
                    2054,
                    2061,
                    2069,
                    2070,
                    281,
                    572,
                    1917
                ],
                "isinstance": [
                    385,
                    898,
                    1400,
                    775,
                    781,
                    1402,
                    788,
                    1306,
                    797,
                    2348,
                    689,
                    691,
                    309,
                    319,
                    706,
                    329,
                    1102,
                    1879,
                    988,
                    349,
                    1500,
                    1501,
                    1386,
                    1388,
                    1390,
                    1392,
                    381,
                    1394,
                    1396,
                    1398,
                    1016,
                    1017,
                    762,
                    1404,
                    893
                ],
                "left": [
                    1026,
                    1030,
                    1097,
                    1102,
                    1106,
                    1107,
                    1113,
                    1128,
                    1134,
                    1138,
                    627,
                    630,
                    633,
                    635,
                    1147,
                    1151,
                    640,
                    1153,
                    642,
                    647,
                    648,
                    1159,
                    651,
                    1163,
                    653,
                    1164,
                    1165,
                    1169,
                    1171,
                    1172,
                    1176,
                    667,
                    1179,
                    671,
                    672,
                    674,
                    1188,
                    677,
                    1191,
                    1192,
                    682,
                    688,
                    689,
                    690,
                    691,
                    692,
                    695,
                    696,
                    716,
                    718,
                    721,
                    723,
                    725,
                    743,
                    1303,
                    1306,
                    1310,
                    1312,
                    1316,
                    1320,
                    1332,
                    309,
                    311,
                    823,
                    826,
                    828,
                    319,
                    832,
                    321,
                    1345,
                    837,
                    329,
                    842,
                    331,
                    1355,
                    1357,
                    342,
                    345,
                    860,
                    349,
                    862,
                    863,
                    864,
                    353,
                    355,
                    868,
                    870,
                    871,
                    1386,
                    1387,
                    876,
                    1388,
                    878,
                    879,
                    880,
                    1389,
                    1390,
                    1391,
                    1392,
                    885,
                    886,
                    887,
                    1393,
                    1394,
                    1395,
                    1396,
                    1397,
                    893,
                    381,
                    895,
                    896,
                    894,
                    383,
                    1398,
                    1399,
                    1400,
                    1406,
                    1408,
                    393,
                    394,
                    906,
                    1401,
                    1402,
                    1403,
                    1404,
                    947,
                    949,
                    954,
                    966,
                    968,
                    972,
                    977,
                    979,
                    1495,
                    984,
                    985,
                    1497,
                    988,
                    989,
                    1500,
                    1504,
                    1507,
                    1510,
                    1524,
                    1526,
                    1527,
                    1016,
                    1019,
                    1021,
                    1023
                ],
                "pd.Index": [
                    1424,
                    1425,
                    1386,
                    309
                ],
                "assert_index_equal": [
                    836,
                    1319,
                    1387,
                    657,
                    1331,
                    310,
                    863,
                    1112,
                    826,
                    862,
                    831
                ],
                "right": [
                    1027,
                    1031,
                    1097,
                    1102,
                    1106,
                    1108,
                    1114,
                    1129,
                    1134,
                    627,
                    1139,
                    630,
                    633,
                    1147,
                    636,
                    1151,
                    640,
                    1154,
                    643,
                    1160,
                    649,
                    1163,
                    1164,
                    654,
                    1168,
                    1169,
                    1173,
                    1174,
                    1176,
                    667,
                    1180,
                    671,
                    672,
                    674,
                    1188,
                    678,
                    1191,
                    1192,
                    683,
                    688,
                    689,
                    690,
                    691,
                    692,
                    695,
                    696,
                    716,
                    718,
                    721,
                    723,
                    725,
                    744,
                    1303,
                    1306,
                    1310,
                    1312,
                    1316,
                    1321,
                    1333,
                    823,
                    312,
                    826,
                    828,
                    1344,
                    833,
                    322,
                    838,
                    842,
                    332,
                    1356,
                    1358,
                    342,
                    345,
                    860,
                    349,
                    862,
                    863,
                    864,
                    353,
                    356,
                    868,
                    870,
                    871,
                    1387,
                    876,
                    1389,
                    878,
                    879,
                    880,
                    1391,
                    1393,
                    1395,
                    885,
                    886,
                    887,
                    1397,
                    1399,
                    1401,
                    1403,
                    1406,
                    385,
                    898,
                    387,
                    899,
                    900,
                    901,
                    393,
                    394,
                    907,
                    947,
                    949,
                    955,
                    966,
                    968,
                    972,
                    979,
                    1495,
                    984,
                    985,
                    1497,
                    988,
                    989,
                    1501,
                    1505,
                    1508,
                    1524,
                    1526,
                    1527,
                    1017,
                    1019,
                    1021,
                    1023
                ],
                "check_dtype": [
                    1018,
                    1123,
                    324,
                    357,
                    1350,
                    1161,
                    334,
                    1038,
                    1362,
                    1140,
                    341,
                    1525,
                    1527,
                    1497,
                    314,
                    987,
                    828,
                    1182
                ],
                "check_less_precise": [
                    325,
                    358,
                    679,
                    1324,
                    335,
                    1039,
                    1364,
                    662,
                    1181,
                    1336,
                    315,
                    1117
                ],
                "kwargs": [
                    2332,
                    1574,
                    2599,
                    2601,
                    1581,
                    316,
                    1601,
                    326,
                    1612,
                    336,
                    1616,
                    1621,
                    1626,
                    2141,
                    2143,
                    359,
                    1387,
                    1389,
                    1391,
                    1393,
                    1395,
                    2548,
                    1397,
                    1399,
                    1401,
                    1403,
                    1405
                ],
                "pd.Series": [
                    775,
                    1388,
                    1426,
                    1427,
                    1429,
                    319
                ],
                "assert_series_equal": [
                    320,
                    1389,
                    1359
                ],
                "pd.DataFrame": [
                    1704,
                    329,
                    1428,
                    1390
                ],
                "assert_frame_equal": [
                    330,
                    1349,
                    1391
                ],
                "is_number": [
                    749,
                    342,
                    751
                ],
                "is_bool": [
                    345
                ],
                "np.ndarray": [
                    898,
                    1442,
                    775,
                    988,
                    949,
                    1402,
                    349,
                    893
                ],
                "np": [
                    2049,
                    898,
                    1026,
                    1027,
                    2051,
                    1030,
                    775,
                    1031,
                    2054,
                    2062,
                    401,
                    402,
                    404,
                    2069,
                    413,
                    414,
                    2718,
                    672,
                    673,
                    800,
                    1442,
                    1443,
                    1697,
                    1574,
                    428,
                    429,
                    1580,
                    1460,
                    949,
                    445,
                    1605,
                    1606,
                    455,
                    2117,
                    2124,
                    2513,
                    978,
                    2514,
                    2518,
                    988,
                    349,
                    750,
                    752,
                    1402,
                    893
                ],
                "assert_class_equal": [
                    353,
                    947,
                    606
                ],
                "_testing.assert_almost_equal": [
                    354,
                    1035,
                    676,
                    1178
                ],
                "_testing": [
                    354,
                    676,
                    394,
                    1035,
                    1178
                ],
                "cls_name": [
                    379,
                    387,
                    383
                ],
                "cls.__name__": [
                    379
                ],
                "cls": [
                    385,
                    387,
                    379,
                    381,
                    383
                ],
                "AssertionError": [
                    962,
                    386,
                    1156,
                    912,
                    981,
                    2486,
                    382,
                    959
                ],
                "type": [
                    1408,
                    387,
                    711,
                    713,
                    779,
                    716,
                    718,
                    1102,
                    1551,
                    786,
                    723,
                    1306,
                    1021,
                    383
                ],
                "_check_isinstance": [
                    1495,
                    868,
                    393,
                    1097,
                    876,
                    1303,
                    627,
                    885,
                    949,
                    823,
                    860
                ],
                "dict": [
                    548,
                    2599,
                    393,
                    781,
                    788,
                    1883
                ],
                "_testing.assert_dict_equal": [
                    394
                ],
                "compare_keys": [
                    394
                ],
                "float": [
                    397
                ],
                "rand": [
                    398
                ],
                "size": [
                    2054,
                    2058,
                    428,
                    430,
                    398,
                    2062,
                    2065,
                    413,
                    415
                ],
                "p": [
                    398
                ],
                "RANDS_CHARS": [
                    401,
                    413,
                    445
                ],
                "np.array": [
                    800,
                    1443,
                    401,
                    402,
                    1460
                ],
                "list": [
                    1346,
                    1929,
                    401,
                    403,
                    1593
                ],
                "string.ascii_letters": [
                    401
                ],
                "string": [
                    401,
                    403,
                    1558
                ],
                "string.digits": [
                    401,
                    403
                ],
                "np.str_": [
                    401,
                    414
                ],
                "RANDU_CHARS": [
                    402,
                    428,
                    455
                ],
                "join": [
                    403,
                    445,
                    455
                ],
                "map": [
                    403
                ],
                "chr": [
                    403
                ],
                "range": [
                    1922,
                    651,
                    2603,
                    1873,
                    403,
                    1911,
                    1593,
                    2042,
                    1597
                ],
                "np.unicode_": [
                    404,
                    429
                ],
                "retval": [
                    418,
                    420,
                    427,
                    433,
                    435,
                    412
                ],
                "reshape": [
                    428,
                    413
                ],
                "view": [
                    428,
                    413
                ],
                "np.random.choice": [
                    455,
                    428,
                    413,
                    445
                ],
                "np.random": [
                    1697,
                    2049,
                    2051,
                    1605,
                    1606,
                    455,
                    428,
                    2513,
                    2514,
                    2518,
                    413,
                    445
                ],
                "nchars": [
                    414,
                    455,
                    428,
                    429,
                    445,
                    413
                ],
                "np.prod": [
                    428,
                    413
                ],
                "dtype": [
                    417,
                    1346,
                    1347,
                    420,
                    1348,
                    1350,
                    432,
                    435,
                    2044,
                    2111
                ],
                "retval.astype": [
                    435,
                    420
                ],
                "fignum": [
                    465,
                    461,
                    462,
                    463
                ],
                "get_fignums": [
                    462
                ],
                "_close": [
                    465,
                    463
                ],
                "filename": [
                    513,
                    515,
                    516,
                    486,
                    490,
                    497,
                    501,
                    508
                ],
                "fd": [
                    513,
                    511,
                    501,
                    487
                ],
                "return_filelike": [
                    489
                ],
                "tempfile.TemporaryFile": [
                    490
                ],
                "tempfile": [
                    490,
                    530,
                    501
                ],
                "os.path.dirname": [
                    497
                ],
                "os.path": [
                    497,
                    515
                ],
                "tempfile.mkstemp": [
                    501
                ],
                "UnicodeEncodeError": [
                    502
                ],
                "pytest.skip": [
                    505
                ],
                "os.close": [
                    511
                ],
                "OSError": [
                    512,
                    536,
                    517
                ],
                "print": [
                    513,
                    518
                ],
                "os.path.exists": [
                    515
                ],
                "os.remove": [
                    516
                ],
                "e": [
                    518
                ],
                "directory_name": [
                    530,
                    532,
                    535
                ],
                "tempfile.mkdtemp": [
                    530
                ],
                "rmtree": [
                    535
                ],
                "saved_environ": [
                    553,
                    548
                ],
                "os.environ.clear": [
                    552
                ],
                "os.environ.update": [
                    553
                ],
                "frozenset": [
                    564
                ],
                "arr1": [
                    564
                ],
                "arr2": [
                    564
                ],
                "Index": [
                    706,
                    1597,
                    1606,
                    1567,
                    1934,
                    1593,
                    1775,
                    1937,
                    1586,
                    627,
                    1588,
                    1589,
                    1817,
                    568,
                    569,
                    1563,
                    797,
                    1151
                ],
                "__tracebackhide__": [
                    741,
                    1094,
                    1384,
                    875,
                    943,
                    884,
                    1300,
                    602,
                    891,
                    2430,
                    703
                ],
                "exact": [
                    680,
                    715,
                    862,
                    722,
                    660,
                    605,
                    606,
                    863
                ],
                "l": [
                    610,
                    613,
                    616,
                    972,
                    974,
                    606
                ],
                "r": [
                    610,
                    614,
                    616,
                    972,
                    974,
                    2040,
                    2042,
                    606
                ],
                "check_categorical": [
                    609,
                    1190,
                    1130,
                    1326,
                    694,
                    1368,
                    1338,
                    670,
                    1119
                ],
                "assert_attr_equal": [
                    864,
                    610,
                    1188,
                    871,
                    616,
                    842,
                    1134,
                    879,
                    688,
                    880,
                    690,
                    1524,
                    1526,
                    887,
                    1019,
                    989
                ],
                "l.inferred_type": [
                    613
                ],
                "r.inferred_type": [
                    614
                ],
                "unique": [
                    620,
                    622,
                    623
                ],
                "index.levels": [
                    620
                ],
                "index": [
                    1934,
                    1937,
                    1939,
                    1940,
                    1817,
                    1695,
                    1696,
                    1826,
                    1704,
                    1764,
                    1765,
                    1769,
                    1770,
                    620,
                    621,
                    2029,
                    623,
                    1776,
                    1777,
                    1781,
                    1782,
                    2044
                ],
                "level": [
                    651,
                    620,
                    621,
                    653,
                    623,
                    654,
                    656,
                    667
                ],
                "level_codes": [
                    621,
                    622
                ],
                "index.codes": [
                    621
                ],
                "filled": [
                    622,
                    623
                ],
                "take_1d": [
                    622
                ],
                "unique._values": [
                    622
                ],
                "unique._na_value": [
                    622
                ],
                "values": [
                    624,
                    1605,
                    1606,
                    623
                ],
                "unique._shallow_copy": [
                    623
                ],
                "index.names": [
                    623
                ],
                "_check_types": [
                    667,
                    630
                ],
                "left.nlevels": [
                    633,
                    635,
                    651,
                    647
                ],
                "right.nlevels": [
                    633,
                    636
                ],
                "msg1": [
                    641,
                    644,
                    1107,
                    1109,
                    634,
                    637
                ],
                "msg2": [
                    642,
                    644,
                    1108,
                    1109,
                    635,
                    637
                ],
                "msg3": [
                    644,
                    643,
                    636,
                    637
                ],
                "raise_assert_detail": [
                    769,
                    674,
                    644,
                    967,
                    1516,
                    721,
                    979,
                    725,
                    1109,
                    637,
                    1311
                ],
                "cast": [
                    648,
                    649
                ],
                "MultiIndex": [
                    648,
                    649,
                    1626,
                    1939
                ],
                "llevel": [
                    658,
                    653
                ],
                "_get_ilevel_values": [
                    653,
                    654
                ],
                "rlevel": [
                    659,
                    654
                ],
                "lobj": [
                    656,
                    664
                ],
                "check_names": [
                    1187,
                    1323,
                    687,
                    661,
                    1366,
                    1335,
                    1116
                ],
                "check_exact": [
                    1032,
                    670,
                    1325,
                    1136,
                    1365,
                    663,
                    1337,
                    1118
                ],
                "left.levels": [
                    667
                ],
                "right.levels": [
                    667
                ],
                "left.equals": [
                    671
                ],
                "diff": [
                    672,
                    673,
                    971,
                    909,
                    910,
                    975,
                    977,
                    978
                ],
                "np.sum": [
                    672
                ],
                "astype": [
                    672,
                    1030,
                    1031,
                    2069,
                    2070
                ],
                "left.values": [
                    672,
                    1153,
                    677,
                    1192,
                    692,
                    696,
                    1151
                ],
                "right.values": [
                    672,
                    1154,
                    678,
                    1192,
                    692,
                    696,
                    1151
                ],
                "msg": [
                    768,
                    769,
                    1152,
                    1156,
                    903,
                    777,
                    781,
                    910,
                    783,
                    912,
                    1550,
                    1554,
                    788,
                    2464,
                    673,
                    674,
                    2469,
                    2480,
                    2484,
                    720,
                    721,
                    978,
                    979,
                    724,
                    725
                ],
                "np.round": [
                    673,
                    978,
                    2054
                ],
                "pd.PeriodIndex": [
                    689
                ],
                "pd.IntervalIndex": [
                    691
                ],
                "assert_interval_array_equal": [
                    1164,
                    692,
                    1393
                ],
                "is_categorical_dtype": [
                    900,
                    1191,
                    1128,
                    1129,
                    1172,
                    1174,
                    695,
                    895
                ],
                "assert_categorical_equal": [
                    696,
                    1192
                ],
                "x": [
                    2716,
                    706,
                    708,
                    1572,
                    1574,
                    711,
                    713,
                    1580,
                    1581,
                    1937,
                    1908,
                    2711,
                    1916
                ],
                "__name__": [
                    786,
                    779,
                    718,
                    711
                ],
                "AttributeError": [
                    712,
                    2443
                ],
                "repr": [
                    896,
                    1312,
                    962,
                    1536,
                    901,
                    713,
                    779,
                    1900,
                    1551,
                    786,
                    2482,
                    2487,
                    959
                ],
                "types": [
                    718,
                    719
                ],
                "repr_class": [
                    721,
                    725
                ],
                "left_attr": [
                    769,
                    743,
                    746,
                    749,
                    750,
                    758
                ],
                "attr": [
                    744,
                    768,
                    743
                ],
                "right_attr": [
                    769,
                    744,
                    746,
                    751,
                    752,
                    758
                ],
                "np.isnan": [
                    752,
                    750
                ],
                "result": [
                    1926,
                    1927,
                    758,
                    761,
                    762,
                    763,
                    765
                ],
                "TypeError": [
                    759
                ],
                "result.all": [
                    763
                ],
                "objs": [
                    776,
                    786,
                    788,
                    775
                ],
                "el": [
                    776,
                    779,
                    781
                ],
                "objs.ravel": [
                    776
                ],
                "plt.Axes": [
                    781
                ],
                "plt": [
                    788,
                    781
                ],
                "plt.Artist": [
                    788
                ],
                "tuple": [
                    788
                ],
                "hasattr": [
                    792,
                    1021,
                    2335
                ],
                "seq": [
                    800,
                    797,
                    798
                ],
                "Series": [
                    1794,
                    1765,
                    1097,
                    1770,
                    1777,
                    1782,
                    2617,
                    1788,
                    797
                ],
                "seq.values": [
                    798
                ],
                "assert_numpy_array_equal": [
                    800,
                    1028,
                    870,
                    1158,
                    1033,
                    878,
                    1137,
                    1403,
                    886,
                    1527,
                    1497,
                    827,
                    1023
                ],
                "np.sort": [
                    800
                ],
                "Categorical": [
                    2641,
                    1574,
                    823
                ],
                "check_category_order": [
                    825
                ],
                "left.categories": [
                    832,
                    826,
                    837
                ],
                "right.categories": [
                    833,
                    826,
                    838
                ],
                "left.codes": [
                    828,
                    837
                ],
                "right.codes": [
                    828,
                    838
                ],
                "left.categories.sort_values": [
                    832
                ],
                "right.categories.sort_values": [
                    833
                ],
                "left.categories.take": [
                    837
                ],
                "right.categories.take": [
                    838
                ],
                "IntervalArray": [
                    1392,
                    860
                ],
                "left.left": [
                    862
                ],
                "right.left": [
                    862
                ],
                "left.right": [
                    863
                ],
                "right.right": [
                    863
                ],
                "PeriodArray": [
                    1394,
                    1435,
                    868
                ],
                "left._data": [
                    878,
                    886,
                    870
                ],
                "right._data": [
                    878,
                    886,
                    870
                ],
                "DatetimeArray": [
                    876,
                    1456,
                    1396,
                    1438,
                    1439
                ],
                "TimedeltaArray": [
                    1440,
                    1441,
                    1458,
                    885,
                    1398
                ],
                "pprint_thing": [
                    899,
                    894
                ],
                "message": [
                    905
                ],
                "obj.base": [
                    952
                ],
                "left_base": [
                    961,
                    962,
                    954,
                    958,
                    959
                ],
                "_get_base": [
                    954,
                    955
                ],
                "right_base": [
                    961,
                    962,
                    955,
                    958,
                    959
                ],
                "check_same": [
                    960,
                    957
                ],
                "err_msg": [
                    981,
                    985,
                    965
                ],
                "left.shape": [
                    968,
                    1312,
                    966,
                    1310
                ],
                "right.shape": [
                    968,
                    1312,
                    966,
                    1310
                ],
                "zip": [
                    1929,
                    972,
                    1548
                ],
                "array_equivalent": [
                    984,
                    974
                ],
                "strict_nan": [
                    984,
                    974
                ],
                "left.size": [
                    977
                ],
                "_raise": [
                    985
                ],
                "ExtensionArray": [
                    1016,
                    1017,
                    1400
                ],
                "left.asi8": [
                    1023
                ],
                "right.asi8": [
                    1023
                ],
                "left_na": [
                    1026,
                    1028,
                    1030
                ],
                "np.asarray": [
                    1026,
                    1027,
                    1030,
                    1031
                ],
                "left.isna": [
                    1026
                ],
                "right_na": [
                    1027,
                    1028,
                    1031
                ],
                "right.isna": [
                    1027
                ],
                "left_valid": [
                    1033,
                    1036,
                    1030
                ],
                "object": [
                    1775,
                    1030,
                    1031
                ],
                "right_valid": [
                    1033,
                    1037,
                    1031
                ],
                "check_series_type": [
                    1099
                ],
                "left.index": [
                    1320,
                    1113,
                    1107
                ],
                "right.index": [
                    1321,
                    1114,
                    1108
                ],
                "check_index_type": [
                    1322,
                    1115,
                    1363
                ],
                "left._internal_get_values": [
                    1138,
                    1179,
                    1159
                ],
                "right._internal_get_values": [
                    1160,
                    1139,
                    1180
                ],
                "check_datetimelike_compat": [
                    1367,
                    1143
                ],
                "needs_i8_conversion": [
                    1147
                ],
                "equals": [
                    1151
                ],
                "is_interval_dtype": [
                    1163
                ],
                "left.array": [
                    1176,
                    1164
                ],
                "right.array": [
                    1176,
                    1164
                ],
                "is_extension_array_dtype": [
                    1168,
                    1171,
                    1165,
                    1173
                ],
                "left.dtype": [
                    1165
                ],
                "is_datetime64tz_dtype": [
                    1165,
                    1455
                ],
                "right.dtype": [
                    1168
                ],
                "assert_extension_array_equal": [
                    1176,
                    1169,
                    1401
                ],
                "left._values": [
                    1169
                ],
                "right._values": [
                    1169
                ],
                "DataFrame": [
                    2629,
                    1830,
                    1835,
                    1808,
                    1813,
                    1303,
                    2044
                ],
                "check_frame_type": [
                    1305
                ],
                "check_like": [
                    1315
                ],
                "left.reindex_like": [
                    1316
                ],
                "left.columns": [
                    1355,
                    1332
                ],
                "right.columns": [
                    1333
                ],
                "check_column_type": [
                    1334
                ],
                "by_blocks": [
                    1343
                ],
                "rblocks": [
                    1344,
                    1346,
                    1348,
                    1350
                ],
                "right._to_dict_of_blocks": [
                    1344
                ],
                "lblocks": [
                    1345,
                    1346,
                    1347,
                    1350
                ],
                "left._to_dict_of_blocks": [
                    1345
                ],
                "set": [
                    1346
                ],
                "lblocks.keys": [
                    1346
                ],
                "rblocks.keys": [
                    1346
                ],
                "i": [
                    1920,
                    1923,
                    1924,
                    2070,
                    2071,
                    2599,
                    2603,
                    2604,
                    1597,
                    2116,
                    2117,
                    1355,
                    2123,
                    1357,
                    1358,
                    2124,
                    1873,
                    1369,
                    1911
                ],
                "col": [
                    1369,
                    1355,
                    1356
                ],
                "enumerate": [
                    1355
                ],
                "lcol": [
                    1360,
                    1357
                ],
                "left.iloc": [
                    1357
                ],
                "rcol": [
                    1361,
                    1358
                ],
                "right.iloc": [
                    1358
                ],
                "assert_period_array_equal": [
                    1395
                ],
                "assert_datetime_array_equal": [
                    1397
                ],
                "assert_timedelta_array_equal": [
                    1399
                ],
                "NotImplementedError": [
                    1408,
                    1447
                ],
                "box_cls": [
                    1440,
                    1442,
                    1444,
                    1447,
                    1424,
                    1426,
                    1428,
                    1435,
                    1438
                ],
                "expected": [
                    1441,
                    1443,
                    1445,
                    1448,
                    1425,
                    1427,
                    1429,
                    2741,
                    2742,
                    1434,
                    1437,
                    1439
                ],
                "to_frame": [
                    1429
                ],
                "transpose": [
                    1430
                ],
                "expected.T": [
                    1434
                ],
                "period_array": [
                    1437,
                    1454
                ],
                "to_array": [
                    1444,
                    1445
                ],
                "is_period_dtype": [
                    1453
                ],
                "is_datetime64_dtype": [
                    1455
                ],
                "DatetimeArray._from_sequence": [
                    1456
                ],
                "is_timedelta64_dtype": [
                    1457
                ],
                "TimedeltaArray._from_sequence": [
                    1458
                ],
                "pd.arrays.SparseArray": [
                    1495
                ],
                "pd.arrays": [
                    1495
                ],
                "left.sp_values": [
                    1497
                ],
                "right.sp_values": [
                    1497
                ],
                "left.sp_index": [
                    1504,
                    1507,
                    1500
                ],
                "pd._libs.sparse.SparseIndex": [
                    1500,
                    1501
                ],
                "pd._libs.sparse": [
                    1500,
                    1501
                ],
                "pd._libs": [
                    1500,
                    1501
                ],
                "right.sp_index": [
                    1505,
                    1508,
                    1501
                ],
                "check_kind": [
                    1503
                ],
                "left_index": [
                    1504,
                    1507,
                    1512,
                    1515,
                    1517
                ],
                "left.sp_index.to_block_index": [
                    1504
                ],
                "right_index": [
                    1505,
                    1508,
                    1513,
                    1515,
                    1517
                ],
                "right.sp_index.to_block_index": [
                    1505
                ],
                "consolidate_block_indices": [
                    1510
                ],
                "left.kind": [
                    1510
                ],
                "to_block_index": [
                    1512,
                    1513
                ],
                "left_index.to_int_index": [
                    1512
                ],
                "right_index.to_int_index": [
                    1513
                ],
                "left_index.equals": [
                    1515
                ],
                "check_fill_value": [
                    1523
                ],
                "left.to_dense": [
                    1527
                ],
                "right.to_dense": [
                    1527
                ],
                "k": [
                    1536,
                    1558,
                    1563,
                    1567,
                    1574,
                    1580,
                    1585,
                    1587,
                    1589,
                    1593,
                    1597,
                    1601,
                    1732,
                    1605,
                    1611,
                    1616,
                    1621,
                    1759,
                    1535
                ],
                "iterable": [
                    1535
                ],
                "dic": [
                    1536
                ],
                "elem1": [
                    1554,
                    1548,
                    1549,
                    1551
                ],
                "elem2": [
                    1554,
                    1548,
                    1549,
                    1551
                ],
                "iter1": [
                    1548
                ],
                "iter2": [
                    1548
                ],
                "assert_almost_equal": [
                    1549
                ],
                "eql_kwargs": [
                    1549
                ],
                "string.ascii_uppercase": [
                    1558
                ],
                "rands_array": [
                    1563,
                    1572
                ],
                "name": [
                    1794,
                    1936,
                    1937,
                    1563,
                    1567,
                    1574,
                    1581,
                    1586,
                    1588,
                    1589,
                    1593,
                    1597,
                    1601,
                    1606,
                    1611,
                    1612,
                    1616,
                    1621,
                    1765,
                    1770,
                    1777,
                    2545,
                    2548,
                    2550,
                    1788
                ],
                "randu_array": [
                    1567
                ],
                "n": [
                    1696,
                    1699,
                    1700,
                    1572,
                    1574,
                    1701,
                    1702
                ],
                "CategoricalIndex": [
                    1573
                ],
                "Categorical.from_codes": [
                    1574
                ],
                "np.arange": [
                    1574
                ],
                "np.linspace": [
                    1580
                ],
                "IntervalIndex.from_breaks": [
                    1581
                ],
                "IntervalIndex": [
                    1581
                ],
                "RangeIndex": [
                    1601
                ],
                "sorted": [
                    1704,
                    1605,
                    1926
                ],
                "np.random.random_sample": [
                    1605
                ],
                "np.random.randint": [
                    1606
                ],
                "dt": [
                    1610,
                    1611,
                    1620,
                    1621
                ],
                "datetime": [
                    1610,
                    1620
                ],
                "dr": [
                    1611,
                    1612,
                    1621,
                    1622
                ],
                "bdate_range": [
                    1611,
                    1823
                ],
                "freq": [
                    1798,
                    1611,
                    1807,
                    1616,
                    1788,
                    1695
                ],
                "DatetimeIndex": [
                    1612
                ],
                "pd.timedelta_range": [
                    1616
                ],
                "pd.period_range": [
                    1621
                ],
                "MultiIndex.from_product": [
                    1626
                ],
                "names": [
                    1895,
                    1896,
                    1866,
                    1934,
                    1871,
                    1936,
                    1873,
                    1874,
                    1939,
                    1876,
                    1879,
                    1880,
                    1626
                ],
                "_names": [
                    1699,
                    1629
                ],
                "pd.date_range": [
                    1695
                ],
                "start": [
                    1695
                ],
                "end": [
                    1705,
                    1695
                ],
                "state": [
                    1697,
                    1699,
                    1700,
                    1701,
                    1702
                ],
                "np.random.RandomState": [
                    1697,
                    2051
                ],
                "seed": [
                    1697,
                    2509
                ],
                "columns": [
                    1704,
                    1698,
                    2044,
                    2021
                ],
                "state.choice": [
                    1699
                ],
                "state.poisson": [
                    1700
                ],
                "state.rand": [
                    1701,
                    1702
                ],
                "df": [
                    2117,
                    2118,
                    1704,
                    1705,
                    1706,
                    1707,
                    2122,
                    2123,
                    2124,
                    2125,
                    2101
                ],
                "df.index": [
                    1705
                ],
                "df.iloc": [
                    1706
                ],
                "all_make_index_funcs": [
                    1731,
                    1718
                ],
                "makeIntIndex": [
                    1884,
                    1719
                ],
                "makeFloatIndex": [
                    1720,
                    1885
                ],
                "makeStringIndex": [
                    1764,
                    1769,
                    1774,
                    1776,
                    1781,
                    1721,
                    1886
                ],
                "makeUnicodeIndex": [
                    1722,
                    1887
                ],
                "makeDateIndex": [
                    1888,
                    1737,
                    1723,
                    1788,
                    1757
                ],
                "makePeriodIndex": [
                    1794,
                    1890,
                    1738,
                    1724,
                    1757
                ],
                "makeTimedeltaIndex": [
                    1757,
                    1889,
                    1739,
                    1725
                ],
                "makeBoolIndex": [
                    1726
                ],
                "makeRangeIndex": [
                    1740,
                    1727
                ],
                "makeIntervalIndex": [
                    1728,
                    1741
                ],
                "makeCategoricalIndex": [
                    1729,
                    1742
                ],
                "make_index_func": [
                    1731,
                    1732,
                    1745,
                    1746,
                    1758,
                    1759
                ],
                "make_index_funcs": [
                    1736,
                    1745,
                    1757,
                    1758
                ],
                "makeMultiIndex": [
                    1743
                ],
                "randn": [
                    1794,
                    1765,
                    1770,
                    1782,
                    1788
                ],
                "c": [
                    1798,
                    1802,
                    1782,
                    2040,
                    2042
                ],
                "getCols": [
                    1802,
                    1782,
                    1798
                ],
                "nper": [
                    1792,
                    1793,
                    1794,
                    1798,
                    1802,
                    1834,
                    1807,
                    1786,
                    1787,
                    1788
                ],
                "makeTimeSeries": [
                    1798
                ],
                "makePeriodSeries": [
                    1802
                ],
                "getTimeSeriesData": [
                    1807
                ],
                "getSeriesData": [
                    1812
                ],
                "getMixedTypeDict": [
                    1830
                ],
                "getPeriodData": [
                    1834
                ],
                "ndupe_l": [
                    1920,
                    1924,
                    1863,
                    1864,
                    1865,
                    1904,
                    1905,
                    1906,
                    1908
                ],
                "nlevels": [
                    1864,
                    1865,
                    1866,
                    1868,
                    1911,
                    1904,
                    1873,
                    1905,
                    1906,
                    1935,
                    1879
                ],
                "is_sequence": [
                    1865
                ],
                "idx_type": [
                    1891,
                    1898,
                    1867,
                    1900,
                    1868
                ],
                "prefix": [
                    1873,
                    1923
                ],
                "idx_func": [
                    1883,
                    1892,
                    1893
                ],
                "get": [
                    1883
                ],
                "idx": [
                    1896,
                    1897,
                    1893
                ],
                "nentries": [
                    1920,
                    1932,
                    1893,
                    1926
                ],
                "idx.name": [
                    1896
                ],
                "ndupe_l.extend": [
                    1905
                ],
                "all": [
                    1908
                ],
                "tuples": [
                    1927,
                    1929,
                    1934,
                    1937,
                    1939,
                    1910
                ],
                "numeric_tuple": [
                    1916,
                    1917
                ],
                "split": [
                    1916
                ],
                "re.sub": [
                    1916
                ],
                "re": [
                    1916
                ],
                "num": [
                    1917
                ],
                "div_factor": [
                    1920,
                    1922
                ],
                "cnt": [
                    1921,
                    1924,
                    1926
                ],
                "Counter": [
                    1921
                ],
                "j": [
                    1922,
                    1923,
                    2116,
                    2117,
                    2123,
                    2124,
                    2069,
                    2070,
                    2071
                ],
                "label": [
                    1923,
                    1924
                ],
                "cnt.elements": [
                    1926
                ],
                "keyfunc": [
                    1926
                ],
                "tuples.append": [
                    1927
                ],
                "MultiIndex.from_tuples": [
                    1939
                ],
                "c_idx_nlevels": [
                    2018,
                    2012,
                    2106,
                    2023
                ],
                "r_idx_nlevels": [
                    2107,
                    2031,
                    2013,
                    2015
                ],
                "r_idx_type": [
                    2113,
                    2035,
                    2014,
                    2015
                ],
                "c_idx_type": [
                    2112,
                    2017,
                    2018,
                    2027
                ],
                "makeCustomIndex": [
                    2029,
                    2021
                ],
                "ncols": [
                    2116,
                    2022,
                    2054,
                    2062,
                    2103,
                    2042
                ],
                "c_idx_names": [
                    2104,
                    2025
                ],
                "c_ndupe_l": [
                    2026,
                    2109
                ],
                "nrows": [
                    2116,
                    2054,
                    2062,
                    2030,
                    2069,
                    2070,
                    2102,
                    2042
                ],
                "r_idx_names": [
                    2033,
                    2105
                ],
                "r_ndupe_l": [
                    2034,
                    2110
                ],
                "data_gen_f": [
                    2040,
                    2042,
                    2108,
                    2039
                ],
                "random_state": [
                    2048,
                    2049,
                    2051,
                    2116,
                    2123,
                    2064,
                    2067
                ],
                "density": [
                    2123,
                    2116,
                    2054
                ],
                "min_rows": [
                    2056,
                    2058
                ],
                "fac": [
                    2057,
                    2058
                ],
                "extra_size": [
                    2064,
                    2067,
                    2058,
                    2066
                ],
                "min": [
                    2058
                ],
                "ind": [
                    2061,
                    2062,
                    2064,
                    2065,
                    2067,
                    2069,
                    2070
                ],
                "rng.rand": [
                    2061
                ],
                "rng": [
                    2061
                ],
                "_extra_size": [
                    2061
                ],
                "np.unique": [
                    2062
                ],
                "np.floor": [
                    2069,
                    2062
                ],
                "_gen_unique_rand": [
                    2064,
                    2067
                ],
                "ind.size": [
                    2065
                ],
                "i.tolist": [
                    2071
                ],
                "j.tolist": [
                    2071
                ],
                "makeCustomDataframe": [
                    2101
                ],
                "_create_missing_idx": [
                    2123,
                    2116
                ],
                "df.values": [
                    2124,
                    2117
                ],
                "np.nan": [
                    2124,
                    2117,
                    2718
                ],
                "makeDataFrame": [
                    2122
                ],
                "df.shape": [
                    2123
                ],
                "decorator": [
                    2138,
                    2141
                ],
                "is_decorating": [
                    2144,
                    2143
                ],
                "callable": [
                    2143
                ],
                "dec": [
                    2147,
                    2149
                ],
                "wraps": [
                    2138,
                    2596,
                    2326
                ],
                "wrapper": [
                    2356,
                    2614,
                    2151
                ],
                "_network_error_messages": [
                    2155,
                    2235
                ],
                "_network_errno_vals": [
                    2234,
                    2175
                ],
                "IOError": [
                    2196
                ],
                "http.client.HTTPException": [
                    2196
                ],
                "http.client": [
                    2196
                ],
                "http": [
                    2196
                ],
                "TimeoutError": [
                    2196
                ],
                "error_classes": [
                    2215,
                    2216,
                    2348,
                    2221,
                    2351,
                    2321,
                    2322,
                    2329
                ],
                "_get_default_network_errors": [
                    2216,
                    2322
                ],
                "urlopen": [
                    2219
                ],
                "url": [
                    2329,
                    2219,
                    2351
                ],
                "t.network": [
                    2324
                ],
                "t": [
                    2324,
                    2332,
                    2326
                ],
                "check_before_test": [
                    2328
                ],
                "raise_on_error": [
                    2328,
                    2351
                ],
                "can_connect": [
                    2329,
                    2351
                ],
                "skip": [
                    2344,
                    2330,
                    2339,
                    2354
                ],
                "Exception": [
                    2333
                ],
                "errno": [
                    2336,
                    2338,
                    2334,
                    2335
                ],
                "err": [
                    2336,
                    2339,
                    2341,
                    2345,
                    2348,
                    2354,
                    2334
                ],
                "err.reason": [
                    2336
                ],
                "skip_errnos": [
                    2338
                ],
                "e_str": [
                    2341,
                    2343
                ],
                "any": [
                    2343
                ],
                "m.lower": [
                    2343
                ],
                "m": [
                    2440,
                    2442,
                    2343
                ],
                "e_str.lower": [
                    2343
                ],
                "_skip_on_messages": [
                    2343
                ],
                "optional_args": [
                    2227
                ],
                "with_connectivity_check": [
                    2359
                ],
                "network": [
                    2359
                ],
                "Warning": [
                    2364
                ],
                "warnings.catch_warnings": [
                    2432
                ],
                "w": [
                    2432,
                    2449,
                    2452
                ],
                "clear": [
                    2440,
                    2434,
                    2438,
                    2439
                ],
                "is_list_like": [
                    2438
                ],
                "m.__warningregistry__.clear": [
                    2442
                ],
                "m.__warningregistry__": [
                    2442
                ],
                "saw_warning": [
                    2456,
                    2484,
                    2447
                ],
                "filter_level": [
                    2448
                ],
                "extra_warnings": [
                    2487,
                    2450,
                    2485,
                    2471
                ],
                "actual_warning": [
                    2466,
                    2467,
                    2469,
                    2473,
                    2474,
                    2475,
                    2476,
                    2452,
                    2454,
                    2459
                ],
                "expected_warning": [
                    2482,
                    2453,
                    2454,
                    2479
                ],
                "issubclass": [
                    2458,
                    2453
                ],
                "actual_warning.category": [
                    2473,
                    2459,
                    2454
                ],
                "check_stacklevel": [
                    2458
                ],
                "FutureWarning": [
                    2459
                ],
                "caller": [
                    2467,
                    2469,
                    2463
                ],
                "getframeinfo": [
                    2463
                ],
                "stack": [
                    2463
                ],
                "actual_warning.filename": [
                    2466,
                    2475,
                    2469
                ],
                "caller.filename": [
                    2467,
                    2469
                ],
                "actual_warning.message": [
                    2474,
                    2467
                ],
                "extra_warnings.append": [
                    2471
                ],
                "actual_warning.category.__name__": [
                    2473
                ],
                "actual_warning.lineno": [
                    2476
                ],
                "expected_warning.__name__": [
                    2482
                ],
                "raise_on_extra_warnings": [
                    2485
                ],
                "self.seed": [
                    2514,
                    2509
                ],
                "self": [
                    2513,
                    2514,
                    2509,
                    2518
                ],
                "self.start_state": [
                    2513,
                    2518
                ],
                "np.random.get_state": [
                    2513
                ],
                "np.random.seed": [
                    2514
                ],
                "np.random.set_state": [
                    2518
                ],
                "_BUILTIN_DIALECTS": [
                    2545,
                    2543
                ],
                "csv.register_dialect": [
                    2548
                ],
                "csv": [
                    2548,
                    2550
                ],
                "csv.unregister_dialect": [
                    2550
                ],
                "min_elements": [
                    2563,
                    2557,
                    2558
                ],
                "expr._MIN_ELEMENTS": [
                    2561,
                    2563,
                    2565,
                    2558
                ],
                "expr": [
                    2560,
                    2561,
                    2562,
                    2563,
                    2565,
                    2566,
                    2558
                ],
                "olduse": [
                    2560,
                    2566
                ],
                "expr._USE_NUMEXPR": [
                    2560
                ],
                "oldmin": [
                    2561,
                    2565
                ],
                "expr.set_use_numexpr": [
                    2562,
                    2566
                ],
                "use": [
                    2562
                ],
                "num_threads": [
                    2592,
                    2603,
                    2589
                ],
                "has_kwargs_list": [
                    2598,
                    2590,
                    2591
                ],
                "kwargs_list": [
                    2592,
                    2590,
                    2599
                ],
                "update_kwargs": [
                    2601,
                    2604,
                    2599
                ],
                "threads": [
                    2609,
                    2602,
                    2606,
                    2607
                ],
                "updated_kwargs": [
                    2604,
                    2605
                ],
                "thread": [
                    2605,
                    2606,
                    2607,
                    2608,
                    2609,
                    2610
                ],
                "threading.Thread": [
                    2605
                ],
                "threading": [
                    2605
                ],
                "func": [
                    2596,
                    2605
                ],
                "threads.append": [
                    2606
                ],
                "thread.start": [
                    2608
                ],
                "thread.join": [
                    2610
                ],
                "inner": [
                    2612
                ],
                "_metadata": [
                    2618,
                    2630
                ],
                "SubclassedSeries": [
                    2638,
                    2622
                ],
                "property": [
                    2624,
                    2632,
                    2636,
                    2642,
                    2620
                ],
                "SubclassedDataFrame": [
                    2626,
                    2634
                ],
                "SubclassedCategorical": [
                    2644
                ],
                "tz": [
                    2681,
                    2675,
                    2685
                ],
                "KeyError": [
                    2678
                ],
                "time.tzset": [
                    2682
                ],
                "time": [
                    2682
                ],
                "orig_tz": [
                    2689,
                    2684
                ],
                "setTZ": [
                    2689,
                    2685
                ],
                "skipna_alternative": [
                    2708,
                    2711
                ],
                "x.values": [
                    2711
                ],
                "nona": [
                    2716,
                    2717,
                    2719
                ],
                "x.dropna": [
                    2716
                ],
                "alternative": [
                    2719
                ],
                "skipna_wrapper": [
                    2721
                ],
                "List": [
                    2724
                ],
                "sep": [
                    2740,
                    2741
                ],
                "os.linesep": [
                    2740
                ],
                "sep.join": [
                    2741
                ],
                "rows_list": [
                    2741
                ]
            },
            "filtered_variables_in_file": {
                "lzma": [
                    209,
                    260,
                    70
                ],
                "_import_lzma": [
                    70
                ],
                "N": [
                    1793,
                    1764,
                    1765,
                    72,
                    1769,
                    1770,
                    1774,
                    1776,
                    1781,
                    1782,
                    1787
                ],
                "K": [
                    73,
                    1802,
                    1782,
                    1798
                ],
                "_RAISE_NETWORK_ERROR_DEFAULT": [
                    74,
                    2231
                ],
                "_testing_mode_warnings": [
                    91,
                    84,
                    77
                ],
                "testing_mode": [
                    89,
                    82,
                    83,
                    90
                ],
                "os.environ.get": [
                    89,
                    82,
                    2684
                ],
                "os.environ": [
                    548,
                    552,
                    553,
                    2681,
                    82,
                    2677,
                    89,
                    2684
                ],
                "os": [
                    515,
                    516,
                    548,
                    552,
                    553,
                    497,
                    82,
                    2681,
                    2740,
                    2677,
                    89,
                    2684,
                    511
                ],
                "warnings.simplefilter": [
                    2448,
                    91,
                    84
                ],
                "warnings": [
                    2432,
                    91,
                    84,
                    2448
                ],
                "set_testing_mode": [
                    94
                ],
                "pd.reset_option": [
                    101
                ],
                "pd": [
                    775,
                    1424,
                    1425,
                    1426,
                    1427,
                    1428,
                    1429,
                    1695,
                    1704,
                    689,
                    691,
                    309,
                    319,
                    329,
                    1616,
                    1621,
                    1495,
                    1500,
                    1501,
                    101,
                    1386,
                    1388,
                    1390,
                    123,
                    124
                ],
                "FrameOrSeries": [
                    104
                ],
                "Optional": [
                    104,
                    156,
                    127
                ],
                "path": [
                    273,
                    148,
                    149,
                    150,
                    151,
                    152,
                    177,
                    178,
                    179,
                    180,
                    181,
                    203,
                    205,
                    207,
                    209,
                    211,
                    216,
                    120,
                    121,
                    122,
                    123,
                    124
                ],
                "rands": [
                    121
                ],
                "ensure_clean": [
                    122,
                    179,
                    150
                ],
                "pd.to_pickle": [
                    123
                ],
                "obj": [
                    641,
                    769,
                    644,
                    903,
                    152,
                    153,
                    792,
                    667,
                    1183,
                    1312,
                    673,
                    674,
                    1188,
                    1192,
                    681,
                    1458,
                    1453,
                    1454,
                    1327,
                    688,
                    1455,
                    690,
                    947,
                    1456,
                    181,
                    182,
                    1457,
                    696,
                    952,
                    826,
                    1339,
                    828,
                    1460,
                    834,
                    1350,
                    839,
                    968,
                    842,
                    720,
                    721,
                    978,
                    979,
                    724,
                    725,
                    1109,
                    1369,
                    989,
                    606,
                    350,
                    352,
                    353,
                    610,
                    862,
                    863,
                    864,
                    870,
                    871,
                    616,
                    1120,
                    878,
                    879,
                    880,
                    887,
                    1134,
                    1141,
                    630,
                    886,
                    634,
                    123,
                    637
                ],
                "pd.read_pickle": [
                    124
                ],
                "Path": [
                    152,
                    147,
                    151
                ],
                "pytest.importorskip": [
                    176,
                    147
                ],
                "pytest": [
                    176,
                    505,
                    147
                ],
                "writer": [
                    180,
                    151
                ],
                "reader": [
                    152,
                    181
                ],
                "LocalPath": [
                    176,
                    180,
                    181
                ],
                "local": [
                    176
                ],
                "compression": [
                    224,
                    259,
                    262,
                    264,
                    202,
                    204,
                    206,
                    208,
                    210,
                    247,
                    218,
                    251,
                    255
                ],
                "f": [
                    2145,
                    2147,
                    490,
                    203,
                    492,
                    205,
                    494,
                    207,
                    209,
                    273,
                    274,
                    2141,
                    214,
                    221,
                    223
                ],
                "gzip.open": [
                    205
                ],
                "gzip": [
                    205,
                    254
                ],
                "bz2.BZ2File": [
                    258,
                    207
                ],
                "bz2": [
                    258,
                    207
                ],
                "_get_lzma_file": [
                    209,
                    260
                ],
                "zip_file": [
                    225,
                    211,
                    212,
                    214
                ],
                "zipfile.ZipFile": [
                    250,
                    211
                ],
                "zipfile": [
                    250,
                    211
                ],
                "zip_names": [
                    212,
                    213,
                    214
                ],
                "zip_file.namelist": [
                    212
                ],
                "zip_file.open": [
                    214
                ],
                "zip_names.pop": [
                    214
                ],
                "f.close": [
                    494,
                    223
                ],
                "zip_file.close": [
                    225
                ],
                "contextmanager": [
                    521,
                    2521,
                    2553,
                    2647,
                    472,
                    185,
                    2362,
                    540
                ],
                "compress_method": [
                    258,
                    260,
                    273,
                    250,
                    254
                ],
                "gzip.GzipFile": [
                    254
                ],
                "mode": [
                    265,
                    269,
                    273
                ],
                "args": [
                    2145,
                    2146,
                    266,
                    2605,
                    270,
                    274,
                    2332,
                    2141,
                    2143
                ],
                "dest": [
                    266
                ],
                "data": [
                    1826,
                    266,
                    1834,
                    1835,
                    1774,
                    270,
                    1775,
                    1777,
                    1807,
                    1808,
                    1812,
                    1813,
                    2042,
                    1819,
                    2044
                ],
                "method": [
                    274,
                    267,
                    271
                ],
                "Union": [
                    280,
                    281,
                    570,
                    699,
                    572
                ],
                "left": [
                    1026,
                    1030,
                    1097,
                    1102,
                    1106,
                    1107,
                    1113,
                    1128,
                    1134,
                    1138,
                    627,
                    630,
                    633,
                    635,
                    1147,
                    1151,
                    640,
                    1153,
                    642,
                    647,
                    648,
                    1159,
                    651,
                    1163,
                    653,
                    1164,
                    1165,
                    1169,
                    1171,
                    1172,
                    1176,
                    667,
                    1179,
                    671,
                    672,
                    674,
                    1188,
                    677,
                    1191,
                    1192,
                    682,
                    688,
                    689,
                    690,
                    691,
                    692,
                    695,
                    696,
                    716,
                    718,
                    721,
                    723,
                    725,
                    743,
                    1303,
                    1306,
                    1310,
                    1312,
                    1316,
                    1320,
                    1332,
                    309,
                    311,
                    823,
                    826,
                    828,
                    319,
                    832,
                    321,
                    1345,
                    837,
                    329,
                    842,
                    331,
                    1355,
                    1357,
                    342,
                    345,
                    860,
                    349,
                    862,
                    863,
                    864,
                    353,
                    355,
                    868,
                    870,
                    871,
                    1386,
                    1387,
                    876,
                    1388,
                    878,
                    879,
                    880,
                    1389,
                    1390,
                    1391,
                    1392,
                    885,
                    886,
                    887,
                    1393,
                    1394,
                    1395,
                    1396,
                    1397,
                    893,
                    381,
                    895,
                    896,
                    894,
                    383,
                    1398,
                    1399,
                    1400,
                    1406,
                    1408,
                    393,
                    394,
                    906,
                    1401,
                    1402,
                    1403,
                    1404,
                    947,
                    949,
                    954,
                    966,
                    968,
                    972,
                    977,
                    979,
                    1495,
                    984,
                    985,
                    1497,
                    988,
                    989,
                    1500,
                    1504,
                    1507,
                    1510,
                    1524,
                    1526,
                    1527,
                    1016,
                    1019,
                    1021,
                    1023
                ],
                "pd.Index": [
                    1424,
                    1425,
                    1386,
                    309
                ],
                "assert_index_equal": [
                    836,
                    1319,
                    1387,
                    657,
                    1331,
                    310,
                    863,
                    1112,
                    826,
                    862,
                    831
                ],
                "right": [
                    1027,
                    1031,
                    1097,
                    1102,
                    1106,
                    1108,
                    1114,
                    1129,
                    1134,
                    627,
                    1139,
                    630,
                    633,
                    1147,
                    636,
                    1151,
                    640,
                    1154,
                    643,
                    1160,
                    649,
                    1163,
                    1164,
                    654,
                    1168,
                    1169,
                    1173,
                    1174,
                    1176,
                    667,
                    1180,
                    671,
                    672,
                    674,
                    1188,
                    678,
                    1191,
                    1192,
                    683,
                    688,
                    689,
                    690,
                    691,
                    692,
                    695,
                    696,
                    716,
                    718,
                    721,
                    723,
                    725,
                    744,
                    1303,
                    1306,
                    1310,
                    1312,
                    1316,
                    1321,
                    1333,
                    823,
                    312,
                    826,
                    828,
                    1344,
                    833,
                    322,
                    838,
                    842,
                    332,
                    1356,
                    1358,
                    342,
                    345,
                    860,
                    349,
                    862,
                    863,
                    864,
                    353,
                    356,
                    868,
                    870,
                    871,
                    1387,
                    876,
                    1389,
                    878,
                    879,
                    880,
                    1391,
                    1393,
                    1395,
                    885,
                    886,
                    887,
                    1397,
                    1399,
                    1401,
                    1403,
                    1406,
                    385,
                    898,
                    387,
                    899,
                    900,
                    901,
                    393,
                    394,
                    907,
                    947,
                    949,
                    955,
                    966,
                    968,
                    972,
                    979,
                    1495,
                    984,
                    985,
                    1497,
                    988,
                    989,
                    1501,
                    1505,
                    1508,
                    1524,
                    1526,
                    1527,
                    1017,
                    1019,
                    1021,
                    1023
                ],
                "check_dtype": [
                    1018,
                    1123,
                    324,
                    357,
                    1350,
                    1161,
                    334,
                    1038,
                    1362,
                    1140,
                    341,
                    1525,
                    1527,
                    1497,
                    314,
                    987,
                    828,
                    1182
                ],
                "check_less_precise": [
                    325,
                    358,
                    679,
                    1324,
                    335,
                    1039,
                    1364,
                    662,
                    1181,
                    1336,
                    315,
                    1117
                ],
                "kwargs": [
                    2332,
                    1574,
                    2599,
                    2601,
                    1581,
                    316,
                    1601,
                    326,
                    1612,
                    336,
                    1616,
                    1621,
                    1626,
                    2141,
                    2143,
                    359,
                    1387,
                    1389,
                    1391,
                    1393,
                    1395,
                    2548,
                    1397,
                    1399,
                    1401,
                    1403,
                    1405
                ],
                "pd.Series": [
                    775,
                    1388,
                    1426,
                    1427,
                    1429,
                    319
                ],
                "assert_series_equal": [
                    320,
                    1389,
                    1359
                ],
                "pd.DataFrame": [
                    1704,
                    329,
                    1428,
                    1390
                ],
                "assert_frame_equal": [
                    330,
                    1349,
                    1391
                ],
                "is_number": [
                    749,
                    342,
                    751
                ],
                "is_bool": [
                    345
                ],
                "np.ndarray": [
                    898,
                    1442,
                    775,
                    988,
                    949,
                    1402,
                    349,
                    893
                ],
                "np": [
                    2049,
                    898,
                    1026,
                    1027,
                    2051,
                    1030,
                    775,
                    1031,
                    2054,
                    2062,
                    401,
                    402,
                    404,
                    2069,
                    413,
                    414,
                    2718,
                    672,
                    673,
                    800,
                    1442,
                    1443,
                    1697,
                    1574,
                    428,
                    429,
                    1580,
                    1460,
                    949,
                    445,
                    1605,
                    1606,
                    455,
                    2117,
                    2124,
                    2513,
                    978,
                    2514,
                    2518,
                    988,
                    349,
                    750,
                    752,
                    1402,
                    893
                ],
                "assert_class_equal": [
                    353,
                    947,
                    606
                ],
                "_testing.assert_almost_equal": [
                    354,
                    1035,
                    676,
                    1178
                ],
                "_testing": [
                    354,
                    676,
                    394,
                    1035,
                    1178
                ],
                "cls_name": [
                    379,
                    387,
                    383
                ],
                "cls.__name__": [
                    379
                ],
                "cls": [
                    385,
                    387,
                    379,
                    381,
                    383
                ],
                "_check_isinstance": [
                    1495,
                    868,
                    393,
                    1097,
                    876,
                    1303,
                    627,
                    885,
                    949,
                    823,
                    860
                ],
                "_testing.assert_dict_equal": [
                    394
                ],
                "compare_keys": [
                    394
                ],
                "rand": [
                    398
                ],
                "size": [
                    2054,
                    2058,
                    428,
                    430,
                    398,
                    2062,
                    2065,
                    413,
                    415
                ],
                "p": [
                    398
                ],
                "RANDS_CHARS": [
                    401,
                    413,
                    445
                ],
                "np.array": [
                    800,
                    1443,
                    401,
                    402,
                    1460
                ],
                "string.ascii_letters": [
                    401
                ],
                "string": [
                    401,
                    403,
                    1558
                ],
                "string.digits": [
                    401,
                    403
                ],
                "np.str_": [
                    401,
                    414
                ],
                "RANDU_CHARS": [
                    402,
                    428,
                    455
                ],
                "join": [
                    403,
                    445,
                    455
                ],
                "np.unicode_": [
                    404,
                    429
                ],
                "retval": [
                    418,
                    420,
                    427,
                    433,
                    435,
                    412
                ],
                "reshape": [
                    428,
                    413
                ],
                "view": [
                    428,
                    413
                ],
                "np.random.choice": [
                    455,
                    428,
                    413,
                    445
                ],
                "np.random": [
                    1697,
                    2049,
                    2051,
                    1605,
                    1606,
                    455,
                    428,
                    2513,
                    2514,
                    2518,
                    413,
                    445
                ],
                "nchars": [
                    414,
                    455,
                    428,
                    429,
                    445,
                    413
                ],
                "np.prod": [
                    428,
                    413
                ],
                "dtype": [
                    417,
                    1346,
                    1347,
                    420,
                    1348,
                    1350,
                    432,
                    435,
                    2044,
                    2111
                ],
                "retval.astype": [
                    435,
                    420
                ],
                "fignum": [
                    465,
                    461,
                    462,
                    463
                ],
                "get_fignums": [
                    462
                ],
                "_close": [
                    465,
                    463
                ],
                "filename": [
                    513,
                    515,
                    516,
                    486,
                    490,
                    497,
                    501,
                    508
                ],
                "fd": [
                    513,
                    511,
                    501,
                    487
                ],
                "return_filelike": [
                    489
                ],
                "tempfile.TemporaryFile": [
                    490
                ],
                "tempfile": [
                    490,
                    530,
                    501
                ],
                "os.path.dirname": [
                    497
                ],
                "os.path": [
                    497,
                    515
                ],
                "tempfile.mkstemp": [
                    501
                ],
                "pytest.skip": [
                    505
                ],
                "os.close": [
                    511
                ],
                "os.path.exists": [
                    515
                ],
                "os.remove": [
                    516
                ],
                "e": [
                    518
                ],
                "directory_name": [
                    530,
                    532,
                    535
                ],
                "tempfile.mkdtemp": [
                    530
                ],
                "rmtree": [
                    535
                ],
                "saved_environ": [
                    553,
                    548
                ],
                "os.environ.clear": [
                    552
                ],
                "os.environ.update": [
                    553
                ],
                "arr1": [
                    564
                ],
                "arr2": [
                    564
                ],
                "Index": [
                    706,
                    1597,
                    1606,
                    1567,
                    1934,
                    1593,
                    1775,
                    1937,
                    1586,
                    627,
                    1588,
                    1589,
                    1817,
                    568,
                    569,
                    1563,
                    797,
                    1151
                ],
                "__tracebackhide__": [
                    741,
                    1094,
                    1384,
                    875,
                    943,
                    884,
                    1300,
                    602,
                    891,
                    2430,
                    703
                ],
                "exact": [
                    680,
                    715,
                    862,
                    722,
                    660,
                    605,
                    606,
                    863
                ],
                "l": [
                    610,
                    613,
                    616,
                    972,
                    974,
                    606
                ],
                "r": [
                    610,
                    614,
                    616,
                    972,
                    974,
                    2040,
                    2042,
                    606
                ],
                "check_categorical": [
                    609,
                    1190,
                    1130,
                    1326,
                    694,
                    1368,
                    1338,
                    670,
                    1119
                ],
                "assert_attr_equal": [
                    864,
                    610,
                    1188,
                    871,
                    616,
                    842,
                    1134,
                    879,
                    688,
                    880,
                    690,
                    1524,
                    1526,
                    887,
                    1019,
                    989
                ],
                "l.inferred_type": [
                    613
                ],
                "r.inferred_type": [
                    614
                ],
                "unique": [
                    620,
                    622,
                    623
                ],
                "index.levels": [
                    620
                ],
                "index": [
                    1934,
                    1937,
                    1939,
                    1940,
                    1817,
                    1695,
                    1696,
                    1826,
                    1704,
                    1764,
                    1765,
                    1769,
                    1770,
                    620,
                    621,
                    2029,
                    623,
                    1776,
                    1777,
                    1781,
                    1782,
                    2044
                ],
                "level": [
                    651,
                    620,
                    621,
                    653,
                    623,
                    654,
                    656,
                    667
                ],
                "level_codes": [
                    621,
                    622
                ],
                "index.codes": [
                    621
                ],
                "filled": [
                    622,
                    623
                ],
                "take_1d": [
                    622
                ],
                "unique._values": [
                    622
                ],
                "unique._na_value": [
                    622
                ],
                "values": [
                    624,
                    1605,
                    1606,
                    623
                ],
                "unique._shallow_copy": [
                    623
                ],
                "index.names": [
                    623
                ],
                "_check_types": [
                    667,
                    630
                ],
                "left.nlevels": [
                    633,
                    635,
                    651,
                    647
                ],
                "right.nlevels": [
                    633,
                    636
                ],
                "msg1": [
                    641,
                    644,
                    1107,
                    1109,
                    634,
                    637
                ],
                "msg2": [
                    642,
                    644,
                    1108,
                    1109,
                    635,
                    637
                ],
                "msg3": [
                    644,
                    643,
                    636,
                    637
                ],
                "raise_assert_detail": [
                    769,
                    674,
                    644,
                    967,
                    1516,
                    721,
                    979,
                    725,
                    1109,
                    637,
                    1311
                ],
                "cast": [
                    648,
                    649
                ],
                "MultiIndex": [
                    648,
                    649,
                    1626,
                    1939
                ],
                "llevel": [
                    658,
                    653
                ],
                "_get_ilevel_values": [
                    653,
                    654
                ],
                "rlevel": [
                    659,
                    654
                ],
                "lobj": [
                    656,
                    664
                ],
                "check_names": [
                    1187,
                    1323,
                    687,
                    661,
                    1366,
                    1335,
                    1116
                ],
                "check_exact": [
                    1032,
                    670,
                    1325,
                    1136,
                    1365,
                    663,
                    1337,
                    1118
                ],
                "left.levels": [
                    667
                ],
                "right.levels": [
                    667
                ],
                "left.equals": [
                    671
                ],
                "diff": [
                    672,
                    673,
                    971,
                    909,
                    910,
                    975,
                    977,
                    978
                ],
                "np.sum": [
                    672
                ],
                "astype": [
                    672,
                    1030,
                    1031,
                    2069,
                    2070
                ],
                "left.values": [
                    672,
                    1153,
                    677,
                    1192,
                    692,
                    696,
                    1151
                ],
                "right.values": [
                    672,
                    1154,
                    678,
                    1192,
                    692,
                    696,
                    1151
                ],
                "msg": [
                    768,
                    769,
                    1152,
                    1156,
                    903,
                    777,
                    781,
                    910,
                    783,
                    912,
                    1550,
                    1554,
                    788,
                    2464,
                    673,
                    674,
                    2469,
                    2480,
                    2484,
                    720,
                    721,
                    978,
                    979,
                    724,
                    725
                ],
                "np.round": [
                    673,
                    978,
                    2054
                ],
                "pd.PeriodIndex": [
                    689
                ],
                "pd.IntervalIndex": [
                    691
                ],
                "assert_interval_array_equal": [
                    1164,
                    692,
                    1393
                ],
                "is_categorical_dtype": [
                    900,
                    1191,
                    1128,
                    1129,
                    1172,
                    1174,
                    695,
                    895
                ],
                "assert_categorical_equal": [
                    696,
                    1192
                ],
                "x": [
                    2716,
                    706,
                    708,
                    1572,
                    1574,
                    711,
                    713,
                    1580,
                    1581,
                    1937,
                    1908,
                    2711,
                    1916
                ],
                "types": [
                    718,
                    719
                ],
                "repr_class": [
                    721,
                    725
                ],
                "left_attr": [
                    769,
                    743,
                    746,
                    749,
                    750,
                    758
                ],
                "attr": [
                    744,
                    768,
                    743
                ],
                "right_attr": [
                    769,
                    744,
                    746,
                    751,
                    752,
                    758
                ],
                "np.isnan": [
                    752,
                    750
                ],
                "result": [
                    1926,
                    1927,
                    758,
                    761,
                    762,
                    763,
                    765
                ],
                "result.all": [
                    763
                ],
                "objs": [
                    776,
                    786,
                    788,
                    775
                ],
                "el": [
                    776,
                    779,
                    781
                ],
                "objs.ravel": [
                    776
                ],
                "plt.Axes": [
                    781
                ],
                "plt": [
                    788,
                    781
                ],
                "plt.Artist": [
                    788
                ],
                "seq": [
                    800,
                    797,
                    798
                ],
                "Series": [
                    1794,
                    1765,
                    1097,
                    1770,
                    1777,
                    1782,
                    2617,
                    1788,
                    797
                ],
                "seq.values": [
                    798
                ],
                "assert_numpy_array_equal": [
                    800,
                    1028,
                    870,
                    1158,
                    1033,
                    878,
                    1137,
                    1403,
                    886,
                    1527,
                    1497,
                    827,
                    1023
                ],
                "np.sort": [
                    800
                ],
                "Categorical": [
                    2641,
                    1574,
                    823
                ],
                "check_category_order": [
                    825
                ],
                "left.categories": [
                    832,
                    826,
                    837
                ],
                "right.categories": [
                    833,
                    826,
                    838
                ],
                "left.codes": [
                    828,
                    837
                ],
                "right.codes": [
                    828,
                    838
                ],
                "left.categories.sort_values": [
                    832
                ],
                "right.categories.sort_values": [
                    833
                ],
                "left.categories.take": [
                    837
                ],
                "right.categories.take": [
                    838
                ],
                "IntervalArray": [
                    1392,
                    860
                ],
                "left.left": [
                    862
                ],
                "right.left": [
                    862
                ],
                "left.right": [
                    863
                ],
                "right.right": [
                    863
                ],
                "PeriodArray": [
                    1394,
                    1435,
                    868
                ],
                "left._data": [
                    878,
                    886,
                    870
                ],
                "right._data": [
                    878,
                    886,
                    870
                ],
                "DatetimeArray": [
                    876,
                    1456,
                    1396,
                    1438,
                    1439
                ],
                "TimedeltaArray": [
                    1440,
                    1441,
                    1458,
                    885,
                    1398
                ],
                "pprint_thing": [
                    899,
                    894
                ],
                "message": [
                    905
                ],
                "obj.base": [
                    952
                ],
                "left_base": [
                    961,
                    962,
                    954,
                    958,
                    959
                ],
                "_get_base": [
                    954,
                    955
                ],
                "right_base": [
                    961,
                    962,
                    955,
                    958,
                    959
                ],
                "check_same": [
                    960,
                    957
                ],
                "err_msg": [
                    981,
                    985,
                    965
                ],
                "left.shape": [
                    968,
                    1312,
                    966,
                    1310
                ],
                "right.shape": [
                    968,
                    1312,
                    966,
                    1310
                ],
                "array_equivalent": [
                    984,
                    974
                ],
                "strict_nan": [
                    984,
                    974
                ],
                "left.size": [
                    977
                ],
                "_raise": [
                    985
                ],
                "ExtensionArray": [
                    1016,
                    1017,
                    1400
                ],
                "left.asi8": [
                    1023
                ],
                "right.asi8": [
                    1023
                ],
                "left_na": [
                    1026,
                    1028,
                    1030
                ],
                "np.asarray": [
                    1026,
                    1027,
                    1030,
                    1031
                ],
                "left.isna": [
                    1026
                ],
                "right_na": [
                    1027,
                    1028,
                    1031
                ],
                "right.isna": [
                    1027
                ],
                "left_valid": [
                    1033,
                    1036,
                    1030
                ],
                "right_valid": [
                    1033,
                    1037,
                    1031
                ],
                "check_series_type": [
                    1099
                ],
                "left.index": [
                    1320,
                    1113,
                    1107
                ],
                "right.index": [
                    1321,
                    1114,
                    1108
                ],
                "check_index_type": [
                    1322,
                    1115,
                    1363
                ],
                "left._internal_get_values": [
                    1138,
                    1179,
                    1159
                ],
                "right._internal_get_values": [
                    1160,
                    1139,
                    1180
                ],
                "check_datetimelike_compat": [
                    1367,
                    1143
                ],
                "needs_i8_conversion": [
                    1147
                ],
                "equals": [
                    1151
                ],
                "is_interval_dtype": [
                    1163
                ],
                "left.array": [
                    1176,
                    1164
                ],
                "right.array": [
                    1176,
                    1164
                ],
                "is_extension_array_dtype": [
                    1168,
                    1171,
                    1165,
                    1173
                ],
                "left.dtype": [
                    1165
                ],
                "is_datetime64tz_dtype": [
                    1165,
                    1455
                ],
                "right.dtype": [
                    1168
                ],
                "assert_extension_array_equal": [
                    1176,
                    1169,
                    1401
                ],
                "left._values": [
                    1169
                ],
                "right._values": [
                    1169
                ],
                "DataFrame": [
                    2629,
                    1830,
                    1835,
                    1808,
                    1813,
                    1303,
                    2044
                ],
                "check_frame_type": [
                    1305
                ],
                "check_like": [
                    1315
                ],
                "left.reindex_like": [
                    1316
                ],
                "left.columns": [
                    1355,
                    1332
                ],
                "right.columns": [
                    1333
                ],
                "check_column_type": [
                    1334
                ],
                "by_blocks": [
                    1343
                ],
                "rblocks": [
                    1344,
                    1346,
                    1348,
                    1350
                ],
                "right._to_dict_of_blocks": [
                    1344
                ],
                "lblocks": [
                    1345,
                    1346,
                    1347,
                    1350
                ],
                "left._to_dict_of_blocks": [
                    1345
                ],
                "lblocks.keys": [
                    1346
                ],
                "rblocks.keys": [
                    1346
                ],
                "i": [
                    1920,
                    1923,
                    1924,
                    2070,
                    2071,
                    2599,
                    2603,
                    2604,
                    1597,
                    2116,
                    2117,
                    1355,
                    2123,
                    1357,
                    1358,
                    2124,
                    1873,
                    1369,
                    1911
                ],
                "col": [
                    1369,
                    1355,
                    1356
                ],
                "lcol": [
                    1360,
                    1357
                ],
                "left.iloc": [
                    1357
                ],
                "rcol": [
                    1361,
                    1358
                ],
                "right.iloc": [
                    1358
                ],
                "assert_period_array_equal": [
                    1395
                ],
                "assert_datetime_array_equal": [
                    1397
                ],
                "assert_timedelta_array_equal": [
                    1399
                ],
                "box_cls": [
                    1440,
                    1442,
                    1444,
                    1447,
                    1424,
                    1426,
                    1428,
                    1435,
                    1438
                ],
                "expected": [
                    1441,
                    1443,
                    1445,
                    1448,
                    1425,
                    1427,
                    1429,
                    2741,
                    2742,
                    1434,
                    1437,
                    1439
                ],
                "to_frame": [
                    1429
                ],
                "transpose": [
                    1430
                ],
                "expected.T": [
                    1434
                ],
                "period_array": [
                    1437,
                    1454
                ],
                "to_array": [
                    1444,
                    1445
                ],
                "is_period_dtype": [
                    1453
                ],
                "is_datetime64_dtype": [
                    1455
                ],
                "DatetimeArray._from_sequence": [
                    1456
                ],
                "is_timedelta64_dtype": [
                    1457
                ],
                "TimedeltaArray._from_sequence": [
                    1458
                ],
                "pd.arrays.SparseArray": [
                    1495
                ],
                "pd.arrays": [
                    1495
                ],
                "left.sp_values": [
                    1497
                ],
                "right.sp_values": [
                    1497
                ],
                "left.sp_index": [
                    1504,
                    1507,
                    1500
                ],
                "pd._libs.sparse.SparseIndex": [
                    1500,
                    1501
                ],
                "pd._libs.sparse": [
                    1500,
                    1501
                ],
                "pd._libs": [
                    1500,
                    1501
                ],
                "right.sp_index": [
                    1505,
                    1508,
                    1501
                ],
                "check_kind": [
                    1503
                ],
                "left_index": [
                    1504,
                    1507,
                    1512,
                    1515,
                    1517
                ],
                "left.sp_index.to_block_index": [
                    1504
                ],
                "right_index": [
                    1505,
                    1508,
                    1513,
                    1515,
                    1517
                ],
                "right.sp_index.to_block_index": [
                    1505
                ],
                "consolidate_block_indices": [
                    1510
                ],
                "left.kind": [
                    1510
                ],
                "to_block_index": [
                    1512,
                    1513
                ],
                "left_index.to_int_index": [
                    1512
                ],
                "right_index.to_int_index": [
                    1513
                ],
                "left_index.equals": [
                    1515
                ],
                "check_fill_value": [
                    1523
                ],
                "left.to_dense": [
                    1527
                ],
                "right.to_dense": [
                    1527
                ],
                "k": [
                    1536,
                    1558,
                    1563,
                    1567,
                    1574,
                    1580,
                    1585,
                    1587,
                    1589,
                    1593,
                    1597,
                    1601,
                    1732,
                    1605,
                    1611,
                    1616,
                    1621,
                    1759,
                    1535
                ],
                "iterable": [
                    1535
                ],
                "dic": [
                    1536
                ],
                "elem1": [
                    1554,
                    1548,
                    1549,
                    1551
                ],
                "elem2": [
                    1554,
                    1548,
                    1549,
                    1551
                ],
                "iter1": [
                    1548
                ],
                "iter2": [
                    1548
                ],
                "assert_almost_equal": [
                    1549
                ],
                "eql_kwargs": [
                    1549
                ],
                "string.ascii_uppercase": [
                    1558
                ],
                "rands_array": [
                    1563,
                    1572
                ],
                "name": [
                    1794,
                    1936,
                    1937,
                    1563,
                    1567,
                    1574,
                    1581,
                    1586,
                    1588,
                    1589,
                    1593,
                    1597,
                    1601,
                    1606,
                    1611,
                    1612,
                    1616,
                    1621,
                    1765,
                    1770,
                    1777,
                    2545,
                    2548,
                    2550,
                    1788
                ],
                "randu_array": [
                    1567
                ],
                "n": [
                    1696,
                    1699,
                    1700,
                    1572,
                    1574,
                    1701,
                    1702
                ],
                "CategoricalIndex": [
                    1573
                ],
                "Categorical.from_codes": [
                    1574
                ],
                "np.arange": [
                    1574
                ],
                "np.linspace": [
                    1580
                ],
                "IntervalIndex.from_breaks": [
                    1581
                ],
                "IntervalIndex": [
                    1581
                ],
                "RangeIndex": [
                    1601
                ],
                "np.random.random_sample": [
                    1605
                ],
                "np.random.randint": [
                    1606
                ],
                "dt": [
                    1610,
                    1611,
                    1620,
                    1621
                ],
                "datetime": [
                    1610,
                    1620
                ],
                "dr": [
                    1611,
                    1612,
                    1621,
                    1622
                ],
                "bdate_range": [
                    1611,
                    1823
                ],
                "freq": [
                    1798,
                    1611,
                    1807,
                    1616,
                    1788,
                    1695
                ],
                "DatetimeIndex": [
                    1612
                ],
                "pd.timedelta_range": [
                    1616
                ],
                "pd.period_range": [
                    1621
                ],
                "MultiIndex.from_product": [
                    1626
                ],
                "names": [
                    1895,
                    1896,
                    1866,
                    1934,
                    1871,
                    1936,
                    1873,
                    1874,
                    1939,
                    1876,
                    1879,
                    1880,
                    1626
                ],
                "_names": [
                    1699,
                    1629
                ],
                "pd.date_range": [
                    1695
                ],
                "start": [
                    1695
                ],
                "end": [
                    1705,
                    1695
                ],
                "state": [
                    1697,
                    1699,
                    1700,
                    1701,
                    1702
                ],
                "np.random.RandomState": [
                    1697,
                    2051
                ],
                "seed": [
                    1697,
                    2509
                ],
                "columns": [
                    1704,
                    1698,
                    2044,
                    2021
                ],
                "state.choice": [
                    1699
                ],
                "state.poisson": [
                    1700
                ],
                "state.rand": [
                    1701,
                    1702
                ],
                "df": [
                    2117,
                    2118,
                    1704,
                    1705,
                    1706,
                    1707,
                    2122,
                    2123,
                    2124,
                    2125,
                    2101
                ],
                "df.index": [
                    1705
                ],
                "df.iloc": [
                    1706
                ],
                "all_make_index_funcs": [
                    1731,
                    1718
                ],
                "makeIntIndex": [
                    1884,
                    1719
                ],
                "makeFloatIndex": [
                    1720,
                    1885
                ],
                "makeStringIndex": [
                    1764,
                    1769,
                    1774,
                    1776,
                    1781,
                    1721,
                    1886
                ],
                "makeUnicodeIndex": [
                    1722,
                    1887
                ],
                "makeDateIndex": [
                    1888,
                    1737,
                    1723,
                    1788,
                    1757
                ],
                "makePeriodIndex": [
                    1794,
                    1890,
                    1738,
                    1724,
                    1757
                ],
                "makeTimedeltaIndex": [
                    1757,
                    1889,
                    1739,
                    1725
                ],
                "makeBoolIndex": [
                    1726
                ],
                "makeRangeIndex": [
                    1740,
                    1727
                ],
                "makeIntervalIndex": [
                    1728,
                    1741
                ],
                "makeCategoricalIndex": [
                    1729,
                    1742
                ],
                "make_index_func": [
                    1731,
                    1732,
                    1745,
                    1746,
                    1758,
                    1759
                ],
                "make_index_funcs": [
                    1736,
                    1745,
                    1757,
                    1758
                ],
                "makeMultiIndex": [
                    1743
                ],
                "randn": [
                    1794,
                    1765,
                    1770,
                    1782,
                    1788
                ],
                "c": [
                    1798,
                    1802,
                    1782,
                    2040,
                    2042
                ],
                "getCols": [
                    1802,
                    1782,
                    1798
                ],
                "nper": [
                    1792,
                    1793,
                    1794,
                    1798,
                    1802,
                    1834,
                    1807,
                    1786,
                    1787,
                    1788
                ],
                "makeTimeSeries": [
                    1798
                ],
                "makePeriodSeries": [
                    1802
                ],
                "getTimeSeriesData": [
                    1807
                ],
                "getSeriesData": [
                    1812
                ],
                "getMixedTypeDict": [
                    1830
                ],
                "getPeriodData": [
                    1834
                ],
                "ndupe_l": [
                    1920,
                    1924,
                    1863,
                    1864,
                    1865,
                    1904,
                    1905,
                    1906,
                    1908
                ],
                "nlevels": [
                    1864,
                    1865,
                    1866,
                    1868,
                    1911,
                    1904,
                    1873,
                    1905,
                    1906,
                    1935,
                    1879
                ],
                "is_sequence": [
                    1865
                ],
                "idx_type": [
                    1891,
                    1898,
                    1867,
                    1900,
                    1868
                ],
                "prefix": [
                    1873,
                    1923
                ],
                "idx_func": [
                    1883,
                    1892,
                    1893
                ],
                "get": [
                    1883
                ],
                "idx": [
                    1896,
                    1897,
                    1893
                ],
                "nentries": [
                    1920,
                    1932,
                    1893,
                    1926
                ],
                "idx.name": [
                    1896
                ],
                "ndupe_l.extend": [
                    1905
                ],
                "tuples": [
                    1927,
                    1929,
                    1934,
                    1937,
                    1939,
                    1910
                ],
                "numeric_tuple": [
                    1916,
                    1917
                ],
                "split": [
                    1916
                ],
                "re.sub": [
                    1916
                ],
                "re": [
                    1916
                ],
                "num": [
                    1917
                ],
                "div_factor": [
                    1920,
                    1922
                ],
                "cnt": [
                    1921,
                    1924,
                    1926
                ],
                "Counter": [
                    1921
                ],
                "j": [
                    1922,
                    1923,
                    2116,
                    2117,
                    2123,
                    2124,
                    2069,
                    2070,
                    2071
                ],
                "label": [
                    1923,
                    1924
                ],
                "cnt.elements": [
                    1926
                ],
                "keyfunc": [
                    1926
                ],
                "tuples.append": [
                    1927
                ],
                "MultiIndex.from_tuples": [
                    1939
                ],
                "c_idx_nlevels": [
                    2018,
                    2012,
                    2106,
                    2023
                ],
                "r_idx_nlevels": [
                    2107,
                    2031,
                    2013,
                    2015
                ],
                "r_idx_type": [
                    2113,
                    2035,
                    2014,
                    2015
                ],
                "c_idx_type": [
                    2112,
                    2017,
                    2018,
                    2027
                ],
                "makeCustomIndex": [
                    2029,
                    2021
                ],
                "ncols": [
                    2116,
                    2022,
                    2054,
                    2062,
                    2103,
                    2042
                ],
                "c_idx_names": [
                    2104,
                    2025
                ],
                "c_ndupe_l": [
                    2026,
                    2109
                ],
                "nrows": [
                    2116,
                    2054,
                    2062,
                    2030,
                    2069,
                    2070,
                    2102,
                    2042
                ],
                "r_idx_names": [
                    2033,
                    2105
                ],
                "r_ndupe_l": [
                    2034,
                    2110
                ],
                "data_gen_f": [
                    2040,
                    2042,
                    2108,
                    2039
                ],
                "random_state": [
                    2048,
                    2049,
                    2051,
                    2116,
                    2123,
                    2064,
                    2067
                ],
                "density": [
                    2123,
                    2116,
                    2054
                ],
                "min_rows": [
                    2056,
                    2058
                ],
                "fac": [
                    2057,
                    2058
                ],
                "extra_size": [
                    2064,
                    2067,
                    2058,
                    2066
                ],
                "ind": [
                    2061,
                    2062,
                    2064,
                    2065,
                    2067,
                    2069,
                    2070
                ],
                "rng.rand": [
                    2061
                ],
                "rng": [
                    2061
                ],
                "_extra_size": [
                    2061
                ],
                "np.unique": [
                    2062
                ],
                "np.floor": [
                    2069,
                    2062
                ],
                "_gen_unique_rand": [
                    2064,
                    2067
                ],
                "ind.size": [
                    2065
                ],
                "i.tolist": [
                    2071
                ],
                "j.tolist": [
                    2071
                ],
                "makeCustomDataframe": [
                    2101
                ],
                "_create_missing_idx": [
                    2123,
                    2116
                ],
                "df.values": [
                    2124,
                    2117
                ],
                "np.nan": [
                    2124,
                    2117,
                    2718
                ],
                "makeDataFrame": [
                    2122
                ],
                "df.shape": [
                    2123
                ],
                "decorator": [
                    2138,
                    2141
                ],
                "is_decorating": [
                    2144,
                    2143
                ],
                "dec": [
                    2147,
                    2149
                ],
                "wraps": [
                    2138,
                    2596,
                    2326
                ],
                "wrapper": [
                    2356,
                    2614,
                    2151
                ],
                "_network_error_messages": [
                    2155,
                    2235
                ],
                "_network_errno_vals": [
                    2234,
                    2175
                ],
                "http.client.HTTPException": [
                    2196
                ],
                "http.client": [
                    2196
                ],
                "http": [
                    2196
                ],
                "error_classes": [
                    2215,
                    2216,
                    2348,
                    2221,
                    2351,
                    2321,
                    2322,
                    2329
                ],
                "_get_default_network_errors": [
                    2216,
                    2322
                ],
                "urlopen": [
                    2219
                ],
                "url": [
                    2329,
                    2219,
                    2351
                ],
                "t.network": [
                    2324
                ],
                "t": [
                    2324,
                    2332,
                    2326
                ],
                "check_before_test": [
                    2328
                ],
                "raise_on_error": [
                    2328,
                    2351
                ],
                "can_connect": [
                    2329,
                    2351
                ],
                "skip": [
                    2344,
                    2330,
                    2339,
                    2354
                ],
                "errno": [
                    2336,
                    2338,
                    2334,
                    2335
                ],
                "err": [
                    2336,
                    2339,
                    2341,
                    2345,
                    2348,
                    2354,
                    2334
                ],
                "err.reason": [
                    2336
                ],
                "skip_errnos": [
                    2338
                ],
                "e_str": [
                    2341,
                    2343
                ],
                "m.lower": [
                    2343
                ],
                "m": [
                    2440,
                    2442,
                    2343
                ],
                "e_str.lower": [
                    2343
                ],
                "_skip_on_messages": [
                    2343
                ],
                "optional_args": [
                    2227
                ],
                "with_connectivity_check": [
                    2359
                ],
                "network": [
                    2359
                ],
                "warnings.catch_warnings": [
                    2432
                ],
                "w": [
                    2432,
                    2449,
                    2452
                ],
                "clear": [
                    2440,
                    2434,
                    2438,
                    2439
                ],
                "is_list_like": [
                    2438
                ],
                "m.__warningregistry__.clear": [
                    2442
                ],
                "m.__warningregistry__": [
                    2442
                ],
                "saw_warning": [
                    2456,
                    2484,
                    2447
                ],
                "filter_level": [
                    2448
                ],
                "extra_warnings": [
                    2487,
                    2450,
                    2485,
                    2471
                ],
                "actual_warning": [
                    2466,
                    2467,
                    2469,
                    2473,
                    2474,
                    2475,
                    2476,
                    2452,
                    2454,
                    2459
                ],
                "expected_warning": [
                    2482,
                    2453,
                    2454,
                    2479
                ],
                "actual_warning.category": [
                    2473,
                    2459,
                    2454
                ],
                "check_stacklevel": [
                    2458
                ],
                "caller": [
                    2467,
                    2469,
                    2463
                ],
                "getframeinfo": [
                    2463
                ],
                "stack": [
                    2463
                ],
                "actual_warning.filename": [
                    2466,
                    2475,
                    2469
                ],
                "caller.filename": [
                    2467,
                    2469
                ],
                "actual_warning.message": [
                    2474,
                    2467
                ],
                "extra_warnings.append": [
                    2471
                ],
                "actual_warning.category.__name__": [
                    2473
                ],
                "actual_warning.lineno": [
                    2476
                ],
                "expected_warning.__name__": [
                    2482
                ],
                "raise_on_extra_warnings": [
                    2485
                ],
                "self.seed": [
                    2514,
                    2509
                ],
                "self": [
                    2513,
                    2514,
                    2509,
                    2518
                ],
                "self.start_state": [
                    2513,
                    2518
                ],
                "np.random.get_state": [
                    2513
                ],
                "np.random.seed": [
                    2514
                ],
                "np.random.set_state": [
                    2518
                ],
                "_BUILTIN_DIALECTS": [
                    2545,
                    2543
                ],
                "csv.register_dialect": [
                    2548
                ],
                "csv": [
                    2548,
                    2550
                ],
                "csv.unregister_dialect": [
                    2550
                ],
                "min_elements": [
                    2563,
                    2557,
                    2558
                ],
                "expr._MIN_ELEMENTS": [
                    2561,
                    2563,
                    2565,
                    2558
                ],
                "expr": [
                    2560,
                    2561,
                    2562,
                    2563,
                    2565,
                    2566,
                    2558
                ],
                "olduse": [
                    2560,
                    2566
                ],
                "expr._USE_NUMEXPR": [
                    2560
                ],
                "oldmin": [
                    2561,
                    2565
                ],
                "expr.set_use_numexpr": [
                    2562,
                    2566
                ],
                "use": [
                    2562
                ],
                "num_threads": [
                    2592,
                    2603,
                    2589
                ],
                "has_kwargs_list": [
                    2598,
                    2590,
                    2591
                ],
                "kwargs_list": [
                    2592,
                    2590,
                    2599
                ],
                "update_kwargs": [
                    2601,
                    2604,
                    2599
                ],
                "threads": [
                    2609,
                    2602,
                    2606,
                    2607
                ],
                "updated_kwargs": [
                    2604,
                    2605
                ],
                "thread": [
                    2605,
                    2606,
                    2607,
                    2608,
                    2609,
                    2610
                ],
                "threading.Thread": [
                    2605
                ],
                "threading": [
                    2605
                ],
                "func": [
                    2596,
                    2605
                ],
                "threads.append": [
                    2606
                ],
                "thread.start": [
                    2608
                ],
                "thread.join": [
                    2610
                ],
                "inner": [
                    2612
                ],
                "_metadata": [
                    2618,
                    2630
                ],
                "SubclassedSeries": [
                    2638,
                    2622
                ],
                "SubclassedDataFrame": [
                    2626,
                    2634
                ],
                "SubclassedCategorical": [
                    2644
                ],
                "tz": [
                    2681,
                    2675,
                    2685
                ],
                "time.tzset": [
                    2682
                ],
                "time": [
                    2682
                ],
                "orig_tz": [
                    2689,
                    2684
                ],
                "setTZ": [
                    2689,
                    2685
                ],
                "skipna_alternative": [
                    2708,
                    2711
                ],
                "x.values": [
                    2711
                ],
                "nona": [
                    2716,
                    2717,
                    2719
                ],
                "x.dropna": [
                    2716
                ],
                "alternative": [
                    2719
                ],
                "skipna_wrapper": [
                    2721
                ],
                "List": [
                    2724
                ],
                "sep": [
                    2740,
                    2741
                ],
                "os.linesep": [
                    2740
                ],
                "sep.join": [
                    2741
                ],
                "rows_list": [
                    2741
                ]
            }
        },
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_90/pandas/io/pickle.py": {
            "buggy_functions": [
                {
                    "function_name": "to_pickle",
                    "function_code": "def to_pickle(obj, path, compression=\"infer\", protocol=pickle.HIGHEST_PROTOCOL):\n    \"\"\"\n    Pickle (serialize) object to file.\n\n    Parameters\n    ----------\n    obj : any object\n        Any python object.\n    path : str\n        File path where the pickled object will be stored.\n    compression : {'infer', 'gzip', 'bz2', 'zip', 'xz', None}, default 'infer'\n        A string representing the compression to use in the output file. By\n        default, infers from the file extension in specified path.\n    protocol : int\n        Int which indicates which protocol should be used by the pickler,\n        default HIGHEST_PROTOCOL (see [1], paragraph 12.1.2). The possible\n        values for this parameter depend on the version of Python. For Python\n        2.x, possible values are 0, 1, 2. For Python>=3.0, 3 is a valid value.\n        For Python >= 3.4, 4 is a valid value. A negative value for the\n        protocol parameter is equivalent to setting its value to\n        HIGHEST_PROTOCOL.\n\n        .. [1] https://docs.python.org/3/library/pickle.html\n        .. versionadded:: 0.21.0\n\n    See Also\n    --------\n    read_pickle : Load pickled pandas object (or any object) from file.\n    DataFrame.to_hdf : Write DataFrame to an HDF5 file.\n    DataFrame.to_sql : Write DataFrame to a SQL database.\n    DataFrame.to_parquet : Write a DataFrame to the binary parquet format.\n\n    Examples\n    --------\n    >>> original_df = pd.DataFrame({\"foo\": range(5), \"bar\": range(5, 10)})\n    >>> original_df\n       foo  bar\n    0    0    5\n    1    1    6\n    2    2    7\n    3    3    8\n    4    4    9\n    >>> pd.to_pickle(original_df, \"./dummy.pkl\")\n\n    >>> unpickled_df = pd.read_pickle(\"./dummy.pkl\")\n    >>> unpickled_df\n       foo  bar\n    0    0    5\n    1    1    6\n    2    2    7\n    3    3    8\n    4    4    9\n\n    >>> import os\n    >>> os.remove(\"./dummy.pkl\")\n    \"\"\"\n    path = stringify_path(path)\n    f, fh = get_handle(path, \"wb\", compression=compression, is_text=False)\n    if protocol < 0:\n        protocol = pickle.HIGHEST_PROTOCOL\n    try:\n        f.write(pickle.dumps(obj, protocol=protocol))\n    finally:\n        f.close()\n        for _f in fh:\n            _f.close()\n",
                    "decorators": [],
                    "docstring": "Pickle (serialize) object to file.\n\nParameters\n----------\nobj : any object\n    Any python object.\npath : str\n    File path where the pickled object will be stored.\ncompression : {'infer', 'gzip', 'bz2', 'zip', 'xz', None}, default 'infer'\n    A string representing the compression to use in the output file. By\n    default, infers from the file extension in specified path.\nprotocol : int\n    Int which indicates which protocol should be used by the pickler,\n    default HIGHEST_PROTOCOL (see [1], paragraph 12.1.2). The possible\n    values for this parameter depend on the version of Python. For Python\n    2.x, possible values are 0, 1, 2. For Python>=3.0, 3 is a valid value.\n    For Python >= 3.4, 4 is a valid value. A negative value for the\n    protocol parameter is equivalent to setting its value to\n    HIGHEST_PROTOCOL.\n\n    .. [1] https://docs.python.org/3/library/pickle.html\n    .. versionadded:: 0.21.0\n\nSee Also\n--------\nread_pickle : Load pickled pandas object (or any object) from file.\nDataFrame.to_hdf : Write DataFrame to an HDF5 file.\nDataFrame.to_sql : Write DataFrame to a SQL database.\nDataFrame.to_parquet : Write a DataFrame to the binary parquet format.\n\nExamples\n--------\n>>> original_df = pd.DataFrame({\"foo\": range(5), \"bar\": range(5, 10)})\n>>> original_df\n   foo  bar\n0    0    5\n1    1    6\n2    2    7\n3    3    8\n4    4    9\n>>> pd.to_pickle(original_df, \"./dummy.pkl\")\n\n>>> unpickled_df = pd.read_pickle(\"./dummy.pkl\")\n>>> unpickled_df\n   foo  bar\n0    0    5\n1    1    6\n2    2    7\n3    3    8\n4    4    9\n\n>>> import os\n>>> os.remove(\"./dummy.pkl\")",
                    "start_line": 10,
                    "variables": {
                        "pickle.HIGHEST_PROTOCOL": [
                            10,
                            69
                        ],
                        "pickle": [
                            10,
                            69,
                            71
                        ],
                        "path": [
                            66,
                            67
                        ],
                        "stringify_path": [
                            66
                        ],
                        "f": [
                            73,
                            67,
                            71
                        ],
                        "fh": [
                            74,
                            67
                        ],
                        "get_handle": [
                            67
                        ],
                        "compression": [
                            67
                        ],
                        "protocol": [
                            68,
                            69,
                            71
                        ],
                        "f.write": [
                            71
                        ],
                        "pickle.dumps": [
                            71
                        ],
                        "obj": [
                            71
                        ],
                        "f.close": [
                            73
                        ],
                        "_f": [
                            74,
                            75
                        ],
                        "_f.close": [
                            75
                        ]
                    },
                    "filtered_variables": {
                        "pickle.HIGHEST_PROTOCOL": [
                            10,
                            69
                        ],
                        "pickle": [
                            10,
                            69,
                            71
                        ],
                        "path": [
                            66,
                            67
                        ],
                        "stringify_path": [
                            66
                        ],
                        "f": [
                            73,
                            67,
                            71
                        ],
                        "fh": [
                            74,
                            67
                        ],
                        "get_handle": [
                            67
                        ],
                        "compression": [
                            67
                        ],
                        "protocol": [
                            68,
                            69,
                            71
                        ],
                        "f.write": [
                            71
                        ],
                        "pickle.dumps": [
                            71
                        ],
                        "obj": [
                            71
                        ],
                        "f.close": [
                            73
                        ],
                        "_f": [
                            74,
                            75
                        ],
                        "_f.close": [
                            75
                        ]
                    },
                    "diff_line_number": 10,
                    "class_data": null,
                    "variable_values": [
                        [
                            {
                                "pickle.HIGHEST_PROTOCOL": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pickle": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "path": {
                                    "variable_value": "<_io.BufferedWriter name='/var/folders/ng/72llsm517x12c2p18htksyjc0000gn/T/tmpr4hld51x'>",
                                    "variable_type": "BufferedWriter",
                                    "variable_shape": null
                                },
                                "stringify_path": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "f": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "fh": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "get_handle": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "compression": {
                                    "variable_value": "'infer'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "protocol": {
                                    "variable_value": "5",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "f.write": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pickle.dumps": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "obj": {
                                    "variable_value": "                   A         B         C         D\njuurO48xkI -1.707594  0.769704 -1.127769  1.141689\nO0xQhJtIVz -0.196223  1.237601  0.367308  0.543181\nJWlUomoQA9 -1.057260  0.191522  0.430592 -0.160917\nmPWadc4DtO  3.723799 -0.081209  0.637478  1.114557\n2O6s122si8 -0.087817 -0.391645  1.036857 -1.789042\nS010WanxT6  0.813566  0.453727  0.598899  0.060722\nNefzX7K3oF -0.127774  0.010185 -0.698065  0.822412\nq1Nzige1da  1.869332 -1.445350  0.973149  0.789358\nQW6gcJg386  0.504029 -0.012278 -0.871391  0.763476\nGmBiD5EGzU  0.101874  1.915929  0.210654  0.590216\njzwwqoJwB1 -0.842055 -0.734631  0.687561 -0.887297\nl4n1ttqgTX  0.953795  1.335328  0.515355  0.690543\nitTz8VFtk6  0.512220  0.460276  1.393643 -1.905659\nRkNUlg7af5 -0.370335 -0.990403 -1.596465 -2.462891\nKOAn9XN2oP  0.579416  0.698595  0.408189  0.790578\nqGNpRiSWwn -0.519742  0.008725  0.997459  0.572148\npim1SFbHfW  0.856067 -0.811959  1.388772 -0.045439\nWUN0xbCBBR  0.168637  1.665157 -1.868711  1.217582\nIsbCdqbvaW -2.234329 -1.055174 -1.650457  0.846792\nFI461r28Do -1.063230 -0.251686 -0.643881  0.131817\nNnf0fIAWZm -0.416261  1.198323 -0.729552  0.558608\nywZUaihOdq -1.720500 -3.283334  1.263696  0.164130\n6Kz2ybhoWV -0.739970  0.353917 -0.242845 -0.402174\nPVQDNOyvfo -0.258701  0.789463  0.671237  1.083040\nMpU627ijtx -1.010599  1.002996 -0.305864 -0.253332\ndpW1fdwvoe  0.957082  1.689099 -1.570508 -0.644561\nOPomMBDO5P -0.530981  1.182358  0.163832  0.338394\nDLdXBhBv0J  2.052911 -0.195024 -0.183402  0.894058\nOASVI3ceUn -0.351773 -0.425312 -0.163828  1.574590\nRhdRpxMTSS -1.516184 -0.061393 -0.648575  0.781595",
                                    "variable_type": "DataFrame",
                                    "variable_shape": "30"
                                },
                                "f.close": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_f": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_f.close": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "Any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "FilePathOrBuffer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Optional": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pickle.HIGHEST_PROTOCOL": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pickle": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "fp_or_buf": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "compression": {
                                    "variable_value": "'infer'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "should_close": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "get_filepath_or_buffer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "filepath_or_buffer": {
                                    "variable_value": "<_io.BufferedWriter name='/var/folders/ng/72llsm517x12c2p18htksyjc0000gn/T/tmphzbwc8u1'>",
                                    "variable_type": "BufferedWriter",
                                    "variable_shape": null
                                },
                                "f": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "fh": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "get_handle": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "protocol": {
                                    "variable_value": "5",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "f.write": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pickle.dumps": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "obj": {
                                    "variable_value": "                   A         B         C         D\n3bmfswTuf2 -0.237510  2.567635  0.144333  1.785127\n0q8kDUuhb7  1.976023  0.255611  2.089563 -0.078391\ni3reIhIHvj  1.650744 -0.455562 -0.691082 -1.257219\nirafbyrbCM -2.254249  1.372351 -0.127592  1.329497\nxncpoLZHbU  0.582700 -0.263857 -0.187674 -1.403623\ncT5IOarHtb  1.065733 -2.488238  0.884640  1.451771\nmZfysAFfCS -0.630868  1.989787 -1.839628 -0.124871\n9DxyCQB3Xt  0.793009 -1.600411 -0.923829  2.155032\nHfrirghNsM -0.926767 -0.141857 -0.774909  1.471171\nVpCiUthLRB  0.583982 -0.556961 -1.421816  0.558038\nwjlJbpa3KB -0.427046 -1.652670 -1.548465 -2.839367\n3Gbbk0awd0 -0.533619  1.225433  0.464822  0.009100\nSt9oR4OxCF -0.405614  0.365366  1.314474  2.625133\nge73ew993s  0.283583  0.281614  1.252583  1.438489\nG6Nqr50MyW -1.860429 -1.500704 -1.027499 -0.736397\nJ7KY38KdDc -0.012154 -1.243803 -0.887642  0.392657\nvBO27ZRncH -0.715093  0.470300 -3.181112  0.851934\nsiduYd9HNc  0.801132 -1.084743 -0.499665 -0.190659\nHisMAaQ0P8 -0.582150 -0.555224  1.968721 -0.467217\nB1CD2WoxQT  1.132535 -0.091060 -0.522866 -0.988450\ncYxhFdTzrt -0.485158 -0.521648 -0.260140 -0.118030\nBU3PFh64Ze -0.293768  0.020291  0.379913 -0.872722\n5nk92UYSTb -2.680181  1.076052 -0.588668  0.538073\nqdSz2j744x -1.108666  1.720423  1.379153  0.022503\nGcBpqV70wZ  1.121741  1.767812  0.167734  0.906828\nnFlCihPDnQ  0.076980 -0.799134  0.989084  0.117688\ngt931EIzm9  2.345893 -0.763720  0.786007 -0.149498\nqsO9TAMHyh  0.432054  0.024222 -0.410567  0.139938\n1HNOWMs17W -0.128735  1.164150 -0.519012  0.198534\nEc47MBK7hk -1.552013  0.757950 -0.499626 -0.927125",
                                    "variable_type": "DataFrame",
                                    "variable_shape": "30"
                                },
                                "f.close": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_f": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_f.close": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "fp_or_buf.close": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "Any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "FilePathOrBuffer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Optional": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pickle.HIGHEST_PROTOCOL": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pickle": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "fp_or_buf": {
                                    "variable_value": "<_io.BufferedWriter name='/var/folders/ng/72llsm517x12c2p18htksyjc0000gn/T/tmphzbwc8u1'>",
                                    "variable_type": "BufferedWriter",
                                    "variable_shape": null
                                },
                                "_": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "compression": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "should_close": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "get_filepath_or_buffer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "filepath_or_buffer": {
                                    "variable_value": "<_io.BufferedWriter name='/var/folders/ng/72llsm517x12c2p18htksyjc0000gn/T/tmphzbwc8u1'>",
                                    "variable_type": "BufferedWriter",
                                    "variable_shape": null
                                },
                                "f": {
                                    "variable_value": "<_io.BufferedWriter name='/var/folders/ng/72llsm517x12c2p18htksyjc0000gn/T/tmphzbwc8u1'>",
                                    "variable_type": "BufferedWriter",
                                    "variable_shape": null
                                },
                                "fh": {
                                    "variable_value": "[]",
                                    "variable_type": "list",
                                    "variable_shape": "0"
                                },
                                "get_handle": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "protocol": {
                                    "variable_value": "5",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "f.write": {
                                    "variable_value": "<built-in method write of _io.BufferedWriter object at 0x11fcf2670>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "pickle.dumps": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "obj": {
                                    "variable_value": "                   A         B         C         D\n3bmfswTuf2 -0.237510  2.567635  0.144333  1.785127\n0q8kDUuhb7  1.976023  0.255611  2.089563 -0.078391\ni3reIhIHvj  1.650744 -0.455562 -0.691082 -1.257219\nirafbyrbCM -2.254249  1.372351 -0.127592  1.329497\nxncpoLZHbU  0.582700 -0.263857 -0.187674 -1.403623\ncT5IOarHtb  1.065733 -2.488238  0.884640  1.451771\nmZfysAFfCS -0.630868  1.989787 -1.839628 -0.124871\n9DxyCQB3Xt  0.793009 -1.600411 -0.923829  2.155032\nHfrirghNsM -0.926767 -0.141857 -0.774909  1.471171\nVpCiUthLRB  0.583982 -0.556961 -1.421816  0.558038\nwjlJbpa3KB -0.427046 -1.652670 -1.548465 -2.839367\n3Gbbk0awd0 -0.533619  1.225433  0.464822  0.009100\nSt9oR4OxCF -0.405614  0.365366  1.314474  2.625133\nge73ew993s  0.283583  0.281614  1.252583  1.438489\nG6Nqr50MyW -1.860429 -1.500704 -1.027499 -0.736397\nJ7KY38KdDc -0.012154 -1.243803 -0.887642  0.392657\nvBO27ZRncH -0.715093  0.470300 -3.181112  0.851934\nsiduYd9HNc  0.801132 -1.084743 -0.499665 -0.190659\nHisMAaQ0P8 -0.582150 -0.555224  1.968721 -0.467217\nB1CD2WoxQT  1.132535 -0.091060 -0.522866 -0.988450\ncYxhFdTzrt -0.485158 -0.521648 -0.260140 -0.118030\nBU3PFh64Ze -0.293768  0.020291  0.379913 -0.872722\n5nk92UYSTb -2.680181  1.076052 -0.588668  0.538073\nqdSz2j744x -1.108666  1.720423  1.379153  0.022503\nGcBpqV70wZ  1.121741  1.767812  0.167734  0.906828\nnFlCihPDnQ  0.076980 -0.799134  0.989084  0.117688\ngt931EIzm9  2.345893 -0.763720  0.786007 -0.149498\nqsO9TAMHyh  0.432054  0.024222 -0.410567  0.139938\n1HNOWMs17W -0.128735  1.164150 -0.519012  0.198534\nEc47MBK7hk -1.552013  0.757950 -0.499626 -0.927125",
                                    "variable_type": "DataFrame",
                                    "variable_shape": "30"
                                },
                                "f.close": {
                                    "variable_value": "<built-in method close of _io.BufferedWriter object at 0x11fcf2670>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "_f": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_f.close": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "fp_or_buf.close": {
                                    "variable_value": "<built-in method close of _io.BufferedWriter object at 0x11fcf2670>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                },
                {
                    "function_name": "read_pickle",
                    "function_code": "def read_pickle(path, compression=\"infer\"):\n    \"\"\"\n    Load pickled pandas object (or any object) from file.\n\n    .. warning::\n\n       Loading pickled data received from untrusted sources can be\n       unsafe. See `here <https://docs.python.org/3/library/pickle.html>`__.\n\n    Parameters\n    ----------\n    path : str\n        File path where the pickled object will be loaded.\n    compression : {'infer', 'gzip', 'bz2', 'zip', 'xz', None}, default 'infer'\n        For on-the-fly decompression of on-disk data. If 'infer', then use\n        gzip, bz2, xz or zip if path ends in '.gz', '.bz2', '.xz',\n        or '.zip' respectively, and no decompression otherwise.\n        Set to None for no decompression.\n\n    Returns\n    -------\n    unpickled : same type as object stored in file\n\n    See Also\n    --------\n    DataFrame.to_pickle : Pickle (serialize) DataFrame object to file.\n    Series.to_pickle : Pickle (serialize) Series object to file.\n    read_hdf : Read HDF5 file into a DataFrame.\n    read_sql : Read SQL query or database table into a DataFrame.\n    read_parquet : Load a parquet object, returning a DataFrame.\n\n    Notes\n    -----\n    read_pickle is only guaranteed to be backwards compatible to pandas 0.20.3.\n\n    Examples\n    --------\n    >>> original_df = pd.DataFrame({\"foo\": range(5), \"bar\": range(5, 10)})\n    >>> original_df\n       foo  bar\n    0    0    5\n    1    1    6\n    2    2    7\n    3    3    8\n    4    4    9\n    >>> pd.to_pickle(original_df, \"./dummy.pkl\")\n\n    >>> unpickled_df = pd.read_pickle(\"./dummy.pkl\")\n    >>> unpickled_df\n       foo  bar\n    0    0    5\n    1    1    6\n    2    2    7\n    3    3    8\n    4    4    9\n\n    >>> import os\n    >>> os.remove(\"./dummy.pkl\")\n    \"\"\"\n    path = stringify_path(path)\n    f, fh = get_handle(path, \"rb\", compression=compression, is_text=False)\n\n    # 1) try standard library Pickle\n    # 2) try pickle_compat (older pandas version) to handle subclass changes\n\n    excs_to_catch = (AttributeError, ImportError, ModuleNotFoundError)\n\n    try:\n        with warnings.catch_warnings(record=True):\n            # We want to silence any warnings about, e.g. moved modules.\n            warnings.simplefilter(\"ignore\", Warning)\n            return pickle.load(f)\n    except excs_to_catch:\n        # e.g.\n        #  \"No module named 'pandas.core.sparse.series'\"\n        #  \"Can't get attribute '__nat_unpickle' on <module 'pandas._libs.tslib\"\n        return pc.load(f, encoding=None)\n    except UnicodeDecodeError:\n        # e.g. can occur for files written in py27; see GH#28645\n        return pc.load(f, encoding=\"latin-1\")\n    finally:\n        f.close()\n        for _f in fh:\n            _f.close()\n",
                    "decorators": [],
                    "docstring": "Load pickled pandas object (or any object) from file.\n\n.. warning::\n\n   Loading pickled data received from untrusted sources can be\n   unsafe. See `here <https://docs.python.org/3/library/pickle.html>`__.\n\nParameters\n----------\npath : str\n    File path where the pickled object will be loaded.\ncompression : {'infer', 'gzip', 'bz2', 'zip', 'xz', None}, default 'infer'\n    For on-the-fly decompression of on-disk data. If 'infer', then use\n    gzip, bz2, xz or zip if path ends in '.gz', '.bz2', '.xz',\n    or '.zip' respectively, and no decompression otherwise.\n    Set to None for no decompression.\n\nReturns\n-------\nunpickled : same type as object stored in file\n\nSee Also\n--------\nDataFrame.to_pickle : Pickle (serialize) DataFrame object to file.\nSeries.to_pickle : Pickle (serialize) Series object to file.\nread_hdf : Read HDF5 file into a DataFrame.\nread_sql : Read SQL query or database table into a DataFrame.\nread_parquet : Load a parquet object, returning a DataFrame.\n\nNotes\n-----\nread_pickle is only guaranteed to be backwards compatible to pandas 0.20.3.\n\nExamples\n--------\n>>> original_df = pd.DataFrame({\"foo\": range(5), \"bar\": range(5, 10)})\n>>> original_df\n   foo  bar\n0    0    5\n1    1    6\n2    2    7\n3    3    8\n4    4    9\n>>> pd.to_pickle(original_df, \"./dummy.pkl\")\n\n>>> unpickled_df = pd.read_pickle(\"./dummy.pkl\")\n>>> unpickled_df\n   foo  bar\n0    0    5\n1    1    6\n2    2    7\n3    3    8\n4    4    9\n\n>>> import os\n>>> os.remove(\"./dummy.pkl\")",
                    "start_line": 78,
                    "variables": {
                        "path": [
                            137,
                            138
                        ],
                        "stringify_path": [
                            137
                        ],
                        "f": [
                            138,
                            149,
                            154,
                            157,
                            159
                        ],
                        "fh": [
                            160,
                            138
                        ],
                        "get_handle": [
                            138
                        ],
                        "compression": [
                            138
                        ],
                        "excs_to_catch": [
                            150,
                            143
                        ],
                        "AttributeError": [
                            143
                        ],
                        "ImportError": [
                            143
                        ],
                        "ModuleNotFoundError": [
                            143
                        ],
                        "warnings.catch_warnings": [
                            146
                        ],
                        "warnings": [
                            146,
                            148
                        ],
                        "warnings.simplefilter": [
                            148
                        ],
                        "Warning": [
                            148
                        ],
                        "pickle.load": [
                            149
                        ],
                        "pickle": [
                            149
                        ],
                        "pc.load": [
                            154,
                            157
                        ],
                        "pc": [
                            154,
                            157
                        ],
                        "UnicodeDecodeError": [
                            155
                        ],
                        "f.close": [
                            159
                        ],
                        "_f": [
                            160,
                            161
                        ],
                        "_f.close": [
                            161
                        ]
                    },
                    "filtered_variables": {
                        "path": [
                            137,
                            138
                        ],
                        "stringify_path": [
                            137
                        ],
                        "f": [
                            138,
                            149,
                            154,
                            157,
                            159
                        ],
                        "fh": [
                            160,
                            138
                        ],
                        "get_handle": [
                            138
                        ],
                        "compression": [
                            138
                        ],
                        "excs_to_catch": [
                            150,
                            143
                        ],
                        "warnings.catch_warnings": [
                            146
                        ],
                        "warnings": [
                            146,
                            148
                        ],
                        "warnings.simplefilter": [
                            148
                        ],
                        "pickle.load": [
                            149
                        ],
                        "pickle": [
                            149
                        ],
                        "pc.load": [
                            154,
                            157
                        ],
                        "pc": [
                            154,
                            157
                        ],
                        "f.close": [
                            159
                        ],
                        "_f": [
                            160,
                            161
                        ],
                        "_f.close": [
                            161
                        ]
                    },
                    "diff_line_number": 78,
                    "class_data": null,
                    "variable_values": [
                        [
                            {
                                "path": {
                                    "variable_value": "'http://gzip.com'",
                                    "variable_type": "str",
                                    "variable_shape": "15"
                                },
                                "stringify_path": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "f": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "fh": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "get_handle": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "compression": {
                                    "variable_value": "'infer'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "excs_to_catch": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "warnings.catch_warnings": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "warnings": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "warnings.simplefilter": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pickle.load": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pickle": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pc.load": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "f.close": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_f": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_f.close": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "FilePathOrBuffer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Optional": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "fp_or_buf": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "compression": {
                                    "variable_value": "'infer'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "should_close": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "get_filepath_or_buffer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "filepath_or_buffer": {
                                    "variable_value": "'http://gzip.com'",
                                    "variable_type": "str",
                                    "variable_shape": "15"
                                },
                                "f": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "fh": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "get_handle": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "excs_to_catch": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "warnings.catch_warnings": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "warnings": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "warnings.simplefilter": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pickle.load": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pickle": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pc.load": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "f.close": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_f": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_f.close": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "fp_or_buf.close": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {}
                        ]
                    ]
                }
            ],
            "snippets": [
                {
                    "snippet_code": "import pickle\nimport warnings\n\nfrom pandas.compat import pickle_compat as pc\n\nfrom pandas.io.common import get_handle, stringify_path",
                    "start_line": 2,
                    "end_line": 8
                }
            ],
            "inscope_functions": [
                "def to_pickle(obj, path, compression=\"infer\", protocol=pickle.HIGHEST_PROTOCOL):\n    \"\"\"\n    Pickle (serialize) object to file.\n\n    Parameters\n    ----------\n    obj : any object\n        Any python object.\n    path : str\n        File path where the pickled object will be stored.\n    compression : {'infer', 'gzip', 'bz2', 'zip', 'xz', None}, default 'infer'\n        A string representing the compression to use in the output file. By\n        default, infers from the file extension in specified path.\n    protocol : int\n        Int which indicates which protocol should be used by the pickler,\n        default HIGHEST_PROTOCOL (see [1], paragraph 12.1.2). The possible\n        values for this parameter depend on the version of Python. For Python\n        2.x, possible values are 0, 1, 2. For Python>=3.0, 3 is a valid value.\n        For Python >= 3.4, 4 is a valid value. A negative value for the\n        protocol parameter is equivalent to setting its value to\n        HIGHEST_PROTOCOL.\n\n        .. [1] https://docs.python.org/3/library/pickle.html\n        .. versionadded:: 0.21.0\n\n    See Also\n    --------\n    read_pickle : Load pickled pandas object (or any object) from file.\n    DataFrame.to_hdf : Write DataFrame to an HDF5 file.\n    DataFrame.to_sql : Write DataFrame to a SQL database.\n    DataFrame.to_parquet : Write a DataFrame to the binary parquet format.\n\n    Examples\n    --------\n    >>> original_df = pd.DataFrame({\"foo\": range(5), \"bar\": range(5, 10)})\n    >>> original_df\n       foo  bar\n    0    0    5\n    1    1    6\n    2    2    7\n    3    3    8\n    4    4    9\n    >>> pd.to_pickle(original_df, \"./dummy.pkl\")\n\n    >>> unpickled_df = pd.read_pickle(\"./dummy.pkl\")\n    >>> unpickled_df\n       foo  bar\n    0    0    5\n    1    1    6\n    2    2    7\n    3    3    8\n    4    4    9\n\n    >>> import os\n    >>> os.remove(\"./dummy.pkl\")\n    \"\"\"\n    path = stringify_path(path)\n    f, fh = get_handle(path, \"wb\", compression=compression, is_text=False)\n    if protocol < 0:\n        protocol = pickle.HIGHEST_PROTOCOL\n    try:\n        f.write(pickle.dumps(obj, protocol=protocol))\n    finally:\n        f.close()\n        for _f in fh:\n            _f.close()",
                "def read_pickle(path, compression=\"infer\"):\n    \"\"\"\n    Load pickled pandas object (or any object) from file.\n\n    .. warning::\n\n       Loading pickled data received from untrusted sources can be\n       unsafe. See `here <https://docs.python.org/3/library/pickle.html>`__.\n\n    Parameters\n    ----------\n    path : str\n        File path where the pickled object will be loaded.\n    compression : {'infer', 'gzip', 'bz2', 'zip', 'xz', None}, default 'infer'\n        For on-the-fly decompression of on-disk data. If 'infer', then use\n        gzip, bz2, xz or zip if path ends in '.gz', '.bz2', '.xz',\n        or '.zip' respectively, and no decompression otherwise.\n        Set to None for no decompression.\n\n    Returns\n    -------\n    unpickled : same type as object stored in file\n\n    See Also\n    --------\n    DataFrame.to_pickle : Pickle (serialize) DataFrame object to file.\n    Series.to_pickle : Pickle (serialize) Series object to file.\n    read_hdf : Read HDF5 file into a DataFrame.\n    read_sql : Read SQL query or database table into a DataFrame.\n    read_parquet : Load a parquet object, returning a DataFrame.\n\n    Notes\n    -----\n    read_pickle is only guaranteed to be backwards compatible to pandas 0.20.3.\n\n    Examples\n    --------\n    >>> original_df = pd.DataFrame({\"foo\": range(5), \"bar\": range(5, 10)})\n    >>> original_df\n       foo  bar\n    0    0    5\n    1    1    6\n    2    2    7\n    3    3    8\n    4    4    9\n    >>> pd.to_pickle(original_df, \"./dummy.pkl\")\n\n    >>> unpickled_df = pd.read_pickle(\"./dummy.pkl\")\n    >>> unpickled_df\n       foo  bar\n    0    0    5\n    1    1    6\n    2    2    7\n    3    3    8\n    4    4    9\n\n    >>> import os\n    >>> os.remove(\"./dummy.pkl\")\n    \"\"\"\n    path = stringify_path(path)\n    f, fh = get_handle(path, \"rb\", compression=compression, is_text=False)\n\n    # 1) try standard library Pickle\n    # 2) try pickle_compat (older pandas version) to handle subclass changes\n\n    excs_to_catch = (AttributeError, ImportError, ModuleNotFoundError)\n\n    try:\n        with warnings.catch_warnings(record=True):\n            # We want to silence any warnings about, e.g. moved modules.\n            warnings.simplefilter(\"ignore\", Warning)\n            return pickle.load(f)\n    except excs_to_catch:\n        # e.g.\n        #  \"No module named 'pandas.core.sparse.series'\"\n        #  \"Can't get attribute '__nat_unpickle' on <module 'pandas._libs.tslib\"\n        return pc.load(f, encoding=None)\n    except UnicodeDecodeError:\n        # e.g. can occur for files written in py27; see GH#28645\n        return pc.load(f, encoding=\"latin-1\")\n    finally:\n        f.close()\n        for _f in fh:\n            _f.close()"
            ],
            "inscope_function_signatures": [
                "to_pickle(obj, path, compression='infer', protocol=pickle.HIGHEST_PROTOCOL)",
                "read_pickle(path, compression='infer')"
            ],
            "variables_in_file": {
                "pickle.HIGHEST_PROTOCOL": [
                    10,
                    69
                ],
                "pickle": [
                    10,
                    69,
                    149,
                    71
                ],
                "path": [
                    137,
                    66,
                    67,
                    138
                ],
                "stringify_path": [
                    137,
                    66
                ],
                "f": [
                    67,
                    71,
                    73,
                    138,
                    149,
                    154,
                    157,
                    159
                ],
                "fh": [
                    160,
                    74,
                    67,
                    138
                ],
                "get_handle": [
                    138,
                    67
                ],
                "compression": [
                    138,
                    67
                ],
                "protocol": [
                    68,
                    69,
                    71
                ],
                "f.write": [
                    71
                ],
                "pickle.dumps": [
                    71
                ],
                "obj": [
                    71
                ],
                "f.close": [
                    73,
                    159
                ],
                "_f": [
                    160,
                    161,
                    74,
                    75
                ],
                "_f.close": [
                    161,
                    75
                ],
                "excs_to_catch": [
                    150,
                    143
                ],
                "AttributeError": [
                    143
                ],
                "ImportError": [
                    143
                ],
                "ModuleNotFoundError": [
                    143
                ],
                "warnings.catch_warnings": [
                    146
                ],
                "warnings": [
                    146,
                    148
                ],
                "warnings.simplefilter": [
                    148
                ],
                "Warning": [
                    148
                ],
                "pickle.load": [
                    149
                ],
                "pc.load": [
                    154,
                    157
                ],
                "pc": [
                    154,
                    157
                ],
                "UnicodeDecodeError": [
                    155
                ]
            },
            "filtered_variables_in_file": {
                "pickle.HIGHEST_PROTOCOL": [
                    10,
                    69
                ],
                "pickle": [
                    10,
                    69,
                    149,
                    71
                ],
                "path": [
                    137,
                    66,
                    67,
                    138
                ],
                "stringify_path": [
                    137,
                    66
                ],
                "f": [
                    67,
                    71,
                    73,
                    138,
                    149,
                    154,
                    157,
                    159
                ],
                "fh": [
                    160,
                    74,
                    67,
                    138
                ],
                "get_handle": [
                    138,
                    67
                ],
                "compression": [
                    138,
                    67
                ],
                "protocol": [
                    68,
                    69,
                    71
                ],
                "f.write": [
                    71
                ],
                "pickle.dumps": [
                    71
                ],
                "obj": [
                    71
                ],
                "f.close": [
                    73,
                    159
                ],
                "_f": [
                    160,
                    161,
                    74,
                    75
                ],
                "_f.close": [
                    161,
                    75
                ],
                "excs_to_catch": [
                    150,
                    143
                ],
                "warnings.catch_warnings": [
                    146
                ],
                "warnings": [
                    146,
                    148
                ],
                "warnings.simplefilter": [
                    148
                ],
                "pickle.load": [
                    149
                ],
                "pc.load": [
                    154,
                    157
                ],
                "pc": [
                    154,
                    157
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_90/pandas/tests/io/test_pickle.py",
                "test_function": "test_pickle_buffer_roundtrip",
                "test_function_code": "def test_pickle_buffer_roundtrip():\n    with tm.ensure_clean() as path:\n        df = tm.makeDataFrame()\n        with open(path, \"wb\") as fh:\n            df.to_pickle(fh)\n        with open(path, \"rb\") as fh:\n            result = pd.read_pickle(fh)\n        tm.assert_frame_equal(df, result)",
                "test_error": "ValueError: Unrecognized compression type: infer",
                "full_test_error": "def test_pickle_buffer_roundtrip():\n        with tm.ensure_clean() as path:\n            df = tm.makeDataFrame()\n            with open(path, \"wb\") as fh:\n>               df.to_pickle(fh)\n\npandas/tests/io/test_pickle.py:405: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:2702: in to_pickle\n    to_pickle(self, path, compression=compression, protocol=protocol)\npandas/io/pickle.py:67: in to_pickle\n    f, fh = get_handle(path, \"wb\", compression=compression, is_text=False)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath_or_buf = <_io.BufferedWriter name='/var/folders/ng/72llsm517x12c2p18htksyjc0000gn/T/tmpg548husw'>\nmode = 'wb', encoding = None, compression = 'infer', memory_map = False\nis_text = False\n\n    def get_handle(\n        path_or_buf,\n        mode: str,\n        encoding=None,\n        compression: Optional[Union[str, Mapping[str, Any]]] = None,\n        memory_map: bool = False,\n        is_text: bool = True,\n    ):\n        \"\"\"\n        Get file handle for given path/buffer and mode.\n    \n        Parameters\n        ----------\n        path_or_buf : str or file handle\n            File path or object.\n        mode : str\n            Mode to open path_or_buf with.\n        encoding : str or None\n            Encoding to use.\n        compression : str or dict, default None\n            If string, specifies compression mode. If dict, value at key 'method'\n            specifies compression mode. Compression mode must be one of {'infer',\n            'gzip', 'bz2', 'zip', 'xz', None}. If compression mode is 'infer'\n            and `filepath_or_buffer` is path-like, then detect compression from\n            the following extensions: '.gz', '.bz2', '.zip', or '.xz' (otherwise\n            no compression). If dict and compression mode is 'zip' or inferred as\n            'zip', other entries passed as additional compression options.\n    \n            .. versionchanged:: 1.0.0\n    \n               May now be a dict with key 'method' as compression mode\n               and other keys as compression options if compression\n               mode is 'zip'.\n    \n        memory_map : boolean, default False\n            See parsers._parser_params for more information.\n        is_text : boolean, default True\n            whether file/buffer is in text format (csv, json, etc.), or in binary\n            mode (pickle, etc.).\n    \n        Returns\n        -------\n        f : file-like\n            A file-like object.\n        handles : list of file-like objects\n            A list of file-like object that were opened in this function.\n        \"\"\"\n        try:\n            from s3fs import S3File\n    \n            need_text_wrapping = (BufferedIOBase, S3File)\n        except ImportError:\n            need_text_wrapping = BufferedIOBase  # type: ignore\n    \n        handles: List[IO] = list()\n        f = path_or_buf\n    \n        # Convert pathlib.Path/py.path.local or string\n        path_or_buf = stringify_path(path_or_buf)\n        is_path = isinstance(path_or_buf, str)\n    \n        compression, compression_args = get_compression_method(compression)\n        if is_path:\n            compression = infer_compression(path_or_buf, compression)\n    \n        if compression:\n    \n            # GZ Compression\n            if compression == \"gzip\":\n                if is_path:\n                    f = gzip.open(path_or_buf, mode)\n                else:\n                    f = gzip.GzipFile(fileobj=path_or_buf)\n    \n            # BZ Compression\n            elif compression == \"bz2\":\n                if is_path:\n                    f = bz2.BZ2File(path_or_buf, mode)\n                else:\n                    f = bz2.BZ2File(path_or_buf)\n    \n            # ZIP Compression\n            elif compression == \"zip\":\n                zf = _BytesZipFile(path_or_buf, mode, **compression_args)\n                # Ensure the container is closed as well.\n                handles.append(zf)\n                if zf.mode == \"w\":\n                    f = zf\n                elif zf.mode == \"r\":\n                    zip_names = zf.namelist()\n                    if len(zip_names) == 1:\n                        f = zf.open(zip_names.pop())\n                    elif len(zip_names) == 0:\n                        raise ValueError(f\"Zero files found in ZIP file {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in ZIP file.\"\n                            f\" Only one file per ZIP: {zip_names}\"\n                        )\n    \n            # XZ Compression\n            elif compression == \"xz\":\n                f = _get_lzma_file(lzma)(path_or_buf, mode)\n    \n            # Unrecognized Compression\n            else:\n                msg = f\"Unrecognized compression type: {compression}\"\n>               raise ValueError(msg)\nE               ValueError: Unrecognized compression type: infer\n\npandas/io/common.py:421: ValueError",
                "traceback": "pandas/core/generic.py:2702: in to_pickle\n    to_pickle(self, path, compression=compression, protocol=protocol)\npandas/io/pickle.py:67: in to_pickle\n    f, fh = get_handle(path, \"wb\", compression=compression, is_text=False)",
                "test_error_location": "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath_or_buf = <_io.BufferedWriter name='/var/folders/ng/72llsm517x12c2p18htksyjc0000gn/T/tmpg548husw'>\nmode = 'wb', encoding = None, compression = 'infer', memory_map = False\nis_text = False\n\n    def get_handle(\n        path_or_buf,\n        mode: str,\n        encoding=None,\n        compression: Optional[Union[str, Mapping[str, Any]]] = None,\n        memory_map: bool = False,\n        is_text: bool = True,\n    ):\n        \"\"\"\n        Get file handle for given path/buffer and mode.\n    \n        Parameters\n        ----------\n        path_or_buf : str or file handle\n            File path or object.\n        mode : str\n            Mode to open path_or_buf with.\n        encoding : str or None\n            Encoding to use.\n        compression : str or dict, default None\n            If string, specifies compression mode. If dict, value at key 'method'\n            specifies compression mode. Compression mode must be one of {'infer',\n            'gzip', 'bz2', 'zip', 'xz', None}. If compression mode is 'infer'\n            and `filepath_or_buffer` is path-like, then detect compression from\n            the following extensions: '.gz', '.bz2', '.zip', or '.xz' (otherwise\n            no compression). If dict and compression mode is 'zip' or inferred as\n            'zip', other entries passed as additional compression options.\n    \n            .. versionchanged:: 1.0.0\n    \n               May now be a dict with key 'method' as compression mode\n               and other keys as compression options if compression\n               mode is 'zip'.\n    \n        memory_map : boolean, default False\n            See parsers._parser_params for more information.\n        is_text : boolean, default True\n            whether file/buffer is in text format (csv, json, etc.), or in binary\n            mode (pickle, etc.).\n    \n        Returns\n        -------\n        f : file-like\n            A file-like object.\n        handles : list of file-like objects\n            A list of file-like object that were opened in this function.\n        \"\"\"\n        try:\n            from s3fs import S3File\n    \n            need_text_wrapping = (BufferedIOBase, S3File)\n        except ImportError:\n            need_text_wrapping = BufferedIOBase  # type: ignore\n    \n        handles: List[IO] = list()\n        f = path_or_buf\n    \n        # Convert pathlib.Path/py.path.local or string\n        path_or_buf = stringify_path(path_or_buf)\n        is_path = isinstance(path_or_buf, str)\n    \n        compression, compression_args = get_compression_method(compression)\n        if is_path:\n            compression = infer_compression(path_or_buf, compression)\n    \n        if compression:\n    \n            # GZ Compression\n            if compression == \"gzip\":\n                if is_path:\n                    f = gzip.open(path_or_buf, mode)\n                else:\n                    f = gzip.GzipFile(fileobj=path_or_buf)\n    \n            # BZ Compression\n            elif compression == \"bz2\":\n                if is_path:\n                    f = bz2.BZ2File(path_or_buf, mode)\n                else:\n                    f = bz2.BZ2File(path_or_buf)\n    \n            # ZIP Compression\n            elif compression == \"zip\":\n                zf = _BytesZipFile(path_or_buf, mode, **compression_args)\n                # Ensure the container is closed as well.\n                handles.append(zf)\n                if zf.mode == \"w\":\n                    f = zf\n                elif zf.mode == \"r\":\n                    zip_names = zf.namelist()\n                    if len(zip_names) == 1:\n                        f = zf.open(zip_names.pop())\n                    elif len(zip_names) == 0:\n                        raise ValueError(f\"Zero files found in ZIP file {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in ZIP file.\"\n                            f\" Only one file per ZIP: {zip_names}\"\n                        )\n    \n            # XZ Compression\n            elif compression == \"xz\":\n                f = _get_lzma_file(lzma)(path_or_buf, mode)\n    \n            # Unrecognized Compression\n            else:\n                msg = f\"Unrecognized compression type: {compression}\"\n>               raise ValueError(msg)\nE               ValueError: Unrecognized compression type: infer\n\npandas/io/common.py:421: ValueError",
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_90/pandas/tests/io/test_pickle.py",
                "test_function": "test_pickle_generalurl_read",
                "test_function_code": "@pytest.mark.parametrize(\n    \"mockurl\", [\"http://url.com\", \"ftp://test.com\", \"http://gzip.com\"]\n)\ndef test_pickle_generalurl_read(monkeypatch, mockurl):\n    def python_pickler(obj, path):\n        with open(path, \"wb\") as fh:\n            pickle.dump(obj, fh, protocol=-1)\n\n    class MockReadResponse:\n        def __init__(self, path):\n            self.file = open(path, \"rb\")\n            if \"gzip\" in path:\n                self.headers = {\"Content-Encoding\": \"gzip\"}\n            else:\n                self.headers = {\"Content-Encoding\": None}\n\n        def read(self):\n            return self.file.read()\n\n        def close(self):\n            return self.file.close()\n\n    with tm.ensure_clean() as path:\n\n        def mock_urlopen_read(*args, **kwargs):\n            return MockReadResponse(path)\n\n        df = tm.makeDataFrame()\n        python_pickler(df, path)\n        monkeypatch.setattr(\"urllib.request.urlopen\", mock_urlopen_read)\n        result = pd.read_pickle(mockurl)\n        tm.assert_frame_equal(df, result)",
                "test_error": "FileNotFoundError: [Errno 2] No such file or directory: 'http://url.com'",
                "full_test_error": "monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x119462520>\nmockurl = 'http://url.com'\n\n    @pytest.mark.parametrize(\n        \"mockurl\", [\"http://url.com\", \"ftp://test.com\", \"http://gzip.com\"]\n    )\n    def test_pickle_generalurl_read(monkeypatch, mockurl):\n        def python_pickler(obj, path):\n            with open(path, \"wb\") as fh:\n                pickle.dump(obj, fh, protocol=-1)\n    \n        class MockReadResponse:\n            def __init__(self, path):\n                self.file = open(path, \"rb\")\n                if \"gzip\" in path:\n                    self.headers = {\"Content-Encoding\": \"gzip\"}\n                else:\n                    self.headers = {\"Content-Encoding\": None}\n    \n            def read(self):\n                return self.file.read()\n    \n            def close(self):\n                return self.file.close()\n    \n        with tm.ensure_clean() as path:\n    \n            def mock_urlopen_read(*args, **kwargs):\n                return MockReadResponse(path)\n    \n            df = tm.makeDataFrame()\n            python_pickler(df, path)\n            monkeypatch.setattr(\"urllib.request.urlopen\", mock_urlopen_read)\n>           result = pd.read_pickle(mockurl)\n\npandas/tests/io/test_pickle.py:446: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/io/pickle.py:138: in read_pickle\n    f, fh = get_handle(path, \"rb\", compression=compression, is_text=False)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath_or_buf = 'http://url.com', mode = 'rb', encoding = None, compression = None\nmemory_map = False, is_text = False\n\n    def get_handle(\n        path_or_buf,\n        mode: str,\n        encoding=None,\n        compression: Optional[Union[str, Mapping[str, Any]]] = None,\n        memory_map: bool = False,\n        is_text: bool = True,\n    ):\n        \"\"\"\n        Get file handle for given path/buffer and mode.\n    \n        Parameters\n        ----------\n        path_or_buf : str or file handle\n            File path or object.\n        mode : str\n            Mode to open path_or_buf with.\n        encoding : str or None\n            Encoding to use.\n        compression : str or dict, default None\n            If string, specifies compression mode. If dict, value at key 'method'\n            specifies compression mode. Compression mode must be one of {'infer',\n            'gzip', 'bz2', 'zip', 'xz', None}. If compression mode is 'infer'\n            and `filepath_or_buffer` is path-like, then detect compression from\n            the following extensions: '.gz', '.bz2', '.zip', or '.xz' (otherwise\n            no compression). If dict and compression mode is 'zip' or inferred as\n            'zip', other entries passed as additional compression options.\n    \n            .. versionchanged:: 1.0.0\n    \n               May now be a dict with key 'method' as compression mode\n               and other keys as compression options if compression\n               mode is 'zip'.\n    \n        memory_map : boolean, default False\n            See parsers._parser_params for more information.\n        is_text : boolean, default True\n            whether file/buffer is in text format (csv, json, etc.), or in binary\n            mode (pickle, etc.).\n    \n        Returns\n        -------\n        f : file-like\n            A file-like object.\n        handles : list of file-like objects\n            A list of file-like object that were opened in this function.\n        \"\"\"\n        try:\n            from s3fs import S3File\n    \n            need_text_wrapping = (BufferedIOBase, S3File)\n        except ImportError:\n            need_text_wrapping = BufferedIOBase  # type: ignore\n    \n        handles: List[IO] = list()\n        f = path_or_buf\n    \n        # Convert pathlib.Path/py.path.local or string\n        path_or_buf = stringify_path(path_or_buf)\n        is_path = isinstance(path_or_buf, str)\n    \n        compression, compression_args = get_compression_method(compression)\n        if is_path:\n            compression = infer_compression(path_or_buf, compression)\n    \n        if compression:\n    \n            # GZ Compression\n            if compression == \"gzip\":\n                if is_path:\n                    f = gzip.open(path_or_buf, mode)\n                else:\n                    f = gzip.GzipFile(fileobj=path_or_buf)\n    \n            # BZ Compression\n            elif compression == \"bz2\":\n                if is_path:\n                    f = bz2.BZ2File(path_or_buf, mode)\n                else:\n                    f = bz2.BZ2File(path_or_buf)\n    \n            # ZIP Compression\n            elif compression == \"zip\":\n                zf = _BytesZipFile(path_or_buf, mode, **compression_args)\n                # Ensure the container is closed as well.\n                handles.append(zf)\n                if zf.mode == \"w\":\n                    f = zf\n                elif zf.mode == \"r\":\n                    zip_names = zf.namelist()\n                    if len(zip_names) == 1:\n                        f = zf.open(zip_names.pop())\n                    elif len(zip_names) == 0:\n                        raise ValueError(f\"Zero files found in ZIP file {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in ZIP file.\"\n                            f\" Only one file per ZIP: {zip_names}\"\n                        )\n    \n            # XZ Compression\n            elif compression == \"xz\":\n                f = _get_lzma_file(lzma)(path_or_buf, mode)\n    \n            # Unrecognized Compression\n            else:\n                msg = f\"Unrecognized compression type: {compression}\"\n                raise ValueError(msg)\n    \n            handles.append(f)\n    \n        elif is_path:\n            if encoding:\n                # Encoding\n                f = open(path_or_buf, mode, encoding=encoding, newline=\"\")\n            elif is_text:\n                # No explicit encoding\n                f = open(path_or_buf, mode, errors=\"replace\", newline=\"\")\n            else:\n                # Binary mode\n>               f = open(path_or_buf, mode)\nE               FileNotFoundError: [Errno 2] No such file or directory: 'http://url.com'\n\npandas/io/common.py:434: FileNotFoundError",
                "traceback": "pandas/io/pickle.py:138: in read_pickle\n    f, fh = get_handle(path, \"rb\", compression=compression, is_text=False)",
                "test_error_location": "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath_or_buf = 'http://url.com', mode = 'rb', encoding = None, compression = None\nmemory_map = False, is_text = False\n\n    def get_handle(\n        path_or_buf,\n        mode: str,\n        encoding=None,\n        compression: Optional[Union[str, Mapping[str, Any]]] = None,\n        memory_map: bool = False,\n        is_text: bool = True,\n    ):\n        \"\"\"\n        Get file handle for given path/buffer and mode.\n    \n        Parameters\n        ----------\n        path_or_buf : str or file handle\n            File path or object.\n        mode : str\n            Mode to open path_or_buf with.\n        encoding : str or None\n            Encoding to use.\n        compression : str or dict, default None\n            If string, specifies compression mode. If dict, value at key 'method'\n            specifies compression mode. Compression mode must be one of {'infer',\n            'gzip', 'bz2', 'zip', 'xz', None}. If compression mode is 'infer'\n            and `filepath_or_buffer` is path-like, then detect compression from\n            the following extensions: '.gz', '.bz2', '.zip', or '.xz' (otherwise\n            no compression). If dict and compression mode is 'zip' or inferred as\n            'zip', other entries passed as additional compression options.\n    \n            .. versionchanged:: 1.0.0\n    \n               May now be a dict with key 'method' as compression mode\n               and other keys as compression options if compression\n               mode is 'zip'.\n    \n        memory_map : boolean, default False\n            See parsers._parser_params for more information.\n        is_text : boolean, default True\n            whether file/buffer is in text format (csv, json, etc.), or in binary\n            mode (pickle, etc.).\n    \n        Returns\n        -------\n        f : file-like\n            A file-like object.\n        handles : list of file-like objects\n            A list of file-like object that were opened in this function.\n        \"\"\"\n        try:\n            from s3fs import S3File\n    \n            need_text_wrapping = (BufferedIOBase, S3File)\n        except ImportError:\n            need_text_wrapping = BufferedIOBase  # type: ignore\n    \n        handles: List[IO] = list()\n        f = path_or_buf\n    \n        # Convert pathlib.Path/py.path.local or string\n        path_or_buf = stringify_path(path_or_buf)\n        is_path = isinstance(path_or_buf, str)\n    \n        compression, compression_args = get_compression_method(compression)\n        if is_path:\n            compression = infer_compression(path_or_buf, compression)\n    \n        if compression:\n    \n            # GZ Compression\n            if compression == \"gzip\":\n                if is_path:\n                    f = gzip.open(path_or_buf, mode)\n                else:\n                    f = gzip.GzipFile(fileobj=path_or_buf)\n    \n            # BZ Compression\n            elif compression == \"bz2\":\n                if is_path:\n                    f = bz2.BZ2File(path_or_buf, mode)\n                else:\n                    f = bz2.BZ2File(path_or_buf)\n    \n            # ZIP Compression\n            elif compression == \"zip\":\n                zf = _BytesZipFile(path_or_buf, mode, **compression_args)\n                # Ensure the container is closed as well.\n                handles.append(zf)\n                if zf.mode == \"w\":\n                    f = zf\n                elif zf.mode == \"r\":\n                    zip_names = zf.namelist()\n                    if len(zip_names) == 1:\n                        f = zf.open(zip_names.pop())\n                    elif len(zip_names) == 0:\n                        raise ValueError(f\"Zero files found in ZIP file {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in ZIP file.\"\n                            f\" Only one file per ZIP: {zip_names}\"\n                        )\n    \n            # XZ Compression\n            elif compression == \"xz\":\n                f = _get_lzma_file(lzma)(path_or_buf, mode)\n    \n            # Unrecognized Compression\n            else:\n                msg = f\"Unrecognized compression type: {compression}\"\n                raise ValueError(msg)\n    \n            handles.append(f)\n    \n        elif is_path:\n            if encoding:\n                # Encoding\n                f = open(path_or_buf, mode, encoding=encoding, newline=\"\")\n            elif is_text:\n                # No explicit encoding\n                f = open(path_or_buf, mode, errors=\"replace\", newline=\"\")\n            else:\n                # Binary mode\n>               f = open(path_or_buf, mode)\nE               FileNotFoundError: [Errno 2] No such file or directory: 'http://url.com'\n\npandas/io/common.py:434: FileNotFoundError",
                "test_function_decorators": [
                    "pytest.mark.parametrize('mockurl', ['http://url.com', 'ftp://test.com', 'http://gzip.com'])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_90/pandas/tests/io/test_pickle.py",
                "test_function": "test_pickle_generalurl_read",
                "test_function_code": "@pytest.mark.parametrize(\n    \"mockurl\", [\"http://url.com\", \"ftp://test.com\", \"http://gzip.com\"]\n)\ndef test_pickle_generalurl_read(monkeypatch, mockurl):\n    def python_pickler(obj, path):\n        with open(path, \"wb\") as fh:\n            pickle.dump(obj, fh, protocol=-1)\n\n    class MockReadResponse:\n        def __init__(self, path):\n            self.file = open(path, \"rb\")\n            if \"gzip\" in path:\n                self.headers = {\"Content-Encoding\": \"gzip\"}\n            else:\n                self.headers = {\"Content-Encoding\": None}\n\n        def read(self):\n            return self.file.read()\n\n        def close(self):\n            return self.file.close()\n\n    with tm.ensure_clean() as path:\n\n        def mock_urlopen_read(*args, **kwargs):\n            return MockReadResponse(path)\n\n        df = tm.makeDataFrame()\n        python_pickler(df, path)\n        monkeypatch.setattr(\"urllib.request.urlopen\", mock_urlopen_read)\n        result = pd.read_pickle(mockurl)\n        tm.assert_frame_equal(df, result)",
                "test_error": "FileNotFoundError: [Errno 2] No such file or directory: 'ftp://test.com'",
                "full_test_error": "monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x1213dda00>\nmockurl = 'ftp://test.com'\n\n    @pytest.mark.parametrize(\n        \"mockurl\", [\"http://url.com\", \"ftp://test.com\", \"http://gzip.com\"]\n    )\n    def test_pickle_generalurl_read(monkeypatch, mockurl):\n        def python_pickler(obj, path):\n            with open(path, \"wb\") as fh:\n                pickle.dump(obj, fh, protocol=-1)\n    \n        class MockReadResponse:\n            def __init__(self, path):\n                self.file = open(path, \"rb\")\n                if \"gzip\" in path:\n                    self.headers = {\"Content-Encoding\": \"gzip\"}\n                else:\n                    self.headers = {\"Content-Encoding\": None}\n    \n            def read(self):\n                return self.file.read()\n    \n            def close(self):\n                return self.file.close()\n    \n        with tm.ensure_clean() as path:\n    \n            def mock_urlopen_read(*args, **kwargs):\n                return MockReadResponse(path)\n    \n            df = tm.makeDataFrame()\n            python_pickler(df, path)\n            monkeypatch.setattr(\"urllib.request.urlopen\", mock_urlopen_read)\n>           result = pd.read_pickle(mockurl)\n\npandas/tests/io/test_pickle.py:446: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/io/pickle.py:138: in read_pickle\n    f, fh = get_handle(path, \"rb\", compression=compression, is_text=False)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath_or_buf = 'ftp://test.com', mode = 'rb', encoding = None, compression = None\nmemory_map = False, is_text = False\n\n    def get_handle(\n        path_or_buf,\n        mode: str,\n        encoding=None,\n        compression: Optional[Union[str, Mapping[str, Any]]] = None,\n        memory_map: bool = False,\n        is_text: bool = True,\n    ):\n        \"\"\"\n        Get file handle for given path/buffer and mode.\n    \n        Parameters\n        ----------\n        path_or_buf : str or file handle\n            File path or object.\n        mode : str\n            Mode to open path_or_buf with.\n        encoding : str or None\n            Encoding to use.\n        compression : str or dict, default None\n            If string, specifies compression mode. If dict, value at key 'method'\n            specifies compression mode. Compression mode must be one of {'infer',\n            'gzip', 'bz2', 'zip', 'xz', None}. If compression mode is 'infer'\n            and `filepath_or_buffer` is path-like, then detect compression from\n            the following extensions: '.gz', '.bz2', '.zip', or '.xz' (otherwise\n            no compression). If dict and compression mode is 'zip' or inferred as\n            'zip', other entries passed as additional compression options.\n    \n            .. versionchanged:: 1.0.0\n    \n               May now be a dict with key 'method' as compression mode\n               and other keys as compression options if compression\n               mode is 'zip'.\n    \n        memory_map : boolean, default False\n            See parsers._parser_params for more information.\n        is_text : boolean, default True\n            whether file/buffer is in text format (csv, json, etc.), or in binary\n            mode (pickle, etc.).\n    \n        Returns\n        -------\n        f : file-like\n            A file-like object.\n        handles : list of file-like objects\n            A list of file-like object that were opened in this function.\n        \"\"\"\n        try:\n            from s3fs import S3File\n    \n            need_text_wrapping = (BufferedIOBase, S3File)\n        except ImportError:\n            need_text_wrapping = BufferedIOBase  # type: ignore\n    \n        handles: List[IO] = list()\n        f = path_or_buf\n    \n        # Convert pathlib.Path/py.path.local or string\n        path_or_buf = stringify_path(path_or_buf)\n        is_path = isinstance(path_or_buf, str)\n    \n        compression, compression_args = get_compression_method(compression)\n        if is_path:\n            compression = infer_compression(path_or_buf, compression)\n    \n        if compression:\n    \n            # GZ Compression\n            if compression == \"gzip\":\n                if is_path:\n                    f = gzip.open(path_or_buf, mode)\n                else:\n                    f = gzip.GzipFile(fileobj=path_or_buf)\n    \n            # BZ Compression\n            elif compression == \"bz2\":\n                if is_path:\n                    f = bz2.BZ2File(path_or_buf, mode)\n                else:\n                    f = bz2.BZ2File(path_or_buf)\n    \n            # ZIP Compression\n            elif compression == \"zip\":\n                zf = _BytesZipFile(path_or_buf, mode, **compression_args)\n                # Ensure the container is closed as well.\n                handles.append(zf)\n                if zf.mode == \"w\":\n                    f = zf\n                elif zf.mode == \"r\":\n                    zip_names = zf.namelist()\n                    if len(zip_names) == 1:\n                        f = zf.open(zip_names.pop())\n                    elif len(zip_names) == 0:\n                        raise ValueError(f\"Zero files found in ZIP file {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in ZIP file.\"\n                            f\" Only one file per ZIP: {zip_names}\"\n                        )\n    \n            # XZ Compression\n            elif compression == \"xz\":\n                f = _get_lzma_file(lzma)(path_or_buf, mode)\n    \n            # Unrecognized Compression\n            else:\n                msg = f\"Unrecognized compression type: {compression}\"\n                raise ValueError(msg)\n    \n            handles.append(f)\n    \n        elif is_path:\n            if encoding:\n                # Encoding\n                f = open(path_or_buf, mode, encoding=encoding, newline=\"\")\n            elif is_text:\n                # No explicit encoding\n                f = open(path_or_buf, mode, errors=\"replace\", newline=\"\")\n            else:\n                # Binary mode\n>               f = open(path_or_buf, mode)\nE               FileNotFoundError: [Errno 2] No such file or directory: 'ftp://test.com'\n\npandas/io/common.py:434: FileNotFoundError",
                "traceback": "pandas/io/pickle.py:138: in read_pickle\n    f, fh = get_handle(path, \"rb\", compression=compression, is_text=False)",
                "test_error_location": "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath_or_buf = 'ftp://test.com', mode = 'rb', encoding = None, compression = None\nmemory_map = False, is_text = False\n\n    def get_handle(\n        path_or_buf,\n        mode: str,\n        encoding=None,\n        compression: Optional[Union[str, Mapping[str, Any]]] = None,\n        memory_map: bool = False,\n        is_text: bool = True,\n    ):\n        \"\"\"\n        Get file handle for given path/buffer and mode.\n    \n        Parameters\n        ----------\n        path_or_buf : str or file handle\n            File path or object.\n        mode : str\n            Mode to open path_or_buf with.\n        encoding : str or None\n            Encoding to use.\n        compression : str or dict, default None\n            If string, specifies compression mode. If dict, value at key 'method'\n            specifies compression mode. Compression mode must be one of {'infer',\n            'gzip', 'bz2', 'zip', 'xz', None}. If compression mode is 'infer'\n            and `filepath_or_buffer` is path-like, then detect compression from\n            the following extensions: '.gz', '.bz2', '.zip', or '.xz' (otherwise\n            no compression). If dict and compression mode is 'zip' or inferred as\n            'zip', other entries passed as additional compression options.\n    \n            .. versionchanged:: 1.0.0\n    \n               May now be a dict with key 'method' as compression mode\n               and other keys as compression options if compression\n               mode is 'zip'.\n    \n        memory_map : boolean, default False\n            See parsers._parser_params for more information.\n        is_text : boolean, default True\n            whether file/buffer is in text format (csv, json, etc.), or in binary\n            mode (pickle, etc.).\n    \n        Returns\n        -------\n        f : file-like\n            A file-like object.\n        handles : list of file-like objects\n            A list of file-like object that were opened in this function.\n        \"\"\"\n        try:\n            from s3fs import S3File\n    \n            need_text_wrapping = (BufferedIOBase, S3File)\n        except ImportError:\n            need_text_wrapping = BufferedIOBase  # type: ignore\n    \n        handles: List[IO] = list()\n        f = path_or_buf\n    \n        # Convert pathlib.Path/py.path.local or string\n        path_or_buf = stringify_path(path_or_buf)\n        is_path = isinstance(path_or_buf, str)\n    \n        compression, compression_args = get_compression_method(compression)\n        if is_path:\n            compression = infer_compression(path_or_buf, compression)\n    \n        if compression:\n    \n            # GZ Compression\n            if compression == \"gzip\":\n                if is_path:\n                    f = gzip.open(path_or_buf, mode)\n                else:\n                    f = gzip.GzipFile(fileobj=path_or_buf)\n    \n            # BZ Compression\n            elif compression == \"bz2\":\n                if is_path:\n                    f = bz2.BZ2File(path_or_buf, mode)\n                else:\n                    f = bz2.BZ2File(path_or_buf)\n    \n            # ZIP Compression\n            elif compression == \"zip\":\n                zf = _BytesZipFile(path_or_buf, mode, **compression_args)\n                # Ensure the container is closed as well.\n                handles.append(zf)\n                if zf.mode == \"w\":\n                    f = zf\n                elif zf.mode == \"r\":\n                    zip_names = zf.namelist()\n                    if len(zip_names) == 1:\n                        f = zf.open(zip_names.pop())\n                    elif len(zip_names) == 0:\n                        raise ValueError(f\"Zero files found in ZIP file {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in ZIP file.\"\n                            f\" Only one file per ZIP: {zip_names}\"\n                        )\n    \n            # XZ Compression\n            elif compression == \"xz\":\n                f = _get_lzma_file(lzma)(path_or_buf, mode)\n    \n            # Unrecognized Compression\n            else:\n                msg = f\"Unrecognized compression type: {compression}\"\n                raise ValueError(msg)\n    \n            handles.append(f)\n    \n        elif is_path:\n            if encoding:\n                # Encoding\n                f = open(path_or_buf, mode, encoding=encoding, newline=\"\")\n            elif is_text:\n                # No explicit encoding\n                f = open(path_or_buf, mode, errors=\"replace\", newline=\"\")\n            else:\n                # Binary mode\n>               f = open(path_or_buf, mode)\nE               FileNotFoundError: [Errno 2] No such file or directory: 'ftp://test.com'\n\npandas/io/common.py:434: FileNotFoundError",
                "test_function_decorators": [
                    "pytest.mark.parametrize('mockurl', ['http://url.com', 'ftp://test.com', 'http://gzip.com'])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_90/pandas/tests/io/test_pickle.py",
                "test_function": "test_pickle_generalurl_read",
                "test_function_code": "@pytest.mark.parametrize(\n    \"mockurl\", [\"http://url.com\", \"ftp://test.com\", \"http://gzip.com\"]\n)\ndef test_pickle_generalurl_read(monkeypatch, mockurl):\n    def python_pickler(obj, path):\n        with open(path, \"wb\") as fh:\n            pickle.dump(obj, fh, protocol=-1)\n\n    class MockReadResponse:\n        def __init__(self, path):\n            self.file = open(path, \"rb\")\n            if \"gzip\" in path:\n                self.headers = {\"Content-Encoding\": \"gzip\"}\n            else:\n                self.headers = {\"Content-Encoding\": None}\n\n        def read(self):\n            return self.file.read()\n\n        def close(self):\n            return self.file.close()\n\n    with tm.ensure_clean() as path:\n\n        def mock_urlopen_read(*args, **kwargs):\n            return MockReadResponse(path)\n\n        df = tm.makeDataFrame()\n        python_pickler(df, path)\n        monkeypatch.setattr(\"urllib.request.urlopen\", mock_urlopen_read)\n        result = pd.read_pickle(mockurl)\n        tm.assert_frame_equal(df, result)",
                "test_error": "FileNotFoundError: [Errno 2] No such file or directory: 'http://gzip.com'",
                "full_test_error": "monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x119490a60>\nmockurl = 'http://gzip.com'\n\n    @pytest.mark.parametrize(\n        \"mockurl\", [\"http://url.com\", \"ftp://test.com\", \"http://gzip.com\"]\n    )\n    def test_pickle_generalurl_read(monkeypatch, mockurl):\n        def python_pickler(obj, path):\n            with open(path, \"wb\") as fh:\n                pickle.dump(obj, fh, protocol=-1)\n    \n        class MockReadResponse:\n            def __init__(self, path):\n                self.file = open(path, \"rb\")\n                if \"gzip\" in path:\n                    self.headers = {\"Content-Encoding\": \"gzip\"}\n                else:\n                    self.headers = {\"Content-Encoding\": None}\n    \n            def read(self):\n                return self.file.read()\n    \n            def close(self):\n                return self.file.close()\n    \n        with tm.ensure_clean() as path:\n    \n            def mock_urlopen_read(*args, **kwargs):\n                return MockReadResponse(path)\n    \n            df = tm.makeDataFrame()\n            python_pickler(df, path)\n            monkeypatch.setattr(\"urllib.request.urlopen\", mock_urlopen_read)\n>           result = pd.read_pickle(mockurl)\n\npandas/tests/io/test_pickle.py:446: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/io/pickle.py:138: in read_pickle\n    f, fh = get_handle(path, \"rb\", compression=compression, is_text=False)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath_or_buf = 'http://gzip.com', mode = 'rb', encoding = None\ncompression = None, memory_map = False, is_text = False\n\n    def get_handle(\n        path_or_buf,\n        mode: str,\n        encoding=None,\n        compression: Optional[Union[str, Mapping[str, Any]]] = None,\n        memory_map: bool = False,\n        is_text: bool = True,\n    ):\n        \"\"\"\n        Get file handle for given path/buffer and mode.\n    \n        Parameters\n        ----------\n        path_or_buf : str or file handle\n            File path or object.\n        mode : str\n            Mode to open path_or_buf with.\n        encoding : str or None\n            Encoding to use.\n        compression : str or dict, default None\n            If string, specifies compression mode. If dict, value at key 'method'\n            specifies compression mode. Compression mode must be one of {'infer',\n            'gzip', 'bz2', 'zip', 'xz', None}. If compression mode is 'infer'\n            and `filepath_or_buffer` is path-like, then detect compression from\n            the following extensions: '.gz', '.bz2', '.zip', or '.xz' (otherwise\n            no compression). If dict and compression mode is 'zip' or inferred as\n            'zip', other entries passed as additional compression options.\n    \n            .. versionchanged:: 1.0.0\n    \n               May now be a dict with key 'method' as compression mode\n               and other keys as compression options if compression\n               mode is 'zip'.\n    \n        memory_map : boolean, default False\n            See parsers._parser_params for more information.\n        is_text : boolean, default True\n            whether file/buffer is in text format (csv, json, etc.), or in binary\n            mode (pickle, etc.).\n    \n        Returns\n        -------\n        f : file-like\n            A file-like object.\n        handles : list of file-like objects\n            A list of file-like object that were opened in this function.\n        \"\"\"\n        try:\n            from s3fs import S3File\n    \n            need_text_wrapping = (BufferedIOBase, S3File)\n        except ImportError:\n            need_text_wrapping = BufferedIOBase  # type: ignore\n    \n        handles: List[IO] = list()\n        f = path_or_buf\n    \n        # Convert pathlib.Path/py.path.local or string\n        path_or_buf = stringify_path(path_or_buf)\n        is_path = isinstance(path_or_buf, str)\n    \n        compression, compression_args = get_compression_method(compression)\n        if is_path:\n            compression = infer_compression(path_or_buf, compression)\n    \n        if compression:\n    \n            # GZ Compression\n            if compression == \"gzip\":\n                if is_path:\n                    f = gzip.open(path_or_buf, mode)\n                else:\n                    f = gzip.GzipFile(fileobj=path_or_buf)\n    \n            # BZ Compression\n            elif compression == \"bz2\":\n                if is_path:\n                    f = bz2.BZ2File(path_or_buf, mode)\n                else:\n                    f = bz2.BZ2File(path_or_buf)\n    \n            # ZIP Compression\n            elif compression == \"zip\":\n                zf = _BytesZipFile(path_or_buf, mode, **compression_args)\n                # Ensure the container is closed as well.\n                handles.append(zf)\n                if zf.mode == \"w\":\n                    f = zf\n                elif zf.mode == \"r\":\n                    zip_names = zf.namelist()\n                    if len(zip_names) == 1:\n                        f = zf.open(zip_names.pop())\n                    elif len(zip_names) == 0:\n                        raise ValueError(f\"Zero files found in ZIP file {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in ZIP file.\"\n                            f\" Only one file per ZIP: {zip_names}\"\n                        )\n    \n            # XZ Compression\n            elif compression == \"xz\":\n                f = _get_lzma_file(lzma)(path_or_buf, mode)\n    \n            # Unrecognized Compression\n            else:\n                msg = f\"Unrecognized compression type: {compression}\"\n                raise ValueError(msg)\n    \n            handles.append(f)\n    \n        elif is_path:\n            if encoding:\n                # Encoding\n                f = open(path_or_buf, mode, encoding=encoding, newline=\"\")\n            elif is_text:\n                # No explicit encoding\n                f = open(path_or_buf, mode, errors=\"replace\", newline=\"\")\n            else:\n                # Binary mode\n>               f = open(path_or_buf, mode)\nE               FileNotFoundError: [Errno 2] No such file or directory: 'http://gzip.com'\n\npandas/io/common.py:434: FileNotFoundError",
                "traceback": "pandas/io/pickle.py:138: in read_pickle\n    f, fh = get_handle(path, \"rb\", compression=compression, is_text=False)",
                "test_error_location": "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\npath_or_buf = 'http://gzip.com', mode = 'rb', encoding = None\ncompression = None, memory_map = False, is_text = False\n\n    def get_handle(\n        path_or_buf,\n        mode: str,\n        encoding=None,\n        compression: Optional[Union[str, Mapping[str, Any]]] = None,\n        memory_map: bool = False,\n        is_text: bool = True,\n    ):\n        \"\"\"\n        Get file handle for given path/buffer and mode.\n    \n        Parameters\n        ----------\n        path_or_buf : str or file handle\n            File path or object.\n        mode : str\n            Mode to open path_or_buf with.\n        encoding : str or None\n            Encoding to use.\n        compression : str or dict, default None\n            If string, specifies compression mode. If dict, value at key 'method'\n            specifies compression mode. Compression mode must be one of {'infer',\n            'gzip', 'bz2', 'zip', 'xz', None}. If compression mode is 'infer'\n            and `filepath_or_buffer` is path-like, then detect compression from\n            the following extensions: '.gz', '.bz2', '.zip', or '.xz' (otherwise\n            no compression). If dict and compression mode is 'zip' or inferred as\n            'zip', other entries passed as additional compression options.\n    \n            .. versionchanged:: 1.0.0\n    \n               May now be a dict with key 'method' as compression mode\n               and other keys as compression options if compression\n               mode is 'zip'.\n    \n        memory_map : boolean, default False\n            See parsers._parser_params for more information.\n        is_text : boolean, default True\n            whether file/buffer is in text format (csv, json, etc.), or in binary\n            mode (pickle, etc.).\n    \n        Returns\n        -------\n        f : file-like\n            A file-like object.\n        handles : list of file-like objects\n            A list of file-like object that were opened in this function.\n        \"\"\"\n        try:\n            from s3fs import S3File\n    \n            need_text_wrapping = (BufferedIOBase, S3File)\n        except ImportError:\n            need_text_wrapping = BufferedIOBase  # type: ignore\n    \n        handles: List[IO] = list()\n        f = path_or_buf\n    \n        # Convert pathlib.Path/py.path.local or string\n        path_or_buf = stringify_path(path_or_buf)\n        is_path = isinstance(path_or_buf, str)\n    \n        compression, compression_args = get_compression_method(compression)\n        if is_path:\n            compression = infer_compression(path_or_buf, compression)\n    \n        if compression:\n    \n            # GZ Compression\n            if compression == \"gzip\":\n                if is_path:\n                    f = gzip.open(path_or_buf, mode)\n                else:\n                    f = gzip.GzipFile(fileobj=path_or_buf)\n    \n            # BZ Compression\n            elif compression == \"bz2\":\n                if is_path:\n                    f = bz2.BZ2File(path_or_buf, mode)\n                else:\n                    f = bz2.BZ2File(path_or_buf)\n    \n            # ZIP Compression\n            elif compression == \"zip\":\n                zf = _BytesZipFile(path_or_buf, mode, **compression_args)\n                # Ensure the container is closed as well.\n                handles.append(zf)\n                if zf.mode == \"w\":\n                    f = zf\n                elif zf.mode == \"r\":\n                    zip_names = zf.namelist()\n                    if len(zip_names) == 1:\n                        f = zf.open(zip_names.pop())\n                    elif len(zip_names) == 0:\n                        raise ValueError(f\"Zero files found in ZIP file {path_or_buf}\")\n                    else:\n                        raise ValueError(\n                            \"Multiple files found in ZIP file.\"\n                            f\" Only one file per ZIP: {zip_names}\"\n                        )\n    \n            # XZ Compression\n            elif compression == \"xz\":\n                f = _get_lzma_file(lzma)(path_or_buf, mode)\n    \n            # Unrecognized Compression\n            else:\n                msg = f\"Unrecognized compression type: {compression}\"\n                raise ValueError(msg)\n    \n            handles.append(f)\n    \n        elif is_path:\n            if encoding:\n                # Encoding\n                f = open(path_or_buf, mode, encoding=encoding, newline=\"\")\n            elif is_text:\n                # No explicit encoding\n                f = open(path_or_buf, mode, errors=\"replace\", newline=\"\")\n            else:\n                # Binary mode\n>               f = open(path_or_buf, mode)\nE               FileNotFoundError: [Errno 2] No such file or directory: 'http://gzip.com'\n\npandas/io/common.py:434: FileNotFoundError",
                "test_function_decorators": [
                    "pytest.mark.parametrize('mockurl', ['http://url.com', 'ftp://test.com', 'http://gzip.com'])"
                ]
            }
        ]
    }
}