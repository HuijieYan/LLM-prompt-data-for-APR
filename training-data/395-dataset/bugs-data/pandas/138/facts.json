{
    "1.1.1": "def _coerce_to_type(x):\n    \n    dtype = None\n\n    if is_datetime64tz_dtype(x):\n        dtype = x.dtype\n    elif is_datetime64_dtype(x):\n        x = to_datetime(x)\n        dtype = np.dtype(\"datetime64[ns]\")\n    elif is_timedelta64_dtype(x):\n        x = to_timedelta(x)\n        dtype = np.dtype(\"timedelta64[ns]\")\n\n    if dtype is not None:\n        # GH 19768: force NaT to NaN during integer conversion\n        x = np.where(x.notna(), x.view(np.int64), np.nan)\n\n    return x, dtype\n",
    "1.1.2": "if the passed data is of datetime/timedelta type,\nthis method converts it to numeric so that cut method can\nhandle it",
    "1.2.1": null,
    "1.2.2": null,
    "1.2.3": null,
    "1.3.1": "/Volumes/JerrySSD/bgp_envs/repos/pandas_138/pandas/core/reshape/tile.py",
    "1.3.2": null,
    "1.4.1": [
        "@pytest.mark.parametrize(\"bins\", [6, 7])\n@pytest.mark.parametrize(\n    \"box, compare\",\n    [\n        (Series, tm.assert_series_equal),\n        (np.array, tm.assert_categorical_equal),\n        (list, tm.assert_equal),\n    ],\n)\ndef test_qcut_bool_coercion_to_int(bins, box, compare):\n    # issue 20303\n    data_expected = box([0, 1, 1, 0, 1] * 10)\n    data_result = box([False, True, True, False, True] * 10)\n    expected = qcut(data_expected, bins, duplicates=\"drop\")\n    result = qcut(data_result, bins, duplicates=\"drop\")\n    compare(result, expected)",
        "@pytest.mark.parametrize(\"bins\", [6, 7])\n@pytest.mark.parametrize(\n    \"box, compare\",\n    [\n        (Series, tm.assert_series_equal),\n        (np.array, tm.assert_categorical_equal),\n        (list, tm.assert_equal),\n    ],\n)\ndef test_qcut_bool_coercion_to_int(bins, box, compare):\n    # issue 20303\n    data_expected = box([0, 1, 1, 0, 1] * 10)\n    data_result = box([False, True, True, False, True] * 10)\n    expected = qcut(data_expected, bins, duplicates=\"drop\")\n    result = qcut(data_result, bins, duplicates=\"drop\")\n    compare(result, expected)",
        "@pytest.mark.parametrize(\"bins\", [6, 7])\n@pytest.mark.parametrize(\n    \"box, compare\",\n    [\n        (Series, tm.assert_series_equal),\n        (np.array, tm.assert_categorical_equal),\n        (list, tm.assert_equal),\n    ],\n)\ndef test_qcut_bool_coercion_to_int(bins, box, compare):\n    # issue 20303\n    data_expected = box([0, 1, 1, 0, 1] * 10)\n    data_result = box([False, True, True, False, True] * 10)\n    expected = qcut(data_expected, bins, duplicates=\"drop\")\n    result = qcut(data_result, bins, duplicates=\"drop\")\n    compare(result, expected)",
        "@pytest.mark.parametrize(\"bins\", [6, 7])\n@pytest.mark.parametrize(\n    \"box, compare\",\n    [\n        (Series, tm.assert_series_equal),\n        (np.array, tm.assert_categorical_equal),\n        (list, tm.assert_equal),\n    ],\n)\ndef test_qcut_bool_coercion_to_int(bins, box, compare):\n    # issue 20303\n    data_expected = box([0, 1, 1, 0, 1] * 10)\n    data_result = box([False, True, True, False, True] * 10)\n    expected = qcut(data_expected, bins, duplicates=\"drop\")\n    result = qcut(data_result, bins, duplicates=\"drop\")\n    compare(result, expected)",
        "@pytest.mark.parametrize(\"bins\", [6, 7])\n@pytest.mark.parametrize(\n    \"box, compare\",\n    [\n        (Series, tm.assert_series_equal),\n        (np.array, tm.assert_categorical_equal),\n        (list, tm.assert_equal),\n    ],\n)\ndef test_qcut_bool_coercion_to_int(bins, box, compare):\n    # issue 20303\n    data_expected = box([0, 1, 1, 0, 1] * 10)\n    data_result = box([False, True, True, False, True] * 10)\n    expected = qcut(data_expected, bins, duplicates=\"drop\")\n    result = qcut(data_result, bins, duplicates=\"drop\")\n    compare(result, expected)",
        "@pytest.mark.parametrize(\"bins\", [6, 7])\n@pytest.mark.parametrize(\n    \"box, compare\",\n    [\n        (Series, tm.assert_series_equal),\n        (np.array, tm.assert_categorical_equal),\n        (list, tm.assert_equal),\n    ],\n)\ndef test_qcut_bool_coercion_to_int(bins, box, compare):\n    # issue 20303\n    data_expected = box([0, 1, 1, 0, 1] * 10)\n    data_result = box([False, True, True, False, True] * 10)\n    expected = qcut(data_expected, bins, duplicates=\"drop\")\n    result = qcut(data_result, bins, duplicates=\"drop\")\n    compare(result, expected)"
    ],
    "1.4.2": [
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_138/pandas/tests/reshape/test_qcut.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_138/pandas/tests/reshape/test_qcut.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_138/pandas/tests/reshape/test_qcut.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_138/pandas/tests/reshape/test_qcut.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_138/pandas/tests/reshape/test_qcut.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_138/pandas/tests/reshape/test_qcut.py"
    ],
    "2.1.1": [
        [
            "E       TypeError: numpy boolean subtract, the `-` operator, is not supported, use the bitwise_xor, the `^` operator, or the logical_xor function instead."
        ],
        [
            "E       TypeError: numpy boolean subtract, the `-` operator, is not supported, use the bitwise_xor, the `^` operator, or the logical_xor function instead."
        ],
        [
            "E       TypeError: numpy boolean subtract, the `-` operator, is not supported, use the bitwise_xor, the `^` operator, or the logical_xor function instead."
        ],
        [
            "E       TypeError: numpy boolean subtract, the `-` operator, is not supported, use the bitwise_xor, the `^` operator, or the logical_xor function instead."
        ],
        [
            "E       TypeError: numpy boolean subtract, the `-` operator, is not supported, use the bitwise_xor, the `^` operator, or the logical_xor function instead."
        ],
        [
            "E       TypeError: numpy boolean subtract, the `-` operator, is not supported, use the bitwise_xor, the `^` operator, or the logical_xor function instead."
        ]
    ],
    "2.1.2": [
        [
            "bins = 6, box = <class 'pandas.core.series.Series'>\ncompare = <function assert_series_equal at 0x1111e1f70>\n\n    @pytest.mark.parametrize(\"bins\", [6, 7])\n    @pytest.mark.parametrize(\n        \"box, compare\",\n        [\n            (Series, tm.assert_series_equal),\n            (np.array, tm.assert_categorical_equal),\n            (list, tm.assert_equal),\n        ],\n    )\n    def test_qcut_bool_coercion_to_int(bins, box, compare):\n        # issue 20303\n        data_expected = box([0, 1, 1, 0, 1] * 10)\n        data_result = box([False, True, True, False, True] * 10)\n        expected = qcut(data_expected, bins, duplicates=\"drop\")\n>       result = qcut(data_result, bins, duplicates=\"drop\")\n\npandas/tests/reshape/test_qcut.py:255: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/tile.py:340: in qcut\n    bins = algos.quantile(x, quantiles)\npandas/core/algorithms.py:1096: in quantile\n    result = [_get_score(x) for x in q]\npandas/core/algorithms.py:1096: in <listcomp>\n    result = [_get_score(x) for x in q]\npandas/core/algorithms.py:1079: in _get_score\n    score = _interpolate(values[int(idx)], values[int(idx) + 1], idx % 1)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\na = False, b = False, fraction = 0.16666666666666607\n\n    def _interpolate(a, b, fraction):\n        \"\"\"Returns the point at the given fraction between a and b, where\n        'fraction' must be between 0 and 1.\n        \"\"\"\n>       return a + (b - a) * fraction",
            "\npandas/core/algorithms.py:1068: TypeError"
        ],
        [
            "bins = 7, box = <class 'pandas.core.series.Series'>\ncompare = <function assert_series_equal at 0x1111e1f70>\n\n    @pytest.mark.parametrize(\"bins\", [6, 7])\n    @pytest.mark.parametrize(\n        \"box, compare\",\n        [\n            (Series, tm.assert_series_equal),\n            (np.array, tm.assert_categorical_equal),\n            (list, tm.assert_equal),\n        ],\n    )\n    def test_qcut_bool_coercion_to_int(bins, box, compare):\n        # issue 20303\n        data_expected = box([0, 1, 1, 0, 1] * 10)\n        data_result = box([False, True, True, False, True] * 10)\n        expected = qcut(data_expected, bins, duplicates=\"drop\")\n>       result = qcut(data_result, bins, duplicates=\"drop\")\n\npandas/tests/reshape/test_qcut.py:255: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/tile.py:340: in qcut\n    bins = algos.quantile(x, quantiles)\npandas/core/algorithms.py:1096: in quantile\n    result = [_get_score(x) for x in q]\npandas/core/algorithms.py:1096: in <listcomp>\n    result = [_get_score(x) for x in q]\npandas/core/algorithms.py:1079: in _get_score\n    score = _interpolate(values[int(idx)], values[int(idx) + 1], idx % 1)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\na = True, b = True, fraction = 0.9999999999999929\n\n    def _interpolate(a, b, fraction):\n        \"\"\"Returns the point at the given fraction between a and b, where\n        'fraction' must be between 0 and 1.\n        \"\"\"\n>       return a + (b - a) * fraction",
            "\npandas/core/algorithms.py:1068: TypeError"
        ],
        [
            "bins = 6, box = <built-in function array>\ncompare = <function assert_categorical_equal at 0x1111e1af0>\n\n    @pytest.mark.parametrize(\"bins\", [6, 7])\n    @pytest.mark.parametrize(\n        \"box, compare\",\n        [\n            (Series, tm.assert_series_equal),\n            (np.array, tm.assert_categorical_equal),\n            (list, tm.assert_equal),\n        ],\n    )\n    def test_qcut_bool_coercion_to_int(bins, box, compare):\n        # issue 20303\n        data_expected = box([0, 1, 1, 0, 1] * 10)\n        data_result = box([False, True, True, False, True] * 10)\n        expected = qcut(data_expected, bins, duplicates=\"drop\")\n>       result = qcut(data_result, bins, duplicates=\"drop\")\n\npandas/tests/reshape/test_qcut.py:255: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/tile.py:340: in qcut\n    bins = algos.quantile(x, quantiles)\npandas/core/algorithms.py:1096: in quantile\n    result = [_get_score(x) for x in q]\npandas/core/algorithms.py:1096: in <listcomp>\n    result = [_get_score(x) for x in q]\npandas/core/algorithms.py:1079: in _get_score\n    score = _interpolate(values[int(idx)], values[int(idx) + 1], idx % 1)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\na = False, b = False, fraction = 0.16666666666666607\n\n    def _interpolate(a, b, fraction):\n        \"\"\"Returns the point at the given fraction between a and b, where\n        'fraction' must be between 0 and 1.\n        \"\"\"\n>       return a + (b - a) * fraction",
            "\npandas/core/algorithms.py:1068: TypeError"
        ],
        [
            "bins = 7, box = <built-in function array>\ncompare = <function assert_categorical_equal at 0x1111e1af0>\n\n    @pytest.mark.parametrize(\"bins\", [6, 7])\n    @pytest.mark.parametrize(\n        \"box, compare\",\n        [\n            (Series, tm.assert_series_equal),\n            (np.array, tm.assert_categorical_equal),\n            (list, tm.assert_equal),\n        ],\n    )\n    def test_qcut_bool_coercion_to_int(bins, box, compare):\n        # issue 20303\n        data_expected = box([0, 1, 1, 0, 1] * 10)\n        data_result = box([False, True, True, False, True] * 10)\n        expected = qcut(data_expected, bins, duplicates=\"drop\")\n>       result = qcut(data_result, bins, duplicates=\"drop\")\n\npandas/tests/reshape/test_qcut.py:255: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/tile.py:340: in qcut\n    bins = algos.quantile(x, quantiles)\npandas/core/algorithms.py:1096: in quantile\n    result = [_get_score(x) for x in q]\npandas/core/algorithms.py:1096: in <listcomp>\n    result = [_get_score(x) for x in q]\npandas/core/algorithms.py:1079: in _get_score\n    score = _interpolate(values[int(idx)], values[int(idx) + 1], idx % 1)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\na = True, b = True, fraction = 0.9999999999999929\n\n    def _interpolate(a, b, fraction):\n        \"\"\"Returns the point at the given fraction between a and b, where\n        'fraction' must be between 0 and 1.\n        \"\"\"\n>       return a + (b - a) * fraction",
            "\npandas/core/algorithms.py:1068: TypeError"
        ],
        [
            "bins = 6, box = <class 'list'>, compare = <function assert_equal at 0x1111e20d0>\n\n    @pytest.mark.parametrize(\"bins\", [6, 7])\n    @pytest.mark.parametrize(\n        \"box, compare\",\n        [\n            (Series, tm.assert_series_equal),\n            (np.array, tm.assert_categorical_equal),\n            (list, tm.assert_equal),\n        ],\n    )\n    def test_qcut_bool_coercion_to_int(bins, box, compare):\n        # issue 20303\n        data_expected = box([0, 1, 1, 0, 1] * 10)\n        data_result = box([False, True, True, False, True] * 10)\n        expected = qcut(data_expected, bins, duplicates=\"drop\")\n>       result = qcut(data_result, bins, duplicates=\"drop\")\n\npandas/tests/reshape/test_qcut.py:255: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/tile.py:340: in qcut\n    bins = algos.quantile(x, quantiles)\npandas/core/algorithms.py:1096: in quantile\n    result = [_get_score(x) for x in q]\npandas/core/algorithms.py:1096: in <listcomp>\n    result = [_get_score(x) for x in q]\npandas/core/algorithms.py:1079: in _get_score\n    score = _interpolate(values[int(idx)], values[int(idx) + 1], idx % 1)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\na = False, b = False, fraction = 0.16666666666666607\n\n    def _interpolate(a, b, fraction):\n        \"\"\"Returns the point at the given fraction between a and b, where\n        'fraction' must be between 0 and 1.\n        \"\"\"\n>       return a + (b - a) * fraction",
            "\npandas/core/algorithms.py:1068: TypeError"
        ],
        [
            "bins = 7, box = <class 'list'>, compare = <function assert_equal at 0x1111e20d0>\n\n    @pytest.mark.parametrize(\"bins\", [6, 7])\n    @pytest.mark.parametrize(\n        \"box, compare\",\n        [\n            (Series, tm.assert_series_equal),\n            (np.array, tm.assert_categorical_equal),\n            (list, tm.assert_equal),\n        ],\n    )\n    def test_qcut_bool_coercion_to_int(bins, box, compare):\n        # issue 20303\n        data_expected = box([0, 1, 1, 0, 1] * 10)\n        data_result = box([False, True, True, False, True] * 10)\n        expected = qcut(data_expected, bins, duplicates=\"drop\")\n>       result = qcut(data_result, bins, duplicates=\"drop\")\n\npandas/tests/reshape/test_qcut.py:255: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/tile.py:340: in qcut\n    bins = algos.quantile(x, quantiles)\npandas/core/algorithms.py:1096: in quantile\n    result = [_get_score(x) for x in q]\npandas/core/algorithms.py:1096: in <listcomp>\n    result = [_get_score(x) for x in q]\npandas/core/algorithms.py:1079: in _get_score\n    score = _interpolate(values[int(idx)], values[int(idx) + 1], idx % 1)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\na = True, b = True, fraction = 0.9999999999999929\n\n    def _interpolate(a, b, fraction):\n        \"\"\"Returns the point at the given fraction between a and b, where\n        'fraction' must be between 0 and 1.\n        \"\"\"\n>       return a + (b - a) * fraction",
            "\npandas/core/algorithms.py:1068: TypeError"
        ]
    ],
    "2.1.3": [
        [
            {
                "x": "0     0\n1     1\n2     1\n3     0\n4     1\n5     0\n6     1\n7     1\n8     0\n9     1\n10    0\n11    1\n12    1\n13    0\n14    1\n15    0\n16    1\n17    1\n18    0\n19    1\n20    0\n21    1\n22    1\n23    0\n24    1\n25    0\n26    1\n27    1\n28    0\n29    1\n30    0\n31    1\n32    1\n33    0\n34    1\n35    0\n36    1\n37    1\n38    0\n39    1\n40    0\n41    1\n42    1\n43    0\n44    1\n45    0\n46    1\n47    1\n48    0\n49    1\ndtype: int64",
                "x.dtype": "dtype('int64')",
                "x.notna": "<bound method Series.notna of 0     0\n1     1\n2     1\n3     0\n4     1\n5     0\n6     1\n7     1\n8     0\n9     1\n10    0\n11    1\n12    1\n13    0\n14    1\n15    0\n16    1\n17    1\n18    0\n19    1\n20    0\n21    1\n22    1\n23    0\n24    1\n25    0\n26    1\n27    1\n28    0\n29    1\n30    0\n31    1\n32    1\n33    0\n34    1\n35    0\n36    1\n37    1\n38    0\n39    1\n40    0\n41    1\n42    1\n43    0\n44    1\n45    0\n46    1\n47    1\n48    0\n49    1\ndtype: int64>",
                "x.view": "<bound method Series.view of 0     0\n1     1\n2     1\n3     0\n4     1\n5     0\n6     1\n7     1\n8     0\n9     1\n10    0\n11    1\n12    1\n13    0\n14    1\n15    0\n16    1\n17    1\n18    0\n19    1\n20    0\n21    1\n22    1\n23    0\n24    1\n25    0\n26    1\n27    1\n28    0\n29    1\n30    0\n31    1\n32    1\n33    0\n34    1\n35    0\n36    1\n37    1\n38    0\n39    1\n40    0\n41    1\n42    1\n43    0\n44    1\n45    0\n46    1\n47    1\n48    0\n49    1\ndtype: int64>"
            },
            {}
        ],
        [
            {
                "x": "array of shape 50",
                "x.dtype": "dtype('bool')",
                "x.notna": "<bound method Series.notna of  ... False\n49     True\ndtype: bool>",
                "x.view": "<bound method Series.view of 0 ... False\n49     True\ndtype: bool>"
            },
            {}
        ],
        [
            {
                "x": "array([0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1,\n       1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0,\n       1, 0, 1, 1, 0, 1])",
                "x.dtype": "dtype('int64')"
            },
            {}
        ],
        [
            {
                "x": "array([False,  True,  True, False,  True, False,  True,  True, False,\n        True, False,  True,  True, False,  True, False,  True,  True,\n       False,  True, False,  True,  True, False,  True, False,  True,\n        True, False,  True, False,  True,  True, False,  True, False,\n        True,  True, False,  True, False,  True,  True, False,  True,\n       False,  True,  True, False,  True])",
                "x.dtype": "dtype('bool')"
            },
            {}
        ],
        [
            {
                "x": "array([0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1,\n       1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0,\n       1, 0, 1, 1, 0, 1])",
                "x.dtype": "dtype('int64')"
            },
            {}
        ],
        [
            {
                "x": "array([False,  True,  True, False,  True, False,  True,  True, False,\n        True, False,  True,  True, False,  True, False,  True,  True,\n       False,  True, False,  True,  True, False,  True, False,  True,\n        True, False,  True, False,  True,  True, False,  True, False,\n        True,  True, False,  True, False,  True,  True, False,  True,\n       False,  True,  True, False,  True])",
                "x.dtype": "dtype('bool')"
            },
            {}
        ],
        [
            {
                "x": "array([0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1,\n       1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0,\n       1, 0, 1, 1, 0, 1])",
                "x.dtype": "dtype('int64')"
            },
            {}
        ],
        [
            {
                "x": "array([False,  True,  True, False,  True, False,  True,  True, False,\n        True, False,  True,  True, False,  True, False,  True,  True,\n       False,  True, False,  True,  True, False,  True, False,  True,\n        True, False,  True, False,  True,  True, False,  True, False,\n        True,  True, False,  True, False,  True,  True, False,  True,\n       False,  True,  True, False,  True])",
                "x.dtype": "dtype('bool')"
            },
            {}
        ],
        [
            {
                "x": "array([0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1,\n       1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0,\n       1, 0, 1, 1, 0, 1])",
                "x.dtype": "dtype('int64')"
            },
            {}
        ],
        [
            {
                "x": "array([False,  True,  True, False,  True, False,  True,  True, False,\n        True, False,  True,  True, False,  True, False,  True,  True,\n       False,  True, False,  True,  True, False,  True, False,  True,\n        True, False,  True, False,  True,  True, False,  True, False,\n        True,  True, False,  True, False,  True,  True, False,  True,\n       False,  True,  True, False,  True])",
                "x.dtype": "dtype('bool')"
            },
            {}
        ]
    ],
    "2.1.4": [
        [
            {
                "x": "Series",
                "x.dtype": "dtype",
                "x.notna": "method",
                "x.view": "method"
            },
            {}
        ],
        [
            {
                "x": "Series",
                "x.dtype": "dtype",
                "x.notna": "method",
                "x.view": "method"
            },
            {}
        ],
        [
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            },
            {}
        ],
        [
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            },
            {}
        ],
        [
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            },
            {}
        ],
        [
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            },
            {}
        ],
        [
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            },
            {}
        ],
        [
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            },
            {}
        ],
        [
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            },
            {}
        ],
        [
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            },
            {}
        ]
    ],
    "2.1.5": [
        [
            {
                "x": "0     0\n1     1\n2     1\n3     0\n4     1\n5     0\n6     1\n7     1\n8     0\n9     1\n10    0\n11    1\n12    1\n13    0\n14    1\n15    0\n16    1\n17    1\n18    0\n19    1\n20    0\n21    1\n22    1\n23    0\n24    1\n25    0\n26    1\n27    1\n28    0\n29    1\n30    0\n31    1\n32    1\n33    0\n34    1\n35    0\n36    1\n37    1\n38    0\n39    1\n40    0\n41    1\n42    1\n43    0\n44    1\n45    0\n46    1\n47    1\n48    0\n49    1\ndtype: int64",
                "x.dtype": "dtype('int64')",
                "x.astype": "<bound method NDFrame.astype of 0     0\n1     1\n2     1\n3     0\n4     1\n5     0\n6     1\n7     1\n8     0\n9     1\n10    0\n11    1\n12    1\n13    0\n14    1\n15    0\n16    1\n17    1\n18    0\n19    1\n20    0\n21    1\n22    1\n23    0\n24    1\n25    0\n26    1\n27    1\n28    0\n29    1\n30    0\n31    1\n32    1\n33    0\n34    1\n35    0\n36    1\n37    1\n38    0\n39    1\n40    0\n41    1\n42    1\n43    0\n44    1\n45    0\n46    1\n47    1\n48    0\n49    1\ndtype: int64>",
                "x.notna": "<bound method Series.notna of 0     0\n1     1\n2     1\n3     0\n4     1\n5     0\n6     1\n7     1\n8     0\n9     1\n10    0\n11    1\n12    1\n13    0\n14    1\n15    0\n16    1\n17    1\n18    0\n19    1\n20    0\n21    1\n22    1\n23    0\n24    1\n25    0\n26    1\n27    1\n28    0\n29    1\n30    0\n31    1\n32    1\n33    0\n34    1\n35    0\n36    1\n37    1\n38    0\n39    1\n40    0\n41    1\n42    1\n43    0\n44    1\n45    0\n46    1\n47    1\n48    0\n49    1\ndtype: int64>",
                "x.view": "<bound method Series.view of 0     0\n1     1\n2     1\n3     0\n4     1\n5     0\n6     1\n7     1\n8     0\n9     1\n10    0\n11    1\n12    1\n13    0\n14    1\n15    0\n16    1\n17    1\n18    0\n19    1\n20    0\n21    1\n22    1\n23    0\n24    1\n25    0\n26    1\n27    1\n28    0\n29    1\n30    0\n31    1\n32    1\n33    0\n34    1\n35    0\n36    1\n37    1\n38    0\n39    1\n40    0\n41    1\n42    1\n43    0\n44    1\n45    0\n46    1\n47    1\n48    0\n49    1\ndtype: int64>"
            },
            {}
        ],
        [
            {
                "x": "array of shape 50",
                "x.dtype": "dtype('bool')",
                "x.astype": "<bound method NDFrame.astype o ... False\n49     True\ndtype: bool>",
                "x.notna": "<bound method Series.notna of  ... False\n49     True\ndtype: bool>",
                "x.view": "<bound method Series.view of 0 ... False\n49     True\ndtype: bool>"
            },
            {
                "x": "0     0\n1     1\n2     1\n3     0\n4     1\n5     0\n6     1\n7     1\n8     0\n9     1\n10    0\n11    1\n12    1\n13    0\n14    1\n15    0\n16    1\n17    1\n18    0\n19    1\n20    0\n21    1\n22    1\n23    0\n24    1\n25    0\n26    1\n27    1\n28    0\n29    1\n30    0\n31    1\n32    1\n33    0\n34    1\n35    0\n36    1\n37    1\n38    0\n39    1\n40    0\n41    1\n42    1\n43    0\n44    1\n45    0\n46    1\n47    1\n48    0\n49    1\ndtype: int64",
                "x.dtype": "dtype('int64')",
                "x.astype": "<bound method NDFrame.astype of 0     0\n1     1\n2     1\n3     0\n4     1\n5     0\n6     1\n7     1\n8     0\n9     1\n10    0\n11    1\n12    1\n13    0\n14    1\n15    0\n16    1\n17    1\n18    0\n19    1\n20    0\n21    1\n22    1\n23    0\n24    1\n25    0\n26    1\n27    1\n28    0\n29    1\n30    0\n31    1\n32    1\n33    0\n34    1\n35    0\n36    1\n37    1\n38    0\n39    1\n40    0\n41    1\n42    1\n43    0\n44    1\n45    0\n46    1\n47    1\n48    0\n49    1\ndtype: int64>",
                "x.notna": "<bound method Series.notna of 0     0\n1     1\n2     1\n3     0\n4     1\n5     0\n6     1\n7     1\n8     0\n9     1\n10    0\n11    1\n12    1\n13    0\n14    1\n15    0\n16    1\n17    1\n18    0\n19    1\n20    0\n21    1\n22    1\n23    0\n24    1\n25    0\n26    1\n27    1\n28    0\n29    1\n30    0\n31    1\n32    1\n33    0\n34    1\n35    0\n36    1\n37    1\n38    0\n39    1\n40    0\n41    1\n42    1\n43    0\n44    1\n45    0\n46    1\n47    1\n48    0\n49    1\ndtype: int64>",
                "x.view": "<bound method Series.view of 0     0\n1     1\n2     1\n3     0\n4     1\n5     0\n6     1\n7     1\n8     0\n9     1\n10    0\n11    1\n12    1\n13    0\n14    1\n15    0\n16    1\n17    1\n18    0\n19    1\n20    0\n21    1\n22    1\n23    0\n24    1\n25    0\n26    1\n27    1\n28    0\n29    1\n30    0\n31    1\n32    1\n33    0\n34    1\n35    0\n36    1\n37    1\n38    0\n39    1\n40    0\n41    1\n42    1\n43    0\n44    1\n45    0\n46    1\n47    1\n48    0\n49    1\ndtype: int64>"
            }
        ],
        [
            {
                "x": "array([0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1,\n       1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0,\n       1, 0, 1, 1, 0, 1])",
                "x.dtype": "dtype('int64')"
            },
            {}
        ],
        [
            {
                "x": "array([False,  True,  True, False,  True, False,  True,  True, False,\n        True, False,  True,  True, False,  True, False,  True,  True,\n       False,  True, False,  True,  True, False,  True, False,  True,\n        True, False,  True, False,  True,  True, False,  True, False,\n        True,  True, False,  True, False,  True,  True, False,  True,\n       False,  True,  True, False,  True])",
                "x.dtype": "dtype('bool')"
            },
            {
                "x": "array([0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1,\n       1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0,\n       1, 0, 1, 1, 0, 1])",
                "x.dtype": "dtype('int64')"
            }
        ],
        [
            {
                "x": "array([0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1,\n       1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0,\n       1, 0, 1, 1, 0, 1])",
                "x.dtype": "dtype('int64')"
            },
            {}
        ],
        [
            {
                "x": "array([False,  True,  True, False,  True, False,  True,  True, False,\n        True, False,  True,  True, False,  True, False,  True,  True,\n       False,  True, False,  True,  True, False,  True, False,  True,\n        True, False,  True, False,  True,  True, False,  True, False,\n        True,  True, False,  True, False,  True,  True, False,  True,\n       False,  True,  True, False,  True])",
                "x.dtype": "dtype('bool')"
            },
            {
                "x": "array([0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1,\n       1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0,\n       1, 0, 1, 1, 0, 1])",
                "x.dtype": "dtype('int64')"
            }
        ],
        [
            {
                "x": "array([0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1,\n       1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0,\n       1, 0, 1, 1, 0, 1])",
                "x.dtype": "dtype('int64')"
            },
            {}
        ],
        [
            {
                "x": "array([False,  True,  True, False,  True, False,  True,  True, False,\n        True, False,  True,  True, False,  True, False,  True,  True,\n       False,  True, False,  True,  True, False,  True, False,  True,\n        True, False,  True, False,  True,  True, False,  True, False,\n        True,  True, False,  True, False,  True,  True, False,  True,\n       False,  True,  True, False,  True])",
                "x.dtype": "dtype('bool')"
            },
            {
                "x": "array([0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1,\n       1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0,\n       1, 0, 1, 1, 0, 1])",
                "x.dtype": "dtype('int64')"
            }
        ],
        [
            {
                "x": "array([0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1,\n       1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0,\n       1, 0, 1, 1, 0, 1])",
                "x.dtype": "dtype('int64')"
            },
            {}
        ],
        [
            {
                "x": "array([False,  True,  True, False,  True, False,  True,  True, False,\n        True, False,  True,  True, False,  True, False,  True,  True,\n       False,  True, False,  True,  True, False,  True, False,  True,\n        True, False,  True, False,  True,  True, False,  True, False,\n        True,  True, False,  True, False,  True,  True, False,  True,\n       False,  True,  True, False,  True])",
                "x.dtype": "dtype('bool')"
            },
            {
                "x": "array([0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1,\n       1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0,\n       1, 0, 1, 1, 0, 1])",
                "x.dtype": "dtype('int64')"
            }
        ]
    ],
    "2.1.6": [
        [
            {
                "x": "Series",
                "x.dtype": "dtype",
                "x.astype": "method",
                "x.notna": "method",
                "x.view": "method"
            },
            {}
        ],
        [
            {
                "x": "Series",
                "x.dtype": "dtype",
                "x.astype": "method",
                "x.notna": "method",
                "x.view": "method"
            },
            {
                "x": "Series",
                "x.dtype": "dtype",
                "x.astype": "method",
                "x.notna": "method",
                "x.view": "method"
            }
        ],
        [
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            },
            {}
        ],
        [
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            },
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            }
        ],
        [
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            },
            {}
        ],
        [
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            },
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            }
        ],
        [
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            },
            {}
        ],
        [
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            },
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            }
        ],
        [
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            },
            {}
        ],
        [
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            },
            {
                "x": "ndarray",
                "x.dtype": "dtype"
            }
        ]
    ],
    "3.1.1": [
        "\n"
    ],
    "3.1.2": [
        "\n"
    ]
}