# Error stack trace

```json
[
    [
        "frame_size = (2, 3), groupby = [0], q = [0.5, 0.6]\n\n    @pytest.mark.parametrize(\"frame_size\", [(2, 3), (100, 10)])\n    @pytest.mark.parametrize(\"groupby\", [[0], [0, 1]])\n    @pytest.mark.parametrize(\"q\", [[0.5, 0.6]])\n    def test_groupby_quantile_with_arraylike_q_and_int_columns(frame_size, groupby, q):\n        # GH30289\n        nrow, ncol = frame_size\n        df = pd.DataFrame(\n            np.array([ncol * [_ % 4] for _ in range(nrow)]), columns=range(ncol)\n        )\n    \n        idx_levels = [list(range(min(nrow, 4)))] * len(groupby) + [q]\n        idx_codes = [[x for x in range(min(nrow, 4)) for _ in q]] * len(groupby) + [\n            list(range(len(q))) * min(nrow, 4)\n        ]\n        expected_index = pd.MultiIndex(\n            levels=idx_levels, codes=idx_codes, names=groupby + [None]\n        )\n        expected_values = [\n            [float(x)] * (ncol - len(groupby)) for x in range(min(nrow, 4)) for _ in q\n        ]\n        expected_columns = [x for x in range(ncol) if x not in groupby]\n        expected = pd.DataFrame(\n            expected_values, index=expected_index, columns=expected_columns\n        )\n>       result = df.groupby(groupby).quantile(q)\n\npandas/tests/groupby/test_function.py:1425: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.groupby.generic.DataFrameGroupBy object at 0x118fdaf40>\nq = [0.5, 0.6], interpolation = 'linear'\n\n    def quantile(self, q=0.5, interpolation: str = \"linear\"):\n        \"\"\"\n        Return group values at the given quantile, a la numpy.percentile.\n    \n        Parameters\n        ----------\n        q : float or array-like, default 0.5 (50% quantile)\n            Value(s) between 0 and 1 providing the quantile(s) to compute.\n        interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}\n            Method to use when the desired quantile falls between two points.\n    \n        Returns\n        -------\n        Series or DataFrame\n            Return type determined by caller of GroupBy object.\n    \n        See Also\n        --------\n        Series.quantile : Similar method for Series.\n        DataFrame.quantile : Similar method for DataFrame.\n        numpy.percentile : NumPy method to compute qth percentile.\n    \n        Examples\n        --------\n        >>> df = pd.DataFrame([\n        ...     ['a', 1], ['a', 2], ['a', 3],\n        ...     ['b', 1], ['b', 3], ['b', 5]\n        ... ], columns=['key', 'val'])\n        >>> df.groupby('key').quantile()\n            val\n        key\n        a    2.0\n        b    3.0\n        \"\"\"\n        from pandas import concat\n    \n        def pre_processor(vals: np.ndarray) -> Tuple[np.ndarray, Optional[Type]]:\n            if is_object_dtype(vals):\n                raise TypeError(\n                    \"'quantile' cannot be performed against 'object' dtypes!\"\n                )\n    \n            inference = None\n            if is_integer_dtype(vals):\n                inference = np.int64\n            elif is_datetime64_dtype(vals):\n                inference = \"datetime64[ns]\"\n                vals = vals.astype(np.float)\n    \n            return vals, inference\n    \n        def post_processor(vals: np.ndarray, inference: Optional[Type]) -> np.ndarray:\n            if inference:\n                # Check for edge case\n                if not (\n                    is_integer_dtype(inference)\n                    and interpolation in {\"linear\", \"midpoint\"}\n                ):\n                    vals = vals.astype(inference)\n    \n            return vals\n    \n        if is_scalar(q):\n            return self._get_cythonized_result(\n                \"group_quantile\",\n                aggregate=True,\n                needs_values=True,\n                needs_mask=True,\n                cython_dtype=np.dtype(np.float64),\n                pre_processing=pre_processor,\n                post_processing=post_processor,\n                q=q,\n                interpolation=interpolation,\n            )\n        else:\n            results = [\n                self._get_cythonized_result(\n                    \"group_quantile\",\n                    aggregate=True,\n                    needs_values=True,\n                    needs_mask=True,\n                    cython_dtype=np.dtype(np.float64),\n                    pre_processing=pre_processor,\n                    post_processing=post_processor,\n                    q=qi,\n                    interpolation=interpolation,\n                )\n                for qi in q\n            ]\n            result = concat(results, axis=0, keys=q)\n            # fix levels to place quantiles on the inside\n            # TODO(GH-10710): Ideally, we could write this as\n            #  >>> result.stack(0).loc[pd.IndexSlice[:, ..., q], :]\n            #  but this hits https://github.com/pandas-dev/pandas/issues/10710\n            #  which doesn't reorder the list-like `q` on the inner level.\n            order = np.roll(list(range(result.index.nlevels)), -1)\n            result = result.reorder_levels(order)\n            result = result.reindex(q, level=-1)\n    \n            # fix order.\n            hi = len(q) * self.ngroups\n            arr = np.arange(0, hi, self.ngroups)\n            arrays = []\n    \n            for i in range(self.ngroups):\n                arr2 = arr + i\n                arrays.append(arr2)\n    \n            indices = np.concatenate(arrays)\n>           assert len(indices) == len(result)",
        "\npandas/core/groupby/groupby.py:1954: AssertionError"
    ],
    [
        "frame_size = (100, 10), groupby = [0], q = [0.5, 0.6]\n\n    @pytest.mark.parametrize(\"frame_size\", [(2, 3), (100, 10)])\n    @pytest.mark.parametrize(\"groupby\", [[0], [0, 1]])\n    @pytest.mark.parametrize(\"q\", [[0.5, 0.6]])\n    def test_groupby_quantile_with_arraylike_q_and_int_columns(frame_size, groupby, q):\n        # GH30289\n        nrow, ncol = frame_size\n        df = pd.DataFrame(\n            np.array([ncol * [_ % 4] for _ in range(nrow)]), columns=range(ncol)\n        )\n    \n        idx_levels = [list(range(min(nrow, 4)))] * len(groupby) + [q]\n        idx_codes = [[x for x in range(min(nrow, 4)) for _ in q]] * len(groupby) + [\n            list(range(len(q))) * min(nrow, 4)\n        ]\n        expected_index = pd.MultiIndex(\n            levels=idx_levels, codes=idx_codes, names=groupby + [None]\n        )\n        expected_values = [\n            [float(x)] * (ncol - len(groupby)) for x in range(min(nrow, 4)) for _ in q\n        ]\n        expected_columns = [x for x in range(ncol) if x not in groupby]\n        expected = pd.DataFrame(\n            expected_values, index=expected_index, columns=expected_columns\n        )\n>       result = df.groupby(groupby).quantile(q)\n\npandas/tests/groupby/test_function.py:1425: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.groupby.generic.DataFrameGroupBy object at 0x119007370>\nq = [0.5, 0.6], interpolation = 'linear'\n\n    def quantile(self, q=0.5, interpolation: str = \"linear\"):\n        \"\"\"\n        Return group values at the given quantile, a la numpy.percentile.\n    \n        Parameters\n        ----------\n        q : float or array-like, default 0.5 (50% quantile)\n            Value(s) between 0 and 1 providing the quantile(s) to compute.\n        interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}\n            Method to use when the desired quantile falls between two points.\n    \n        Returns\n        -------\n        Series or DataFrame\n            Return type determined by caller of GroupBy object.\n    \n        See Also\n        --------\n        Series.quantile : Similar method for Series.\n        DataFrame.quantile : Similar method for DataFrame.\n        numpy.percentile : NumPy method to compute qth percentile.\n    \n        Examples\n        --------\n        >>> df = pd.DataFrame([\n        ...     ['a', 1], ['a', 2], ['a', 3],\n        ...     ['b', 1], ['b', 3], ['b', 5]\n        ... ], columns=['key', 'val'])\n        >>> df.groupby('key').quantile()\n            val\n        key\n        a    2.0\n        b    3.0\n        \"\"\"\n        from pandas import concat\n    \n        def pre_processor(vals: np.ndarray) -> Tuple[np.ndarray, Optional[Type]]:\n            if is_object_dtype(vals):\n                raise TypeError(\n                    \"'quantile' cannot be performed against 'object' dtypes!\"\n                )\n    \n            inference = None\n            if is_integer_dtype(vals):\n                inference = np.int64\n            elif is_datetime64_dtype(vals):\n                inference = \"datetime64[ns]\"\n                vals = vals.astype(np.float)\n    \n            return vals, inference\n    \n        def post_processor(vals: np.ndarray, inference: Optional[Type]) -> np.ndarray:\n            if inference:\n                # Check for edge case\n                if not (\n                    is_integer_dtype(inference)\n                    and interpolation in {\"linear\", \"midpoint\"}\n                ):\n                    vals = vals.astype(inference)\n    \n            return vals\n    \n        if is_scalar(q):\n            return self._get_cythonized_result(\n                \"group_quantile\",\n                aggregate=True,\n                needs_values=True,\n                needs_mask=True,\n                cython_dtype=np.dtype(np.float64),\n                pre_processing=pre_processor,\n                post_processing=post_processor,\n                q=q,\n                interpolation=interpolation,\n            )\n        else:\n            results = [\n                self._get_cythonized_result(\n                    \"group_quantile\",\n                    aggregate=True,\n                    needs_values=True,\n                    needs_mask=True,\n                    cython_dtype=np.dtype(np.float64),\n                    pre_processing=pre_processor,\n                    post_processing=post_processor,\n                    q=qi,\n                    interpolation=interpolation,\n                )\n                for qi in q\n            ]\n            result = concat(results, axis=0, keys=q)\n            # fix levels to place quantiles on the inside\n            # TODO(GH-10710): Ideally, we could write this as\n            #  >>> result.stack(0).loc[pd.IndexSlice[:, ..., q], :]\n            #  but this hits https://github.com/pandas-dev/pandas/issues/10710\n            #  which doesn't reorder the list-like `q` on the inner level.\n            order = np.roll(list(range(result.index.nlevels)), -1)\n            result = result.reorder_levels(order)\n            result = result.reindex(q, level=-1)\n    \n            # fix order.\n            hi = len(q) * self.ngroups\n            arr = np.arange(0, hi, self.ngroups)\n            arrays = []\n    \n            for i in range(self.ngroups):\n                arr2 = arr + i\n                arrays.append(arr2)\n    \n            indices = np.concatenate(arrays)\n>           assert len(indices) == len(result)",
        "\npandas/core/groupby/groupby.py:1954: AssertionError"
    ],
    [
        "frame_size = (2, 3), groupby = [0, 1], q = [0.5, 0.6]\n\n    @pytest.mark.parametrize(\"frame_size\", [(2, 3), (100, 10)])\n    @pytest.mark.parametrize(\"groupby\", [[0], [0, 1]])\n    @pytest.mark.parametrize(\"q\", [[0.5, 0.6]])\n    def test_groupby_quantile_with_arraylike_q_and_int_columns(frame_size, groupby, q):\n        # GH30289\n        nrow, ncol = frame_size\n        df = pd.DataFrame(\n            np.array([ncol * [_ % 4] for _ in range(nrow)]), columns=range(ncol)\n        )\n    \n        idx_levels = [list(range(min(nrow, 4)))] * len(groupby) + [q]\n        idx_codes = [[x for x in range(min(nrow, 4)) for _ in q]] * len(groupby) + [\n            list(range(len(q))) * min(nrow, 4)\n        ]\n        expected_index = pd.MultiIndex(\n            levels=idx_levels, codes=idx_codes, names=groupby + [None]\n        )\n        expected_values = [\n            [float(x)] * (ncol - len(groupby)) for x in range(min(nrow, 4)) for _ in q\n        ]\n        expected_columns = [x for x in range(ncol) if x not in groupby]\n        expected = pd.DataFrame(\n            expected_values, index=expected_index, columns=expected_columns\n        )\n>       result = df.groupby(groupby).quantile(q)\n\npandas/tests/groupby/test_function.py:1425: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.groupby.generic.DataFrameGroupBy object at 0x118f07e80>\nq = [0.5, 0.6], interpolation = 'linear'\n\n    def quantile(self, q=0.5, interpolation: str = \"linear\"):\n        \"\"\"\n        Return group values at the given quantile, a la numpy.percentile.\n    \n        Parameters\n        ----------\n        q : float or array-like, default 0.5 (50% quantile)\n            Value(s) between 0 and 1 providing the quantile(s) to compute.\n        interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}\n            Method to use when the desired quantile falls between two points.\n    \n        Returns\n        -------\n        Series or DataFrame\n            Return type determined by caller of GroupBy object.\n    \n        See Also\n        --------\n        Series.quantile : Similar method for Series.\n        DataFrame.quantile : Similar method for DataFrame.\n        numpy.percentile : NumPy method to compute qth percentile.\n    \n        Examples\n        --------\n        >>> df = pd.DataFrame([\n        ...     ['a', 1], ['a', 2], ['a', 3],\n        ...     ['b', 1], ['b', 3], ['b', 5]\n        ... ], columns=['key', 'val'])\n        >>> df.groupby('key').quantile()\n            val\n        key\n        a    2.0\n        b    3.0\n        \"\"\"\n        from pandas import concat\n    \n        def pre_processor(vals: np.ndarray) -> Tuple[np.ndarray, Optional[Type]]:\n            if is_object_dtype(vals):\n                raise TypeError(\n                    \"'quantile' cannot be performed against 'object' dtypes!\"\n                )\n    \n            inference = None\n            if is_integer_dtype(vals):\n                inference = np.int64\n            elif is_datetime64_dtype(vals):\n                inference = \"datetime64[ns]\"\n                vals = vals.astype(np.float)\n    \n            return vals, inference\n    \n        def post_processor(vals: np.ndarray, inference: Optional[Type]) -> np.ndarray:\n            if inference:\n                # Check for edge case\n                if not (\n                    is_integer_dtype(inference)\n                    and interpolation in {\"linear\", \"midpoint\"}\n                ):\n                    vals = vals.astype(inference)\n    \n            return vals\n    \n        if is_scalar(q):\n            return self._get_cythonized_result(\n                \"group_quantile\",\n                aggregate=True,\n                needs_values=True,\n                needs_mask=True,\n                cython_dtype=np.dtype(np.float64),\n                pre_processing=pre_processor,\n                post_processing=post_processor,\n                q=q,\n                interpolation=interpolation,\n            )\n        else:\n            results = [\n                self._get_cythonized_result(\n                    \"group_quantile\",\n                    aggregate=True,\n                    needs_values=True,\n                    needs_mask=True,\n                    cython_dtype=np.dtype(np.float64),\n                    pre_processing=pre_processor,\n                    post_processing=post_processor,\n                    q=qi,\n                    interpolation=interpolation,\n                )\n                for qi in q\n            ]\n            result = concat(results, axis=0, keys=q)\n            # fix levels to place quantiles on the inside\n            # TODO(GH-10710): Ideally, we could write this as\n            #  >>> result.stack(0).loc[pd.IndexSlice[:, ..., q], :]\n            #  but this hits https://github.com/pandas-dev/pandas/issues/10710\n            #  which doesn't reorder the list-like `q` on the inner level.\n            order = np.roll(list(range(result.index.nlevels)), -1)\n            result = result.reorder_levels(order)\n            result = result.reindex(q, level=-1)\n    \n            # fix order.\n            hi = len(q) * self.ngroups\n            arr = np.arange(0, hi, self.ngroups)\n            arrays = []\n    \n            for i in range(self.ngroups):\n                arr2 = arr + i\n                arrays.append(arr2)\n    \n            indices = np.concatenate(arrays)\n>           assert len(indices) == len(result)",
        "\npandas/core/groupby/groupby.py:1954: AssertionError"
    ],
    [
        "frame_size = (100, 10), groupby = [0, 1], q = [0.5, 0.6]\n\n    @pytest.mark.parametrize(\"frame_size\", [(2, 3), (100, 10)])\n    @pytest.mark.parametrize(\"groupby\", [[0], [0, 1]])\n    @pytest.mark.parametrize(\"q\", [[0.5, 0.6]])\n    def test_groupby_quantile_with_arraylike_q_and_int_columns(frame_size, groupby, q):\n        # GH30289\n        nrow, ncol = frame_size\n        df = pd.DataFrame(\n            np.array([ncol * [_ % 4] for _ in range(nrow)]), columns=range(ncol)\n        )\n    \n        idx_levels = [list(range(min(nrow, 4)))] * len(groupby) + [q]\n        idx_codes = [[x for x in range(min(nrow, 4)) for _ in q]] * len(groupby) + [\n            list(range(len(q))) * min(nrow, 4)\n        ]\n        expected_index = pd.MultiIndex(\n            levels=idx_levels, codes=idx_codes, names=groupby + [None]\n        )\n        expected_values = [\n            [float(x)] * (ncol - len(groupby)) for x in range(min(nrow, 4)) for _ in q\n        ]\n        expected_columns = [x for x in range(ncol) if x not in groupby]\n        expected = pd.DataFrame(\n            expected_values, index=expected_index, columns=expected_columns\n        )\n>       result = df.groupby(groupby).quantile(q)\n\npandas/tests/groupby/test_function.py:1425: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.groupby.generic.DataFrameGroupBy object at 0x1190baac0>\nq = [0.5, 0.6], interpolation = 'linear'\n\n    def quantile(self, q=0.5, interpolation: str = \"linear\"):\n        \"\"\"\n        Return group values at the given quantile, a la numpy.percentile.\n    \n        Parameters\n        ----------\n        q : float or array-like, default 0.5 (50% quantile)\n            Value(s) between 0 and 1 providing the quantile(s) to compute.\n        interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}\n            Method to use when the desired quantile falls between two points.\n    \n        Returns\n        -------\n        Series or DataFrame\n            Return type determined by caller of GroupBy object.\n    \n        See Also\n        --------\n        Series.quantile : Similar method for Series.\n        DataFrame.quantile : Similar method for DataFrame.\n        numpy.percentile : NumPy method to compute qth percentile.\n    \n        Examples\n        --------\n        >>> df = pd.DataFrame([\n        ...     ['a', 1], ['a', 2], ['a', 3],\n        ...     ['b', 1], ['b', 3], ['b', 5]\n        ... ], columns=['key', 'val'])\n        >>> df.groupby('key').quantile()\n            val\n        key\n        a    2.0\n        b    3.0\n        \"\"\"\n        from pandas import concat\n    \n        def pre_processor(vals: np.ndarray) -> Tuple[np.ndarray, Optional[Type]]:\n            if is_object_dtype(vals):\n                raise TypeError(\n                    \"'quantile' cannot be performed against 'object' dtypes!\"\n                )\n    \n            inference = None\n            if is_integer_dtype(vals):\n                inference = np.int64\n            elif is_datetime64_dtype(vals):\n                inference = \"datetime64[ns]\"\n                vals = vals.astype(np.float)\n    \n            return vals, inference\n    \n        def post_processor(vals: np.ndarray, inference: Optional[Type]) -> np.ndarray:\n            if inference:\n                # Check for edge case\n                if not (\n                    is_integer_dtype(inference)\n                    and interpolation in {\"linear\", \"midpoint\"}\n                ):\n                    vals = vals.astype(inference)\n    \n            return vals\n    \n        if is_scalar(q):\n            return self._get_cythonized_result(\n                \"group_quantile\",\n                aggregate=True,\n                needs_values=True,\n                needs_mask=True,\n                cython_dtype=np.dtype(np.float64),\n                pre_processing=pre_processor,\n                post_processing=post_processor,\n                q=q,\n                interpolation=interpolation,\n            )\n        else:\n            results = [\n                self._get_cythonized_result(\n                    \"group_quantile\",\n                    aggregate=True,\n                    needs_values=True,\n                    needs_mask=True,\n                    cython_dtype=np.dtype(np.float64),\n                    pre_processing=pre_processor,\n                    post_processing=post_processor,\n                    q=qi,\n                    interpolation=interpolation,\n                )\n                for qi in q\n            ]\n            result = concat(results, axis=0, keys=q)\n            # fix levels to place quantiles on the inside\n            # TODO(GH-10710): Ideally, we could write this as\n            #  >>> result.stack(0).loc[pd.IndexSlice[:, ..., q], :]\n            #  but this hits https://github.com/pandas-dev/pandas/issues/10710\n            #  which doesn't reorder the list-like `q` on the inner level.\n            order = np.roll(list(range(result.index.nlevels)), -1)\n            result = result.reorder_levels(order)\n            result = result.reindex(q, level=-1)\n    \n            # fix order.\n            hi = len(q) * self.ngroups\n            arr = np.arange(0, hi, self.ngroups)\n            arrays = []\n    \n            for i in range(self.ngroups):\n                arr2 = arr + i\n                arrays.append(arr2)\n    \n            indices = np.concatenate(arrays)\n>           assert len(indices) == len(result)",
        "\npandas/core/groupby/groupby.py:1954: AssertionError"
    ]
]
```
