{
    "1.1.1": "def crosstab(\n    index,\n    columns,\n    values=None,\n    rownames=None,\n    colnames=None,\n    aggfunc=None,\n    margins=False,\n    margins_name: str = \"All\",\n    dropna: bool = True,\n    normalize=False,\n) -> \"DataFrame\":\n    \n\n    index = com.maybe_make_list(index)\n    columns = com.maybe_make_list(columns)\n\n    rownames = _get_names(index, rownames, prefix=\"row\")\n    colnames = _get_names(columns, colnames, prefix=\"col\")\n\n    common_idx = None\n    pass_objs = [x for x in index + columns if isinstance(x, (ABCSeries, ABCDataFrame))]\n    if pass_objs:\n        common_idx = get_objs_combined_axis(pass_objs, intersect=True, sort=False)\n\n    data: Dict = {}\n    data.update(zip(rownames, index))\n    data.update(zip(colnames, columns))\n\n    if values is None and aggfunc is not None:\n        raise ValueError(\"aggfunc cannot be used without values.\")\n\n    if values is not None and aggfunc is None:\n        raise ValueError(\"values cannot be used without an aggfunc.\")\n\n    from pandas import DataFrame\n\n    df = DataFrame(data, index=common_idx)\n    if values is None:\n        df[\"__dummy__\"] = 0\n        kwargs = {\"aggfunc\": len, \"fill_value\": 0}\n    else:\n        df[\"__dummy__\"] = values\n        kwargs = {\"aggfunc\": aggfunc}\n\n    table = df.pivot_table(\n        \"__dummy__\",\n        index=rownames,\n        columns=colnames,\n        margins=margins,\n        margins_name=margins_name,\n        dropna=dropna,\n        **kwargs,\n    )\n\n    # Post-process\n    if normalize is not False:\n        table = _normalize(\n            table, normalize=normalize, margins=margins, margins_name=margins_name\n        )\n\n    return table\n",
    "1.1.2": "Compute a simple cross tabulation of two (or more) factors. By default\ncomputes a frequency table of the factors unless an array of values and an\naggregation function are passed.\n\nParameters\n----------\nindex : array-like, Series, or list of arrays/Series\n    Values to group by in the rows.\ncolumns : array-like, Series, or list of arrays/Series\n    Values to group by in the columns.\nvalues : array-like, optional\n    Array of values to aggregate according to the factors.\n    Requires `aggfunc` be specified.\nrownames : sequence, default None\n    If passed, must match number of row arrays passed.\ncolnames : sequence, default None\n    If passed, must match number of column arrays passed.\naggfunc : function, optional\n    If specified, requires `values` be specified as well.\nmargins : bool, default False\n    Add row/column margins (subtotals).\nmargins_name : str, default 'All'\n    Name of the row/column that will contain the totals\n    when margins is True.\n\n    .. versionadded:: 0.21.0\n\ndropna : bool, default True\n    Do not include columns whose entries are all NaN.\nnormalize : bool, {'all', 'index', 'columns'}, or {0,1}, default False\n    Normalize by dividing all values by the sum of values.\n\n    - If passed 'all' or `True`, will normalize over all values.\n    - If passed 'index' will normalize over each row.\n    - If passed 'columns' will normalize over each column.\n    - If margins is `True`, will also normalize margin values.\n\nReturns\n-------\nDataFrame\n    Cross tabulation of the data.\n\nSee Also\n--------\nDataFrame.pivot : Reshape data based on column values.\npivot_table : Create a pivot table as a DataFrame.\n\nNotes\n-----\nAny Series passed will have their name attributes used unless row or column\nnames for the cross-tabulation are specified.\n\nAny input passed containing Categorical data will have **all** of its\ncategories included in the cross-tabulation, even if the actual data does\nnot contain any instances of a particular category.\n\nIn the event that there aren't overlapping indexes an empty DataFrame will\nbe returned.\n\nExamples\n--------\n>>> a = np.array([\"foo\", \"foo\", \"foo\", \"foo\", \"bar\", \"bar\",\n...               \"bar\", \"bar\", \"foo\", \"foo\", \"foo\"], dtype=object)\n>>> b = np.array([\"one\", \"one\", \"one\", \"two\", \"one\", \"one\",\n...               \"one\", \"two\", \"two\", \"two\", \"one\"], dtype=object)\n>>> c = np.array([\"dull\", \"dull\", \"shiny\", \"dull\", \"dull\", \"shiny\",\n...               \"shiny\", \"dull\", \"shiny\", \"shiny\", \"shiny\"],\n...              dtype=object)\n>>> pd.crosstab(a, [b, c], rownames=['a'], colnames=['b', 'c'])\nb   one        two\nc   dull shiny dull shiny\na\nbar    1     2    1     0\nfoo    2     2    1     2\n\nHere 'c' and 'f' are not represented in the data and will not be\nshown in the output because dropna is True by default. Set\ndropna=False to preserve categories with no data.\n\n>>> foo = pd.Categorical(['a', 'b'], categories=['a', 'b', 'c'])\n>>> bar = pd.Categorical(['d', 'e'], categories=['d', 'e', 'f'])\n>>> pd.crosstab(foo, bar)\ncol_0  d  e\nrow_0\na      1  0\nb      0  1\n>>> pd.crosstab(foo, bar, dropna=False)\ncol_0  d  e  f\nrow_0\na      1  0  0\nb      0  1  0\nc      0  0  0",
    "1.2.1": null,
    "1.2.2": null,
    "1.2.3": null,
    "1.3.1": "/Volumes/JerrySSD/bgp_envs/repos/pandas_87/pandas/core/reshape/pivot.py",
    "1.3.2": [
        "pivot_table(data, values=None, index=None, columns=None, aggfunc='mean', fill_value=None, margins=False, dropna=True, margins_name='All', observed=False) -> 'DataFrame'",
        "_normalize(table, normalize, margins: bool, margins_name='All')",
        "_get_names(arrs, names, prefix: str='row')"
    ],
    "1.4.1": [
        "    def test_crosstab_both_tuple_names(self):\n        # GH 18321\n        s1 = pd.Series(range(3), name=(\"a\", \"b\"))\n        s2 = pd.Series(range(3), name=(\"c\", \"d\"))\n\n        expected = pd.DataFrame(\n            np.eye(3, dtype=\"int64\"),\n            index=pd.Index(range(3), name=(\"a\", \"b\")),\n            columns=pd.Index(range(3), name=(\"c\", \"d\")),\n        )\n        result = crosstab(s1, s2)\n        tm.assert_frame_equal(result, expected)"
    ],
    "1.4.2": [
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_87/pandas/tests/reshape/test_pivot.py"
    ],
    "2.1.1": [
        [
            "E           AssertionError: DataFrame.columns are different\nE           \nE           DataFrame.columns classes are not equivalent\nE           [left]:  MultiIndex([('', 0),\nE                       ('', 1),\nE                       ('', 2)],\nE                      names=[None, ('c', 'd')])\nE           [right]: RangeIndex(start=0, stop=3, step=1, name=('c', 'd'))"
        ]
    ],
    "2.1.2": [
        [
            "self = <pandas.tests.reshape.test_pivot.TestCrosstab object at 0x11e2a3b80>\n\n    def test_crosstab_both_tuple_names(self):\n        # GH 18321\n        s1 = pd.Series(range(3), name=(\"a\", \"b\"))\n        s2 = pd.Series(range(3), name=(\"c\", \"d\"))\n    \n        expected = pd.DataFrame(\n            np.eye(3, dtype=\"int64\"),\n            index=pd.Index(range(3), name=(\"a\", \"b\")),\n            columns=pd.Index(range(3), name=(\"c\", \"d\")),\n        )\n        result = crosstab(s1, s2)\n>       tm.assert_frame_equal(result, expected)\n\npandas/tests/reshape/test_pivot.py:2571: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nl = MultiIndex([('', 0),\n            ('', 1),\n            ('', 2)],\n           names=[None, ('c', 'd')])\nr = RangeIndex(start=0, stop=3, step=1, name=('c', 'd'))\nobj = 'DataFrame.columns'\n\n    def _check_types(l, r, obj=\"Index\"):\n        if exact:\n>           assert_class_equal(l, r, exact=exact, obj=obj)",
            "\npandas/_testing.py:623: AssertionError"
        ]
    ],
    "2.1.3": [
        [
            {
                "index": "0    0\n1    1\n2    2\nName: (a, b), dtype: int64",
                "columns": "0    0\n1    1\n2    2\nName: (c, d), dtype: int64",
                "margins": "False",
                "margins_name": "'All'",
                "dropna": "True",
                "normalize": "False"
            },
            {
                "index": "[0    0\n1    1\n2    2\nName: (a, b), dtype: int64]",
                "columns": "[0    0\n1    1\n2    2\nName: (c, d), dtype: int64]",
                "rownames": "[('a', 'b')]",
                "colnames": "[('c', 'd')]",
                "common_idx": "RangeIndex(start=0, stop=3, step=1)",
                "pass_objs": "[0    0\n1    1\n2    2\nName: (a, b), dtype: int64, 0    0\n1    1\n2    2\nName: (c, d), dtype: int64]",
                "data": "{('a', 'b'): 0    0\n1    1\n2    2\nName: (a, b), dtype: int64, ('c', 'd'): 0    0\n1    1\n2    2\nName: (c, d), dtype: int64}",
                "df": "   a  c __dummy__\n   b  d          \n0  0  0         0\n1  1  1         0\n2  2  2         0",
                "DataFrame": "<class 'pandas.core.frame.DataFrame'>",
                "kwargs": "{'aggfunc': <built-in function len>, 'fill_value': 0}",
                "table": "                   \n('c', 'd')  0  1  2\n(a, b)             \n0           1  0  0\n1           0  1  0\n2           0  0  1",
                "df.pivot_table": "<bound method DataFrame.pivot_table of    a  c __dummy__\n   b  d          \n0  0  0         0\n1  1  1         0\n2  2  2         0>"
            }
        ]
    ],
    "2.1.4": [
        [
            {
                "index": "Series",
                "columns": "Series",
                "margins": "bool",
                "margins_name": "str",
                "dropna": "bool",
                "normalize": "bool"
            },
            {
                "index": "list",
                "columns": "list",
                "rownames": "list",
                "colnames": "list",
                "common_idx": "RangeIndex",
                "pass_objs": "list",
                "data": "dict",
                "df": "DataFrame",
                "DataFrame": "type",
                "kwargs": "dict",
                "table": "DataFrame",
                "df.pivot_table": "method"
            }
        ]
    ],
    "2.1.5": [
        [
            {
                "index": "0    0\n1    1\n2    2\nName: (a, b), dtype: int64",
                "columns": "0    0\n1    1\n2    2\nName: (c, d), dtype: int64",
                "margins": "False",
                "margins_name": "'All'",
                "dropna": "True",
                "normalize": "False"
            },
            {
                "index": "[0    0\n1    1\n2    2\nName: (a, b), dtype: int64]",
                "columns": "[0    0\n1    1\n2    2\nName: (c, d), dtype: int64]",
                "rownames": "[('a', 'b')]",
                "colnames": "[('c', 'd')]",
                "common_idx": "RangeIndex(start=0, stop=3, step=1)",
                "pass_objs": "[0    0\n1    1\n2    2\nName: (a, b), dtype: int64, 0    0\n1    1\n2    2\nName: (c, d), dtype: int64]",
                "data": "{('a', 'b'): 0    0\n1    1\n2    2\nName: (a, b), dtype: int64, ('c', 'd'): 0    0\n1    1\n2    2\nName: (c, d), dtype: int64}",
                "df": "   a  c __dummy__\n   b  d          \n0  0  0         0\n1  1  1         0\n2  2  2         0",
                "DataFrame": "<class 'pandas.core.frame.DataFrame'>",
                "original_df_cols": "MultiIndex([('a', 'b'),\n            ('c', 'd')],\n           )",
                "df.columns": "MultiIndex([(        'a', 'b'),\n            (        'c', 'd'),\n            ('__dummy__',  '')],\n           )",
                "kwargs": "{'aggfunc': <built-in function len>, 'fill_value': 0}",
                "table": "('c', 'd')  0  1  2\n(a, b)             \n0           1  0  0\n1           0  1  0\n2           0  0  1",
                "df.pivot_table": "<bound method DataFrame.pivot_table of    a  c __dummy__\n   b  d          \n0  0  0         0\n1  1  1         0\n2  2  2         0>",
                "table.empty": "False",
                "cols_diff": "('__dummy__', '')"
            }
        ]
    ],
    "2.1.6": [
        [
            {
                "index": "Series",
                "columns": "Series",
                "margins": "bool",
                "margins_name": "str",
                "dropna": "bool",
                "normalize": "bool"
            },
            {
                "index": "list",
                "columns": "list",
                "rownames": "list",
                "colnames": "list",
                "common_idx": "RangeIndex",
                "pass_objs": "list",
                "data": "dict",
                "df": "DataFrame",
                "DataFrame": "type",
                "original_df_cols": "MultiIndex",
                "df.columns": "MultiIndex",
                "kwargs": "dict",
                "table": "DataFrame",
                "df.pivot_table": "method",
                "table.empty": "bool",
                "cols_diff": "tuple"
            }
        ]
    ],
    "3.1.1": [
        "\n"
    ],
    "3.1.2": [
        "\n"
    ]
}