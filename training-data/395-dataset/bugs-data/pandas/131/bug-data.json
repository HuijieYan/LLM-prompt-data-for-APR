{
    "pandas:131": {
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_131/pandas/core/indexes/accessors.py": {
            "buggy_functions": [
                {
                    "function_name": "_delegate_property_get",
                    "function_code": "def _delegate_property_get(self, name):\n    from pandas import Series\n\n    values = self._get_values()\n\n    result = getattr(values, name)\n\n    # maybe need to upcast (ints)\n    if isinstance(result, np.ndarray):\n        if is_integer_dtype(result):\n            result = result.astype(\"int64\")\n    elif not is_list_like(result):\n        return result\n\n    result = np.asarray(result)\n\n    # blow up if we operate on categories\n    if self.orig is not None:\n        result = take_1d(result, self.orig.cat.codes)\n        index = self.orig.index\n    else:\n        index = self._parent.index\n    # return the result as a Series, which is by definition a copy\n    result = Series(result, index=index, name=self.name)\n\n    # setting this object will show a SettingWithCopyWarning/Error\n    result._is_copy = (\n        \"modifications to a property of a datetimelike \"\n        \"object are not supported and are discarded. \"\n        \"Change values on the original.\"\n    )\n\n    return result\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 62,
                    "end_line": 94,
                    "variables": {
                        "values": [
                            65,
                            67
                        ],
                        "self._get_values": [
                            65
                        ],
                        "self": [
                            65,
                            79,
                            80,
                            81,
                            83,
                            85
                        ],
                        "result": [
                            67,
                            70,
                            71,
                            72,
                            73,
                            74,
                            76,
                            80,
                            85,
                            88,
                            94
                        ],
                        "getattr": [
                            67
                        ],
                        "name": [
                            67
                        ],
                        "isinstance": [
                            70
                        ],
                        "np.ndarray": [
                            70
                        ],
                        "np": [
                            76,
                            70
                        ],
                        "is_integer_dtype": [
                            71
                        ],
                        "result.astype": [
                            72
                        ],
                        "is_list_like": [
                            73
                        ],
                        "np.asarray": [
                            76
                        ],
                        "self.orig": [
                            80,
                            81,
                            79
                        ],
                        "take_1d": [
                            80
                        ],
                        "self.orig.cat.codes": [
                            80
                        ],
                        "self.orig.cat": [
                            80
                        ],
                        "index": [
                            81,
                            83,
                            85
                        ],
                        "self.orig.index": [
                            81
                        ],
                        "self._parent.index": [
                            83
                        ],
                        "self._parent": [
                            83
                        ],
                        "Series": [
                            85
                        ],
                        "self.name": [
                            85
                        ],
                        "result._is_copy": [
                            88
                        ]
                    },
                    "filtered_variables": {
                        "values": [
                            65,
                            67
                        ],
                        "self._get_values": [
                            65
                        ],
                        "self": [
                            65,
                            79,
                            80,
                            81,
                            83,
                            85
                        ],
                        "result": [
                            67,
                            70,
                            71,
                            72,
                            73,
                            74,
                            76,
                            80,
                            85,
                            88,
                            94
                        ],
                        "name": [
                            67
                        ],
                        "np.ndarray": [
                            70
                        ],
                        "np": [
                            76,
                            70
                        ],
                        "is_integer_dtype": [
                            71
                        ],
                        "result.astype": [
                            72
                        ],
                        "is_list_like": [
                            73
                        ],
                        "np.asarray": [
                            76
                        ],
                        "self.orig": [
                            80,
                            81,
                            79
                        ],
                        "take_1d": [
                            80
                        ],
                        "self.orig.cat.codes": [
                            80
                        ],
                        "self.orig.cat": [
                            80
                        ],
                        "index": [
                            81,
                            83,
                            85
                        ],
                        "self.orig.index": [
                            81
                        ],
                        "self._parent.index": [
                            83
                        ],
                        "self._parent": [
                            83
                        ],
                        "Series": [
                            85
                        ],
                        "self.name": [
                            85
                        ],
                        "result._is_copy": [
                            88
                        ]
                    },
                    "diff_line_number": 78,
                    "class_data": {
                        "signature": "class Properties(PandasDelegate, PandasObject, NoNewAttributesMixin)",
                        "docstring": null,
                        "constructor_docstring": null,
                        "functions": [
                            "def __init__(self, data, orig):\n    if not isinstance(data, ABCSeries):\n        raise TypeError('cannot convert an object of type {0} to a datetimelike index'.format(type(data)))\n    self._parent = data\n    self.orig = orig\n    self.name = getattr(data, 'name', None)\n    self._freeze()",
                            "def _get_values(self):\n    data = self._parent\n    if is_datetime64_dtype(data.dtype):\n        return DatetimeIndex(data, copy=False, name=self.name)\n    elif is_datetime64tz_dtype(data.dtype):\n        return DatetimeIndex(data, copy=False, name=self.name)\n    elif is_timedelta64_dtype(data.dtype):\n        return TimedeltaIndex(data, copy=False, name=self.name)\n    else:\n        if is_period_arraylike(data):\n            return PeriodArray(data, copy=False)\n        if is_datetime_arraylike(data):\n            return DatetimeIndex(data, copy=False, name=self.name)\n    raise TypeError('cannot convert an object of type {0} to a datetimelike index'.format(type(data)))",
                            "def _delegate_property_get(self, name):\n    from pandas import Series\n    values = self._get_values()\n    result = getattr(values, name)\n    if isinstance(result, np.ndarray):\n        if is_integer_dtype(result):\n            result = result.astype('int64')\n    elif not is_list_like(result):\n        return result\n    result = np.asarray(result)\n    if self.orig is not None:\n        result = take_1d(result, self.orig.cat.codes)\n        index = self.orig.index\n    else:\n        index = self._parent.index\n    result = Series(result, index=index, name=self.name)\n    result._is_copy = 'modifications to a property of a datetimelike object are not supported and are discarded. Change values on the original.'\n    return result",
                            "def _delegate_property_set(self, name, value, *args, **kwargs):\n    raise ValueError('modifications to a property of a datetimelike object are not supported. Change values on the original.')",
                            "def _delegate_method(self, name, *args, **kwargs):\n    from pandas import Series\n    values = self._get_values()\n    method = getattr(values, name)\n    result = method(*args, **kwargs)\n    if not is_list_like(result):\n        return result\n    result = Series(result, index=self._parent.index, name=self.name)\n    result._is_copy = 'modifications to a method of a datetimelike object are not supported and are discarded. Change values on the original.'\n    return result"
                        ],
                        "constructor_variables": [
                            "orig",
                            "_parent",
                            "name"
                        ],
                        "class_level_variables": [],
                        "class_decorators": [],
                        "function_signatures": [
                            "__init__(self, data, orig)",
                            "_get_values(self)",
                            "_delegate_property_get(self, name)",
                            "_delegate_property_set(self, name, value, *args, **kwargs)",
                            "_delegate_method(self, name, *args, **kwargs)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "__new__",
                    "function_code": "def __new__(cls, data):\n    # CombinedDatetimelikeProperties isn't really instantiated. Instead\n    # we need to choose which parent (datetime or timedelta) is\n    # appropriate. Since we're checking the dtypes anyway, we'll just\n    # do all the validation here.\n    from pandas import Series\n\n    if not isinstance(data, ABCSeries):\n        raise TypeError(\n            \"cannot convert an object of type {0} to a \"\n            \"datetimelike index\".format(type(data))\n        )\n\n    orig = data if is_categorical_dtype(data) else None\n    if orig is not None:\n        data = Series(orig.values.categories, name=orig.name, copy=False)\n\n    if is_datetime64_dtype(data.dtype):\n        return DatetimeProperties(data, orig)\n    elif is_datetime64tz_dtype(data.dtype):\n        return DatetimeProperties(data, orig)\n    elif is_timedelta64_dtype(data.dtype):\n        return TimedeltaProperties(data, orig)\n    elif is_period_arraylike(data):\n        return PeriodProperties(data, orig)\n    elif is_datetime_arraylike(data):\n        return DatetimeProperties(data, orig)\n\n    raise AttributeError(\"Can only use .dt accessor with datetimelike values\")\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 312,
                    "end_line": 340,
                    "variables": {
                        "isinstance": [
                            319
                        ],
                        "data": [
                            322,
                            325,
                            327,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338,
                            319
                        ],
                        "ABCSeries": [
                            319
                        ],
                        "TypeError": [
                            320
                        ],
                        "format": [
                            321
                        ],
                        "type": [
                            322
                        ],
                        "orig": [
                            325,
                            326,
                            327,
                            330,
                            332,
                            334,
                            336,
                            338
                        ],
                        "is_categorical_dtype": [
                            325
                        ],
                        "Series": [
                            327
                        ],
                        "orig.values.categories": [
                            327
                        ],
                        "orig.values": [
                            327
                        ],
                        "orig.name": [
                            327
                        ],
                        "is_datetime64_dtype": [
                            329
                        ],
                        "data.dtype": [
                            329,
                            331,
                            333
                        ],
                        "DatetimeProperties": [
                            330,
                            332,
                            338
                        ],
                        "is_datetime64tz_dtype": [
                            331
                        ],
                        "is_timedelta64_dtype": [
                            333
                        ],
                        "TimedeltaProperties": [
                            334
                        ],
                        "is_period_arraylike": [
                            335
                        ],
                        "PeriodProperties": [
                            336
                        ],
                        "is_datetime_arraylike": [
                            337
                        ],
                        "AttributeError": [
                            340
                        ]
                    },
                    "filtered_variables": {
                        "data": [
                            322,
                            325,
                            327,
                            329,
                            330,
                            331,
                            332,
                            333,
                            334,
                            335,
                            336,
                            337,
                            338,
                            319
                        ],
                        "ABCSeries": [
                            319
                        ],
                        "orig": [
                            325,
                            326,
                            327,
                            330,
                            332,
                            334,
                            336,
                            338
                        ],
                        "is_categorical_dtype": [
                            325
                        ],
                        "Series": [
                            327
                        ],
                        "orig.values.categories": [
                            327
                        ],
                        "orig.values": [
                            327
                        ],
                        "orig.name": [
                            327
                        ],
                        "is_datetime64_dtype": [
                            329
                        ],
                        "data.dtype": [
                            329,
                            331,
                            333
                        ],
                        "DatetimeProperties": [
                            330,
                            332,
                            338
                        ],
                        "is_datetime64tz_dtype": [
                            331
                        ],
                        "is_timedelta64_dtype": [
                            333
                        ],
                        "TimedeltaProperties": [
                            334
                        ],
                        "is_period_arraylike": [
                            335
                        ],
                        "PeriodProperties": [
                            336
                        ],
                        "is_datetime_arraylike": [
                            337
                        ]
                    },
                    "diff_line_number": 327,
                    "class_data": {
                        "signature": "class CombinedDatetimelikeProperties(DatetimeProperties, TimedeltaProperties, PeriodProperties)",
                        "docstring": null,
                        "constructor_docstring": null,
                        "functions": [
                            "def __new__(cls, data):\n    from pandas import Series\n    if not isinstance(data, ABCSeries):\n        raise TypeError('cannot convert an object of type {0} to a datetimelike index'.format(type(data)))\n    orig = data if is_categorical_dtype(data) else None\n    if orig is not None:\n        data = Series(orig.values.categories, name=orig.name, copy=False)\n    if is_datetime64_dtype(data.dtype):\n        return DatetimeProperties(data, orig)\n    elif is_datetime64tz_dtype(data.dtype):\n        return DatetimeProperties(data, orig)\n    elif is_timedelta64_dtype(data.dtype):\n        return TimedeltaProperties(data, orig)\n    elif is_period_arraylike(data):\n        return PeriodProperties(data, orig)\n    elif is_datetime_arraylike(data):\n        return DatetimeProperties(data, orig)\n    raise AttributeError('Can only use .dt accessor with datetimelike values')"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [],
                        "class_decorators": [],
                        "function_signatures": [
                            "__new__(cls, data)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                }
            ],
            "snippets": [
                {
                    "snippet_code": "from pandas.core.algorithms import take_1d",
                    "start_line": 19,
                    "end_line": 19
                }
            ],
            "inscope_functions": [
                "def __init__(self, data, orig):\n    if not isinstance(data, ABCSeries):\n        raise TypeError(\n            \"cannot convert an object of type {0} to a \"\n            \"datetimelike index\".format(type(data))\n        )\n\n    self._parent = data\n    self.orig = orig\n    self.name = getattr(data, \"name\", None)\n    self._freeze()",
                "def _get_values(self):\n    data = self._parent\n    if is_datetime64_dtype(data.dtype):\n        return DatetimeIndex(data, copy=False, name=self.name)\n\n    elif is_datetime64tz_dtype(data.dtype):\n        return DatetimeIndex(data, copy=False, name=self.name)\n\n    elif is_timedelta64_dtype(data.dtype):\n        return TimedeltaIndex(data, copy=False, name=self.name)\n\n    else:\n        if is_period_arraylike(data):\n            # TODO: use to_period_array\n            return PeriodArray(data, copy=False)\n        if is_datetime_arraylike(data):\n            return DatetimeIndex(data, copy=False, name=self.name)\n\n    raise TypeError(\n        \"cannot convert an object of type {0} to a \"\n        \"datetimelike index\".format(type(data))\n    )",
                "def _delegate_property_get(self, name):\n    from pandas import Series\n\n    values = self._get_values()\n\n    result = getattr(values, name)\n\n    # maybe need to upcast (ints)\n    if isinstance(result, np.ndarray):\n        if is_integer_dtype(result):\n            result = result.astype(\"int64\")\n    elif not is_list_like(result):\n        return result\n\n    result = np.asarray(result)\n\n    # blow up if we operate on categories\n    if self.orig is not None:\n        result = take_1d(result, self.orig.cat.codes)\n        index = self.orig.index\n    else:\n        index = self._parent.index\n    # return the result as a Series, which is by definition a copy\n    result = Series(result, index=index, name=self.name)\n\n    # setting this object will show a SettingWithCopyWarning/Error\n    result._is_copy = (\n        \"modifications to a property of a datetimelike \"\n        \"object are not supported and are discarded. \"\n        \"Change values on the original.\"\n    )\n\n    return result",
                "def _delegate_property_set(self, name, value, *args, **kwargs):\n    raise ValueError(\n        \"modifications to a property of a datetimelike \"\n        \"object are not supported. Change values on the \"\n        \"original.\"\n    )",
                "def _delegate_method(self, name, *args, **kwargs):\n    from pandas import Series\n\n    values = self._get_values()\n\n    method = getattr(values, name)\n    result = method(*args, **kwargs)\n\n    if not is_list_like(result):\n        return result\n\n    result = Series(result, index=self._parent.index, name=self.name)\n\n    # setting this object will show a SettingWithCopyWarning/Error\n    result._is_copy = (\n        \"modifications to a method of a datetimelike \"\n        \"object are not supported and are discarded. \"\n        \"Change values on the original.\"\n    )\n\n    return result",
                "def to_pydatetime(self):\n    \"\"\"\n    Return the data as an array of native Python datetime objects.\n\n    Timezone information is retained if present.\n\n    .. warning::\n\n       Python's datetime uses microsecond resolution, which is lower than\n       pandas (nanosecond). The values are truncated.\n\n    Returns\n    -------\n    numpy.ndarray\n        Object dtype array containing native Python datetime objects.\n\n    See Also\n    --------\n    datetime.datetime : Standard library value for a datetime.\n\n    Examples\n    --------\n    >>> s = pd.Series(pd.date_range('20180310', periods=2))\n    >>> s\n    0   2018-03-10\n    1   2018-03-11\n    dtype: datetime64[ns]\n\n    >>> s.dt.to_pydatetime()\n    array([datetime.datetime(2018, 3, 10, 0, 0),\n           datetime.datetime(2018, 3, 11, 0, 0)], dtype=object)\n\n    pandas' nanosecond precision is truncated to microseconds.\n\n    >>> s = pd.Series(pd.date_range('20180310', periods=2, freq='ns'))\n    >>> s\n    0   2018-03-10 00:00:00.000000000\n    1   2018-03-10 00:00:00.000000001\n    dtype: datetime64[ns]\n\n    >>> s.dt.to_pydatetime()\n    array([datetime.datetime(2018, 3, 10, 0, 0),\n           datetime.datetime(2018, 3, 10, 0, 0)], dtype=object)\n    \"\"\"\n    return self._get_values().to_pydatetime()",
                "@property\ndef freq(self):\n    return self._get_values().inferred_freq",
                "def to_pytimedelta(self):\n    \"\"\"\n    Return an array of native `datetime.timedelta` objects.\n\n    Python's standard `datetime` library uses a different representation\n    timedelta's. This method converts a Series of pandas Timedeltas\n    to `datetime.timedelta` format with the same length as the original\n    Series.\n\n    Returns\n    -------\n    a : numpy.ndarray\n        Array of 1D containing data with `datetime.timedelta` type.\n\n    See Also\n    --------\n    datetime.timedelta\n\n    Examples\n    --------\n    >>> s = pd.Series(pd.to_timedelta(np.arange(5), unit='d'))\n    >>> s\n    0   0 days\n    1   1 days\n    2   2 days\n    3   3 days\n    4   4 days\n    dtype: timedelta64[ns]\n\n    >>> s.dt.to_pytimedelta()\n    array([datetime.timedelta(0), datetime.timedelta(1),\n           datetime.timedelta(2), datetime.timedelta(3),\n           datetime.timedelta(4)], dtype=object)\n    \"\"\"\n    return self._get_values().to_pytimedelta()",
                "@property\ndef components(self):\n    \"\"\"\n    Return a Dataframe of the components of the Timedeltas.\n\n    Returns\n    -------\n    DataFrame\n\n    Examples\n    --------\n    >>> s = pd.Series(pd.to_timedelta(np.arange(5), unit='s'))\n    >>> s\n    0   00:00:00\n    1   00:00:01\n    2   00:00:02\n    3   00:00:03\n    4   00:00:04\n    dtype: timedelta64[ns]\n    >>> s.dt.components\n       days  hours  minutes  seconds  milliseconds  microseconds  nanoseconds\n    0     0      0        0        0             0             0            0\n    1     0      0        0        1             0             0            0\n    2     0      0        0        2             0             0            0\n    3     0      0        0        3             0             0            0\n    4     0      0        0        4             0             0            0\n    \"\"\"  # noqa: E501\n    return self._get_values().components.set_index(self._parent.index)",
                "@property\ndef freq(self):\n    return self._get_values().inferred_freq",
                "def __new__(cls, data):\n    # CombinedDatetimelikeProperties isn't really instantiated. Instead\n    # we need to choose which parent (datetime or timedelta) is\n    # appropriate. Since we're checking the dtypes anyway, we'll just\n    # do all the validation here.\n    from pandas import Series\n\n    if not isinstance(data, ABCSeries):\n        raise TypeError(\n            \"cannot convert an object of type {0} to a \"\n            \"datetimelike index\".format(type(data))\n        )\n\n    orig = data if is_categorical_dtype(data) else None\n    if orig is not None:\n        data = Series(orig.values.categories, name=orig.name, copy=False)\n\n    if is_datetime64_dtype(data.dtype):\n        return DatetimeProperties(data, orig)\n    elif is_datetime64tz_dtype(data.dtype):\n        return DatetimeProperties(data, orig)\n    elif is_timedelta64_dtype(data.dtype):\n        return TimedeltaProperties(data, orig)\n    elif is_period_arraylike(data):\n        return PeriodProperties(data, orig)\n    elif is_datetime_arraylike(data):\n        return DatetimeProperties(data, orig)\n\n    raise AttributeError(\"Can only use .dt accessor with datetimelike values\")"
            ],
            "inscope_function_signatures": [
                "__init__(self, data, orig)",
                "_get_values(self)",
                "_delegate_property_get(self, name)",
                "_delegate_property_set(self, name, value, *args, **kwargs)",
                "_delegate_method(self, name, *args, **kwargs)",
                "to_pydatetime(self)",
                "freq(self)",
                "to_pytimedelta(self)",
                "components(self)",
                "freq(self)",
                "__new__(cls, data)"
            ],
            "variables_in_file": {
                "PandasDelegate": [
                    26
                ],
                "PandasObject": [
                    26
                ],
                "NoNewAttributesMixin": [
                    26
                ],
                "isinstance": [
                    28,
                    70,
                    319
                ],
                "data": [
                    28,
                    31,
                    34,
                    36,
                    40,
                    41,
                    42,
                    44,
                    45,
                    47,
                    48,
                    51,
                    53,
                    54,
                    55,
                    59,
                    319,
                    322,
                    325,
                    327,
                    329,
                    330,
                    331,
                    332,
                    333,
                    334,
                    335,
                    336,
                    337,
                    338
                ],
                "ABCSeries": [
                    28,
                    319
                ],
                "TypeError": [
                    320,
                    57,
                    29
                ],
                "format": [
                    321,
                    58,
                    30
                ],
                "type": [
                    322,
                    59,
                    31
                ],
                "self._parent": [
                    34,
                    40,
                    114,
                    83,
                    281
                ],
                "self": [
                    281,
                    285,
                    34,
                    35,
                    36,
                    37,
                    40,
                    42,
                    45,
                    48,
                    55,
                    190,
                    65,
                    194,
                    79,
                    80,
                    81,
                    83,
                    85,
                    106,
                    114,
                    252
                ],
                "self.orig": [
                    80,
                    81,
                    35,
                    79
                ],
                "orig": [
                    35,
                    325,
                    326,
                    327,
                    330,
                    332,
                    334,
                    336,
                    338
                ],
                "self.name": [
                    36,
                    42,
                    45,
                    48,
                    114,
                    85,
                    55
                ],
                "getattr": [
                    108,
                    67,
                    36
                ],
                "self._freeze": [
                    37
                ],
                "is_datetime64_dtype": [
                    329,
                    41
                ],
                "data.dtype": [
                    329,
                    41,
                    331,
                    44,
                    333,
                    47
                ],
                "DatetimeIndex": [
                    42,
                    45,
                    55
                ],
                "is_datetime64tz_dtype": [
                    331,
                    44
                ],
                "is_timedelta64_dtype": [
                    333,
                    47
                ],
                "TimedeltaIndex": [
                    48
                ],
                "is_period_arraylike": [
                    51,
                    335
                ],
                "PeriodArray": [
                    289,
                    292,
                    53
                ],
                "is_datetime_arraylike": [
                    337,
                    54
                ],
                "values": [
                    65,
                    106,
                    67,
                    108
                ],
                "self._get_values": [
                    65,
                    194,
                    106,
                    281,
                    252,
                    285,
                    190
                ],
                "result": [
                    67,
                    70,
                    71,
                    72,
                    73,
                    74,
                    76,
                    109,
                    111,
                    80,
                    112,
                    114,
                    85,
                    117,
                    88,
                    123,
                    94
                ],
                "name": [
                    67,
                    108
                ],
                "np.ndarray": [
                    70
                ],
                "np": [
                    76,
                    70
                ],
                "is_integer_dtype": [
                    71
                ],
                "result.astype": [
                    72
                ],
                "is_list_like": [
                    73,
                    111
                ],
                "np.asarray": [
                    76
                ],
                "take_1d": [
                    80
                ],
                "self.orig.cat.codes": [
                    80
                ],
                "self.orig.cat": [
                    80
                ],
                "index": [
                    81,
                    83,
                    85
                ],
                "self.orig.index": [
                    81
                ],
                "self._parent.index": [
                    281,
                    114,
                    83
                ],
                "Series": [
                    114,
                    85,
                    327
                ],
                "result._is_copy": [
                    88,
                    117
                ],
                "ValueError": [
                    97
                ],
                "method": [
                    108,
                    109
                ],
                "args": [
                    109
                ],
                "kwargs": [
                    109
                ],
                "Properties": [
                    132,
                    205,
                    294
                ],
                "to_pydatetime": [
                    190
                ],
                "inferred_freq": [
                    194,
                    285
                ],
                "property": [
                    192,
                    283,
                    254
                ],
                "delegate_names": [
                    288,
                    129,
                    291,
                    197,
                    200,
                    126
                ],
                "DatetimeArray": [
                    130,
                    127
                ],
                "DatetimeArray._datetimelike_ops": [
                    127
                ],
                "DatetimeArray._datetimelike_methods": [
                    130
                ],
                "to_pytimedelta": [
                    252
                ],
                "components.set_index": [
                    281
                ],
                "components": [
                    281
                ],
                "TimedeltaArray": [
                    201,
                    202,
                    198
                ],
                "TimedeltaArray._datetimelike_ops": [
                    198
                ],
                "TimedeltaArray._datetimelike_methods": [
                    202
                ],
                "PeriodArray._datetimelike_ops": [
                    289
                ],
                "PeriodArray._datetimelike_methods": [
                    292
                ],
                "DatetimeProperties": [
                    330,
                    332,
                    338,
                    310
                ],
                "TimedeltaProperties": [
                    334,
                    310
                ],
                "PeriodProperties": [
                    336,
                    310
                ],
                "is_categorical_dtype": [
                    325
                ],
                "orig.values.categories": [
                    327
                ],
                "orig.values": [
                    327
                ],
                "orig.name": [
                    327
                ],
                "AttributeError": [
                    340
                ]
            },
            "filtered_variables_in_file": {
                "PandasDelegate": [
                    26
                ],
                "PandasObject": [
                    26
                ],
                "NoNewAttributesMixin": [
                    26
                ],
                "data": [
                    28,
                    31,
                    34,
                    36,
                    40,
                    41,
                    42,
                    44,
                    45,
                    47,
                    48,
                    51,
                    53,
                    54,
                    55,
                    59,
                    319,
                    322,
                    325,
                    327,
                    329,
                    330,
                    331,
                    332,
                    333,
                    334,
                    335,
                    336,
                    337,
                    338
                ],
                "ABCSeries": [
                    28,
                    319
                ],
                "self._parent": [
                    34,
                    40,
                    114,
                    83,
                    281
                ],
                "self": [
                    281,
                    285,
                    34,
                    35,
                    36,
                    37,
                    40,
                    42,
                    45,
                    48,
                    55,
                    190,
                    65,
                    194,
                    79,
                    80,
                    81,
                    83,
                    85,
                    106,
                    114,
                    252
                ],
                "self.orig": [
                    80,
                    81,
                    35,
                    79
                ],
                "orig": [
                    35,
                    325,
                    326,
                    327,
                    330,
                    332,
                    334,
                    336,
                    338
                ],
                "self.name": [
                    36,
                    42,
                    45,
                    48,
                    114,
                    85,
                    55
                ],
                "self._freeze": [
                    37
                ],
                "is_datetime64_dtype": [
                    329,
                    41
                ],
                "data.dtype": [
                    329,
                    41,
                    331,
                    44,
                    333,
                    47
                ],
                "DatetimeIndex": [
                    42,
                    45,
                    55
                ],
                "is_datetime64tz_dtype": [
                    331,
                    44
                ],
                "is_timedelta64_dtype": [
                    333,
                    47
                ],
                "TimedeltaIndex": [
                    48
                ],
                "is_period_arraylike": [
                    51,
                    335
                ],
                "PeriodArray": [
                    289,
                    292,
                    53
                ],
                "is_datetime_arraylike": [
                    337,
                    54
                ],
                "values": [
                    65,
                    106,
                    67,
                    108
                ],
                "self._get_values": [
                    65,
                    194,
                    106,
                    281,
                    252,
                    285,
                    190
                ],
                "result": [
                    67,
                    70,
                    71,
                    72,
                    73,
                    74,
                    76,
                    109,
                    111,
                    80,
                    112,
                    114,
                    85,
                    117,
                    88,
                    123,
                    94
                ],
                "name": [
                    67,
                    108
                ],
                "np.ndarray": [
                    70
                ],
                "np": [
                    76,
                    70
                ],
                "is_integer_dtype": [
                    71
                ],
                "result.astype": [
                    72
                ],
                "is_list_like": [
                    73,
                    111
                ],
                "np.asarray": [
                    76
                ],
                "take_1d": [
                    80
                ],
                "self.orig.cat.codes": [
                    80
                ],
                "self.orig.cat": [
                    80
                ],
                "index": [
                    81,
                    83,
                    85
                ],
                "self.orig.index": [
                    81
                ],
                "self._parent.index": [
                    281,
                    114,
                    83
                ],
                "Series": [
                    114,
                    85,
                    327
                ],
                "result._is_copy": [
                    88,
                    117
                ],
                "method": [
                    108,
                    109
                ],
                "args": [
                    109
                ],
                "kwargs": [
                    109
                ],
                "Properties": [
                    132,
                    205,
                    294
                ],
                "to_pydatetime": [
                    190
                ],
                "inferred_freq": [
                    194,
                    285
                ],
                "delegate_names": [
                    288,
                    129,
                    291,
                    197,
                    200,
                    126
                ],
                "DatetimeArray": [
                    130,
                    127
                ],
                "DatetimeArray._datetimelike_ops": [
                    127
                ],
                "DatetimeArray._datetimelike_methods": [
                    130
                ],
                "to_pytimedelta": [
                    252
                ],
                "components.set_index": [
                    281
                ],
                "components": [
                    281
                ],
                "TimedeltaArray": [
                    201,
                    202,
                    198
                ],
                "TimedeltaArray._datetimelike_ops": [
                    198
                ],
                "TimedeltaArray._datetimelike_methods": [
                    202
                ],
                "PeriodArray._datetimelike_ops": [
                    289
                ],
                "PeriodArray._datetimelike_methods": [
                    292
                ],
                "DatetimeProperties": [
                    330,
                    332,
                    338,
                    310
                ],
                "TimedeltaProperties": [
                    334,
                    310
                ],
                "PeriodProperties": [
                    336,
                    310
                ],
                "is_categorical_dtype": [
                    325
                ],
                "orig.values.categories": [
                    327
                ],
                "orig.values": [
                    327
                ],
                "orig.name": [
                    327
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_131/pandas/tests/series/test_datetime_values.py",
                "test_function": "test_dt_tz_localize_categorical",
                "test_function_code": "    def test_dt_tz_localize_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_localize(tz)\n        expected = datetimes.dt.tz_localize(tz)\n        tm.assert_series_equal(result, expected)",
                "test_error": "AssertionError: Series are different  Series length are different [left]:  2, RangeIndex(start=0, stop=2, step=1) [right]: 3, RangeIndex(start=0, stop=3, step=1)",
                "full_test_error": "self = <pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues object at 0x119778f70>\ntz_aware_fixture = 'UTC'\n\n    def test_dt_tz_localize_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_localize(tz)\n        expected = datetimes.dt.tz_localize(tz)\n>       tm.assert_series_equal(result, expected)\nE       AssertionError: Series are different\nE       \nE       Series length are different\nE       [left]:  2, RangeIndex(start=0, stop=2, step=1)\nE       [right]: 3, RangeIndex(start=0, stop=3, step=1)\n\npandas/tests/series/test_datetime_values.py:356: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_131/pandas/tests/series/test_datetime_values.py",
                "test_function": "test_dt_tz_localize_categorical",
                "test_function_code": "    def test_dt_tz_localize_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_localize(tz)\n        expected = datetimes.dt.tz_localize(tz)\n        tm.assert_series_equal(result, expected)",
                "test_error": "AssertionError: Series are different  Series length are different [left]:  2, RangeIndex(start=0, stop=2, step=1) [right]: 3, RangeIndex(start=0, stop=3, step=1)",
                "full_test_error": "self = <pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues object at 0x1197ba5b0>\ntz_aware_fixture = 'US/Eastern'\n\n    def test_dt_tz_localize_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_localize(tz)\n        expected = datetimes.dt.tz_localize(tz)\n>       tm.assert_series_equal(result, expected)\nE       AssertionError: Series are different\nE       \nE       Series length are different\nE       [left]:  2, RangeIndex(start=0, stop=2, step=1)\nE       [right]: 3, RangeIndex(start=0, stop=3, step=1)\n\npandas/tests/series/test_datetime_values.py:356: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_131/pandas/tests/series/test_datetime_values.py",
                "test_function": "test_dt_tz_localize_categorical",
                "test_function_code": "    def test_dt_tz_localize_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_localize(tz)\n        expected = datetimes.dt.tz_localize(tz)\n        tm.assert_series_equal(result, expected)",
                "test_error": "AssertionError: Series are different  Series length are different [left]:  2, RangeIndex(start=0, stop=2, step=1) [right]: 3, RangeIndex(start=0, stop=3, step=1)",
                "full_test_error": "self = <pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues object at 0x11976b4c0>\ntz_aware_fixture = 'Asia/Tokyo'\n\n    def test_dt_tz_localize_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_localize(tz)\n        expected = datetimes.dt.tz_localize(tz)\n>       tm.assert_series_equal(result, expected)\nE       AssertionError: Series are different\nE       \nE       Series length are different\nE       [left]:  2, RangeIndex(start=0, stop=2, step=1)\nE       [right]: 3, RangeIndex(start=0, stop=3, step=1)\n\npandas/tests/series/test_datetime_values.py:356: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_131/pandas/tests/series/test_datetime_values.py",
                "test_function": "test_dt_tz_localize_categorical",
                "test_function_code": "    def test_dt_tz_localize_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_localize(tz)\n        expected = datetimes.dt.tz_localize(tz)\n        tm.assert_series_equal(result, expected)",
                "test_error": "AssertionError: Series are different  Series length are different [left]:  2, RangeIndex(start=0, stop=2, step=1) [right]: 3, RangeIndex(start=0, stop=3, step=1)",
                "full_test_error": "self = <pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues object at 0x11984ec10>\ntz_aware_fixture = 'dateutil/US/Pacific'\n\n    def test_dt_tz_localize_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_localize(tz)\n        expected = datetimes.dt.tz_localize(tz)\n>       tm.assert_series_equal(result, expected)\nE       AssertionError: Series are different\nE       \nE       Series length are different\nE       [left]:  2, RangeIndex(start=0, stop=2, step=1)\nE       [right]: 3, RangeIndex(start=0, stop=3, step=1)\n\npandas/tests/series/test_datetime_values.py:356: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_131/pandas/tests/series/test_datetime_values.py",
                "test_function": "test_dt_tz_localize_categorical",
                "test_function_code": "    def test_dt_tz_localize_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_localize(tz)\n        expected = datetimes.dt.tz_localize(tz)\n        tm.assert_series_equal(result, expected)",
                "test_error": "AssertionError: Series are different  Series length are different [left]:  2, RangeIndex(start=0, stop=2, step=1) [right]: 3, RangeIndex(start=0, stop=3, step=1)",
                "full_test_error": "self = <pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues object at 0x119a5d7c0>\ntz_aware_fixture = 'dateutil/Asia/Singapore'\n\n    def test_dt_tz_localize_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_localize(tz)\n        expected = datetimes.dt.tz_localize(tz)\n>       tm.assert_series_equal(result, expected)\nE       AssertionError: Series are different\nE       \nE       Series length are different\nE       [left]:  2, RangeIndex(start=0, stop=2, step=1)\nE       [right]: 3, RangeIndex(start=0, stop=3, step=1)\n\npandas/tests/series/test_datetime_values.py:356: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_131/pandas/tests/series/test_datetime_values.py",
                "test_function": "test_dt_tz_localize_categorical",
                "test_function_code": "    def test_dt_tz_localize_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_localize(tz)\n        expected = datetimes.dt.tz_localize(tz)\n        tm.assert_series_equal(result, expected)",
                "test_error": "AssertionError: Series are different  Series length are different [left]:  2, RangeIndex(start=0, stop=2, step=1) [right]: 3, RangeIndex(start=0, stop=3, step=1)",
                "full_test_error": "self = <pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues object at 0x119835f10>\ntz_aware_fixture = tzutc()\n\n    def test_dt_tz_localize_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_localize(tz)\n        expected = datetimes.dt.tz_localize(tz)\n>       tm.assert_series_equal(result, expected)\nE       AssertionError: Series are different\nE       \nE       Series length are different\nE       [left]:  2, RangeIndex(start=0, stop=2, step=1)\nE       [right]: 3, RangeIndex(start=0, stop=3, step=1)\n\npandas/tests/series/test_datetime_values.py:356: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_131/pandas/tests/series/test_datetime_values.py",
                "test_function": "test_dt_tz_localize_categorical",
                "test_function_code": "    def test_dt_tz_localize_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_localize(tz)\n        expected = datetimes.dt.tz_localize(tz)\n        tm.assert_series_equal(result, expected)",
                "test_error": "AssertionError: Series are different  Series length are different [left]:  2, RangeIndex(start=0, stop=2, step=1) [right]: 3, RangeIndex(start=0, stop=3, step=1)",
                "full_test_error": "self = <pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues object at 0x119847a60>\ntz_aware_fixture = tzlocal()\n\n    def test_dt_tz_localize_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_localize(tz)\n        expected = datetimes.dt.tz_localize(tz)\n>       tm.assert_series_equal(result, expected)\nE       AssertionError: Series are different\nE       \nE       Series length are different\nE       [left]:  2, RangeIndex(start=0, stop=2, step=1)\nE       [right]: 3, RangeIndex(start=0, stop=3, step=1)\n\npandas/tests/series/test_datetime_values.py:356: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_131/pandas/tests/series/test_datetime_values.py",
                "test_function": "test_dt_tz_localize_categorical",
                "test_function_code": "    def test_dt_tz_localize_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_localize(tz)\n        expected = datetimes.dt.tz_localize(tz)\n        tm.assert_series_equal(result, expected)",
                "test_error": "AssertionError: Series are different  Series length are different [left]:  2, RangeIndex(start=0, stop=2, step=1) [right]: 3, RangeIndex(start=0, stop=3, step=1)",
                "full_test_error": "self = <pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues object at 0x119749e80>\ntz_aware_fixture = pytz.FixedOffset(300)\n\n    def test_dt_tz_localize_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_localize(tz)\n        expected = datetimes.dt.tz_localize(tz)\n>       tm.assert_series_equal(result, expected)\nE       AssertionError: Series are different\nE       \nE       Series length are different\nE       [left]:  2, RangeIndex(start=0, stop=2, step=1)\nE       [right]: 3, RangeIndex(start=0, stop=3, step=1)\n\npandas/tests/series/test_datetime_values.py:356: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_131/pandas/tests/series/test_datetime_values.py",
                "test_function": "test_dt_tz_localize_categorical",
                "test_function_code": "    def test_dt_tz_localize_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_localize(tz)\n        expected = datetimes.dt.tz_localize(tz)\n        tm.assert_series_equal(result, expected)",
                "test_error": "AssertionError: Series are different  Series length are different [left]:  2, RangeIndex(start=0, stop=2, step=1) [right]: 3, RangeIndex(start=0, stop=3, step=1)",
                "full_test_error": "self = <pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues object at 0x119780460>\ntz_aware_fixture = <UTC>\n\n    def test_dt_tz_localize_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_localize(tz)\n        expected = datetimes.dt.tz_localize(tz)\n>       tm.assert_series_equal(result, expected)\nE       AssertionError: Series are different\nE       \nE       Series length are different\nE       [left]:  2, RangeIndex(start=0, stop=2, step=1)\nE       [right]: 3, RangeIndex(start=0, stop=3, step=1)\n\npandas/tests/series/test_datetime_values.py:356: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_131/pandas/tests/series/test_datetime_values.py",
                "test_function": "test_dt_tz_localize_categorical",
                "test_function_code": "    def test_dt_tz_localize_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_localize(tz)\n        expected = datetimes.dt.tz_localize(tz)\n        tm.assert_series_equal(result, expected)",
                "test_error": "AssertionError: Series are different  Series length are different [left]:  2, RangeIndex(start=0, stop=2, step=1) [right]: 3, RangeIndex(start=0, stop=3, step=1)",
                "full_test_error": "self = <pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues object at 0x11982a5b0>\ntz_aware_fixture = pytz.FixedOffset(-300)\n\n    def test_dt_tz_localize_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_localize(tz)\n        expected = datetimes.dt.tz_localize(tz)\n>       tm.assert_series_equal(result, expected)\nE       AssertionError: Series are different\nE       \nE       Series length are different\nE       [left]:  2, RangeIndex(start=0, stop=2, step=1)\nE       [right]: 3, RangeIndex(start=0, stop=3, step=1)\n\npandas/tests/series/test_datetime_values.py:356: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_131/pandas/tests/series/test_datetime_values.py",
                "test_function": "test_dt_tz_localize_categorical",
                "test_function_code": "    def test_dt_tz_localize_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_localize(tz)\n        expected = datetimes.dt.tz_localize(tz)\n        tm.assert_series_equal(result, expected)",
                "test_error": "AssertionError: Series are different  Series length are different [left]:  2, RangeIndex(start=0, stop=2, step=1) [right]: 3, RangeIndex(start=0, stop=3, step=1)",
                "full_test_error": "self = <pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues object at 0x1196f6430>\ntz_aware_fixture = datetime.timezone.utc\n\n    def test_dt_tz_localize_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_localize(tz)\n        expected = datetimes.dt.tz_localize(tz)\n>       tm.assert_series_equal(result, expected)\nE       AssertionError: Series are different\nE       \nE       Series length are different\nE       [left]:  2, RangeIndex(start=0, stop=2, step=1)\nE       [right]: 3, RangeIndex(start=0, stop=3, step=1)\n\npandas/tests/series/test_datetime_values.py:356: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_131/pandas/tests/series/test_datetime_values.py",
                "test_function": "test_dt_tz_localize_categorical",
                "test_function_code": "    def test_dt_tz_localize_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_localize(tz)\n        expected = datetimes.dt.tz_localize(tz)\n        tm.assert_series_equal(result, expected)",
                "test_error": "AssertionError: Series are different  Series length are different [left]:  2, RangeIndex(start=0, stop=2, step=1) [right]: 3, RangeIndex(start=0, stop=3, step=1)",
                "full_test_error": "self = <pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues object at 0x1197809d0>\ntz_aware_fixture = datetime.timezone(datetime.timedelta(seconds=3600))\n\n    def test_dt_tz_localize_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_localize(tz)\n        expected = datetimes.dt.tz_localize(tz)\n>       tm.assert_series_equal(result, expected)\nE       AssertionError: Series are different\nE       \nE       Series length are different\nE       [left]:  2, RangeIndex(start=0, stop=2, step=1)\nE       [right]: 3, RangeIndex(start=0, stop=3, step=1)\n\npandas/tests/series/test_datetime_values.py:356: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_131/pandas/tests/series/test_datetime_values.py",
                "test_function": "test_dt_tz_localize_categorical",
                "test_function_code": "    def test_dt_tz_localize_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_localize(tz)\n        expected = datetimes.dt.tz_localize(tz)\n        tm.assert_series_equal(result, expected)",
                "test_error": "AssertionError: Series are different  Series length are different [left]:  2, RangeIndex(start=0, stop=2, step=1) [right]: 3, RangeIndex(start=0, stop=3, step=1)",
                "full_test_error": "self = <pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues object at 0x11973d4f0>\ntz_aware_fixture = datetime.timezone(datetime.timedelta(days=-1, seconds=82800), 'foo')\n\n    def test_dt_tz_localize_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_localize(tz)\n        expected = datetimes.dt.tz_localize(tz)\n>       tm.assert_series_equal(result, expected)\nE       AssertionError: Series are different\nE       \nE       Series length are different\nE       [left]:  2, RangeIndex(start=0, stop=2, step=1)\nE       [right]: 3, RangeIndex(start=0, stop=3, step=1)\n\npandas/tests/series/test_datetime_values.py:356: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_131/pandas/tests/series/test_datetime_values.py",
                "test_function": "test_dt_tz_convert_categorical",
                "test_function_code": "    def test_dt_tz_convert_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns, MET]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_convert(tz)\n        expected = datetimes.dt.tz_convert(tz)\n        tm.assert_series_equal(result, expected)",
                "test_error": "AssertionError: Series are different  Series length are different [left]:  2, RangeIndex(start=0, stop=2, step=1) [right]: 3, RangeIndex(start=0, stop=3, step=1)",
                "full_test_error": "self = <pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues object at 0x1197804c0>\ntz_aware_fixture = 'UTC'\n\n    def test_dt_tz_convert_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns, MET]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_convert(tz)\n        expected = datetimes.dt.tz_convert(tz)\n>       tm.assert_series_equal(result, expected)\nE       AssertionError: Series are different\nE       \nE       Series length are different\nE       [left]:  2, RangeIndex(start=0, stop=2, step=1)\nE       [right]: 3, RangeIndex(start=0, stop=3, step=1)\n\npandas/tests/series/test_datetime_values.py:367: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_131/pandas/tests/series/test_datetime_values.py",
                "test_function": "test_dt_tz_convert_categorical",
                "test_function_code": "    def test_dt_tz_convert_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns, MET]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_convert(tz)\n        expected = datetimes.dt.tz_convert(tz)\n        tm.assert_series_equal(result, expected)",
                "test_error": "AssertionError: Series are different  Series length are different [left]:  2, RangeIndex(start=0, stop=2, step=1) [right]: 3, RangeIndex(start=0, stop=3, step=1)",
                "full_test_error": "self = <pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues object at 0x119a5d3a0>\ntz_aware_fixture = 'US/Eastern'\n\n    def test_dt_tz_convert_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns, MET]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_convert(tz)\n        expected = datetimes.dt.tz_convert(tz)\n>       tm.assert_series_equal(result, expected)\nE       AssertionError: Series are different\nE       \nE       Series length are different\nE       [left]:  2, RangeIndex(start=0, stop=2, step=1)\nE       [right]: 3, RangeIndex(start=0, stop=3, step=1)\n\npandas/tests/series/test_datetime_values.py:367: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_131/pandas/tests/series/test_datetime_values.py",
                "test_function": "test_dt_tz_convert_categorical",
                "test_function_code": "    def test_dt_tz_convert_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns, MET]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_convert(tz)\n        expected = datetimes.dt.tz_convert(tz)\n        tm.assert_series_equal(result, expected)",
                "test_error": "AssertionError: Series are different  Series length are different [left]:  2, RangeIndex(start=0, stop=2, step=1) [right]: 3, RangeIndex(start=0, stop=3, step=1)",
                "full_test_error": "self = <pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues object at 0x1198e2310>\ntz_aware_fixture = 'Asia/Tokyo'\n\n    def test_dt_tz_convert_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns, MET]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_convert(tz)\n        expected = datetimes.dt.tz_convert(tz)\n>       tm.assert_series_equal(result, expected)\nE       AssertionError: Series are different\nE       \nE       Series length are different\nE       [left]:  2, RangeIndex(start=0, stop=2, step=1)\nE       [right]: 3, RangeIndex(start=0, stop=3, step=1)\n\npandas/tests/series/test_datetime_values.py:367: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_131/pandas/tests/series/test_datetime_values.py",
                "test_function": "test_dt_tz_convert_categorical",
                "test_function_code": "    def test_dt_tz_convert_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns, MET]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_convert(tz)\n        expected = datetimes.dt.tz_convert(tz)\n        tm.assert_series_equal(result, expected)",
                "test_error": "AssertionError: Series are different  Series length are different [left]:  2, RangeIndex(start=0, stop=2, step=1) [right]: 3, RangeIndex(start=0, stop=3, step=1)",
                "full_test_error": "self = <pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues object at 0x1198e3b80>\ntz_aware_fixture = 'dateutil/US/Pacific'\n\n    def test_dt_tz_convert_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns, MET]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_convert(tz)\n        expected = datetimes.dt.tz_convert(tz)\n>       tm.assert_series_equal(result, expected)\nE       AssertionError: Series are different\nE       \nE       Series length are different\nE       [left]:  2, RangeIndex(start=0, stop=2, step=1)\nE       [right]: 3, RangeIndex(start=0, stop=3, step=1)\n\npandas/tests/series/test_datetime_values.py:367: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_131/pandas/tests/series/test_datetime_values.py",
                "test_function": "test_dt_tz_convert_categorical",
                "test_function_code": "    def test_dt_tz_convert_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns, MET]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_convert(tz)\n        expected = datetimes.dt.tz_convert(tz)\n        tm.assert_series_equal(result, expected)",
                "test_error": "AssertionError: Series are different  Series length are different [left]:  2, RangeIndex(start=0, stop=2, step=1) [right]: 3, RangeIndex(start=0, stop=3, step=1)",
                "full_test_error": "self = <pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues object at 0x1198188e0>\ntz_aware_fixture = 'dateutil/Asia/Singapore'\n\n    def test_dt_tz_convert_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns, MET]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_convert(tz)\n        expected = datetimes.dt.tz_convert(tz)\n>       tm.assert_series_equal(result, expected)\nE       AssertionError: Series are different\nE       \nE       Series length are different\nE       [left]:  2, RangeIndex(start=0, stop=2, step=1)\nE       [right]: 3, RangeIndex(start=0, stop=3, step=1)\n\npandas/tests/series/test_datetime_values.py:367: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_131/pandas/tests/series/test_datetime_values.py",
                "test_function": "test_dt_tz_convert_categorical",
                "test_function_code": "    def test_dt_tz_convert_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns, MET]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_convert(tz)\n        expected = datetimes.dt.tz_convert(tz)\n        tm.assert_series_equal(result, expected)",
                "test_error": "AssertionError: Series are different  Series length are different [left]:  2, RangeIndex(start=0, stop=2, step=1) [right]: 3, RangeIndex(start=0, stop=3, step=1)",
                "full_test_error": "self = <pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues object at 0x1198d67c0>\ntz_aware_fixture = tzutc()\n\n    def test_dt_tz_convert_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns, MET]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_convert(tz)\n        expected = datetimes.dt.tz_convert(tz)\n>       tm.assert_series_equal(result, expected)\nE       AssertionError: Series are different\nE       \nE       Series length are different\nE       [left]:  2, RangeIndex(start=0, stop=2, step=1)\nE       [right]: 3, RangeIndex(start=0, stop=3, step=1)\n\npandas/tests/series/test_datetime_values.py:367: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_131/pandas/tests/series/test_datetime_values.py",
                "test_function": "test_dt_tz_convert_categorical",
                "test_function_code": "    def test_dt_tz_convert_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns, MET]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_convert(tz)\n        expected = datetimes.dt.tz_convert(tz)\n        tm.assert_series_equal(result, expected)",
                "test_error": "AssertionError: Series are different  Series length are different [left]:  2, RangeIndex(start=0, stop=2, step=1) [right]: 3, RangeIndex(start=0, stop=3, step=1)",
                "full_test_error": "self = <pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues object at 0x119760760>\ntz_aware_fixture = tzlocal()\n\n    def test_dt_tz_convert_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns, MET]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_convert(tz)\n        expected = datetimes.dt.tz_convert(tz)\n>       tm.assert_series_equal(result, expected)\nE       AssertionError: Series are different\nE       \nE       Series length are different\nE       [left]:  2, RangeIndex(start=0, stop=2, step=1)\nE       [right]: 3, RangeIndex(start=0, stop=3, step=1)\n\npandas/tests/series/test_datetime_values.py:367: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_131/pandas/tests/series/test_datetime_values.py",
                "test_function": "test_dt_tz_convert_categorical",
                "test_function_code": "    def test_dt_tz_convert_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns, MET]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_convert(tz)\n        expected = datetimes.dt.tz_convert(tz)\n        tm.assert_series_equal(result, expected)",
                "test_error": "AssertionError: Series are different  Series length are different [left]:  2, RangeIndex(start=0, stop=2, step=1) [right]: 3, RangeIndex(start=0, stop=3, step=1)",
                "full_test_error": "self = <pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues object at 0x119a463d0>\ntz_aware_fixture = pytz.FixedOffset(300)\n\n    def test_dt_tz_convert_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns, MET]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_convert(tz)\n        expected = datetimes.dt.tz_convert(tz)\n>       tm.assert_series_equal(result, expected)\nE       AssertionError: Series are different\nE       \nE       Series length are different\nE       [left]:  2, RangeIndex(start=0, stop=2, step=1)\nE       [right]: 3, RangeIndex(start=0, stop=3, step=1)\n\npandas/tests/series/test_datetime_values.py:367: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_131/pandas/tests/series/test_datetime_values.py",
                "test_function": "test_dt_tz_convert_categorical",
                "test_function_code": "    def test_dt_tz_convert_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns, MET]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_convert(tz)\n        expected = datetimes.dt.tz_convert(tz)\n        tm.assert_series_equal(result, expected)",
                "test_error": "AssertionError: Series are different  Series length are different [left]:  2, RangeIndex(start=0, stop=2, step=1) [right]: 3, RangeIndex(start=0, stop=3, step=1)",
                "full_test_error": "self = <pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues object at 0x1198e4280>\ntz_aware_fixture = <UTC>\n\n    def test_dt_tz_convert_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns, MET]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_convert(tz)\n        expected = datetimes.dt.tz_convert(tz)\n>       tm.assert_series_equal(result, expected)\nE       AssertionError: Series are different\nE       \nE       Series length are different\nE       [left]:  2, RangeIndex(start=0, stop=2, step=1)\nE       [right]: 3, RangeIndex(start=0, stop=3, step=1)\n\npandas/tests/series/test_datetime_values.py:367: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_131/pandas/tests/series/test_datetime_values.py",
                "test_function": "test_dt_tz_convert_categorical",
                "test_function_code": "    def test_dt_tz_convert_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns, MET]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_convert(tz)\n        expected = datetimes.dt.tz_convert(tz)\n        tm.assert_series_equal(result, expected)",
                "test_error": "AssertionError: Series are different  Series length are different [left]:  2, RangeIndex(start=0, stop=2, step=1) [right]: 3, RangeIndex(start=0, stop=3, step=1)",
                "full_test_error": "self = <pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues object at 0x1197780a0>\ntz_aware_fixture = pytz.FixedOffset(-300)\n\n    def test_dt_tz_convert_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns, MET]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_convert(tz)\n        expected = datetimes.dt.tz_convert(tz)\n>       tm.assert_series_equal(result, expected)\nE       AssertionError: Series are different\nE       \nE       Series length are different\nE       [left]:  2, RangeIndex(start=0, stop=2, step=1)\nE       [right]: 3, RangeIndex(start=0, stop=3, step=1)\n\npandas/tests/series/test_datetime_values.py:367: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_131/pandas/tests/series/test_datetime_values.py",
                "test_function": "test_dt_tz_convert_categorical",
                "test_function_code": "    def test_dt_tz_convert_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns, MET]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_convert(tz)\n        expected = datetimes.dt.tz_convert(tz)\n        tm.assert_series_equal(result, expected)",
                "test_error": "AssertionError: Series are different  Series length are different [left]:  2, RangeIndex(start=0, stop=2, step=1) [right]: 3, RangeIndex(start=0, stop=3, step=1)",
                "full_test_error": "self = <pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues object at 0x1198e4070>\ntz_aware_fixture = datetime.timezone.utc\n\n    def test_dt_tz_convert_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns, MET]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_convert(tz)\n        expected = datetimes.dt.tz_convert(tz)\n>       tm.assert_series_equal(result, expected)\nE       AssertionError: Series are different\nE       \nE       Series length are different\nE       [left]:  2, RangeIndex(start=0, stop=2, step=1)\nE       [right]: 3, RangeIndex(start=0, stop=3, step=1)\n\npandas/tests/series/test_datetime_values.py:367: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_131/pandas/tests/series/test_datetime_values.py",
                "test_function": "test_dt_tz_convert_categorical",
                "test_function_code": "    def test_dt_tz_convert_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns, MET]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_convert(tz)\n        expected = datetimes.dt.tz_convert(tz)\n        tm.assert_series_equal(result, expected)",
                "test_error": "AssertionError: Series are different  Series length are different [left]:  2, RangeIndex(start=0, stop=2, step=1) [right]: 3, RangeIndex(start=0, stop=3, step=1)",
                "full_test_error": "self = <pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues object at 0x1196f6a60>\ntz_aware_fixture = datetime.timezone(datetime.timedelta(seconds=3600))\n\n    def test_dt_tz_convert_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns, MET]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_convert(tz)\n        expected = datetimes.dt.tz_convert(tz)\n>       tm.assert_series_equal(result, expected)\nE       AssertionError: Series are different\nE       \nE       Series length are different\nE       [left]:  2, RangeIndex(start=0, stop=2, step=1)\nE       [right]: 3, RangeIndex(start=0, stop=3, step=1)\n\npandas/tests/series/test_datetime_values.py:367: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_131/pandas/tests/series/test_datetime_values.py",
                "test_function": "test_dt_tz_convert_categorical",
                "test_function_code": "    def test_dt_tz_convert_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns, MET]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_convert(tz)\n        expected = datetimes.dt.tz_convert(tz)\n        tm.assert_series_equal(result, expected)",
                "test_error": "AssertionError: Series are different  Series length are different [left]:  2, RangeIndex(start=0, stop=2, step=1) [right]: 3, RangeIndex(start=0, stop=3, step=1)",
                "full_test_error": "self = <pandas.tests.series.test_datetime_values.TestSeriesDatetimeValues object at 0x11986ad90>\ntz_aware_fixture = datetime.timezone(datetime.timedelta(days=-1, seconds=82800), 'foo')\n\n    def test_dt_tz_convert_categorical(self, tz_aware_fixture):\n        # GH 27952\n        tz = tz_aware_fixture\n        datetimes = pd.Series(\n            [\"2019-01-01\", \"2019-01-01\", \"2019-01-02\"], dtype=\"datetime64[ns, MET]\"\n        )\n        categorical = datetimes.astype(\"category\")\n        result = categorical.dt.tz_convert(tz)\n        expected = datetimes.dt.tz_convert(tz)\n>       tm.assert_series_equal(result, expected)\nE       AssertionError: Series are different\nE       \nE       Series length are different\nE       [left]:  2, RangeIndex(start=0, stop=2, step=1)\nE       [right]: 3, RangeIndex(start=0, stop=3, step=1)\n\npandas/tests/series/test_datetime_values.py:367: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            }
        ]
    }
}