{
    "pandas:26": {
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_26/pandas/core/arrays/categorical.py": {
            "buggy_functions": [
                {
                    "function_name": "min",
                    "function_code": "@deprecate_kwarg(old_arg_name=\"numeric_only\", new_arg_name=\"skipna\")\ndef min(self, skipna=True):\n    \"\"\"\n    The minimum value of the object.\n\n    Only ordered `Categoricals` have a minimum!\n\n    .. versionchanged:: 1.0.0\n\n       Returns an NA value on empty arrays\n\n    Raises\n    ------\n    TypeError\n        If the `Categorical` is not `ordered`.\n\n    Returns\n    -------\n    min : the minimum of this `Categorical`\n    \"\"\"\n    self.check_for_ordered(\"min\")\n\n    if not len(self._codes):\n        return self.dtype.na_value\n\n    good = self._codes != -1\n    if not good.all():\n        if skipna:\n            pointer = self._codes[good].min()\n        else:\n            return np.nan\n    else:\n        pointer = self._codes.min()\n    return self.categories[pointer]\n",
                    "decorators": [
                        "deprecate_kwarg(old_arg_name='numeric_only', new_arg_name='skipna')"
                    ],
                    "docstring": "The minimum value of the object.\n\nOnly ordered `Categoricals` have a minimum!\n\n.. versionchanged:: 1.0.0\n\n   Returns an NA value on empty arrays\n\nRaises\n------\nTypeError\n    If the `Categorical` is not `ordered`.\n\nReturns\n-------\nmin : the minimum of this `Categorical`",
                    "start_line": 2119,
                    "end_line": 2152,
                    "variables": {
                        "self.check_for_ordered": [
                            2139
                        ],
                        "self": [
                            2144,
                            2147,
                            2151,
                            2152,
                            2139,
                            2141,
                            2142
                        ],
                        "len": [
                            2141
                        ],
                        "self._codes": [
                            2144,
                            2147,
                            2141,
                            2151
                        ],
                        "self.dtype.na_value": [
                            2142
                        ],
                        "self.dtype": [
                            2142
                        ],
                        "good": [
                            2144,
                            2145,
                            2147
                        ],
                        "good.all": [
                            2145
                        ],
                        "skipna": [
                            2146
                        ],
                        "pointer": [
                            2152,
                            2147,
                            2151
                        ],
                        "min": [
                            2147
                        ],
                        "np.nan": [
                            2149
                        ],
                        "np": [
                            2149
                        ],
                        "self._codes.min": [
                            2151
                        ],
                        "self.categories": [
                            2152
                        ],
                        "deprecate_kwarg": [
                            2119
                        ]
                    },
                    "filtered_variables": {
                        "self.check_for_ordered": [
                            2139
                        ],
                        "self": [
                            2144,
                            2147,
                            2151,
                            2152,
                            2139,
                            2141,
                            2142
                        ],
                        "self._codes": [
                            2144,
                            2147,
                            2141,
                            2151
                        ],
                        "self.dtype.na_value": [
                            2142
                        ],
                        "self.dtype": [
                            2142
                        ],
                        "good": [
                            2144,
                            2145,
                            2147
                        ],
                        "good.all": [
                            2145
                        ],
                        "skipna": [
                            2146
                        ],
                        "pointer": [
                            2152,
                            2147,
                            2151
                        ],
                        "np.nan": [
                            2149
                        ],
                        "np": [
                            2149
                        ],
                        "self._codes.min": [
                            2151
                        ],
                        "self.categories": [
                            2152
                        ],
                        "deprecate_kwarg": [
                            2119
                        ]
                    },
                    "diff_line_number": 2146,
                    "class_data": {
                        "signature": "class Categorical(ExtensionArray, PandasObject)",
                        "docstring": "Represent a categorical variable in classic R / S-plus fashion.\n\n`Categoricals` can only take on only a limited, and usually fixed, number\nof possible values (`categories`). In contrast to statistical categorical\nvariables, a `Categorical` might have an order, but numerical operations\n(additions, divisions, ...) are not possible.\n\nAll values of the `Categorical` are either in `categories` or `np.nan`.\nAssigning values outside of `categories` will raise a `ValueError`. Order\nis defined by the order of the `categories`, not lexical order of the\nvalues.\n\nParameters\n----------\nvalues : list-like\n    The values of the categorical. If categories are given, values not in\n    categories will be replaced with NaN.\ncategories : Index-like (unique), optional\n    The unique categories for this categorical. If not given, the\n    categories are assumed to be the unique values of `values` (sorted, if\n    possible, otherwise in the order in which they appear).\nordered : bool, default False\n    Whether or not this categorical is treated as a ordered categorical.\n    If True, the resulting categorical will be ordered.\n    An ordered categorical respects, when sorted, the order of its\n    `categories` attribute (which in turn is the `categories` argument, if\n    provided).\ndtype : CategoricalDtype\n    An instance of ``CategoricalDtype`` to use for this categorical.\n\nAttributes\n----------\ncategories : Index\n    The categories of this categorical\ncodes : ndarray\n    The codes (integer positions, which point to the categories) of this\n    categorical, read only.\nordered : bool\n    Whether or not this Categorical is ordered.\ndtype : CategoricalDtype\n    The instance of ``CategoricalDtype`` storing the ``categories``\n    and ``ordered``.\n\nMethods\n-------\nfrom_codes\n__array__\n\nRaises\n------\nValueError\n    If the categories do not validate.\nTypeError\n    If an explicit ``ordered=True`` is given but no `categories` and the\n    `values` are not sortable.\n\nSee Also\n--------\nCategoricalDtype : Type for categorical data.\nCategoricalIndex : An Index with an underlying ``Categorical``.\n\nNotes\n-----\nSee the `user guide\n<https://pandas.pydata.org/pandas-docs/stable/user_guide/categorical.html>`_\nfor more.\n\nExamples\n--------\n>>> pd.Categorical([1, 2, 3, 1, 2, 3])\n[1, 2, 3, 1, 2, 3]\nCategories (3, int64): [1, 2, 3]\n\n>>> pd.Categorical(['a', 'b', 'c', 'a', 'b', 'c'])\n[a, b, c, a, b, c]\nCategories (3, object): [a, b, c]\n\nOrdered `Categoricals` can be sorted according to the custom order\nof the categories and can have a min and max value.\n\n>>> c = pd.Categorical(['a', 'b', 'c', 'a', 'b', 'c'], ordered=True,\n...                    categories=['c', 'b', 'a'])\n>>> c\n[a, b, c, a, b, c]\nCategories (3, object): [c < b < a]\n>>> c.min()\n'c'",
                        "constructor_docstring": null,
                        "functions": [
                            "def __init__(self, values, categories=None, ordered=None, dtype=None, fastpath=False):\n    dtype = CategoricalDtype._from_values_or_dtype(values, categories, ordered, dtype)\n    if fastpath:\n        self._codes = coerce_indexer_dtype(values, dtype.categories)\n        self._dtype = self._dtype.update_dtype(dtype)\n        return\n    null_mask = np.array(False)\n    if is_categorical_dtype(values):\n        if dtype.categories is None:\n            dtype = CategoricalDtype(values.categories, dtype.ordered)\n    elif not isinstance(values, (ABCIndexClass, ABCSeries)):\n        values = maybe_infer_to_datetimelike(values, convert_dates=True)\n        if not isinstance(values, np.ndarray):\n            values = _convert_to_list_like(values)\n            sanitize_dtype = 'object' if len(values) == 0 else None\n            null_mask = isna(values)\n            if null_mask.any():\n                values = [values[idx] for idx in np.where(~null_mask)[0]]\n            values = sanitize_array(values, None, dtype=sanitize_dtype)\n    if dtype.categories is None:\n        try:\n            codes, categories = factorize(values, sort=True)\n        except TypeError as err:\n            codes, categories = factorize(values, sort=False)\n            if dtype.ordered:\n                raise TypeError(\"'values' is not ordered, please explicitly specify the categories order by passing in a categories argument.\") from err\n        except ValueError as err:\n            raise NotImplementedError('> 1 ndim Categorical are not supported at this time') from err\n        dtype = CategoricalDtype(categories, dtype.ordered)\n    elif is_categorical_dtype(values):\n        old_codes = values._values.codes if isinstance(values, ABCSeries) else values.codes\n        codes = recode_for_categories(old_codes, values.dtype.categories, dtype.categories)\n    else:\n        codes = _get_codes_for_values(values, dtype.categories)\n    if null_mask.any():\n        full_codes = -np.ones(null_mask.shape, dtype=codes.dtype)\n        full_codes[~null_mask] = codes\n        codes = full_codes\n    self._dtype = self._dtype.update_dtype(dtype)\n    self._codes = coerce_indexer_dtype(codes, dtype.categories)",
                            "@property\ndef categories(self):\n    \"\"\"\n    The categories of this categorical.\n\n    Setting assigns new values to each category (effectively a rename of\n    each individual category).\n\n    The assigned value has to be a list-like object. All items must be\n    unique and the number of items in the new categories must be the same\n    as the number of items in the old categories.\n\n    Assigning to `categories` is a inplace operation!\n\n    Raises\n    ------\n    ValueError\n        If the new categories do not validate as categories or if the\n        number of new categories is unequal the number of old categories\n\n    See Also\n    --------\n    rename_categories : Rename categories.\n    reorder_categories : Reorder categories.\n    add_categories : Add new categories.\n    remove_categories : Remove the specified categories.\n    remove_unused_categories : Remove categories which are not used.\n    set_categories : Set the categories to the specified ones.\n    \"\"\"\n    return self.dtype.categories",
                            "@categories.setter\ndef categories(self, categories):\n    new_dtype = CategoricalDtype(categories, ordered=self.ordered)\n    if self.dtype.categories is not None and len(self.dtype.categories) != len(new_dtype.categories):\n        raise ValueError('new categories need to have the same number of items as the old categories!')\n    self._dtype = new_dtype",
                            "@property\ndef ordered(self) -> Ordered:\n    \"\"\"\n    Whether the categories have an ordered relationship.\n    \"\"\"\n    return self.dtype.ordered",
                            "@property\ndef dtype(self) -> CategoricalDtype:\n    \"\"\"\n    The :class:`~pandas.api.types.CategoricalDtype` for this instance.\n    \"\"\"\n    return self._dtype",
                            "@property\ndef _constructor(self) -> Type['Categorical']:\n    return Categorical",
                            "@classmethod\ndef _from_sequence(cls, scalars, dtype=None, copy=False):\n    return Categorical(scalars, dtype=dtype)",
                            "def _formatter(self, boxed=False):\n    return None",
                            "def copy(self) -> 'Categorical':\n    \"\"\"\n    Copy constructor.\n    \"\"\"\n    return self._constructor(values=self._codes.copy(), dtype=self.dtype, fastpath=True)",
                            "def astype(self, dtype: Dtype, copy: bool=True) -> ArrayLike:\n    \"\"\"\n    Coerce this type to another dtype\n\n    Parameters\n    ----------\n    dtype : numpy dtype or pandas type\n    copy : bool, default True\n        By default, astype always returns a newly allocated object.\n        If copy is set to False and dtype is categorical, the original\n        object is returned.\n    \"\"\"\n    if is_categorical_dtype(dtype):\n        dtype = cast(Union[str, CategoricalDtype], dtype)\n        dtype = self.dtype.update_dtype(dtype)\n        self = self.copy() if copy else self\n        if dtype == self.dtype:\n            return self\n        return self._set_dtype(dtype)\n    if is_extension_array_dtype(dtype):\n        return array(self, dtype=dtype, copy=copy)\n    if is_integer_dtype(dtype) and self.isna().any():\n        raise ValueError('Cannot convert float NaN to integer')\n    return np.array(self, dtype=dtype, copy=copy)",
                            "@cache_readonly\ndef size(self) -> int:\n    \"\"\"\n    Return the len of myself.\n    \"\"\"\n    return self._codes.size",
                            "@cache_readonly\ndef itemsize(self) -> int:\n    \"\"\"\n    return the size of a single category\n    \"\"\"\n    return self.categories.itemsize",
                            "def tolist(self) -> List[Scalar]:\n    \"\"\"\n    Return a list of the values.\n\n    These are each a scalar type, which is a Python scalar\n    (for str, int, float) or a pandas scalar\n    (for Timestamp/Timedelta/Interval/Period)\n    \"\"\"\n    return list(self)",
                            "@classmethod\ndef _from_inferred_categories(cls, inferred_categories, inferred_codes, dtype, true_values=None):\n    \"\"\"\n    Construct a Categorical from inferred values.\n\n    For inferred categories (`dtype` is None) the categories are sorted.\n    For explicit `dtype`, the `inferred_categories` are cast to the\n    appropriate type.\n\n    Parameters\n    ----------\n    inferred_categories : Index\n    inferred_codes : Index\n    dtype : CategoricalDtype or 'category'\n    true_values : list, optional\n        If none are provided, the default ones are\n        \"True\", \"TRUE\", and \"true.\"\n\n    Returns\n    -------\n    Categorical\n    \"\"\"\n    from pandas import Index, to_numeric, to_datetime, to_timedelta\n    cats = Index(inferred_categories)\n    known_categories = isinstance(dtype, CategoricalDtype) and dtype.categories is not None\n    if known_categories:\n        if dtype.categories.is_numeric():\n            cats = to_numeric(inferred_categories, errors='coerce')\n        elif is_datetime64_dtype(dtype.categories):\n            cats = to_datetime(inferred_categories, errors='coerce')\n        elif is_timedelta64_dtype(dtype.categories):\n            cats = to_timedelta(inferred_categories, errors='coerce')\n        elif dtype.categories.is_boolean():\n            if true_values is None:\n                true_values = ['True', 'TRUE', 'true']\n            cats = cats.isin(true_values)\n    if known_categories:\n        categories = dtype.categories\n        codes = recode_for_categories(inferred_codes, cats, categories)\n    elif not cats.is_monotonic_increasing:\n        unsorted = cats.copy()\n        categories = cats.sort_values()\n        codes = recode_for_categories(inferred_codes, unsorted, categories)\n        dtype = CategoricalDtype(categories, ordered=False)\n    else:\n        dtype = CategoricalDtype(cats, ordered=False)\n        codes = inferred_codes\n    return cls(codes, dtype=dtype, fastpath=True)",
                            "@classmethod\ndef from_codes(cls, codes, categories=None, ordered=None, dtype=None):\n    \"\"\"\n    Make a Categorical type from codes and categories or dtype.\n\n    This constructor is useful if you already have codes and\n    categories/dtype and so do not need the (computation intensive)\n    factorization step, which is usually done on the constructor.\n\n    If your data does not follow this convention, please use the normal\n    constructor.\n\n    Parameters\n    ----------\n    codes : array-like of int\n        An integer array, where each integer points to a category in\n        categories or dtype.categories, or else is -1 for NaN.\n    categories : index-like, optional\n        The categories for the categorical. Items need to be unique.\n        If the categories are not given here, then they must be provided\n        in `dtype`.\n    ordered : bool, optional\n        Whether or not this categorical is treated as an ordered\n        categorical. If not given here or in `dtype`, the resulting\n        categorical will be unordered.\n    dtype : CategoricalDtype or \"category\", optional\n        If :class:`CategoricalDtype`, cannot be used together with\n        `categories` or `ordered`.\n\n        .. versionadded:: 0.24.0\n\n           When `dtype` is provided, neither `categories` nor `ordered`\n           should be provided.\n\n    Returns\n    -------\n    Categorical\n\n    Examples\n    --------\n    >>> dtype = pd.CategoricalDtype(['a', 'b'], ordered=True)\n    >>> pd.Categorical.from_codes(codes=[0, 1, 0, 1], dtype=dtype)\n    [a, b, a, b]\n    Categories (2, object): [a < b]\n    \"\"\"\n    dtype = CategoricalDtype._from_values_or_dtype(categories=categories, ordered=ordered, dtype=dtype)\n    if dtype.categories is None:\n        msg = \"The categories must be provided in 'categories' or 'dtype'. Both were None.\"\n        raise ValueError(msg)\n    if is_extension_array_dtype(codes) and is_integer_dtype(codes):\n        if isna(codes).any():\n            raise ValueError('codes cannot contain NA values')\n        codes = codes.to_numpy(dtype=np.int64)\n    else:\n        codes = np.asarray(codes)\n    if len(codes) and (not is_integer_dtype(codes)):\n        raise ValueError('codes need to be array-like integers')\n    if len(codes) and (codes.max() >= len(dtype.categories) or codes.min() < -1):\n        raise ValueError('codes need to be between -1 and len(categories)-1')\n    return cls(codes, dtype=dtype, fastpath=True)",
                            "def _get_codes(self):\n    \"\"\"\n    Get the codes.\n\n    Returns\n    -------\n    codes : integer array view\n        A non writable view of the `codes` array.\n    \"\"\"\n    v = self._codes.view()\n    v.flags.writeable = False\n    return v",
                            "def _set_codes(self, codes):\n    \"\"\"\n    Not settable by the user directly\n    \"\"\"\n    raise ValueError('cannot set Categorical codes directly')",
                            "def _set_categories(self, categories, fastpath=False):\n    \"\"\"\n    Sets new categories inplace\n\n    Parameters\n    ----------\n    fastpath : bool, default False\n       Don't perform validation of the categories for uniqueness or nulls\n\n    Examples\n    --------\n    >>> c = pd.Categorical(['a', 'b'])\n    >>> c\n    [a, b]\n    Categories (2, object): [a, b]\n\n    >>> c._set_categories(pd.Index(['a', 'c']))\n    >>> c\n    [a, c]\n    Categories (2, object): [a, c]\n    \"\"\"\n    if fastpath:\n        new_dtype = CategoricalDtype._from_fastpath(categories, self.ordered)\n    else:\n        new_dtype = CategoricalDtype(categories, ordered=self.ordered)\n    if not fastpath and self.dtype.categories is not None and (len(new_dtype.categories) != len(self.dtype.categories)):\n        raise ValueError('new categories need to have the same number of items than the old categories!')\n    self._dtype = new_dtype",
                            "def _set_dtype(self, dtype: CategoricalDtype) -> 'Categorical':\n    \"\"\"\n    Internal method for directly updating the CategoricalDtype\n\n    Parameters\n    ----------\n    dtype : CategoricalDtype\n\n    Notes\n    -----\n    We don't do any validation here. It's assumed that the dtype is\n    a (valid) instance of `CategoricalDtype`.\n    \"\"\"\n    codes = recode_for_categories(self.codes, self.categories, dtype.categories)\n    return type(self)(codes, dtype=dtype, fastpath=True)",
                            "def set_ordered(self, value, inplace=False):\n    \"\"\"\n    Set the ordered attribute to the boolean value.\n\n    Parameters\n    ----------\n    value : bool\n       Set whether this categorical is ordered (True) or not (False).\n    inplace : bool, default False\n       Whether or not to set the ordered attribute in-place or return\n       a copy of this categorical with ordered set to the value.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    new_dtype = CategoricalDtype(self.categories, ordered=value)\n    cat = self if inplace else self.copy()\n    cat._dtype = new_dtype\n    if not inplace:\n        return cat",
                            "def as_ordered(self, inplace=False):\n    \"\"\"\n    Set the Categorical to be ordered.\n\n    Parameters\n    ----------\n    inplace : bool, default False\n       Whether or not to set the ordered attribute in-place or return\n       a copy of this categorical with ordered set to True.\n\n    Returns\n    -------\n    Categorical\n        Ordered Categorical.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    return self.set_ordered(True, inplace=inplace)",
                            "def as_unordered(self, inplace=False):\n    \"\"\"\n    Set the Categorical to be unordered.\n\n    Parameters\n    ----------\n    inplace : bool, default False\n       Whether or not to set the ordered attribute in-place or return\n       a copy of this categorical with ordered set to False.\n\n    Returns\n    -------\n    Categorical\n        Unordered Categorical.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    return self.set_ordered(False, inplace=inplace)",
                            "def set_categories(self, new_categories, ordered=None, rename=False, inplace=False):\n    \"\"\"\n    Set the categories to the specified new_categories.\n\n    `new_categories` can include new categories (which will result in\n    unused categories) or remove old categories (which results in values\n    set to NaN). If `rename==True`, the categories will simple be renamed\n    (less or more items than in old categories will result in values set to\n    NaN or in unused categories respectively).\n\n    This method can be used to perform more than one action of adding,\n    removing, and reordering simultaneously and is therefore faster than\n    performing the individual steps via the more specialised methods.\n\n    On the other hand this methods does not do checks (e.g., whether the\n    old categories are included in the new categories on a reorder), which\n    can result in surprising changes, for example when using special string\n    dtypes, which does not considers a S1 string equal to a single char\n    python string.\n\n    Parameters\n    ----------\n    new_categories : Index-like\n       The categories in new order.\n    ordered : bool, default False\n       Whether or not the categorical is treated as a ordered categorical.\n       If not given, do not change the ordered information.\n    rename : bool, default False\n       Whether or not the new_categories should be considered as a rename\n       of the old categories or as reordered categories.\n    inplace : bool, default False\n       Whether or not to reorder the categories in-place or return a copy\n       of this categorical with reordered categories.\n\n    Returns\n    -------\n    Categorical with reordered categories or None if inplace.\n\n    Raises\n    ------\n    ValueError\n        If new_categories does not validate as categories\n\n    See Also\n    --------\n    rename_categories : Rename categories.\n    reorder_categories : Reorder categories.\n    add_categories : Add new categories.\n    remove_categories : Remove the specified categories.\n    remove_unused_categories : Remove categories which are not used.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    if ordered is None:\n        ordered = self.dtype.ordered\n    new_dtype = CategoricalDtype(new_categories, ordered=ordered)\n    cat = self if inplace else self.copy()\n    if rename:\n        if cat.dtype.categories is not None and len(new_dtype.categories) < len(cat.dtype.categories):\n            cat._codes[cat._codes >= len(new_dtype.categories)] = -1\n    else:\n        codes = recode_for_categories(cat.codes, cat.categories, new_dtype.categories)\n        cat._codes = codes\n    cat._dtype = new_dtype\n    if not inplace:\n        return cat",
                            "def rename_categories(self, new_categories, inplace=False):\n    \"\"\"\n    Rename categories.\n\n    Parameters\n    ----------\n    new_categories : list-like, dict-like or callable\n\n        New categories which will replace old categories.\n\n        * list-like: all items must be unique and the number of items in\n          the new categories must match the existing number of categories.\n\n        * dict-like: specifies a mapping from\n          old categories to new. Categories not contained in the mapping\n          are passed through and extra categories in the mapping are\n          ignored.\n\n        * callable : a callable that is called on all items in the old\n          categories and whose return values comprise the new categories.\n\n        .. versionadded:: 0.23.0.\n\n    inplace : bool, default False\n        Whether or not to rename the categories inplace or return a copy of\n        this categorical with renamed categories.\n\n    Returns\n    -------\n    cat : Categorical or None\n       With ``inplace=False``, the new categorical is returned.\n       With ``inplace=True``, there is no return value.\n\n    Raises\n    ------\n    ValueError\n        If new categories are list-like and do not have the same number of\n        items than the current categories or do not validate as categories\n\n    See Also\n    --------\n    reorder_categories : Reorder categories.\n    add_categories : Add new categories.\n    remove_categories : Remove the specified categories.\n    remove_unused_categories : Remove categories which are not used.\n    set_categories : Set the categories to the specified ones.\n\n    Examples\n    --------\n    >>> c = pd.Categorical(['a', 'a', 'b'])\n    >>> c.rename_categories([0, 1])\n    [0, 0, 1]\n    Categories (2, int64): [0, 1]\n\n    For dict-like ``new_categories``, extra keys are ignored and\n    categories not in the dictionary are passed through\n\n    >>> c.rename_categories({'a': 'A', 'c': 'C'})\n    [A, A, b]\n    Categories (2, object): [A, b]\n\n    You may also provide a callable to create the new categories\n\n    >>> c.rename_categories(lambda x: x.upper())\n    [A, A, B]\n    Categories (2, object): [A, B]\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    cat = self if inplace else self.copy()\n    if is_dict_like(new_categories):\n        cat.categories = [new_categories.get(item, item) for item in cat.categories]\n    elif callable(new_categories):\n        cat.categories = [new_categories(item) for item in cat.categories]\n    else:\n        cat.categories = new_categories\n    if not inplace:\n        return cat",
                            "def reorder_categories(self, new_categories, ordered=None, inplace=False):\n    \"\"\"\n    Reorder categories as specified in new_categories.\n\n    `new_categories` need to include all old categories and no new category\n    items.\n\n    Parameters\n    ----------\n    new_categories : Index-like\n       The categories in new order.\n    ordered : bool, optional\n       Whether or not the categorical is treated as a ordered categorical.\n       If not given, do not change the ordered information.\n    inplace : bool, default False\n       Whether or not to reorder the categories inplace or return a copy of\n       this categorical with reordered categories.\n\n    Returns\n    -------\n    cat : Categorical with reordered categories or None if inplace.\n\n    Raises\n    ------\n    ValueError\n        If the new categories do not contain all old category items or any\n        new ones\n\n    See Also\n    --------\n    rename_categories : Rename categories.\n    add_categories : Add new categories.\n    remove_categories : Remove the specified categories.\n    remove_unused_categories : Remove categories which are not used.\n    set_categories : Set the categories to the specified ones.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    if set(self.dtype.categories) != set(new_categories):\n        raise ValueError('items in new_categories are not the same as in old categories')\n    return self.set_categories(new_categories, ordered=ordered, inplace=inplace)",
                            "def add_categories(self, new_categories, inplace=False):\n    \"\"\"\n    Add new categories.\n\n    `new_categories` will be included at the last/highest place in the\n    categories and will be unused directly after this call.\n\n    Parameters\n    ----------\n    new_categories : category or list-like of category\n       The new categories to be included.\n    inplace : bool, default False\n       Whether or not to add the categories inplace or return a copy of\n       this categorical with added categories.\n\n    Returns\n    -------\n    cat : Categorical with new categories added or None if inplace.\n\n    Raises\n    ------\n    ValueError\n        If the new categories include old categories or do not validate as\n        categories\n\n    See Also\n    --------\n    rename_categories : Rename categories.\n    reorder_categories : Reorder categories.\n    remove_categories : Remove the specified categories.\n    remove_unused_categories : Remove categories which are not used.\n    set_categories : Set the categories to the specified ones.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    if not is_list_like(new_categories):\n        new_categories = [new_categories]\n    already_included = set(new_categories) & set(self.dtype.categories)\n    if len(already_included) != 0:\n        raise ValueError(f'new categories must not include old categories: {already_included}')\n    new_categories = list(self.dtype.categories) + list(new_categories)\n    new_dtype = CategoricalDtype(new_categories, self.ordered)\n    cat = self if inplace else self.copy()\n    cat._dtype = new_dtype\n    cat._codes = coerce_indexer_dtype(cat._codes, new_dtype.categories)\n    if not inplace:\n        return cat",
                            "def remove_categories(self, removals, inplace=False):\n    \"\"\"\n    Remove the specified categories.\n\n    `removals` must be included in the old categories. Values which were in\n    the removed categories will be set to NaN\n\n    Parameters\n    ----------\n    removals : category or list of categories\n       The categories which should be removed.\n    inplace : bool, default False\n       Whether or not to remove the categories inplace or return a copy of\n       this categorical with removed categories.\n\n    Returns\n    -------\n    cat : Categorical with removed categories or None if inplace.\n\n    Raises\n    ------\n    ValueError\n        If the removals are not contained in the categories\n\n    See Also\n    --------\n    rename_categories : Rename categories.\n    reorder_categories : Reorder categories.\n    add_categories : Add new categories.\n    remove_unused_categories : Remove categories which are not used.\n    set_categories : Set the categories to the specified ones.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    if not is_list_like(removals):\n        removals = [removals]\n    removal_set = set(removals)\n    not_included = removal_set - set(self.dtype.categories)\n    new_categories = [c for c in self.dtype.categories if c not in removal_set]\n    if any(isna(removals)):\n        not_included = {x for x in not_included if notna(x)}\n        new_categories = [x for x in new_categories if notna(x)]\n    if len(not_included) != 0:\n        raise ValueError(f'removals must all be in old categories: {not_included}')\n    return self.set_categories(new_categories, ordered=self.ordered, rename=False, inplace=inplace)",
                            "def remove_unused_categories(self, inplace=False):\n    \"\"\"\n    Remove categories which are not used.\n\n    Parameters\n    ----------\n    inplace : bool, default False\n       Whether or not to drop unused categories inplace or return a copy of\n       this categorical with unused categories dropped.\n\n    Returns\n    -------\n    cat : Categorical with unused categories dropped or None if inplace.\n\n    See Also\n    --------\n    rename_categories : Rename categories.\n    reorder_categories : Reorder categories.\n    add_categories : Add new categories.\n    remove_categories : Remove the specified categories.\n    set_categories : Set the categories to the specified ones.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    cat = self if inplace else self.copy()\n    idx, inv = np.unique(cat._codes, return_inverse=True)\n    if idx.size != 0 and idx[0] == -1:\n        idx, inv = (idx[1:], inv - 1)\n    new_categories = cat.dtype.categories.take(idx)\n    new_dtype = CategoricalDtype._from_fastpath(new_categories, ordered=self.ordered)\n    cat._dtype = new_dtype\n    cat._codes = coerce_indexer_dtype(inv, new_dtype.categories)\n    if not inplace:\n        return cat",
                            "def map(self, mapper):\n    \"\"\"\n    Map categories using input correspondence (dict, Series, or function).\n\n    Maps the categories to new categories. If the mapping correspondence is\n    one-to-one the result is a :class:`~pandas.Categorical` which has the\n    same order property as the original, otherwise a :class:`~pandas.Index`\n    is returned. NaN values are unaffected.\n\n    If a `dict` or :class:`~pandas.Series` is used any unmapped category is\n    mapped to `NaN`. Note that if this happens an :class:`~pandas.Index`\n    will be returned.\n\n    Parameters\n    ----------\n    mapper : function, dict, or Series\n        Mapping correspondence.\n\n    Returns\n    -------\n    pandas.Categorical or pandas.Index\n        Mapped categorical.\n\n    See Also\n    --------\n    CategoricalIndex.map : Apply a mapping correspondence on a\n        :class:`~pandas.CategoricalIndex`.\n    Index.map : Apply a mapping correspondence on an\n        :class:`~pandas.Index`.\n    Series.map : Apply a mapping correspondence on a\n        :class:`~pandas.Series`.\n    Series.apply : Apply more complex functions on a\n        :class:`~pandas.Series`.\n\n    Examples\n    --------\n    >>> cat = pd.Categorical(['a', 'b', 'c'])\n    >>> cat\n    [a, b, c]\n    Categories (3, object): [a, b, c]\n    >>> cat.map(lambda x: x.upper())\n    [A, B, C]\n    Categories (3, object): [A, B, C]\n    >>> cat.map({'a': 'first', 'b': 'second', 'c': 'third'})\n    [first, second, third]\n    Categories (3, object): [first, second, third]\n\n    If the mapping is one-to-one the ordering of the categories is\n    preserved:\n\n    >>> cat = pd.Categorical(['a', 'b', 'c'], ordered=True)\n    >>> cat\n    [a, b, c]\n    Categories (3, object): [a < b < c]\n    >>> cat.map({'a': 3, 'b': 2, 'c': 1})\n    [3, 2, 1]\n    Categories (3, int64): [3 < 2 < 1]\n\n    If the mapping is not one-to-one an :class:`~pandas.Index` is returned:\n\n    >>> cat.map({'a': 'first', 'b': 'second', 'c': 'first'})\n    Index(['first', 'second', 'first'], dtype='object')\n\n    If a `dict` is used, all unmapped categories are mapped to `NaN` and\n    the result is an :class:`~pandas.Index`:\n\n    >>> cat.map({'a': 'first', 'b': 'second'})\n    Index(['first', 'second', nan], dtype='object')\n    \"\"\"\n    new_categories = self.categories.map(mapper)\n    try:\n        return self.from_codes(self._codes.copy(), categories=new_categories, ordered=self.ordered)\n    except ValueError:\n        if np.any(self._codes == -1):\n            new_categories = new_categories.insert(len(new_categories), np.nan)\n        return np.take(new_categories, self._codes)",
                            "@property\ndef shape(self):\n    \"\"\"\n    Shape of the Categorical.\n\n    For internal compatibility with numpy arrays.\n\n    Returns\n    -------\n    shape : tuple\n    \"\"\"\n    return tuple([len(self._codes)])",
                            "def shift(self, periods, fill_value=None):\n    \"\"\"\n    Shift Categorical by desired number of periods.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to move, can be positive or negative\n    fill_value : object, optional\n        The scalar value to use for newly introduced missing values.\n\n        .. versionadded:: 0.24.0\n\n    Returns\n    -------\n    shifted : Categorical\n    \"\"\"\n    codes = self.codes\n    if codes.ndim > 1:\n        raise NotImplementedError('Categorical with ndim > 1.')\n    if np.prod(codes.shape) and periods != 0:\n        codes = np.roll(codes, ensure_platform_int(periods), axis=0)\n        if isna(fill_value):\n            fill_value = -1\n        elif fill_value in self.categories:\n            fill_value = self.categories.get_loc(fill_value)\n        else:\n            raise ValueError(f\"'fill_value={fill_value}' is not present in this Categorical's categories\")\n        if periods > 0:\n            codes[:periods] = fill_value\n        else:\n            codes[periods:] = fill_value\n    return self.from_codes(codes, dtype=self.dtype)",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    \"\"\"\n    The numpy array interface.\n\n    Returns\n    -------\n    numpy.array\n        A numpy array of either the specified dtype or,\n        if dtype==None (default), the same dtype as\n        categorical.categories.dtype.\n    \"\"\"\n    ret = take_1d(self.categories.values, self._codes)\n    if dtype and (not is_dtype_equal(dtype, self.categories.dtype)):\n        return np.asarray(ret, dtype)\n    if is_extension_array_dtype(ret):\n        ret = np.asarray(ret)\n    return ret",
                            "def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n    result = ops.maybe_dispatch_ufunc_to_dunder_op(self, ufunc, method, *inputs, **kwargs)\n    if result is not NotImplemented:\n        return result\n    raise TypeError(f'Object with dtype {self.dtype} cannot perform the numpy op {ufunc.__name__}')",
                            "def __setstate__(self, state):\n    \"\"\"Necessary for making this object picklable\"\"\"\n    if not isinstance(state, dict):\n        raise Exception('invalid pickle state')\n    if '_dtype' not in state:\n        state['_dtype'] = CategoricalDtype(state['_categories'], state['_ordered'])\n    for k, v in state.items():\n        setattr(self, k, v)",
                            "@property\ndef T(self) -> 'Categorical':\n    \"\"\"\n    Return transposed numpy array.\n    \"\"\"\n    return self",
                            "@property\ndef nbytes(self):\n    return self._codes.nbytes + self.dtype.categories.values.nbytes",
                            "def memory_usage(self, deep=False):\n    \"\"\"\n    Memory usage of my values\n\n    Parameters\n    ----------\n    deep : bool\n        Introspect the data deeply, interrogate\n        `object` dtypes for system-level memory consumption\n\n    Returns\n    -------\n    bytes used\n\n    Notes\n    -----\n    Memory usage does not include memory consumed by elements that\n    are not components of the array if deep=False\n\n    See Also\n    --------\n    numpy.ndarray.nbytes\n    \"\"\"\n    return self._codes.nbytes + self.dtype.categories.memory_usage(deep=deep)",
                            "@doc(_shared_docs['searchsorted'], klass='Categorical')\ndef searchsorted(self, value, side='left', sorter=None):\n    if is_scalar(value):\n        codes = self.categories.get_loc(value)\n        codes = self.codes.dtype.type(codes)\n    else:\n        locs = [self.categories.get_loc(x) for x in value]\n        codes = np.array(locs, dtype=self.codes.dtype)\n    return self.codes.searchsorted(codes, side=side, sorter=sorter)",
                            "def isna(self):\n    \"\"\"\n    Detect missing values\n\n    Missing values (-1 in .codes) are detected.\n\n    Returns\n    -------\n    a boolean array of whether my values are null\n\n    See Also\n    --------\n    isna : Top-level isna.\n    isnull : Alias of isna.\n    Categorical.notna : Boolean inverse of Categorical.isna.\n\n    \"\"\"\n    ret = self._codes == -1\n    return ret",
                            "def notna(self):\n    \"\"\"\n    Inverse of isna\n\n    Both missing values (-1 in .codes) and NA as a category are detected as\n    null.\n\n    Returns\n    -------\n    a boolean array of whether my values are not null\n\n    See Also\n    --------\n    notna : Top-level notna.\n    notnull : Alias of notna.\n    Categorical.isna : Boolean inverse of Categorical.notna.\n\n    \"\"\"\n    return ~self.isna()",
                            "def dropna(self):\n    \"\"\"\n    Return the Categorical without null values.\n\n    Missing values (-1 in .codes) are detected.\n\n    Returns\n    -------\n    valid : Categorical\n    \"\"\"\n    result = self[self.notna()]\n    return result",
                            "def value_counts(self, dropna=True):\n    \"\"\"\n    Return a Series containing counts of each category.\n\n    Every category will have an entry, even those with a count of 0.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaN.\n\n    Returns\n    -------\n    counts : Series\n\n    See Also\n    --------\n    Series.value_counts\n    \"\"\"\n    from pandas import Series, CategoricalIndex\n    code, cat = (self._codes, self.categories)\n    ncat, mask = (len(cat), 0 <= code)\n    ix, clean = (np.arange(ncat), mask.all())\n    if dropna or clean:\n        obs = code if clean else code[mask]\n        count = np.bincount(obs, minlength=ncat or 0)\n    else:\n        count = np.bincount(np.where(mask, code, ncat))\n        ix = np.append(ix, -1)\n    ix = self._constructor(ix, dtype=self.dtype, fastpath=True)\n    return Series(count, index=CategoricalIndex(ix), dtype='int64')",
                            "def _internal_get_values(self):\n    \"\"\"\n    Return the values.\n\n    For internal compatibility with pandas formatting.\n\n    Returns\n    -------\n    np.ndarray or Index\n        A numpy array of the same dtype as categorical.categories.dtype or\n        Index if datetime / periods.\n    \"\"\"\n    if needs_i8_conversion(self.categories):\n        return self.categories.take(self._codes, fill_value=np.nan)\n    elif is_integer_dtype(self.categories) and -1 in self._codes:\n        return self.categories.astype('object').take(self._codes, fill_value=np.nan)\n    return np.array(self)",
                            "def check_for_ordered(self, op):\n    \"\"\" assert that we are ordered \"\"\"\n    if not self.ordered:\n        raise TypeError(f'Categorical is not ordered for operation {op}\\nyou can use .as_ordered() to change the Categorical to an ordered one\\n')",
                            "def _values_for_argsort(self):\n    return self._codes",
                            "def argsort(self, ascending=True, kind='quicksort', **kwargs):\n    \"\"\"\n    Return the indices that would sort the Categorical.\n\n    .. versionchanged:: 0.25.0\n\n       Changed to sort missing values at the end.\n\n    Parameters\n    ----------\n    ascending : bool, default True\n        Whether the indices should result in an ascending\n        or descending sort.\n    kind : {'quicksort', 'mergesort', 'heapsort'}, optional\n        Sorting algorithm.\n    **kwargs:\n        passed through to :func:`numpy.argsort`.\n\n    Returns\n    -------\n    numpy.array\n\n    See Also\n    --------\n    numpy.ndarray.argsort\n\n    Notes\n    -----\n    While an ordering is applied to the category values, arg-sorting\n    in this context refers more to organizing and grouping together\n    based on matching category values. Thus, this function can be\n    called on an unordered Categorical instance unlike the functions\n    'Categorical.min' and 'Categorical.max'.\n\n    Examples\n    --------\n    >>> pd.Categorical(['b', 'b', 'a', 'c']).argsort()\n    array([2, 0, 1, 3])\n\n    >>> cat = pd.Categorical(['b', 'b', 'a', 'c'],\n    ...                      categories=['c', 'b', 'a'],\n    ...                      ordered=True)\n    >>> cat.argsort()\n    array([3, 0, 1, 2])\n\n    Missing values are placed at the end\n\n    >>> cat = pd.Categorical([2, None, 1])\n    >>> cat.argsort()\n    array([2, 0, 1])\n    \"\"\"\n    return super().argsort(ascending=ascending, kind=kind, **kwargs)",
                            "def sort_values(self, inplace=False, ascending=True, na_position='last'):\n    \"\"\"\n    Sort the Categorical by category value returning a new\n    Categorical by default.\n\n    While an ordering is applied to the category values, sorting in this\n    context refers more to organizing and grouping together based on\n    matching category values. Thus, this function can be called on an\n    unordered Categorical instance unlike the functions 'Categorical.min'\n    and 'Categorical.max'.\n\n    Parameters\n    ----------\n    inplace : bool, default False\n        Do operation in place.\n    ascending : bool, default True\n        Order ascending. Passing False orders descending. The\n        ordering parameter provides the method by which the\n        category values are organized.\n    na_position : {'first', 'last'} (optional, default='last')\n        'first' puts NaNs at the beginning\n        'last' puts NaNs at the end\n\n    Returns\n    -------\n    Categorical or None\n\n    See Also\n    --------\n    Categorical.sort\n    Series.sort_values\n\n    Examples\n    --------\n    >>> c = pd.Categorical([1, 2, 2, 1, 5])\n    >>> c\n    [1, 2, 2, 1, 5]\n    Categories (3, int64): [1, 2, 5]\n    >>> c.sort_values()\n    [1, 1, 2, 2, 5]\n    Categories (3, int64): [1, 2, 5]\n    >>> c.sort_values(ascending=False)\n    [5, 2, 2, 1, 1]\n    Categories (3, int64): [1, 2, 5]\n\n    Inplace sorting can be done as well:\n\n    >>> c.sort_values(inplace=True)\n    >>> c\n    [1, 1, 2, 2, 5]\n    Categories (3, int64): [1, 2, 5]\n    >>>\n    >>> c = pd.Categorical([1, 2, 2, 1, 5])\n\n    'sort_values' behaviour with NaNs. Note that 'na_position'\n    is independent of the 'ascending' parameter:\n\n    >>> c = pd.Categorical([np.nan, 2, 2, np.nan, 5])\n    >>> c\n    [NaN, 2, 2, NaN, 5]\n    Categories (2, int64): [2, 5]\n    >>> c.sort_values()\n    [2, 2, 5, NaN, NaN]\n    Categories (2, int64): [2, 5]\n    >>> c.sort_values(ascending=False)\n    [5, 2, 2, NaN, NaN]\n    Categories (2, int64): [2, 5]\n    >>> c.sort_values(na_position='first')\n    [NaN, NaN, 2, 2, 5]\n    Categories (2, int64): [2, 5]\n    >>> c.sort_values(ascending=False, na_position='first')\n    [NaN, NaN, 5, 2, 2]\n    Categories (2, int64): [2, 5]\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    if na_position not in ['last', 'first']:\n        raise ValueError(f'invalid na_position: {repr(na_position)}')\n    sorted_idx = nargsort(self, ascending=ascending, na_position=na_position)\n    if inplace:\n        self._codes = self._codes[sorted_idx]\n    else:\n        return self._constructor(values=self._codes[sorted_idx], dtype=self.dtype, fastpath=True)",
                            "def _values_for_rank(self):\n    \"\"\"\n    For correctly ranking ordered categorical data. See GH#15420\n\n    Ordered categorical data should be ranked on the basis of\n    codes with -1 translated to NaN.\n\n    Returns\n    -------\n    numpy.array\n\n    \"\"\"\n    from pandas import Series\n    if self.ordered:\n        values = self.codes\n        mask = values == -1\n        if mask.any():\n            values = values.astype('float64')\n            values[mask] = np.nan\n    elif self.categories.is_numeric():\n        values = np.array(self)\n    else:\n        values = np.array(self.rename_categories(Series(self.categories).rank().values))\n    return values",
                            "def view(self, dtype=None):\n    if dtype is not None:\n        raise NotImplementedError(dtype)\n    return self._constructor(values=self._codes, dtype=self.dtype, fastpath=True)",
                            "def to_dense(self):\n    \"\"\"\n    Return my 'dense' representation\n\n    For internal compatibility with numpy arrays.\n\n    Returns\n    -------\n    dense : array\n    \"\"\"\n    warn('Categorical.to_dense is deprecated and will be removed in a future version.  Use np.asarray(cat) instead.', FutureWarning, stacklevel=2)\n    return np.asarray(self)",
                            "def fillna(self, value=None, method=None, limit=None):\n    \"\"\"\n    Fill NA/NaN values using the specified method.\n\n    Parameters\n    ----------\n    value : scalar, dict, Series\n        If a scalar value is passed it is used to fill all missing values.\n        Alternatively, a Series or dict can be used to fill in different\n        values for each index. The value should not be a list. The\n        value(s) passed should either be in the categories or should be\n        NaN.\n    method : {'backfill', 'bfill', 'pad', 'ffill', None}, default None\n        Method to use for filling holes in reindexed Series\n        pad / ffill: propagate last valid observation forward to next valid\n        backfill / bfill: use NEXT valid observation to fill gap\n    limit : int, default None\n        (Not implemented yet for Categorical!)\n        If method is specified, this is the maximum number of consecutive\n        NaN values to forward/backward fill. In other words, if there is\n        a gap with more than this number of consecutive NaNs, it will only\n        be partially filled. If method is not specified, this is the\n        maximum number of entries along the entire axis where NaNs will be\n        filled.\n\n    Returns\n    -------\n    filled : Categorical with NA/NaN filled\n    \"\"\"\n    value, method = validate_fillna_kwargs(value, method, validate_scalar_dict_value=False)\n    if value is None:\n        value = np.nan\n    if limit is not None:\n        raise NotImplementedError('specifying a limit for fillna has not been implemented yet')\n    codes = self._codes\n    if method is not None:\n        values = np.asarray(self).reshape(-1, len(self))\n        values = interpolate_2d(values, method, 0, None, value).astype(self.categories.dtype)[0]\n        codes = _get_codes_for_values(values, self.categories)\n    elif isinstance(value, (np.ndarray, Categorical, ABCSeries)):\n        mask = ~algorithms.isin(value, self.categories)\n        if not isna(value[mask]).all():\n            raise ValueError('fill value must be in categories')\n        values_codes = _get_codes_for_values(value, self.categories)\n        indexer = np.where(codes == -1)\n        codes = codes.copy()\n        codes[indexer] = values_codes[indexer]\n    elif is_hashable(value):\n        if not isna(value) and value not in self.categories:\n            raise ValueError('fill value must be in categories')\n        mask = codes == -1\n        if mask.any():\n            codes = codes.copy()\n            if isna(value):\n                codes[mask] = -1\n            else:\n                codes[mask] = self.categories.get_loc(value)\n    else:\n        raise TypeError(f\"'value' parameter must be a scalar, dict or Series, but you passed a {type(value).__name__}\")\n    return self._constructor(codes, dtype=self.dtype, fastpath=True)",
                            "def take(self, indexer, allow_fill: bool=False, fill_value=None):\n    \"\"\"\n    Take elements from the Categorical.\n\n    Parameters\n    ----------\n    indexer : sequence of int\n        The indices in `self` to take. The meaning of negative values in\n        `indexer` depends on the value of `allow_fill`.\n    allow_fill : bool, default False\n        How to handle negative values in `indexer`.\n\n        * False: negative values in `indices` indicate positional indices\n          from the right. This is similar to\n          :func:`numpy.take`.\n\n        * True: negative values in `indices` indicate missing values\n          (the default). These values are set to `fill_value`. Any other\n          other negative values raise a ``ValueError``.\n\n        .. versionchanged:: 1.0.0\n\n           Default value changed from ``True`` to ``False``.\n\n    fill_value : object\n        The value to use for `indices` that are missing (-1), when\n        ``allow_fill=True``. This should be the category, i.e. a value\n        in ``self.categories``, not a code.\n\n    Returns\n    -------\n    Categorical\n        This Categorical will have the same categories and ordered as\n        `self`.\n\n    See Also\n    --------\n    Series.take : Similar method for Series.\n    numpy.ndarray.take : Similar method for NumPy arrays.\n\n    Examples\n    --------\n    >>> cat = pd.Categorical(['a', 'a', 'b'])\n    >>> cat\n    [a, a, b]\n    Categories (2, object): [a, b]\n\n    Specify ``allow_fill==False`` to have negative indices mean indexing\n    from the right.\n\n    >>> cat.take([0, -1, -2], allow_fill=False)\n    [a, b, a]\n    Categories (2, object): [a, b]\n\n    With ``allow_fill=True``, indices equal to ``-1`` mean \"missing\"\n    values that should be filled with the `fill_value`, which is\n    ``np.nan`` by default.\n\n    >>> cat.take([0, -1, -1], allow_fill=True)\n    [a, NaN, NaN]\n    Categories (2, object): [a, b]\n\n    The fill value can be specified.\n\n    >>> cat.take([0, -1, -1], allow_fill=True, fill_value='a')\n    [a, a, a]\n    Categories (2, object): [a, b]\n\n    Specifying a fill value that's not in ``self.categories``\n    will raise a ``TypeError``.\n    \"\"\"\n    indexer = np.asarray(indexer, dtype=np.intp)\n    dtype = self.dtype\n    if isna(fill_value):\n        fill_value = -1\n    elif allow_fill:\n        if fill_value in self.categories:\n            fill_value = self.categories.get_loc(fill_value)\n        else:\n            msg = f\"'fill_value' ('{fill_value}') is not in this Categorical's categories.\"\n            raise TypeError(msg)\n    codes = take(self._codes, indexer, allow_fill=allow_fill, fill_value=fill_value)\n    result = type(self).from_codes(codes, dtype=dtype)\n    return result",
                            "def take_nd(self, indexer, allow_fill: bool=False, fill_value=None):\n    warn('Categorical.take_nd is deprecated, use Categorical.take instead', FutureWarning, stacklevel=2)\n    return self.take(indexer, allow_fill=allow_fill, fill_value=fill_value)",
                            "def __len__(self) -> int:\n    \"\"\"\n    The length of this Categorical.\n    \"\"\"\n    return len(self._codes)",
                            "def __iter__(self):\n    \"\"\"\n    Returns an Iterator over the values of this Categorical.\n    \"\"\"\n    return iter(self._internal_get_values().tolist())",
                            "def __contains__(self, key) -> bool:\n    \"\"\"\n    Returns True if `key` is in this Categorical.\n    \"\"\"\n    if is_scalar(key) and isna(key):\n        return self.isna().any()\n    return contains(self, key, container=self._codes)",
                            "def _tidy_repr(self, max_vals=10, footer=True) -> str:\n    \"\"\"\n    a short repr displaying only max_vals and an optional (but default\n    footer)\n    \"\"\"\n    num = max_vals // 2\n    head = self[:num]._get_repr(length=False, footer=False)\n    tail = self[-(max_vals - num):]._get_repr(length=False, footer=False)\n    result = f'{head[:-1]}, ..., {tail[1:]}'\n    if footer:\n        result = f'{result}\\n{self._repr_footer()}'\n    return str(result)",
                            "def _repr_categories(self):\n    \"\"\"\n    return the base repr for the categories\n    \"\"\"\n    max_categories = 10 if get_option('display.max_categories') == 0 else get_option('display.max_categories')\n    from pandas.io.formats import format as fmt\n    if len(self.categories) > max_categories:\n        num = max_categories // 2\n        head = fmt.format_array(self.categories[:num], None)\n        tail = fmt.format_array(self.categories[-num:], None)\n        category_strs = head + ['...'] + tail\n    else:\n        category_strs = fmt.format_array(self.categories, None)\n    category_strs = [x.strip() for x in category_strs]\n    return category_strs",
                            "def _repr_categories_info(self) -> str:\n    \"\"\"\n    Returns a string representation of the footer.\n    \"\"\"\n    category_strs = self._repr_categories()\n    dtype = str(self.categories.dtype)\n    levheader = f'Categories ({len(self.categories)}, {dtype}): '\n    width, height = get_terminal_size()\n    max_width = get_option('display.width') or width\n    if console.in_ipython_frontend():\n        max_width = 0\n    levstring = ''\n    start = True\n    cur_col_len = len(levheader)\n    sep_len, sep = (3, ' < ') if self.ordered else (2, ', ')\n    linesep = sep.rstrip() + '\\n'\n    for val in category_strs:\n        if max_width != 0 and cur_col_len + sep_len + len(val) > max_width:\n            levstring += linesep + ' ' * (len(levheader) + 1)\n            cur_col_len = len(levheader) + 1\n        elif not start:\n            levstring += sep\n            cur_col_len += len(val)\n        levstring += val\n        start = False\n    return levheader + '[' + levstring.replace(' < ... < ', ' ... ') + ']'",
                            "def _repr_footer(self) -> str:\n    info = self._repr_categories_info()\n    return f'Length: {len(self)}\\n{info}'",
                            "def _get_repr(self, length=True, na_rep='NaN', footer=True) -> str:\n    from pandas.io.formats import format as fmt\n    formatter = fmt.CategoricalFormatter(self, length=length, na_rep=na_rep, footer=footer)\n    result = formatter.to_string()\n    return str(result)",
                            "def __repr__(self) -> str:\n    \"\"\"\n    String representation.\n    \"\"\"\n    _maxlen = 10\n    if len(self._codes) > _maxlen:\n        result = self._tidy_repr(_maxlen)\n    elif len(self._codes) > 0:\n        result = self._get_repr(length=len(self) > _maxlen)\n    else:\n        msg = self._get_repr(length=False, footer=True).replace('\\n', ', ')\n        result = f'[], {msg}'\n    return result",
                            "def _maybe_coerce_indexer(self, indexer):\n    \"\"\"\n    return an indexer coerced to the codes dtype\n    \"\"\"\n    if isinstance(indexer, np.ndarray) and indexer.dtype.kind == 'i':\n        indexer = indexer.astype(self._codes.dtype)\n    return indexer",
                            "def __getitem__(self, key):\n    \"\"\"\n    Return an item.\n    \"\"\"\n    if isinstance(key, (int, np.integer)):\n        i = self._codes[key]\n        if i == -1:\n            return np.nan\n        else:\n            return self.categories[i]\n    key = check_array_indexer(self, key)\n    result = self._codes[key]\n    if result.ndim > 1:\n        deprecate_ndim_indexing(result)\n        return result\n    return self._constructor(result, dtype=self.dtype, fastpath=True)",
                            "def __setitem__(self, key, value):\n    \"\"\"\n    Item assignment.\n\n    Raises\n    ------\n    ValueError\n        If (one or more) Value is not in categories or if a assigned\n        `Categorical` does not have the same categories\n    \"\"\"\n    value = extract_array(value, extract_numpy=True)\n    if isinstance(value, Categorical):\n        if not is_dtype_equal(self, value):\n            raise ValueError('Cannot set a Categorical with another, without identical categories')\n        if not self.categories.equals(value.categories):\n            new_codes = recode_for_categories(value.codes, value.categories, self.categories)\n            value = Categorical.from_codes(new_codes, dtype=self.dtype)\n    rvalue = value if is_list_like(value) else [value]\n    from pandas import Index\n    to_add = Index(rvalue).difference(self.categories)\n    if len(to_add) and (not isna(to_add).all()):\n        raise ValueError('Cannot setitem on a Categorical with a new category, set the categories first')\n    if isinstance(key, (int, np.integer)):\n        pass\n    elif isinstance(key, tuple):\n        if len(key) == 2:\n            if not com.is_null_slice(key[0]):\n                raise AssertionError('invalid slicing for a 1-ndim categorical')\n            key = key[1]\n        elif len(key) == 1:\n            key = key[0]\n        else:\n            raise AssertionError('invalid slicing for a 1-ndim categorical')\n    elif isinstance(key, slice):\n        pass\n    lindexer = self.categories.get_indexer(rvalue)\n    lindexer = self._maybe_coerce_indexer(lindexer)\n    key = check_array_indexer(self, key)\n    self._codes[key] = lindexer",
                            "def _reverse_indexer(self) -> Dict[Hashable, np.ndarray]:\n    \"\"\"\n    Compute the inverse of a categorical, returning\n    a dict of categories -> indexers.\n\n    *This is an internal function*\n\n    Returns\n    -------\n    dict of categories -> indexers\n\n    Examples\n    --------\n    >>> c = pd.Categorical(list('aabca'))\n    >>> c\n    [a, a, b, c, a]\n    Categories (3, object): [a, b, c]\n    >>> c.categories\n    Index(['a', 'b', 'c'], dtype='object')\n    >>> c.codes\n    array([0, 0, 1, 2, 0], dtype=int8)\n    >>> c._reverse_indexer()\n    {'a': array([0, 1, 4]), 'b': array([2]), 'c': array([3])}\n\n    \"\"\"\n    categories = self.categories\n    r, counts = libalgos.groupsort_indexer(self.codes.astype('int64'), categories.size)\n    counts = counts.cumsum()\n    _result = (r[start:end] for start, end in zip(counts, counts[1:]))\n    result = dict(zip(categories, _result))\n    return result",
                            "def _reduce(self, name, axis=0, **kwargs):\n    func = getattr(self, name, None)\n    if func is None:\n        raise TypeError(f'Categorical cannot perform the operation {name}')\n    return func(**kwargs)",
                            "@deprecate_kwarg(old_arg_name='numeric_only', new_arg_name='skipna')\ndef min(self, skipna=True):\n    \"\"\"\n    The minimum value of the object.\n\n    Only ordered `Categoricals` have a minimum!\n\n    .. versionchanged:: 1.0.0\n\n       Returns an NA value on empty arrays\n\n    Raises\n    ------\n    TypeError\n        If the `Categorical` is not `ordered`.\n\n    Returns\n    -------\n    min : the minimum of this `Categorical`\n    \"\"\"\n    self.check_for_ordered('min')\n    if not len(self._codes):\n        return self.dtype.na_value\n    good = self._codes != -1\n    if not good.all():\n        if skipna:\n            pointer = self._codes[good].min()\n        else:\n            return np.nan\n    else:\n        pointer = self._codes.min()\n    return self.categories[pointer]",
                            "@deprecate_kwarg(old_arg_name='numeric_only', new_arg_name='skipna')\ndef max(self, skipna=True):\n    \"\"\"\n    The maximum value of the object.\n\n    Only ordered `Categoricals` have a maximum!\n\n    .. versionchanged:: 1.0.0\n\n       Returns an NA value on empty arrays\n\n    Raises\n    ------\n    TypeError\n        If the `Categorical` is not `ordered`.\n\n    Returns\n    -------\n    max : the maximum of this `Categorical`\n    \"\"\"\n    self.check_for_ordered('max')\n    if not len(self._codes):\n        return self.dtype.na_value\n    good = self._codes != -1\n    if not good.all():\n        if skipna:\n            pointer = self._codes[good].max()\n        else:\n            return np.nan\n    else:\n        pointer = self._codes.max()\n    return self.categories[pointer]",
                            "def mode(self, dropna=True):\n    \"\"\"\n    Returns the mode(s) of the Categorical.\n\n    Always returns `Categorical` even if only one value.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't consider counts of NaN/NaT.\n\n        .. versionadded:: 0.24.0\n\n    Returns\n    -------\n    modes : `Categorical` (sorted)\n    \"\"\"\n    codes = self._codes\n    if dropna:\n        good = self._codes != -1\n        codes = self._codes[good]\n    codes = sorted(htable.mode_int64(ensure_int64(codes), dropna))\n    return self._constructor(values=codes, dtype=self.dtype, fastpath=True)",
                            "def unique(self):\n    \"\"\"\n    Return the ``Categorical`` which ``categories`` and ``codes`` are\n    unique. Unused categories are NOT returned.\n\n    - unordered category: values and categories are sorted by appearance\n      order.\n    - ordered category: values are sorted by appearance order, categories\n      keeps existing order.\n\n    Returns\n    -------\n    unique values : ``Categorical``\n\n    See Also\n    --------\n    pandas.unique\n    CategoricalIndex.unique\n    Series.unique\n\n    Examples\n    --------\n    An unordered Categorical will return categories in the\n    order of appearance.\n\n    >>> pd.Categorical(list(\"baabc\")).unique()\n    [b, a, c]\n    Categories (3, object): [b, a, c]\n\n    >>> pd.Categorical(list(\"baabc\"), categories=list(\"abc\")).unique()\n    [b, a, c]\n    Categories (3, object): [b, a, c]\n\n    An ordered Categorical preserves the category ordering.\n\n    >>> pd.Categorical(\n    ...     list(\"baabc\"), categories=list(\"abc\"), ordered=True\n    ... ).unique()\n    [b, a, c]\n    Categories (3, object): [a < b < c]\n    \"\"\"\n    unique_codes = unique1d(self.codes)\n    cat = self.copy()\n    cat._codes = unique_codes\n    take_codes = unique_codes[unique_codes != -1]\n    if self.ordered:\n        take_codes = np.sort(take_codes)\n    return cat.set_categories(cat.categories.take(take_codes))",
                            "def _values_for_factorize(self):\n    codes = self.codes.astype('int64')\n    return (codes, -1)",
                            "@classmethod\ndef _from_factorized(cls, uniques, original):\n    return original._constructor(original.categories.take(uniques), dtype=original.dtype)",
                            "def equals(self, other):\n    \"\"\"\n    Returns True if categorical arrays are equal.\n\n    Parameters\n    ----------\n    other : `Categorical`\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    if self.is_dtype_equal(other):\n        if self.categories.equals(other.categories):\n            other_codes = other._codes\n        else:\n            other_codes = recode_for_categories(other.codes, other.categories, self.categories)\n        return np.array_equal(self._codes, other_codes)\n    return False",
                            "def is_dtype_equal(self, other):\n    \"\"\"\n    Returns True if categoricals are the same dtype\n      same categories, and same ordered\n\n    Parameters\n    ----------\n    other : Categorical\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    try:\n        return hash(self.dtype) == hash(other.dtype)\n    except (AttributeError, TypeError):\n        return False",
                            "def describe(self):\n    \"\"\"\n    Describes this Categorical\n\n    Returns\n    -------\n    description: `DataFrame`\n        A dataframe with frequency and counts by category.\n    \"\"\"\n    counts = self.value_counts(dropna=False)\n    freqs = counts / float(counts.sum())\n    from pandas.core.reshape.concat import concat\n    result = concat([counts, freqs], axis=1)\n    result.columns = ['counts', 'freqs']\n    result.index.name = 'categories'\n    return result",
                            "@Substitution(klass='Categorical')\n@Appender(_extension_array_shared_docs['repeat'])\ndef repeat(self, repeats, axis=None):\n    nv.validate_repeat(tuple(), dict(axis=axis))\n    codes = self._codes.repeat(repeats)\n    return self._constructor(values=codes, dtype=self.dtype, fastpath=True)",
                            "@property\ndef _can_hold_na(self):\n    return True",
                            "@classmethod\ndef _concat_same_type(self, to_concat):\n    from pandas.core.dtypes.concat import concat_categorical\n    return concat_categorical(to_concat)",
                            "def isin(self, values):\n    \"\"\"\n    Check whether `values` are contained in Categorical.\n\n    Return a boolean NumPy Array showing whether each element in\n    the Categorical matches an element in the passed sequence of\n    `values` exactly.\n\n    Parameters\n    ----------\n    values : set or list-like\n        The sequence of values to test. Passing in a single string will\n        raise a ``TypeError``. Instead, turn a single string into a\n        list of one element.\n\n    Returns\n    -------\n    isin : numpy.ndarray (bool dtype)\n\n    Raises\n    ------\n    TypeError\n      * If `values` is not a set or list-like\n\n    See Also\n    --------\n    pandas.Series.isin : Equivalent method on Series.\n\n    Examples\n    --------\n    >>> s = pd.Categorical(['lama', 'cow', 'lama', 'beetle', 'lama',\n    ...                'hippo'])\n    >>> s.isin(['cow', 'lama'])\n    array([ True,  True,  True, False,  True, False])\n\n    Passing a single string as ``s.isin('lama')`` will raise an error. Use\n    a list of one element instead:\n\n    >>> s.isin(['lama'])\n    array([ True, False,  True, False,  True, False])\n    \"\"\"\n    if not is_list_like(values):\n        values_type = type(values).__name__\n        raise TypeError(f'only list-like objects are allowed to be passed to isin(), you passed a [{values_type}]')\n    values = sanitize_array(values, None, None)\n    null_mask = np.asarray(isna(values))\n    code_values = self.categories.get_indexer(values)\n    code_values = code_values[null_mask | (code_values >= 0)]\n    return algorithms.isin(self.codes, code_values)",
                            "def replace(self, to_replace, value, inplace: bool=False):\n    \"\"\"\n    Replaces all instances of one value with another\n\n    Parameters\n    ----------\n    to_replace: object\n        The value to be replaced\n\n    value: object\n        The value to replace it with\n\n    inplace: bool\n        Whether the operation is done in-place\n\n    Returns\n    -------\n    None if inplace is True, otherwise the new Categorical after replacement\n\n\n    Examples\n    --------\n    >>> s = pd.Categorical([1, 2, 1, 3])\n    >>> s.replace(1, 3)\n    [3, 2, 3, 3]\n    Categories (2, int64): [2, 3]\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    cat = self if inplace else self.copy()\n    if is_list_like(to_replace):\n        replace_dict = {replace_value: value for replace_value in to_replace}\n    else:\n        replace_dict = {to_replace: value}\n    for replace_value, new_value in replace_dict.items():\n        if new_value == replace_value:\n            continue\n        if replace_value in cat.categories:\n            if isna(new_value):\n                cat.remove_categories(replace_value, inplace=True)\n                continue\n            categories = cat.categories.tolist()\n            index = categories.index(replace_value)\n            if new_value in cat.categories:\n                value_index = categories.index(new_value)\n                cat._codes[cat._codes == index] = value_index\n                cat.remove_categories(replace_value, inplace=True)\n            else:\n                categories[index] = new_value\n                cat.rename_categories(categories, inplace=True)\n    if not inplace:\n        return cat"
                        ],
                        "constructor_variables": [
                            "_dtype",
                            "full_codes",
                            "_codes",
                            "sanitize_dtype",
                            "codes",
                            "dtype",
                            "null_mask",
                            "old_codes",
                            "values"
                        ],
                        "class_level_variables": [
                            "__array_priority__",
                            "_dtype",
                            "_deprecations",
                            "_typ",
                            "to_list",
                            "codes",
                            "__eq__",
                            "__ne__",
                            "__lt__",
                            "__gt__",
                            "__le__",
                            "__ge__",
                            "isnull",
                            "notnull"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "__init__(self, values, categories=None, ordered=None, dtype=None, fastpath=False)",
                            "categories(self)",
                            "categories(self, categories)",
                            "ordered(self) -> Ordered",
                            "dtype(self) -> CategoricalDtype",
                            "_constructor(self) -> Type['Categorical']",
                            "_from_sequence(cls, scalars, dtype=None, copy=False)",
                            "_formatter(self, boxed=False)",
                            "copy(self) -> 'Categorical'",
                            "astype(self, dtype: Dtype, copy: bool=True) -> ArrayLike",
                            "size(self) -> int",
                            "itemsize(self) -> int",
                            "tolist(self) -> List[Scalar]",
                            "_from_inferred_categories(cls, inferred_categories, inferred_codes, dtype, true_values=None)",
                            "from_codes(cls, codes, categories=None, ordered=None, dtype=None)",
                            "_get_codes(self)",
                            "_set_codes(self, codes)",
                            "_set_categories(self, categories, fastpath=False)",
                            "_set_dtype(self, dtype: CategoricalDtype) -> 'Categorical'",
                            "set_ordered(self, value, inplace=False)",
                            "as_ordered(self, inplace=False)",
                            "as_unordered(self, inplace=False)",
                            "set_categories(self, new_categories, ordered=None, rename=False, inplace=False)",
                            "rename_categories(self, new_categories, inplace=False)",
                            "reorder_categories(self, new_categories, ordered=None, inplace=False)",
                            "add_categories(self, new_categories, inplace=False)",
                            "remove_categories(self, removals, inplace=False)",
                            "remove_unused_categories(self, inplace=False)",
                            "map(self, mapper)",
                            "shape(self)",
                            "shift(self, periods, fill_value=None)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__array_ufunc__(self, ufunc, method, *inputs, **kwargs)",
                            "__setstate__(self, state)",
                            "T(self) -> 'Categorical'",
                            "nbytes(self)",
                            "memory_usage(self, deep=False)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "isna(self)",
                            "notna(self)",
                            "dropna(self)",
                            "value_counts(self, dropna=True)",
                            "_internal_get_values(self)",
                            "check_for_ordered(self, op)",
                            "_values_for_argsort(self)",
                            "argsort(self, ascending=True, kind='quicksort', **kwargs)",
                            "sort_values(self, inplace=False, ascending=True, na_position='last')",
                            "_values_for_rank(self)",
                            "view(self, dtype=None)",
                            "to_dense(self)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "take(self, indexer, allow_fill: bool=False, fill_value=None)",
                            "take_nd(self, indexer, allow_fill: bool=False, fill_value=None)",
                            "__len__(self) -> int",
                            "__iter__(self)",
                            "__contains__(self, key) -> bool",
                            "_tidy_repr(self, max_vals=10, footer=True) -> str",
                            "_repr_categories(self)",
                            "_repr_categories_info(self) -> str",
                            "_repr_footer(self) -> str",
                            "_get_repr(self, length=True, na_rep='NaN', footer=True) -> str",
                            "__repr__(self) -> str",
                            "_maybe_coerce_indexer(self, indexer)",
                            "__getitem__(self, key)",
                            "__setitem__(self, key, value)",
                            "_reverse_indexer(self) -> Dict[Hashable, np.ndarray]",
                            "_reduce(self, name, axis=0, **kwargs)",
                            "min(self, skipna=True)",
                            "max(self, skipna=True)",
                            "mode(self, dropna=True)",
                            "unique(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, uniques, original)",
                            "equals(self, other)",
                            "is_dtype_equal(self, other)",
                            "describe(self)",
                            "repeat(self, repeats, axis=None)",
                            "_can_hold_na(self)",
                            "_concat_same_type(self, to_concat)",
                            "isin(self, values)",
                            "replace(self, to_replace, value, inplace: bool=False)"
                        ]
                    },
                    "variable_values": [
                        [
                            {
                                "self.check_for_ordered": {
                                    "variable_value": "<bound method Categorical.check_for_ordered of [NaN]\nCategories (2, int64): [1 < 2]>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "[NaN]\nCategories (2, int64): [1 < 2]",
                                    "variable_type": "Categorical",
                                    "variable_shape": "(1,)"
                                },
                                "self._codes": {
                                    "variable_value": "array([-1], dtype=int8)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "self.dtype.na_value": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "CategoricalDtype(categories=[1, 2], ordered=True)",
                                    "variable_type": "CategoricalDtype",
                                    "variable_shape": "()"
                                },
                                "good": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "good.all": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "skipna": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "pointer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.nan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._codes.min": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.categories": {
                                    "variable_value": "Int64Index([1, 2], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "(2,)"
                                },
                                "deprecate_kwarg": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "self.check_for_ordered": {
                                    "variable_value": "<bound method Categorical.check_for_ordered of [NaN]\nCategories (2, int64): [1 < 2]>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "[NaN]\nCategories (2, int64): [1 < 2]",
                                    "variable_type": "Categorical",
                                    "variable_shape": "(1,)"
                                },
                                "self._codes": {
                                    "variable_value": "array([-1], dtype=int8)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "self.dtype.na_value": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "CategoricalDtype(categories=[1, 2], ordered=True)",
                                    "variable_type": "CategoricalDtype",
                                    "variable_shape": "()"
                                },
                                "good": {
                                    "variable_value": "array([False])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "good.all": {
                                    "variable_value": "<built-in method all of numpy.ndarray object at 0x11ac94bc0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "skipna": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "pointer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.nan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._codes.min": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.categories": {
                                    "variable_value": "Int64Index([1, 2], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "(2,)"
                                },
                                "deprecate_kwarg": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "self.check_for_ordered": {
                                    "variable_value": "<bound method Categorical.check_for_ordered of [NaN]\nCategories (2, int64): [1 < 2]>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "[NaN]\nCategories (2, int64): [1 < 2]",
                                    "variable_type": "Categorical",
                                    "variable_shape": "(1,)"
                                },
                                "self._codes": {
                                    "variable_value": "array([-1], dtype=int8)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "self.dtype.na_value": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "CategoricalDtype(categories=[1, 2], ordered=True)",
                                    "variable_type": "CategoricalDtype",
                                    "variable_shape": "()"
                                },
                                "good": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "good.all": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "skipna": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "good.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pointer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.nan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._codes.min": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.categories": {
                                    "variable_value": "Int64Index([1, 2], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "(2,)"
                                },
                                "deprecate_kwarg": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "self.check_for_ordered": {
                                    "variable_value": "<bound method Categorical.check_for_ordered of [NaN]\nCategories (2, int64): [1 < 2]>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "[NaN]\nCategories (2, int64): [1 < 2]",
                                    "variable_type": "Categorical",
                                    "variable_shape": "(1,)"
                                },
                                "self._codes": {
                                    "variable_value": "array([-1], dtype=int8)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "self.dtype.na_value": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "CategoricalDtype(categories=[1, 2], ordered=True)",
                                    "variable_type": "CategoricalDtype",
                                    "variable_shape": "()"
                                },
                                "good": {
                                    "variable_value": "array([False])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "good.all": {
                                    "variable_value": "<built-in method all of numpy.ndarray object at 0x11ef64c10>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "skipna": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "good.any": {
                                    "variable_value": "<built-in method any of numpy.ndarray object at 0x11ef64c10>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "pointer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.nan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._codes.min": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.categories": {
                                    "variable_value": "Int64Index([1, 2], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "(2,)"
                                },
                                "deprecate_kwarg": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "self.check_for_ordered": {
                                    "variable_value": "<bound method Categorical.check_for_ordered of [NaN]\nCategories (2, int64): [1 < 2]>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "[NaN]\nCategories (2, int64): [1 < 2]",
                                    "variable_type": "Categorical",
                                    "variable_shape": "(1,)"
                                },
                                "self._codes": {
                                    "variable_value": "array([-1], dtype=int8)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "self.dtype.na_value": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "CategoricalDtype(categories=[1, 2], ordered=True)",
                                    "variable_type": "CategoricalDtype",
                                    "variable_shape": "()"
                                },
                                "good": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "good.all": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "skipna": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "good.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pointer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.nan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._codes.min": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.categories": {
                                    "variable_value": "Int64Index([1, 2], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "(2,)"
                                },
                                "deprecate_kwarg": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "self.check_for_ordered": {
                                    "variable_value": "<bound method Categorical.check_for_ordered of [NaN]\nCategories (2, int64): [1 < 2]>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "[NaN]\nCategories (2, int64): [1 < 2]",
                                    "variable_type": "Categorical",
                                    "variable_shape": "(1,)"
                                },
                                "self._codes": {
                                    "variable_value": "array([-1], dtype=int8)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "self.dtype.na_value": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "CategoricalDtype(categories=[1, 2], ordered=True)",
                                    "variable_type": "CategoricalDtype",
                                    "variable_shape": "()"
                                },
                                "good": {
                                    "variable_value": "array([False])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "good.all": {
                                    "variable_value": "<built-in method all of numpy.ndarray object at 0x11ef64bc0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "skipna": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "good.any": {
                                    "variable_value": "<built-in method any of numpy.ndarray object at 0x11ef64bc0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "pointer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.nan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._codes.min": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.categories": {
                                    "variable_value": "Int64Index([1, 2], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "(2,)"
                                },
                                "deprecate_kwarg": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                },
                {
                    "function_name": "max",
                    "function_code": "@deprecate_kwarg(old_arg_name=\"numeric_only\", new_arg_name=\"skipna\")\ndef max(self, skipna=True):\n    \"\"\"\n    The maximum value of the object.\n\n    Only ordered `Categoricals` have a maximum!\n\n    .. versionchanged:: 1.0.0\n\n       Returns an NA value on empty arrays\n\n    Raises\n    ------\n    TypeError\n        If the `Categorical` is not `ordered`.\n\n    Returns\n    -------\n    max : the maximum of this `Categorical`\n    \"\"\"\n    self.check_for_ordered(\"max\")\n\n    if not len(self._codes):\n        return self.dtype.na_value\n\n    good = self._codes != -1\n    if not good.all():\n        if skipna:\n            pointer = self._codes[good].max()\n        else:\n            return np.nan\n    else:\n        pointer = self._codes.max()\n    return self.categories[pointer]\n",
                    "decorators": [
                        "deprecate_kwarg(old_arg_name='numeric_only', new_arg_name='skipna')"
                    ],
                    "docstring": "The maximum value of the object.\n\nOnly ordered `Categoricals` have a maximum!\n\n.. versionchanged:: 1.0.0\n\n   Returns an NA value on empty arrays\n\nRaises\n------\nTypeError\n    If the `Categorical` is not `ordered`.\n\nReturns\n-------\nmax : the maximum of this `Categorical`",
                    "start_line": 2154,
                    "end_line": 2187,
                    "variables": {
                        "self.check_for_ordered": [
                            2174
                        ],
                        "self": [
                            2176,
                            2177,
                            2179,
                            2182,
                            2186,
                            2187,
                            2174
                        ],
                        "len": [
                            2176
                        ],
                        "self._codes": [
                            2176,
                            2186,
                            2179,
                            2182
                        ],
                        "self.dtype.na_value": [
                            2177
                        ],
                        "self.dtype": [
                            2177
                        ],
                        "good": [
                            2179,
                            2180,
                            2182
                        ],
                        "good.all": [
                            2180
                        ],
                        "skipna": [
                            2181
                        ],
                        "pointer": [
                            2186,
                            2187,
                            2182
                        ],
                        "max": [
                            2182
                        ],
                        "np.nan": [
                            2184
                        ],
                        "np": [
                            2184
                        ],
                        "self._codes.max": [
                            2186
                        ],
                        "self.categories": [
                            2187
                        ],
                        "deprecate_kwarg": [
                            2154
                        ]
                    },
                    "filtered_variables": {
                        "self.check_for_ordered": [
                            2174
                        ],
                        "self": [
                            2176,
                            2177,
                            2179,
                            2182,
                            2186,
                            2187,
                            2174
                        ],
                        "self._codes": [
                            2176,
                            2186,
                            2179,
                            2182
                        ],
                        "self.dtype.na_value": [
                            2177
                        ],
                        "self.dtype": [
                            2177
                        ],
                        "good": [
                            2179,
                            2180,
                            2182
                        ],
                        "good.all": [
                            2180
                        ],
                        "skipna": [
                            2181
                        ],
                        "pointer": [
                            2186,
                            2187,
                            2182
                        ],
                        "np.nan": [
                            2184
                        ],
                        "np": [
                            2184
                        ],
                        "self._codes.max": [
                            2186
                        ],
                        "self.categories": [
                            2187
                        ],
                        "deprecate_kwarg": [
                            2154
                        ]
                    },
                    "diff_line_number": 2181,
                    "class_data": {
                        "signature": "class Categorical(ExtensionArray, PandasObject)",
                        "docstring": "Represent a categorical variable in classic R / S-plus fashion.\n\n`Categoricals` can only take on only a limited, and usually fixed, number\nof possible values (`categories`). In contrast to statistical categorical\nvariables, a `Categorical` might have an order, but numerical operations\n(additions, divisions, ...) are not possible.\n\nAll values of the `Categorical` are either in `categories` or `np.nan`.\nAssigning values outside of `categories` will raise a `ValueError`. Order\nis defined by the order of the `categories`, not lexical order of the\nvalues.\n\nParameters\n----------\nvalues : list-like\n    The values of the categorical. If categories are given, values not in\n    categories will be replaced with NaN.\ncategories : Index-like (unique), optional\n    The unique categories for this categorical. If not given, the\n    categories are assumed to be the unique values of `values` (sorted, if\n    possible, otherwise in the order in which they appear).\nordered : bool, default False\n    Whether or not this categorical is treated as a ordered categorical.\n    If True, the resulting categorical will be ordered.\n    An ordered categorical respects, when sorted, the order of its\n    `categories` attribute (which in turn is the `categories` argument, if\n    provided).\ndtype : CategoricalDtype\n    An instance of ``CategoricalDtype`` to use for this categorical.\n\nAttributes\n----------\ncategories : Index\n    The categories of this categorical\ncodes : ndarray\n    The codes (integer positions, which point to the categories) of this\n    categorical, read only.\nordered : bool\n    Whether or not this Categorical is ordered.\ndtype : CategoricalDtype\n    The instance of ``CategoricalDtype`` storing the ``categories``\n    and ``ordered``.\n\nMethods\n-------\nfrom_codes\n__array__\n\nRaises\n------\nValueError\n    If the categories do not validate.\nTypeError\n    If an explicit ``ordered=True`` is given but no `categories` and the\n    `values` are not sortable.\n\nSee Also\n--------\nCategoricalDtype : Type for categorical data.\nCategoricalIndex : An Index with an underlying ``Categorical``.\n\nNotes\n-----\nSee the `user guide\n<https://pandas.pydata.org/pandas-docs/stable/user_guide/categorical.html>`_\nfor more.\n\nExamples\n--------\n>>> pd.Categorical([1, 2, 3, 1, 2, 3])\n[1, 2, 3, 1, 2, 3]\nCategories (3, int64): [1, 2, 3]\n\n>>> pd.Categorical(['a', 'b', 'c', 'a', 'b', 'c'])\n[a, b, c, a, b, c]\nCategories (3, object): [a, b, c]\n\nOrdered `Categoricals` can be sorted according to the custom order\nof the categories and can have a min and max value.\n\n>>> c = pd.Categorical(['a', 'b', 'c', 'a', 'b', 'c'], ordered=True,\n...                    categories=['c', 'b', 'a'])\n>>> c\n[a, b, c, a, b, c]\nCategories (3, object): [c < b < a]\n>>> c.min()\n'c'",
                        "constructor_docstring": null,
                        "functions": [
                            "def __init__(self, values, categories=None, ordered=None, dtype=None, fastpath=False):\n    dtype = CategoricalDtype._from_values_or_dtype(values, categories, ordered, dtype)\n    if fastpath:\n        self._codes = coerce_indexer_dtype(values, dtype.categories)\n        self._dtype = self._dtype.update_dtype(dtype)\n        return\n    null_mask = np.array(False)\n    if is_categorical_dtype(values):\n        if dtype.categories is None:\n            dtype = CategoricalDtype(values.categories, dtype.ordered)\n    elif not isinstance(values, (ABCIndexClass, ABCSeries)):\n        values = maybe_infer_to_datetimelike(values, convert_dates=True)\n        if not isinstance(values, np.ndarray):\n            values = _convert_to_list_like(values)\n            sanitize_dtype = 'object' if len(values) == 0 else None\n            null_mask = isna(values)\n            if null_mask.any():\n                values = [values[idx] for idx in np.where(~null_mask)[0]]\n            values = sanitize_array(values, None, dtype=sanitize_dtype)\n    if dtype.categories is None:\n        try:\n            codes, categories = factorize(values, sort=True)\n        except TypeError as err:\n            codes, categories = factorize(values, sort=False)\n            if dtype.ordered:\n                raise TypeError(\"'values' is not ordered, please explicitly specify the categories order by passing in a categories argument.\") from err\n        except ValueError as err:\n            raise NotImplementedError('> 1 ndim Categorical are not supported at this time') from err\n        dtype = CategoricalDtype(categories, dtype.ordered)\n    elif is_categorical_dtype(values):\n        old_codes = values._values.codes if isinstance(values, ABCSeries) else values.codes\n        codes = recode_for_categories(old_codes, values.dtype.categories, dtype.categories)\n    else:\n        codes = _get_codes_for_values(values, dtype.categories)\n    if null_mask.any():\n        full_codes = -np.ones(null_mask.shape, dtype=codes.dtype)\n        full_codes[~null_mask] = codes\n        codes = full_codes\n    self._dtype = self._dtype.update_dtype(dtype)\n    self._codes = coerce_indexer_dtype(codes, dtype.categories)",
                            "@property\ndef categories(self):\n    \"\"\"\n    The categories of this categorical.\n\n    Setting assigns new values to each category (effectively a rename of\n    each individual category).\n\n    The assigned value has to be a list-like object. All items must be\n    unique and the number of items in the new categories must be the same\n    as the number of items in the old categories.\n\n    Assigning to `categories` is a inplace operation!\n\n    Raises\n    ------\n    ValueError\n        If the new categories do not validate as categories or if the\n        number of new categories is unequal the number of old categories\n\n    See Also\n    --------\n    rename_categories : Rename categories.\n    reorder_categories : Reorder categories.\n    add_categories : Add new categories.\n    remove_categories : Remove the specified categories.\n    remove_unused_categories : Remove categories which are not used.\n    set_categories : Set the categories to the specified ones.\n    \"\"\"\n    return self.dtype.categories",
                            "@categories.setter\ndef categories(self, categories):\n    new_dtype = CategoricalDtype(categories, ordered=self.ordered)\n    if self.dtype.categories is not None and len(self.dtype.categories) != len(new_dtype.categories):\n        raise ValueError('new categories need to have the same number of items as the old categories!')\n    self._dtype = new_dtype",
                            "@property\ndef ordered(self) -> Ordered:\n    \"\"\"\n    Whether the categories have an ordered relationship.\n    \"\"\"\n    return self.dtype.ordered",
                            "@property\ndef dtype(self) -> CategoricalDtype:\n    \"\"\"\n    The :class:`~pandas.api.types.CategoricalDtype` for this instance.\n    \"\"\"\n    return self._dtype",
                            "@property\ndef _constructor(self) -> Type['Categorical']:\n    return Categorical",
                            "@classmethod\ndef _from_sequence(cls, scalars, dtype=None, copy=False):\n    return Categorical(scalars, dtype=dtype)",
                            "def _formatter(self, boxed=False):\n    return None",
                            "def copy(self) -> 'Categorical':\n    \"\"\"\n    Copy constructor.\n    \"\"\"\n    return self._constructor(values=self._codes.copy(), dtype=self.dtype, fastpath=True)",
                            "def astype(self, dtype: Dtype, copy: bool=True) -> ArrayLike:\n    \"\"\"\n    Coerce this type to another dtype\n\n    Parameters\n    ----------\n    dtype : numpy dtype or pandas type\n    copy : bool, default True\n        By default, astype always returns a newly allocated object.\n        If copy is set to False and dtype is categorical, the original\n        object is returned.\n    \"\"\"\n    if is_categorical_dtype(dtype):\n        dtype = cast(Union[str, CategoricalDtype], dtype)\n        dtype = self.dtype.update_dtype(dtype)\n        self = self.copy() if copy else self\n        if dtype == self.dtype:\n            return self\n        return self._set_dtype(dtype)\n    if is_extension_array_dtype(dtype):\n        return array(self, dtype=dtype, copy=copy)\n    if is_integer_dtype(dtype) and self.isna().any():\n        raise ValueError('Cannot convert float NaN to integer')\n    return np.array(self, dtype=dtype, copy=copy)",
                            "@cache_readonly\ndef size(self) -> int:\n    \"\"\"\n    Return the len of myself.\n    \"\"\"\n    return self._codes.size",
                            "@cache_readonly\ndef itemsize(self) -> int:\n    \"\"\"\n    return the size of a single category\n    \"\"\"\n    return self.categories.itemsize",
                            "def tolist(self) -> List[Scalar]:\n    \"\"\"\n    Return a list of the values.\n\n    These are each a scalar type, which is a Python scalar\n    (for str, int, float) or a pandas scalar\n    (for Timestamp/Timedelta/Interval/Period)\n    \"\"\"\n    return list(self)",
                            "@classmethod\ndef _from_inferred_categories(cls, inferred_categories, inferred_codes, dtype, true_values=None):\n    \"\"\"\n    Construct a Categorical from inferred values.\n\n    For inferred categories (`dtype` is None) the categories are sorted.\n    For explicit `dtype`, the `inferred_categories` are cast to the\n    appropriate type.\n\n    Parameters\n    ----------\n    inferred_categories : Index\n    inferred_codes : Index\n    dtype : CategoricalDtype or 'category'\n    true_values : list, optional\n        If none are provided, the default ones are\n        \"True\", \"TRUE\", and \"true.\"\n\n    Returns\n    -------\n    Categorical\n    \"\"\"\n    from pandas import Index, to_numeric, to_datetime, to_timedelta\n    cats = Index(inferred_categories)\n    known_categories = isinstance(dtype, CategoricalDtype) and dtype.categories is not None\n    if known_categories:\n        if dtype.categories.is_numeric():\n            cats = to_numeric(inferred_categories, errors='coerce')\n        elif is_datetime64_dtype(dtype.categories):\n            cats = to_datetime(inferred_categories, errors='coerce')\n        elif is_timedelta64_dtype(dtype.categories):\n            cats = to_timedelta(inferred_categories, errors='coerce')\n        elif dtype.categories.is_boolean():\n            if true_values is None:\n                true_values = ['True', 'TRUE', 'true']\n            cats = cats.isin(true_values)\n    if known_categories:\n        categories = dtype.categories\n        codes = recode_for_categories(inferred_codes, cats, categories)\n    elif not cats.is_monotonic_increasing:\n        unsorted = cats.copy()\n        categories = cats.sort_values()\n        codes = recode_for_categories(inferred_codes, unsorted, categories)\n        dtype = CategoricalDtype(categories, ordered=False)\n    else:\n        dtype = CategoricalDtype(cats, ordered=False)\n        codes = inferred_codes\n    return cls(codes, dtype=dtype, fastpath=True)",
                            "@classmethod\ndef from_codes(cls, codes, categories=None, ordered=None, dtype=None):\n    \"\"\"\n    Make a Categorical type from codes and categories or dtype.\n\n    This constructor is useful if you already have codes and\n    categories/dtype and so do not need the (computation intensive)\n    factorization step, which is usually done on the constructor.\n\n    If your data does not follow this convention, please use the normal\n    constructor.\n\n    Parameters\n    ----------\n    codes : array-like of int\n        An integer array, where each integer points to a category in\n        categories or dtype.categories, or else is -1 for NaN.\n    categories : index-like, optional\n        The categories for the categorical. Items need to be unique.\n        If the categories are not given here, then they must be provided\n        in `dtype`.\n    ordered : bool, optional\n        Whether or not this categorical is treated as an ordered\n        categorical. If not given here or in `dtype`, the resulting\n        categorical will be unordered.\n    dtype : CategoricalDtype or \"category\", optional\n        If :class:`CategoricalDtype`, cannot be used together with\n        `categories` or `ordered`.\n\n        .. versionadded:: 0.24.0\n\n           When `dtype` is provided, neither `categories` nor `ordered`\n           should be provided.\n\n    Returns\n    -------\n    Categorical\n\n    Examples\n    --------\n    >>> dtype = pd.CategoricalDtype(['a', 'b'], ordered=True)\n    >>> pd.Categorical.from_codes(codes=[0, 1, 0, 1], dtype=dtype)\n    [a, b, a, b]\n    Categories (2, object): [a < b]\n    \"\"\"\n    dtype = CategoricalDtype._from_values_or_dtype(categories=categories, ordered=ordered, dtype=dtype)\n    if dtype.categories is None:\n        msg = \"The categories must be provided in 'categories' or 'dtype'. Both were None.\"\n        raise ValueError(msg)\n    if is_extension_array_dtype(codes) and is_integer_dtype(codes):\n        if isna(codes).any():\n            raise ValueError('codes cannot contain NA values')\n        codes = codes.to_numpy(dtype=np.int64)\n    else:\n        codes = np.asarray(codes)\n    if len(codes) and (not is_integer_dtype(codes)):\n        raise ValueError('codes need to be array-like integers')\n    if len(codes) and (codes.max() >= len(dtype.categories) or codes.min() < -1):\n        raise ValueError('codes need to be between -1 and len(categories)-1')\n    return cls(codes, dtype=dtype, fastpath=True)",
                            "def _get_codes(self):\n    \"\"\"\n    Get the codes.\n\n    Returns\n    -------\n    codes : integer array view\n        A non writable view of the `codes` array.\n    \"\"\"\n    v = self._codes.view()\n    v.flags.writeable = False\n    return v",
                            "def _set_codes(self, codes):\n    \"\"\"\n    Not settable by the user directly\n    \"\"\"\n    raise ValueError('cannot set Categorical codes directly')",
                            "def _set_categories(self, categories, fastpath=False):\n    \"\"\"\n    Sets new categories inplace\n\n    Parameters\n    ----------\n    fastpath : bool, default False\n       Don't perform validation of the categories for uniqueness or nulls\n\n    Examples\n    --------\n    >>> c = pd.Categorical(['a', 'b'])\n    >>> c\n    [a, b]\n    Categories (2, object): [a, b]\n\n    >>> c._set_categories(pd.Index(['a', 'c']))\n    >>> c\n    [a, c]\n    Categories (2, object): [a, c]\n    \"\"\"\n    if fastpath:\n        new_dtype = CategoricalDtype._from_fastpath(categories, self.ordered)\n    else:\n        new_dtype = CategoricalDtype(categories, ordered=self.ordered)\n    if not fastpath and self.dtype.categories is not None and (len(new_dtype.categories) != len(self.dtype.categories)):\n        raise ValueError('new categories need to have the same number of items than the old categories!')\n    self._dtype = new_dtype",
                            "def _set_dtype(self, dtype: CategoricalDtype) -> 'Categorical':\n    \"\"\"\n    Internal method for directly updating the CategoricalDtype\n\n    Parameters\n    ----------\n    dtype : CategoricalDtype\n\n    Notes\n    -----\n    We don't do any validation here. It's assumed that the dtype is\n    a (valid) instance of `CategoricalDtype`.\n    \"\"\"\n    codes = recode_for_categories(self.codes, self.categories, dtype.categories)\n    return type(self)(codes, dtype=dtype, fastpath=True)",
                            "def set_ordered(self, value, inplace=False):\n    \"\"\"\n    Set the ordered attribute to the boolean value.\n\n    Parameters\n    ----------\n    value : bool\n       Set whether this categorical is ordered (True) or not (False).\n    inplace : bool, default False\n       Whether or not to set the ordered attribute in-place or return\n       a copy of this categorical with ordered set to the value.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    new_dtype = CategoricalDtype(self.categories, ordered=value)\n    cat = self if inplace else self.copy()\n    cat._dtype = new_dtype\n    if not inplace:\n        return cat",
                            "def as_ordered(self, inplace=False):\n    \"\"\"\n    Set the Categorical to be ordered.\n\n    Parameters\n    ----------\n    inplace : bool, default False\n       Whether or not to set the ordered attribute in-place or return\n       a copy of this categorical with ordered set to True.\n\n    Returns\n    -------\n    Categorical\n        Ordered Categorical.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    return self.set_ordered(True, inplace=inplace)",
                            "def as_unordered(self, inplace=False):\n    \"\"\"\n    Set the Categorical to be unordered.\n\n    Parameters\n    ----------\n    inplace : bool, default False\n       Whether or not to set the ordered attribute in-place or return\n       a copy of this categorical with ordered set to False.\n\n    Returns\n    -------\n    Categorical\n        Unordered Categorical.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    return self.set_ordered(False, inplace=inplace)",
                            "def set_categories(self, new_categories, ordered=None, rename=False, inplace=False):\n    \"\"\"\n    Set the categories to the specified new_categories.\n\n    `new_categories` can include new categories (which will result in\n    unused categories) or remove old categories (which results in values\n    set to NaN). If `rename==True`, the categories will simple be renamed\n    (less or more items than in old categories will result in values set to\n    NaN or in unused categories respectively).\n\n    This method can be used to perform more than one action of adding,\n    removing, and reordering simultaneously and is therefore faster than\n    performing the individual steps via the more specialised methods.\n\n    On the other hand this methods does not do checks (e.g., whether the\n    old categories are included in the new categories on a reorder), which\n    can result in surprising changes, for example when using special string\n    dtypes, which does not considers a S1 string equal to a single char\n    python string.\n\n    Parameters\n    ----------\n    new_categories : Index-like\n       The categories in new order.\n    ordered : bool, default False\n       Whether or not the categorical is treated as a ordered categorical.\n       If not given, do not change the ordered information.\n    rename : bool, default False\n       Whether or not the new_categories should be considered as a rename\n       of the old categories or as reordered categories.\n    inplace : bool, default False\n       Whether or not to reorder the categories in-place or return a copy\n       of this categorical with reordered categories.\n\n    Returns\n    -------\n    Categorical with reordered categories or None if inplace.\n\n    Raises\n    ------\n    ValueError\n        If new_categories does not validate as categories\n\n    See Also\n    --------\n    rename_categories : Rename categories.\n    reorder_categories : Reorder categories.\n    add_categories : Add new categories.\n    remove_categories : Remove the specified categories.\n    remove_unused_categories : Remove categories which are not used.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    if ordered is None:\n        ordered = self.dtype.ordered\n    new_dtype = CategoricalDtype(new_categories, ordered=ordered)\n    cat = self if inplace else self.copy()\n    if rename:\n        if cat.dtype.categories is not None and len(new_dtype.categories) < len(cat.dtype.categories):\n            cat._codes[cat._codes >= len(new_dtype.categories)] = -1\n    else:\n        codes = recode_for_categories(cat.codes, cat.categories, new_dtype.categories)\n        cat._codes = codes\n    cat._dtype = new_dtype\n    if not inplace:\n        return cat",
                            "def rename_categories(self, new_categories, inplace=False):\n    \"\"\"\n    Rename categories.\n\n    Parameters\n    ----------\n    new_categories : list-like, dict-like or callable\n\n        New categories which will replace old categories.\n\n        * list-like: all items must be unique and the number of items in\n          the new categories must match the existing number of categories.\n\n        * dict-like: specifies a mapping from\n          old categories to new. Categories not contained in the mapping\n          are passed through and extra categories in the mapping are\n          ignored.\n\n        * callable : a callable that is called on all items in the old\n          categories and whose return values comprise the new categories.\n\n        .. versionadded:: 0.23.0.\n\n    inplace : bool, default False\n        Whether or not to rename the categories inplace or return a copy of\n        this categorical with renamed categories.\n\n    Returns\n    -------\n    cat : Categorical or None\n       With ``inplace=False``, the new categorical is returned.\n       With ``inplace=True``, there is no return value.\n\n    Raises\n    ------\n    ValueError\n        If new categories are list-like and do not have the same number of\n        items than the current categories or do not validate as categories\n\n    See Also\n    --------\n    reorder_categories : Reorder categories.\n    add_categories : Add new categories.\n    remove_categories : Remove the specified categories.\n    remove_unused_categories : Remove categories which are not used.\n    set_categories : Set the categories to the specified ones.\n\n    Examples\n    --------\n    >>> c = pd.Categorical(['a', 'a', 'b'])\n    >>> c.rename_categories([0, 1])\n    [0, 0, 1]\n    Categories (2, int64): [0, 1]\n\n    For dict-like ``new_categories``, extra keys are ignored and\n    categories not in the dictionary are passed through\n\n    >>> c.rename_categories({'a': 'A', 'c': 'C'})\n    [A, A, b]\n    Categories (2, object): [A, b]\n\n    You may also provide a callable to create the new categories\n\n    >>> c.rename_categories(lambda x: x.upper())\n    [A, A, B]\n    Categories (2, object): [A, B]\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    cat = self if inplace else self.copy()\n    if is_dict_like(new_categories):\n        cat.categories = [new_categories.get(item, item) for item in cat.categories]\n    elif callable(new_categories):\n        cat.categories = [new_categories(item) for item in cat.categories]\n    else:\n        cat.categories = new_categories\n    if not inplace:\n        return cat",
                            "def reorder_categories(self, new_categories, ordered=None, inplace=False):\n    \"\"\"\n    Reorder categories as specified in new_categories.\n\n    `new_categories` need to include all old categories and no new category\n    items.\n\n    Parameters\n    ----------\n    new_categories : Index-like\n       The categories in new order.\n    ordered : bool, optional\n       Whether or not the categorical is treated as a ordered categorical.\n       If not given, do not change the ordered information.\n    inplace : bool, default False\n       Whether or not to reorder the categories inplace or return a copy of\n       this categorical with reordered categories.\n\n    Returns\n    -------\n    cat : Categorical with reordered categories or None if inplace.\n\n    Raises\n    ------\n    ValueError\n        If the new categories do not contain all old category items or any\n        new ones\n\n    See Also\n    --------\n    rename_categories : Rename categories.\n    add_categories : Add new categories.\n    remove_categories : Remove the specified categories.\n    remove_unused_categories : Remove categories which are not used.\n    set_categories : Set the categories to the specified ones.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    if set(self.dtype.categories) != set(new_categories):\n        raise ValueError('items in new_categories are not the same as in old categories')\n    return self.set_categories(new_categories, ordered=ordered, inplace=inplace)",
                            "def add_categories(self, new_categories, inplace=False):\n    \"\"\"\n    Add new categories.\n\n    `new_categories` will be included at the last/highest place in the\n    categories and will be unused directly after this call.\n\n    Parameters\n    ----------\n    new_categories : category or list-like of category\n       The new categories to be included.\n    inplace : bool, default False\n       Whether or not to add the categories inplace or return a copy of\n       this categorical with added categories.\n\n    Returns\n    -------\n    cat : Categorical with new categories added or None if inplace.\n\n    Raises\n    ------\n    ValueError\n        If the new categories include old categories or do not validate as\n        categories\n\n    See Also\n    --------\n    rename_categories : Rename categories.\n    reorder_categories : Reorder categories.\n    remove_categories : Remove the specified categories.\n    remove_unused_categories : Remove categories which are not used.\n    set_categories : Set the categories to the specified ones.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    if not is_list_like(new_categories):\n        new_categories = [new_categories]\n    already_included = set(new_categories) & set(self.dtype.categories)\n    if len(already_included) != 0:\n        raise ValueError(f'new categories must not include old categories: {already_included}')\n    new_categories = list(self.dtype.categories) + list(new_categories)\n    new_dtype = CategoricalDtype(new_categories, self.ordered)\n    cat = self if inplace else self.copy()\n    cat._dtype = new_dtype\n    cat._codes = coerce_indexer_dtype(cat._codes, new_dtype.categories)\n    if not inplace:\n        return cat",
                            "def remove_categories(self, removals, inplace=False):\n    \"\"\"\n    Remove the specified categories.\n\n    `removals` must be included in the old categories. Values which were in\n    the removed categories will be set to NaN\n\n    Parameters\n    ----------\n    removals : category or list of categories\n       The categories which should be removed.\n    inplace : bool, default False\n       Whether or not to remove the categories inplace or return a copy of\n       this categorical with removed categories.\n\n    Returns\n    -------\n    cat : Categorical with removed categories or None if inplace.\n\n    Raises\n    ------\n    ValueError\n        If the removals are not contained in the categories\n\n    See Also\n    --------\n    rename_categories : Rename categories.\n    reorder_categories : Reorder categories.\n    add_categories : Add new categories.\n    remove_unused_categories : Remove categories which are not used.\n    set_categories : Set the categories to the specified ones.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    if not is_list_like(removals):\n        removals = [removals]\n    removal_set = set(removals)\n    not_included = removal_set - set(self.dtype.categories)\n    new_categories = [c for c in self.dtype.categories if c not in removal_set]\n    if any(isna(removals)):\n        not_included = {x for x in not_included if notna(x)}\n        new_categories = [x for x in new_categories if notna(x)]\n    if len(not_included) != 0:\n        raise ValueError(f'removals must all be in old categories: {not_included}')\n    return self.set_categories(new_categories, ordered=self.ordered, rename=False, inplace=inplace)",
                            "def remove_unused_categories(self, inplace=False):\n    \"\"\"\n    Remove categories which are not used.\n\n    Parameters\n    ----------\n    inplace : bool, default False\n       Whether or not to drop unused categories inplace or return a copy of\n       this categorical with unused categories dropped.\n\n    Returns\n    -------\n    cat : Categorical with unused categories dropped or None if inplace.\n\n    See Also\n    --------\n    rename_categories : Rename categories.\n    reorder_categories : Reorder categories.\n    add_categories : Add new categories.\n    remove_categories : Remove the specified categories.\n    set_categories : Set the categories to the specified ones.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    cat = self if inplace else self.copy()\n    idx, inv = np.unique(cat._codes, return_inverse=True)\n    if idx.size != 0 and idx[0] == -1:\n        idx, inv = (idx[1:], inv - 1)\n    new_categories = cat.dtype.categories.take(idx)\n    new_dtype = CategoricalDtype._from_fastpath(new_categories, ordered=self.ordered)\n    cat._dtype = new_dtype\n    cat._codes = coerce_indexer_dtype(inv, new_dtype.categories)\n    if not inplace:\n        return cat",
                            "def map(self, mapper):\n    \"\"\"\n    Map categories using input correspondence (dict, Series, or function).\n\n    Maps the categories to new categories. If the mapping correspondence is\n    one-to-one the result is a :class:`~pandas.Categorical` which has the\n    same order property as the original, otherwise a :class:`~pandas.Index`\n    is returned. NaN values are unaffected.\n\n    If a `dict` or :class:`~pandas.Series` is used any unmapped category is\n    mapped to `NaN`. Note that if this happens an :class:`~pandas.Index`\n    will be returned.\n\n    Parameters\n    ----------\n    mapper : function, dict, or Series\n        Mapping correspondence.\n\n    Returns\n    -------\n    pandas.Categorical or pandas.Index\n        Mapped categorical.\n\n    See Also\n    --------\n    CategoricalIndex.map : Apply a mapping correspondence on a\n        :class:`~pandas.CategoricalIndex`.\n    Index.map : Apply a mapping correspondence on an\n        :class:`~pandas.Index`.\n    Series.map : Apply a mapping correspondence on a\n        :class:`~pandas.Series`.\n    Series.apply : Apply more complex functions on a\n        :class:`~pandas.Series`.\n\n    Examples\n    --------\n    >>> cat = pd.Categorical(['a', 'b', 'c'])\n    >>> cat\n    [a, b, c]\n    Categories (3, object): [a, b, c]\n    >>> cat.map(lambda x: x.upper())\n    [A, B, C]\n    Categories (3, object): [A, B, C]\n    >>> cat.map({'a': 'first', 'b': 'second', 'c': 'third'})\n    [first, second, third]\n    Categories (3, object): [first, second, third]\n\n    If the mapping is one-to-one the ordering of the categories is\n    preserved:\n\n    >>> cat = pd.Categorical(['a', 'b', 'c'], ordered=True)\n    >>> cat\n    [a, b, c]\n    Categories (3, object): [a < b < c]\n    >>> cat.map({'a': 3, 'b': 2, 'c': 1})\n    [3, 2, 1]\n    Categories (3, int64): [3 < 2 < 1]\n\n    If the mapping is not one-to-one an :class:`~pandas.Index` is returned:\n\n    >>> cat.map({'a': 'first', 'b': 'second', 'c': 'first'})\n    Index(['first', 'second', 'first'], dtype='object')\n\n    If a `dict` is used, all unmapped categories are mapped to `NaN` and\n    the result is an :class:`~pandas.Index`:\n\n    >>> cat.map({'a': 'first', 'b': 'second'})\n    Index(['first', 'second', nan], dtype='object')\n    \"\"\"\n    new_categories = self.categories.map(mapper)\n    try:\n        return self.from_codes(self._codes.copy(), categories=new_categories, ordered=self.ordered)\n    except ValueError:\n        if np.any(self._codes == -1):\n            new_categories = new_categories.insert(len(new_categories), np.nan)\n        return np.take(new_categories, self._codes)",
                            "@property\ndef shape(self):\n    \"\"\"\n    Shape of the Categorical.\n\n    For internal compatibility with numpy arrays.\n\n    Returns\n    -------\n    shape : tuple\n    \"\"\"\n    return tuple([len(self._codes)])",
                            "def shift(self, periods, fill_value=None):\n    \"\"\"\n    Shift Categorical by desired number of periods.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to move, can be positive or negative\n    fill_value : object, optional\n        The scalar value to use for newly introduced missing values.\n\n        .. versionadded:: 0.24.0\n\n    Returns\n    -------\n    shifted : Categorical\n    \"\"\"\n    codes = self.codes\n    if codes.ndim > 1:\n        raise NotImplementedError('Categorical with ndim > 1.')\n    if np.prod(codes.shape) and periods != 0:\n        codes = np.roll(codes, ensure_platform_int(periods), axis=0)\n        if isna(fill_value):\n            fill_value = -1\n        elif fill_value in self.categories:\n            fill_value = self.categories.get_loc(fill_value)\n        else:\n            raise ValueError(f\"'fill_value={fill_value}' is not present in this Categorical's categories\")\n        if periods > 0:\n            codes[:periods] = fill_value\n        else:\n            codes[periods:] = fill_value\n    return self.from_codes(codes, dtype=self.dtype)",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    \"\"\"\n    The numpy array interface.\n\n    Returns\n    -------\n    numpy.array\n        A numpy array of either the specified dtype or,\n        if dtype==None (default), the same dtype as\n        categorical.categories.dtype.\n    \"\"\"\n    ret = take_1d(self.categories.values, self._codes)\n    if dtype and (not is_dtype_equal(dtype, self.categories.dtype)):\n        return np.asarray(ret, dtype)\n    if is_extension_array_dtype(ret):\n        ret = np.asarray(ret)\n    return ret",
                            "def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n    result = ops.maybe_dispatch_ufunc_to_dunder_op(self, ufunc, method, *inputs, **kwargs)\n    if result is not NotImplemented:\n        return result\n    raise TypeError(f'Object with dtype {self.dtype} cannot perform the numpy op {ufunc.__name__}')",
                            "def __setstate__(self, state):\n    \"\"\"Necessary for making this object picklable\"\"\"\n    if not isinstance(state, dict):\n        raise Exception('invalid pickle state')\n    if '_dtype' not in state:\n        state['_dtype'] = CategoricalDtype(state['_categories'], state['_ordered'])\n    for k, v in state.items():\n        setattr(self, k, v)",
                            "@property\ndef T(self) -> 'Categorical':\n    \"\"\"\n    Return transposed numpy array.\n    \"\"\"\n    return self",
                            "@property\ndef nbytes(self):\n    return self._codes.nbytes + self.dtype.categories.values.nbytes",
                            "def memory_usage(self, deep=False):\n    \"\"\"\n    Memory usage of my values\n\n    Parameters\n    ----------\n    deep : bool\n        Introspect the data deeply, interrogate\n        `object` dtypes for system-level memory consumption\n\n    Returns\n    -------\n    bytes used\n\n    Notes\n    -----\n    Memory usage does not include memory consumed by elements that\n    are not components of the array if deep=False\n\n    See Also\n    --------\n    numpy.ndarray.nbytes\n    \"\"\"\n    return self._codes.nbytes + self.dtype.categories.memory_usage(deep=deep)",
                            "@doc(_shared_docs['searchsorted'], klass='Categorical')\ndef searchsorted(self, value, side='left', sorter=None):\n    if is_scalar(value):\n        codes = self.categories.get_loc(value)\n        codes = self.codes.dtype.type(codes)\n    else:\n        locs = [self.categories.get_loc(x) for x in value]\n        codes = np.array(locs, dtype=self.codes.dtype)\n    return self.codes.searchsorted(codes, side=side, sorter=sorter)",
                            "def isna(self):\n    \"\"\"\n    Detect missing values\n\n    Missing values (-1 in .codes) are detected.\n\n    Returns\n    -------\n    a boolean array of whether my values are null\n\n    See Also\n    --------\n    isna : Top-level isna.\n    isnull : Alias of isna.\n    Categorical.notna : Boolean inverse of Categorical.isna.\n\n    \"\"\"\n    ret = self._codes == -1\n    return ret",
                            "def notna(self):\n    \"\"\"\n    Inverse of isna\n\n    Both missing values (-1 in .codes) and NA as a category are detected as\n    null.\n\n    Returns\n    -------\n    a boolean array of whether my values are not null\n\n    See Also\n    --------\n    notna : Top-level notna.\n    notnull : Alias of notna.\n    Categorical.isna : Boolean inverse of Categorical.notna.\n\n    \"\"\"\n    return ~self.isna()",
                            "def dropna(self):\n    \"\"\"\n    Return the Categorical without null values.\n\n    Missing values (-1 in .codes) are detected.\n\n    Returns\n    -------\n    valid : Categorical\n    \"\"\"\n    result = self[self.notna()]\n    return result",
                            "def value_counts(self, dropna=True):\n    \"\"\"\n    Return a Series containing counts of each category.\n\n    Every category will have an entry, even those with a count of 0.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaN.\n\n    Returns\n    -------\n    counts : Series\n\n    See Also\n    --------\n    Series.value_counts\n    \"\"\"\n    from pandas import Series, CategoricalIndex\n    code, cat = (self._codes, self.categories)\n    ncat, mask = (len(cat), 0 <= code)\n    ix, clean = (np.arange(ncat), mask.all())\n    if dropna or clean:\n        obs = code if clean else code[mask]\n        count = np.bincount(obs, minlength=ncat or 0)\n    else:\n        count = np.bincount(np.where(mask, code, ncat))\n        ix = np.append(ix, -1)\n    ix = self._constructor(ix, dtype=self.dtype, fastpath=True)\n    return Series(count, index=CategoricalIndex(ix), dtype='int64')",
                            "def _internal_get_values(self):\n    \"\"\"\n    Return the values.\n\n    For internal compatibility with pandas formatting.\n\n    Returns\n    -------\n    np.ndarray or Index\n        A numpy array of the same dtype as categorical.categories.dtype or\n        Index if datetime / periods.\n    \"\"\"\n    if needs_i8_conversion(self.categories):\n        return self.categories.take(self._codes, fill_value=np.nan)\n    elif is_integer_dtype(self.categories) and -1 in self._codes:\n        return self.categories.astype('object').take(self._codes, fill_value=np.nan)\n    return np.array(self)",
                            "def check_for_ordered(self, op):\n    \"\"\" assert that we are ordered \"\"\"\n    if not self.ordered:\n        raise TypeError(f'Categorical is not ordered for operation {op}\\nyou can use .as_ordered() to change the Categorical to an ordered one\\n')",
                            "def _values_for_argsort(self):\n    return self._codes",
                            "def argsort(self, ascending=True, kind='quicksort', **kwargs):\n    \"\"\"\n    Return the indices that would sort the Categorical.\n\n    .. versionchanged:: 0.25.0\n\n       Changed to sort missing values at the end.\n\n    Parameters\n    ----------\n    ascending : bool, default True\n        Whether the indices should result in an ascending\n        or descending sort.\n    kind : {'quicksort', 'mergesort', 'heapsort'}, optional\n        Sorting algorithm.\n    **kwargs:\n        passed through to :func:`numpy.argsort`.\n\n    Returns\n    -------\n    numpy.array\n\n    See Also\n    --------\n    numpy.ndarray.argsort\n\n    Notes\n    -----\n    While an ordering is applied to the category values, arg-sorting\n    in this context refers more to organizing and grouping together\n    based on matching category values. Thus, this function can be\n    called on an unordered Categorical instance unlike the functions\n    'Categorical.min' and 'Categorical.max'.\n\n    Examples\n    --------\n    >>> pd.Categorical(['b', 'b', 'a', 'c']).argsort()\n    array([2, 0, 1, 3])\n\n    >>> cat = pd.Categorical(['b', 'b', 'a', 'c'],\n    ...                      categories=['c', 'b', 'a'],\n    ...                      ordered=True)\n    >>> cat.argsort()\n    array([3, 0, 1, 2])\n\n    Missing values are placed at the end\n\n    >>> cat = pd.Categorical([2, None, 1])\n    >>> cat.argsort()\n    array([2, 0, 1])\n    \"\"\"\n    return super().argsort(ascending=ascending, kind=kind, **kwargs)",
                            "def sort_values(self, inplace=False, ascending=True, na_position='last'):\n    \"\"\"\n    Sort the Categorical by category value returning a new\n    Categorical by default.\n\n    While an ordering is applied to the category values, sorting in this\n    context refers more to organizing and grouping together based on\n    matching category values. Thus, this function can be called on an\n    unordered Categorical instance unlike the functions 'Categorical.min'\n    and 'Categorical.max'.\n\n    Parameters\n    ----------\n    inplace : bool, default False\n        Do operation in place.\n    ascending : bool, default True\n        Order ascending. Passing False orders descending. The\n        ordering parameter provides the method by which the\n        category values are organized.\n    na_position : {'first', 'last'} (optional, default='last')\n        'first' puts NaNs at the beginning\n        'last' puts NaNs at the end\n\n    Returns\n    -------\n    Categorical or None\n\n    See Also\n    --------\n    Categorical.sort\n    Series.sort_values\n\n    Examples\n    --------\n    >>> c = pd.Categorical([1, 2, 2, 1, 5])\n    >>> c\n    [1, 2, 2, 1, 5]\n    Categories (3, int64): [1, 2, 5]\n    >>> c.sort_values()\n    [1, 1, 2, 2, 5]\n    Categories (3, int64): [1, 2, 5]\n    >>> c.sort_values(ascending=False)\n    [5, 2, 2, 1, 1]\n    Categories (3, int64): [1, 2, 5]\n\n    Inplace sorting can be done as well:\n\n    >>> c.sort_values(inplace=True)\n    >>> c\n    [1, 1, 2, 2, 5]\n    Categories (3, int64): [1, 2, 5]\n    >>>\n    >>> c = pd.Categorical([1, 2, 2, 1, 5])\n\n    'sort_values' behaviour with NaNs. Note that 'na_position'\n    is independent of the 'ascending' parameter:\n\n    >>> c = pd.Categorical([np.nan, 2, 2, np.nan, 5])\n    >>> c\n    [NaN, 2, 2, NaN, 5]\n    Categories (2, int64): [2, 5]\n    >>> c.sort_values()\n    [2, 2, 5, NaN, NaN]\n    Categories (2, int64): [2, 5]\n    >>> c.sort_values(ascending=False)\n    [5, 2, 2, NaN, NaN]\n    Categories (2, int64): [2, 5]\n    >>> c.sort_values(na_position='first')\n    [NaN, NaN, 2, 2, 5]\n    Categories (2, int64): [2, 5]\n    >>> c.sort_values(ascending=False, na_position='first')\n    [NaN, NaN, 5, 2, 2]\n    Categories (2, int64): [2, 5]\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    if na_position not in ['last', 'first']:\n        raise ValueError(f'invalid na_position: {repr(na_position)}')\n    sorted_idx = nargsort(self, ascending=ascending, na_position=na_position)\n    if inplace:\n        self._codes = self._codes[sorted_idx]\n    else:\n        return self._constructor(values=self._codes[sorted_idx], dtype=self.dtype, fastpath=True)",
                            "def _values_for_rank(self):\n    \"\"\"\n    For correctly ranking ordered categorical data. See GH#15420\n\n    Ordered categorical data should be ranked on the basis of\n    codes with -1 translated to NaN.\n\n    Returns\n    -------\n    numpy.array\n\n    \"\"\"\n    from pandas import Series\n    if self.ordered:\n        values = self.codes\n        mask = values == -1\n        if mask.any():\n            values = values.astype('float64')\n            values[mask] = np.nan\n    elif self.categories.is_numeric():\n        values = np.array(self)\n    else:\n        values = np.array(self.rename_categories(Series(self.categories).rank().values))\n    return values",
                            "def view(self, dtype=None):\n    if dtype is not None:\n        raise NotImplementedError(dtype)\n    return self._constructor(values=self._codes, dtype=self.dtype, fastpath=True)",
                            "def to_dense(self):\n    \"\"\"\n    Return my 'dense' representation\n\n    For internal compatibility with numpy arrays.\n\n    Returns\n    -------\n    dense : array\n    \"\"\"\n    warn('Categorical.to_dense is deprecated and will be removed in a future version.  Use np.asarray(cat) instead.', FutureWarning, stacklevel=2)\n    return np.asarray(self)",
                            "def fillna(self, value=None, method=None, limit=None):\n    \"\"\"\n    Fill NA/NaN values using the specified method.\n\n    Parameters\n    ----------\n    value : scalar, dict, Series\n        If a scalar value is passed it is used to fill all missing values.\n        Alternatively, a Series or dict can be used to fill in different\n        values for each index. The value should not be a list. The\n        value(s) passed should either be in the categories or should be\n        NaN.\n    method : {'backfill', 'bfill', 'pad', 'ffill', None}, default None\n        Method to use for filling holes in reindexed Series\n        pad / ffill: propagate last valid observation forward to next valid\n        backfill / bfill: use NEXT valid observation to fill gap\n    limit : int, default None\n        (Not implemented yet for Categorical!)\n        If method is specified, this is the maximum number of consecutive\n        NaN values to forward/backward fill. In other words, if there is\n        a gap with more than this number of consecutive NaNs, it will only\n        be partially filled. If method is not specified, this is the\n        maximum number of entries along the entire axis where NaNs will be\n        filled.\n\n    Returns\n    -------\n    filled : Categorical with NA/NaN filled\n    \"\"\"\n    value, method = validate_fillna_kwargs(value, method, validate_scalar_dict_value=False)\n    if value is None:\n        value = np.nan\n    if limit is not None:\n        raise NotImplementedError('specifying a limit for fillna has not been implemented yet')\n    codes = self._codes\n    if method is not None:\n        values = np.asarray(self).reshape(-1, len(self))\n        values = interpolate_2d(values, method, 0, None, value).astype(self.categories.dtype)[0]\n        codes = _get_codes_for_values(values, self.categories)\n    elif isinstance(value, (np.ndarray, Categorical, ABCSeries)):\n        mask = ~algorithms.isin(value, self.categories)\n        if not isna(value[mask]).all():\n            raise ValueError('fill value must be in categories')\n        values_codes = _get_codes_for_values(value, self.categories)\n        indexer = np.where(codes == -1)\n        codes = codes.copy()\n        codes[indexer] = values_codes[indexer]\n    elif is_hashable(value):\n        if not isna(value) and value not in self.categories:\n            raise ValueError('fill value must be in categories')\n        mask = codes == -1\n        if mask.any():\n            codes = codes.copy()\n            if isna(value):\n                codes[mask] = -1\n            else:\n                codes[mask] = self.categories.get_loc(value)\n    else:\n        raise TypeError(f\"'value' parameter must be a scalar, dict or Series, but you passed a {type(value).__name__}\")\n    return self._constructor(codes, dtype=self.dtype, fastpath=True)",
                            "def take(self, indexer, allow_fill: bool=False, fill_value=None):\n    \"\"\"\n    Take elements from the Categorical.\n\n    Parameters\n    ----------\n    indexer : sequence of int\n        The indices in `self` to take. The meaning of negative values in\n        `indexer` depends on the value of `allow_fill`.\n    allow_fill : bool, default False\n        How to handle negative values in `indexer`.\n\n        * False: negative values in `indices` indicate positional indices\n          from the right. This is similar to\n          :func:`numpy.take`.\n\n        * True: negative values in `indices` indicate missing values\n          (the default). These values are set to `fill_value`. Any other\n          other negative values raise a ``ValueError``.\n\n        .. versionchanged:: 1.0.0\n\n           Default value changed from ``True`` to ``False``.\n\n    fill_value : object\n        The value to use for `indices` that are missing (-1), when\n        ``allow_fill=True``. This should be the category, i.e. a value\n        in ``self.categories``, not a code.\n\n    Returns\n    -------\n    Categorical\n        This Categorical will have the same categories and ordered as\n        `self`.\n\n    See Also\n    --------\n    Series.take : Similar method for Series.\n    numpy.ndarray.take : Similar method for NumPy arrays.\n\n    Examples\n    --------\n    >>> cat = pd.Categorical(['a', 'a', 'b'])\n    >>> cat\n    [a, a, b]\n    Categories (2, object): [a, b]\n\n    Specify ``allow_fill==False`` to have negative indices mean indexing\n    from the right.\n\n    >>> cat.take([0, -1, -2], allow_fill=False)\n    [a, b, a]\n    Categories (2, object): [a, b]\n\n    With ``allow_fill=True``, indices equal to ``-1`` mean \"missing\"\n    values that should be filled with the `fill_value`, which is\n    ``np.nan`` by default.\n\n    >>> cat.take([0, -1, -1], allow_fill=True)\n    [a, NaN, NaN]\n    Categories (2, object): [a, b]\n\n    The fill value can be specified.\n\n    >>> cat.take([0, -1, -1], allow_fill=True, fill_value='a')\n    [a, a, a]\n    Categories (2, object): [a, b]\n\n    Specifying a fill value that's not in ``self.categories``\n    will raise a ``TypeError``.\n    \"\"\"\n    indexer = np.asarray(indexer, dtype=np.intp)\n    dtype = self.dtype\n    if isna(fill_value):\n        fill_value = -1\n    elif allow_fill:\n        if fill_value in self.categories:\n            fill_value = self.categories.get_loc(fill_value)\n        else:\n            msg = f\"'fill_value' ('{fill_value}') is not in this Categorical's categories.\"\n            raise TypeError(msg)\n    codes = take(self._codes, indexer, allow_fill=allow_fill, fill_value=fill_value)\n    result = type(self).from_codes(codes, dtype=dtype)\n    return result",
                            "def take_nd(self, indexer, allow_fill: bool=False, fill_value=None):\n    warn('Categorical.take_nd is deprecated, use Categorical.take instead', FutureWarning, stacklevel=2)\n    return self.take(indexer, allow_fill=allow_fill, fill_value=fill_value)",
                            "def __len__(self) -> int:\n    \"\"\"\n    The length of this Categorical.\n    \"\"\"\n    return len(self._codes)",
                            "def __iter__(self):\n    \"\"\"\n    Returns an Iterator over the values of this Categorical.\n    \"\"\"\n    return iter(self._internal_get_values().tolist())",
                            "def __contains__(self, key) -> bool:\n    \"\"\"\n    Returns True if `key` is in this Categorical.\n    \"\"\"\n    if is_scalar(key) and isna(key):\n        return self.isna().any()\n    return contains(self, key, container=self._codes)",
                            "def _tidy_repr(self, max_vals=10, footer=True) -> str:\n    \"\"\"\n    a short repr displaying only max_vals and an optional (but default\n    footer)\n    \"\"\"\n    num = max_vals // 2\n    head = self[:num]._get_repr(length=False, footer=False)\n    tail = self[-(max_vals - num):]._get_repr(length=False, footer=False)\n    result = f'{head[:-1]}, ..., {tail[1:]}'\n    if footer:\n        result = f'{result}\\n{self._repr_footer()}'\n    return str(result)",
                            "def _repr_categories(self):\n    \"\"\"\n    return the base repr for the categories\n    \"\"\"\n    max_categories = 10 if get_option('display.max_categories') == 0 else get_option('display.max_categories')\n    from pandas.io.formats import format as fmt\n    if len(self.categories) > max_categories:\n        num = max_categories // 2\n        head = fmt.format_array(self.categories[:num], None)\n        tail = fmt.format_array(self.categories[-num:], None)\n        category_strs = head + ['...'] + tail\n    else:\n        category_strs = fmt.format_array(self.categories, None)\n    category_strs = [x.strip() for x in category_strs]\n    return category_strs",
                            "def _repr_categories_info(self) -> str:\n    \"\"\"\n    Returns a string representation of the footer.\n    \"\"\"\n    category_strs = self._repr_categories()\n    dtype = str(self.categories.dtype)\n    levheader = f'Categories ({len(self.categories)}, {dtype}): '\n    width, height = get_terminal_size()\n    max_width = get_option('display.width') or width\n    if console.in_ipython_frontend():\n        max_width = 0\n    levstring = ''\n    start = True\n    cur_col_len = len(levheader)\n    sep_len, sep = (3, ' < ') if self.ordered else (2, ', ')\n    linesep = sep.rstrip() + '\\n'\n    for val in category_strs:\n        if max_width != 0 and cur_col_len + sep_len + len(val) > max_width:\n            levstring += linesep + ' ' * (len(levheader) + 1)\n            cur_col_len = len(levheader) + 1\n        elif not start:\n            levstring += sep\n            cur_col_len += len(val)\n        levstring += val\n        start = False\n    return levheader + '[' + levstring.replace(' < ... < ', ' ... ') + ']'",
                            "def _repr_footer(self) -> str:\n    info = self._repr_categories_info()\n    return f'Length: {len(self)}\\n{info}'",
                            "def _get_repr(self, length=True, na_rep='NaN', footer=True) -> str:\n    from pandas.io.formats import format as fmt\n    formatter = fmt.CategoricalFormatter(self, length=length, na_rep=na_rep, footer=footer)\n    result = formatter.to_string()\n    return str(result)",
                            "def __repr__(self) -> str:\n    \"\"\"\n    String representation.\n    \"\"\"\n    _maxlen = 10\n    if len(self._codes) > _maxlen:\n        result = self._tidy_repr(_maxlen)\n    elif len(self._codes) > 0:\n        result = self._get_repr(length=len(self) > _maxlen)\n    else:\n        msg = self._get_repr(length=False, footer=True).replace('\\n', ', ')\n        result = f'[], {msg}'\n    return result",
                            "def _maybe_coerce_indexer(self, indexer):\n    \"\"\"\n    return an indexer coerced to the codes dtype\n    \"\"\"\n    if isinstance(indexer, np.ndarray) and indexer.dtype.kind == 'i':\n        indexer = indexer.astype(self._codes.dtype)\n    return indexer",
                            "def __getitem__(self, key):\n    \"\"\"\n    Return an item.\n    \"\"\"\n    if isinstance(key, (int, np.integer)):\n        i = self._codes[key]\n        if i == -1:\n            return np.nan\n        else:\n            return self.categories[i]\n    key = check_array_indexer(self, key)\n    result = self._codes[key]\n    if result.ndim > 1:\n        deprecate_ndim_indexing(result)\n        return result\n    return self._constructor(result, dtype=self.dtype, fastpath=True)",
                            "def __setitem__(self, key, value):\n    \"\"\"\n    Item assignment.\n\n    Raises\n    ------\n    ValueError\n        If (one or more) Value is not in categories or if a assigned\n        `Categorical` does not have the same categories\n    \"\"\"\n    value = extract_array(value, extract_numpy=True)\n    if isinstance(value, Categorical):\n        if not is_dtype_equal(self, value):\n            raise ValueError('Cannot set a Categorical with another, without identical categories')\n        if not self.categories.equals(value.categories):\n            new_codes = recode_for_categories(value.codes, value.categories, self.categories)\n            value = Categorical.from_codes(new_codes, dtype=self.dtype)\n    rvalue = value if is_list_like(value) else [value]\n    from pandas import Index\n    to_add = Index(rvalue).difference(self.categories)\n    if len(to_add) and (not isna(to_add).all()):\n        raise ValueError('Cannot setitem on a Categorical with a new category, set the categories first')\n    if isinstance(key, (int, np.integer)):\n        pass\n    elif isinstance(key, tuple):\n        if len(key) == 2:\n            if not com.is_null_slice(key[0]):\n                raise AssertionError('invalid slicing for a 1-ndim categorical')\n            key = key[1]\n        elif len(key) == 1:\n            key = key[0]\n        else:\n            raise AssertionError('invalid slicing for a 1-ndim categorical')\n    elif isinstance(key, slice):\n        pass\n    lindexer = self.categories.get_indexer(rvalue)\n    lindexer = self._maybe_coerce_indexer(lindexer)\n    key = check_array_indexer(self, key)\n    self._codes[key] = lindexer",
                            "def _reverse_indexer(self) -> Dict[Hashable, np.ndarray]:\n    \"\"\"\n    Compute the inverse of a categorical, returning\n    a dict of categories -> indexers.\n\n    *This is an internal function*\n\n    Returns\n    -------\n    dict of categories -> indexers\n\n    Examples\n    --------\n    >>> c = pd.Categorical(list('aabca'))\n    >>> c\n    [a, a, b, c, a]\n    Categories (3, object): [a, b, c]\n    >>> c.categories\n    Index(['a', 'b', 'c'], dtype='object')\n    >>> c.codes\n    array([0, 0, 1, 2, 0], dtype=int8)\n    >>> c._reverse_indexer()\n    {'a': array([0, 1, 4]), 'b': array([2]), 'c': array([3])}\n\n    \"\"\"\n    categories = self.categories\n    r, counts = libalgos.groupsort_indexer(self.codes.astype('int64'), categories.size)\n    counts = counts.cumsum()\n    _result = (r[start:end] for start, end in zip(counts, counts[1:]))\n    result = dict(zip(categories, _result))\n    return result",
                            "def _reduce(self, name, axis=0, **kwargs):\n    func = getattr(self, name, None)\n    if func is None:\n        raise TypeError(f'Categorical cannot perform the operation {name}')\n    return func(**kwargs)",
                            "@deprecate_kwarg(old_arg_name='numeric_only', new_arg_name='skipna')\ndef min(self, skipna=True):\n    \"\"\"\n    The minimum value of the object.\n\n    Only ordered `Categoricals` have a minimum!\n\n    .. versionchanged:: 1.0.0\n\n       Returns an NA value on empty arrays\n\n    Raises\n    ------\n    TypeError\n        If the `Categorical` is not `ordered`.\n\n    Returns\n    -------\n    min : the minimum of this `Categorical`\n    \"\"\"\n    self.check_for_ordered('min')\n    if not len(self._codes):\n        return self.dtype.na_value\n    good = self._codes != -1\n    if not good.all():\n        if skipna:\n            pointer = self._codes[good].min()\n        else:\n            return np.nan\n    else:\n        pointer = self._codes.min()\n    return self.categories[pointer]",
                            "@deprecate_kwarg(old_arg_name='numeric_only', new_arg_name='skipna')\ndef max(self, skipna=True):\n    \"\"\"\n    The maximum value of the object.\n\n    Only ordered `Categoricals` have a maximum!\n\n    .. versionchanged:: 1.0.0\n\n       Returns an NA value on empty arrays\n\n    Raises\n    ------\n    TypeError\n        If the `Categorical` is not `ordered`.\n\n    Returns\n    -------\n    max : the maximum of this `Categorical`\n    \"\"\"\n    self.check_for_ordered('max')\n    if not len(self._codes):\n        return self.dtype.na_value\n    good = self._codes != -1\n    if not good.all():\n        if skipna:\n            pointer = self._codes[good].max()\n        else:\n            return np.nan\n    else:\n        pointer = self._codes.max()\n    return self.categories[pointer]",
                            "def mode(self, dropna=True):\n    \"\"\"\n    Returns the mode(s) of the Categorical.\n\n    Always returns `Categorical` even if only one value.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't consider counts of NaN/NaT.\n\n        .. versionadded:: 0.24.0\n\n    Returns\n    -------\n    modes : `Categorical` (sorted)\n    \"\"\"\n    codes = self._codes\n    if dropna:\n        good = self._codes != -1\n        codes = self._codes[good]\n    codes = sorted(htable.mode_int64(ensure_int64(codes), dropna))\n    return self._constructor(values=codes, dtype=self.dtype, fastpath=True)",
                            "def unique(self):\n    \"\"\"\n    Return the ``Categorical`` which ``categories`` and ``codes`` are\n    unique. Unused categories are NOT returned.\n\n    - unordered category: values and categories are sorted by appearance\n      order.\n    - ordered category: values are sorted by appearance order, categories\n      keeps existing order.\n\n    Returns\n    -------\n    unique values : ``Categorical``\n\n    See Also\n    --------\n    pandas.unique\n    CategoricalIndex.unique\n    Series.unique\n\n    Examples\n    --------\n    An unordered Categorical will return categories in the\n    order of appearance.\n\n    >>> pd.Categorical(list(\"baabc\")).unique()\n    [b, a, c]\n    Categories (3, object): [b, a, c]\n\n    >>> pd.Categorical(list(\"baabc\"), categories=list(\"abc\")).unique()\n    [b, a, c]\n    Categories (3, object): [b, a, c]\n\n    An ordered Categorical preserves the category ordering.\n\n    >>> pd.Categorical(\n    ...     list(\"baabc\"), categories=list(\"abc\"), ordered=True\n    ... ).unique()\n    [b, a, c]\n    Categories (3, object): [a < b < c]\n    \"\"\"\n    unique_codes = unique1d(self.codes)\n    cat = self.copy()\n    cat._codes = unique_codes\n    take_codes = unique_codes[unique_codes != -1]\n    if self.ordered:\n        take_codes = np.sort(take_codes)\n    return cat.set_categories(cat.categories.take(take_codes))",
                            "def _values_for_factorize(self):\n    codes = self.codes.astype('int64')\n    return (codes, -1)",
                            "@classmethod\ndef _from_factorized(cls, uniques, original):\n    return original._constructor(original.categories.take(uniques), dtype=original.dtype)",
                            "def equals(self, other):\n    \"\"\"\n    Returns True if categorical arrays are equal.\n\n    Parameters\n    ----------\n    other : `Categorical`\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    if self.is_dtype_equal(other):\n        if self.categories.equals(other.categories):\n            other_codes = other._codes\n        else:\n            other_codes = recode_for_categories(other.codes, other.categories, self.categories)\n        return np.array_equal(self._codes, other_codes)\n    return False",
                            "def is_dtype_equal(self, other):\n    \"\"\"\n    Returns True if categoricals are the same dtype\n      same categories, and same ordered\n\n    Parameters\n    ----------\n    other : Categorical\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    try:\n        return hash(self.dtype) == hash(other.dtype)\n    except (AttributeError, TypeError):\n        return False",
                            "def describe(self):\n    \"\"\"\n    Describes this Categorical\n\n    Returns\n    -------\n    description: `DataFrame`\n        A dataframe with frequency and counts by category.\n    \"\"\"\n    counts = self.value_counts(dropna=False)\n    freqs = counts / float(counts.sum())\n    from pandas.core.reshape.concat import concat\n    result = concat([counts, freqs], axis=1)\n    result.columns = ['counts', 'freqs']\n    result.index.name = 'categories'\n    return result",
                            "@Substitution(klass='Categorical')\n@Appender(_extension_array_shared_docs['repeat'])\ndef repeat(self, repeats, axis=None):\n    nv.validate_repeat(tuple(), dict(axis=axis))\n    codes = self._codes.repeat(repeats)\n    return self._constructor(values=codes, dtype=self.dtype, fastpath=True)",
                            "@property\ndef _can_hold_na(self):\n    return True",
                            "@classmethod\ndef _concat_same_type(self, to_concat):\n    from pandas.core.dtypes.concat import concat_categorical\n    return concat_categorical(to_concat)",
                            "def isin(self, values):\n    \"\"\"\n    Check whether `values` are contained in Categorical.\n\n    Return a boolean NumPy Array showing whether each element in\n    the Categorical matches an element in the passed sequence of\n    `values` exactly.\n\n    Parameters\n    ----------\n    values : set or list-like\n        The sequence of values to test. Passing in a single string will\n        raise a ``TypeError``. Instead, turn a single string into a\n        list of one element.\n\n    Returns\n    -------\n    isin : numpy.ndarray (bool dtype)\n\n    Raises\n    ------\n    TypeError\n      * If `values` is not a set or list-like\n\n    See Also\n    --------\n    pandas.Series.isin : Equivalent method on Series.\n\n    Examples\n    --------\n    >>> s = pd.Categorical(['lama', 'cow', 'lama', 'beetle', 'lama',\n    ...                'hippo'])\n    >>> s.isin(['cow', 'lama'])\n    array([ True,  True,  True, False,  True, False])\n\n    Passing a single string as ``s.isin('lama')`` will raise an error. Use\n    a list of one element instead:\n\n    >>> s.isin(['lama'])\n    array([ True, False,  True, False,  True, False])\n    \"\"\"\n    if not is_list_like(values):\n        values_type = type(values).__name__\n        raise TypeError(f'only list-like objects are allowed to be passed to isin(), you passed a [{values_type}]')\n    values = sanitize_array(values, None, None)\n    null_mask = np.asarray(isna(values))\n    code_values = self.categories.get_indexer(values)\n    code_values = code_values[null_mask | (code_values >= 0)]\n    return algorithms.isin(self.codes, code_values)",
                            "def replace(self, to_replace, value, inplace: bool=False):\n    \"\"\"\n    Replaces all instances of one value with another\n\n    Parameters\n    ----------\n    to_replace: object\n        The value to be replaced\n\n    value: object\n        The value to replace it with\n\n    inplace: bool\n        Whether the operation is done in-place\n\n    Returns\n    -------\n    None if inplace is True, otherwise the new Categorical after replacement\n\n\n    Examples\n    --------\n    >>> s = pd.Categorical([1, 2, 1, 3])\n    >>> s.replace(1, 3)\n    [3, 2, 3, 3]\n    Categories (2, int64): [2, 3]\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    cat = self if inplace else self.copy()\n    if is_list_like(to_replace):\n        replace_dict = {replace_value: value for replace_value in to_replace}\n    else:\n        replace_dict = {to_replace: value}\n    for replace_value, new_value in replace_dict.items():\n        if new_value == replace_value:\n            continue\n        if replace_value in cat.categories:\n            if isna(new_value):\n                cat.remove_categories(replace_value, inplace=True)\n                continue\n            categories = cat.categories.tolist()\n            index = categories.index(replace_value)\n            if new_value in cat.categories:\n                value_index = categories.index(new_value)\n                cat._codes[cat._codes == index] = value_index\n                cat.remove_categories(replace_value, inplace=True)\n            else:\n                categories[index] = new_value\n                cat.rename_categories(categories, inplace=True)\n    if not inplace:\n        return cat"
                        ],
                        "constructor_variables": [
                            "_dtype",
                            "full_codes",
                            "_codes",
                            "sanitize_dtype",
                            "codes",
                            "dtype",
                            "null_mask",
                            "old_codes",
                            "values"
                        ],
                        "class_level_variables": [
                            "__array_priority__",
                            "_dtype",
                            "_deprecations",
                            "_typ",
                            "to_list",
                            "codes",
                            "__eq__",
                            "__ne__",
                            "__lt__",
                            "__gt__",
                            "__le__",
                            "__ge__",
                            "isnull",
                            "notnull"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "__init__(self, values, categories=None, ordered=None, dtype=None, fastpath=False)",
                            "categories(self)",
                            "categories(self, categories)",
                            "ordered(self) -> Ordered",
                            "dtype(self) -> CategoricalDtype",
                            "_constructor(self) -> Type['Categorical']",
                            "_from_sequence(cls, scalars, dtype=None, copy=False)",
                            "_formatter(self, boxed=False)",
                            "copy(self) -> 'Categorical'",
                            "astype(self, dtype: Dtype, copy: bool=True) -> ArrayLike",
                            "size(self) -> int",
                            "itemsize(self) -> int",
                            "tolist(self) -> List[Scalar]",
                            "_from_inferred_categories(cls, inferred_categories, inferred_codes, dtype, true_values=None)",
                            "from_codes(cls, codes, categories=None, ordered=None, dtype=None)",
                            "_get_codes(self)",
                            "_set_codes(self, codes)",
                            "_set_categories(self, categories, fastpath=False)",
                            "_set_dtype(self, dtype: CategoricalDtype) -> 'Categorical'",
                            "set_ordered(self, value, inplace=False)",
                            "as_ordered(self, inplace=False)",
                            "as_unordered(self, inplace=False)",
                            "set_categories(self, new_categories, ordered=None, rename=False, inplace=False)",
                            "rename_categories(self, new_categories, inplace=False)",
                            "reorder_categories(self, new_categories, ordered=None, inplace=False)",
                            "add_categories(self, new_categories, inplace=False)",
                            "remove_categories(self, removals, inplace=False)",
                            "remove_unused_categories(self, inplace=False)",
                            "map(self, mapper)",
                            "shape(self)",
                            "shift(self, periods, fill_value=None)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__array_ufunc__(self, ufunc, method, *inputs, **kwargs)",
                            "__setstate__(self, state)",
                            "T(self) -> 'Categorical'",
                            "nbytes(self)",
                            "memory_usage(self, deep=False)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "isna(self)",
                            "notna(self)",
                            "dropna(self)",
                            "value_counts(self, dropna=True)",
                            "_internal_get_values(self)",
                            "check_for_ordered(self, op)",
                            "_values_for_argsort(self)",
                            "argsort(self, ascending=True, kind='quicksort', **kwargs)",
                            "sort_values(self, inplace=False, ascending=True, na_position='last')",
                            "_values_for_rank(self)",
                            "view(self, dtype=None)",
                            "to_dense(self)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "take(self, indexer, allow_fill: bool=False, fill_value=None)",
                            "take_nd(self, indexer, allow_fill: bool=False, fill_value=None)",
                            "__len__(self) -> int",
                            "__iter__(self)",
                            "__contains__(self, key) -> bool",
                            "_tidy_repr(self, max_vals=10, footer=True) -> str",
                            "_repr_categories(self)",
                            "_repr_categories_info(self) -> str",
                            "_repr_footer(self) -> str",
                            "_get_repr(self, length=True, na_rep='NaN', footer=True) -> str",
                            "__repr__(self) -> str",
                            "_maybe_coerce_indexer(self, indexer)",
                            "__getitem__(self, key)",
                            "__setitem__(self, key, value)",
                            "_reverse_indexer(self) -> Dict[Hashable, np.ndarray]",
                            "_reduce(self, name, axis=0, **kwargs)",
                            "min(self, skipna=True)",
                            "max(self, skipna=True)",
                            "mode(self, dropna=True)",
                            "unique(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, uniques, original)",
                            "equals(self, other)",
                            "is_dtype_equal(self, other)",
                            "describe(self)",
                            "repeat(self, repeats, axis=None)",
                            "_can_hold_na(self)",
                            "_concat_same_type(self, to_concat)",
                            "isin(self, values)",
                            "replace(self, to_replace, value, inplace: bool=False)"
                        ]
                    },
                    "variable_values": [
                        [
                            {
                                "self.check_for_ordered": {
                                    "variable_value": "<bound method Categorical.check_for_ordered of [NaN]\nCategories (2, int64): [1 < 2]>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "[NaN]\nCategories (2, int64): [1 < 2]",
                                    "variable_type": "Categorical",
                                    "variable_shape": "(1,)"
                                },
                                "self._codes": {
                                    "variable_value": "array([-1], dtype=int8)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "self.dtype.na_value": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "CategoricalDtype(categories=[1, 2], ordered=True)",
                                    "variable_type": "CategoricalDtype",
                                    "variable_shape": "()"
                                },
                                "good": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "good.all": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "skipna": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "pointer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.nan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._codes.max": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.categories": {
                                    "variable_value": "Int64Index([1, 2], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "(2,)"
                                },
                                "deprecate_kwarg": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "self.check_for_ordered": {
                                    "variable_value": "<bound method Categorical.check_for_ordered of [NaN]\nCategories (2, int64): [1 < 2]>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "[NaN]\nCategories (2, int64): [1 < 2]",
                                    "variable_type": "Categorical",
                                    "variable_shape": "(1,)"
                                },
                                "self._codes": {
                                    "variable_value": "array([-1], dtype=int8)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "self.dtype.na_value": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "CategoricalDtype(categories=[1, 2], ordered=True)",
                                    "variable_type": "CategoricalDtype",
                                    "variable_shape": "()"
                                },
                                "good": {
                                    "variable_value": "array([False])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "good.all": {
                                    "variable_value": "<built-in method all of numpy.ndarray object at 0x116a07440>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "skipna": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "pointer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.nan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._codes.max": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.categories": {
                                    "variable_value": "Int64Index([1, 2], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "(2,)"
                                },
                                "deprecate_kwarg": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "self.check_for_ordered": {
                                    "variable_value": "<bound method Categorical.check_for_ordered of [NaN]\nCategories (2, int64): [1 < 2]>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "[NaN]\nCategories (2, int64): [1 < 2]",
                                    "variable_type": "Categorical",
                                    "variable_shape": "(1,)"
                                },
                                "self._codes": {
                                    "variable_value": "array([-1], dtype=int8)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "self.dtype.na_value": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "CategoricalDtype(categories=[1, 2], ordered=True)",
                                    "variable_type": "CategoricalDtype",
                                    "variable_shape": "()"
                                },
                                "good": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "good.all": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "skipna": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "good.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pointer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.nan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._codes.max": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.categories": {
                                    "variable_value": "Int64Index([1, 2], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "(2,)"
                                },
                                "deprecate_kwarg": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "self.check_for_ordered": {
                                    "variable_value": "<bound method Categorical.check_for_ordered of [NaN]\nCategories (2, int64): [1 < 2]>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "[NaN]\nCategories (2, int64): [1 < 2]",
                                    "variable_type": "Categorical",
                                    "variable_shape": "(1,)"
                                },
                                "self._codes": {
                                    "variable_value": "array([-1], dtype=int8)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "self.dtype.na_value": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "CategoricalDtype(categories=[1, 2], ordered=True)",
                                    "variable_type": "CategoricalDtype",
                                    "variable_shape": "()"
                                },
                                "good": {
                                    "variable_value": "array([False])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "good.all": {
                                    "variable_value": "<built-in method all of numpy.ndarray object at 0x115bbee40>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "skipna": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "good.any": {
                                    "variable_value": "<built-in method any of numpy.ndarray object at 0x115bbee40>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "pointer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.nan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._codes.max": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.categories": {
                                    "variable_value": "Int64Index([1, 2], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "(2,)"
                                },
                                "deprecate_kwarg": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "self.check_for_ordered": {
                                    "variable_value": "<bound method Categorical.check_for_ordered of [NaN]\nCategories (2, int64): [1 < 2]>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "[NaN]\nCategories (2, int64): [1 < 2]",
                                    "variable_type": "Categorical",
                                    "variable_shape": "(1,)"
                                },
                                "self._codes": {
                                    "variable_value": "array([-1], dtype=int8)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "self.dtype.na_value": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "CategoricalDtype(categories=[1, 2], ordered=True)",
                                    "variable_type": "CategoricalDtype",
                                    "variable_shape": "()"
                                },
                                "good": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "good.all": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "skipna": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "good.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pointer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.nan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._codes.max": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.categories": {
                                    "variable_value": "Int64Index([1, 2], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "(2,)"
                                },
                                "deprecate_kwarg": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "self.check_for_ordered": {
                                    "variable_value": "<bound method Categorical.check_for_ordered of [NaN]\nCategories (2, int64): [1 < 2]>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "[NaN]\nCategories (2, int64): [1 < 2]",
                                    "variable_type": "Categorical",
                                    "variable_shape": "(1,)"
                                },
                                "self._codes": {
                                    "variable_value": "array([-1], dtype=int8)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "self.dtype.na_value": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "CategoricalDtype(categories=[1, 2], ordered=True)",
                                    "variable_type": "CategoricalDtype",
                                    "variable_shape": "()"
                                },
                                "good": {
                                    "variable_value": "array([False])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(1,)"
                                },
                                "good.all": {
                                    "variable_value": "<built-in method all of numpy.ndarray object at 0x115ba8760>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "skipna": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "good.any": {
                                    "variable_value": "<built-in method any of numpy.ndarray object at 0x115ba8760>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "pointer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.nan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._codes.max": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.categories": {
                                    "variable_value": "Int64Index([1, 2], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "(2,)"
                                },
                                "deprecate_kwarg": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                }
            ],
            "inscope_functions": [
                "def _cat_compare_op(op):\n    opname = f\"__{op.__name__}__\"\n\n    @unpack_zerodim_and_defer(opname)\n    def func(self, other):\n        if is_list_like(other) and len(other) != len(self):\n            # TODO: Could this fail if the categories are listlike objects?\n            raise ValueError(\"Lengths must match.\")\n\n        if not self.ordered:\n            if opname in [\"__lt__\", \"__gt__\", \"__le__\", \"__ge__\"]:\n                raise TypeError(\n                    \"Unordered Categoricals can only compare equality or not\"\n                )\n        if isinstance(other, Categorical):\n            # Two Categoricals can only be be compared if the categories are\n            # the same (maybe up to ordering, depending on ordered)\n\n            msg = \"Categoricals can only be compared if 'categories' are the same.\"\n            if len(self.categories) != len(other.categories):\n                raise TypeError(msg + \" Categories are different lengths\")\n            elif self.ordered and not (self.categories == other.categories).all():\n                raise TypeError(msg)\n            elif not set(self.categories) == set(other.categories):\n                raise TypeError(msg)\n\n            if not (self.ordered == other.ordered):\n                raise TypeError(\n                    \"Categoricals can only be compared if 'ordered' is the same\"\n                )\n            if not self.ordered and not self.categories.equals(other.categories):\n                # both unordered and different order\n                other_codes = _get_codes_for_values(other, self.categories)\n            else:\n                other_codes = other._codes\n\n            f = getattr(self._codes, opname)\n            ret = f(other_codes)\n            mask = (self._codes == -1) | (other_codes == -1)\n            if mask.any():\n                # In other series, the leads to False, so do that here too\n                if opname == \"__ne__\":\n                    ret[(self._codes == -1) & (other_codes == -1)] = True\n                else:\n                    ret[mask] = False\n            return ret\n\n        if is_scalar(other):\n            if other in self.categories:\n                i = self.categories.get_loc(other)\n                ret = getattr(self._codes, opname)(i)\n\n                if opname not in {\"__eq__\", \"__ge__\", \"__gt__\"}:\n                    # check for NaN needed if we are not equal or larger\n                    mask = self._codes == -1\n                    ret[mask] = False\n                return ret\n            else:\n                if opname == \"__eq__\":\n                    return np.zeros(len(self), dtype=bool)\n                elif opname == \"__ne__\":\n                    return np.ones(len(self), dtype=bool)\n                else:\n                    raise TypeError(\n                        f\"Cannot compare a Categorical for op {opname} with a \"\n                        \"scalar, which is not a category.\"\n                    )\n        else:\n\n            # allow categorical vs object dtype array comparisons for equality\n            # these are only positional comparisons\n            if opname in [\"__eq__\", \"__ne__\"]:\n                return getattr(np.array(self), opname)(np.array(other))\n\n            raise TypeError(\n                f\"Cannot compare a Categorical for op {opname} with \"\n                f\"type {type(other)}.\\nIf you want to compare values, \"\n                \"use 'np.asarray(cat) <op> other'.\"\n            )\n\n    func.__name__ = opname\n\n    return func",
                "def contains(cat, key, container):\n    \"\"\"\n    Helper for membership check for ``key`` in ``cat``.\n\n    This is a helper method for :method:`__contains__`\n    and :class:`CategoricalIndex.__contains__`.\n\n    Returns True if ``key`` is in ``cat.categories`` and the\n    location of ``key`` in ``categories`` is in ``container``.\n\n    Parameters\n    ----------\n    cat : :class:`Categorical`or :class:`categoricalIndex`\n    key : a hashable object\n        The key to check membership for.\n    container : Container (e.g. list-like or mapping)\n        The container to check for membership in.\n\n    Returns\n    -------\n    is_in : bool\n        True if ``key`` is in ``self.categories`` and location of\n        ``key`` in ``categories`` is in ``container``, else False.\n\n    Notes\n    -----\n    This method does not check for NaN values. Do that separately\n    before calling this method.\n    \"\"\"\n    hash(key)\n\n    # get location of key in categories.\n    # If a KeyError, the key isn't in categories, so logically\n    #  can't be in container either.\n    try:\n        loc = cat.categories.get_loc(key)\n    except (KeyError, TypeError):\n        return False\n\n    # loc is the location of key in categories, but also the *value*\n    # for key in container. So, `key` may be in categories,\n    # but still not in `container`. Example ('b' in categories,\n    # but not in values):\n    # 'b' in Categorical(['a'], categories=['a', 'b'])  # False\n    if is_scalar(loc):\n        return loc in container\n    else:\n        # if categories is an IntervalIndex, loc is an array.\n        return any(loc_ in container for loc_ in loc)",
                "def _get_codes_for_values(values, categories):\n    \"\"\"\n    utility routine to turn values into codes given the specified categories\n    \"\"\"\n    dtype_equal = is_dtype_equal(values.dtype, categories.dtype)\n\n    if is_extension_array_dtype(categories.dtype) and is_object_dtype(values):\n        # Support inferring the correct extension dtype from an array of\n        # scalar objects. e.g.\n        # Categorical(array[Period, Period], categories=PeriodIndex(...))\n        cls = categories.dtype.construct_array_type()\n        values = maybe_cast_to_extension_array(cls, values)\n        if not isinstance(values, cls):\n            # exception raised in _from_sequence\n            values = ensure_object(values)\n            categories = ensure_object(categories)\n    elif not dtype_equal:\n        values = ensure_object(values)\n        categories = ensure_object(categories)\n\n    hash_klass, vals = _get_data_algo(values)\n    _, cats = _get_data_algo(categories)\n    t = hash_klass(len(cats))\n    t.map_locations(cats)\n    return coerce_indexer_dtype(t.lookup(vals), cats)",
                "def recode_for_categories(codes: np.ndarray, old_categories, new_categories):\n    \"\"\"\n    Convert a set of codes for to a new set of categories\n\n    Parameters\n    ----------\n    codes : np.ndarray\n    old_categories, new_categories : Index\n\n    Returns\n    -------\n    new_codes : np.ndarray[np.int64]\n\n    Examples\n    --------\n    >>> old_cat = pd.Index(['b', 'a', 'c'])\n    >>> new_cat = pd.Index(['a', 'b'])\n    >>> codes = np.array([0, 1, 1, 2])\n    >>> recode_for_categories(codes, old_cat, new_cat)\n    array([ 1,  0,  0, -1], dtype=int8)\n    \"\"\"\n    if len(old_categories) == 0:\n        # All null anyway, so just retain the nulls\n        return codes.copy()\n    elif new_categories.equals(old_categories):\n        # Same categories, so no need to actually recode\n        return codes.copy()\n    indexer = coerce_indexer_dtype(\n        new_categories.get_indexer(old_categories), new_categories\n    )\n    new_codes = take_1d(indexer, codes.copy(), fill_value=-1)\n    return new_codes",
                "def _convert_to_list_like(list_like):\n    if hasattr(list_like, \"dtype\"):\n        return list_like\n    if isinstance(list_like, list):\n        return list_like\n    if is_sequence(list_like) or isinstance(list_like, tuple) or is_iterator(list_like):\n        return list(list_like)\n    elif is_scalar(list_like):\n        return [list_like]\n    else:\n        # TODO: is this reached?\n        return [list_like]",
                "def factorize_from_iterable(values):\n    \"\"\"\n    Factorize an input `values` into `categories` and `codes`. Preserves\n    categorical dtype in `categories`.\n\n    *This is an internal function*\n\n    Parameters\n    ----------\n    values : list-like\n\n    Returns\n    -------\n    codes : ndarray\n    categories : Index\n        If `values` has a categorical dtype, then `categories` is\n        a CategoricalIndex keeping the categories and order of `values`.\n    \"\"\"\n    if not is_list_like(values):\n        raise TypeError(\"Input must be list-like\")\n\n    if is_categorical_dtype(values):\n        values = extract_array(values)\n        # The Categorical we want to build has the same categories\n        # as values but its codes are by def [0, ..., len(n_categories) - 1]\n        cat_codes = np.arange(len(values.categories), dtype=values.codes.dtype)\n        categories = Categorical.from_codes(cat_codes, dtype=values.dtype)\n        codes = values.codes\n    else:\n        # The value of ordered is irrelevant since we don't use cat as such,\n        # but only the resulting categories, the order of which is independent\n        # from ordered. Set ordered to False as default. See GH #15457\n        cat = Categorical(values, ordered=False)\n        categories = cat.categories\n        codes = cat.codes\n    return codes, categories",
                "def factorize_from_iterables(iterables):\n    \"\"\"\n    A higher-level wrapper over `factorize_from_iterable`.\n\n    *This is an internal function*\n\n    Parameters\n    ----------\n    iterables : list-like of list-likes\n\n    Returns\n    -------\n    codes_list : list of ndarrays\n    categories_list : list of Indexes\n\n    Notes\n    -----\n    See `factorize_from_iterable` for more info.\n    \"\"\"\n    if len(iterables) == 0:\n        # For consistency, it should return a list of 2 lists.\n        return [[], []]\n    return map(list, zip(*(factorize_from_iterable(it) for it in iterables)))",
                "@unpack_zerodim_and_defer(opname)\ndef func(self, other):\n    if is_list_like(other) and len(other) != len(self):\n        # TODO: Could this fail if the categories are listlike objects?\n        raise ValueError(\"Lengths must match.\")\n\n    if not self.ordered:\n        if opname in [\"__lt__\", \"__gt__\", \"__le__\", \"__ge__\"]:\n            raise TypeError(\n                \"Unordered Categoricals can only compare equality or not\"\n            )\n    if isinstance(other, Categorical):\n        # Two Categoricals can only be be compared if the categories are\n        # the same (maybe up to ordering, depending on ordered)\n\n        msg = \"Categoricals can only be compared if 'categories' are the same.\"\n        if len(self.categories) != len(other.categories):\n            raise TypeError(msg + \" Categories are different lengths\")\n        elif self.ordered and not (self.categories == other.categories).all():\n            raise TypeError(msg)\n        elif not set(self.categories) == set(other.categories):\n            raise TypeError(msg)\n\n        if not (self.ordered == other.ordered):\n            raise TypeError(\n                \"Categoricals can only be compared if 'ordered' is the same\"\n            )\n        if not self.ordered and not self.categories.equals(other.categories):\n            # both unordered and different order\n            other_codes = _get_codes_for_values(other, self.categories)\n        else:\n            other_codes = other._codes\n\n        f = getattr(self._codes, opname)\n        ret = f(other_codes)\n        mask = (self._codes == -1) | (other_codes == -1)\n        if mask.any():\n            # In other series, the leads to False, so do that here too\n            if opname == \"__ne__\":\n                ret[(self._codes == -1) & (other_codes == -1)] = True\n            else:\n                ret[mask] = False\n        return ret\n\n    if is_scalar(other):\n        if other in self.categories:\n            i = self.categories.get_loc(other)\n            ret = getattr(self._codes, opname)(i)\n\n            if opname not in {\"__eq__\", \"__ge__\", \"__gt__\"}:\n                # check for NaN needed if we are not equal or larger\n                mask = self._codes == -1\n                ret[mask] = False\n            return ret\n        else:\n            if opname == \"__eq__\":\n                return np.zeros(len(self), dtype=bool)\n            elif opname == \"__ne__\":\n                return np.ones(len(self), dtype=bool)\n            else:\n                raise TypeError(\n                    f\"Cannot compare a Categorical for op {opname} with a \"\n                    \"scalar, which is not a category.\"\n                )\n    else:\n\n        # allow categorical vs object dtype array comparisons for equality\n        # these are only positional comparisons\n        if opname in [\"__eq__\", \"__ne__\"]:\n            return getattr(np.array(self), opname)(np.array(other))\n\n        raise TypeError(\n            f\"Cannot compare a Categorical for op {opname} with \"\n            f\"type {type(other)}.\\nIf you want to compare values, \"\n            \"use 'np.asarray(cat) <op> other'.\"\n        )",
                "def __init__(\n    self, values, categories=None, ordered=None, dtype=None, fastpath=False\n):\n\n    dtype = CategoricalDtype._from_values_or_dtype(\n        values, categories, ordered, dtype\n    )\n    # At this point, dtype is always a CategoricalDtype, but\n    # we may have dtype.categories be None, and we need to\n    # infer categories in a factorization step further below\n\n    if fastpath:\n        self._codes = coerce_indexer_dtype(values, dtype.categories)\n        self._dtype = self._dtype.update_dtype(dtype)\n        return\n\n    # null_mask indicates missing values we want to exclude from inference.\n    # This means: only missing values in list-likes (not arrays/ndframes).\n    null_mask = np.array(False)\n\n    # sanitize input\n    if is_categorical_dtype(values):\n        if dtype.categories is None:\n            dtype = CategoricalDtype(values.categories, dtype.ordered)\n    elif not isinstance(values, (ABCIndexClass, ABCSeries)):\n        # sanitize_array coerces np.nan to a string under certain versions\n        # of numpy\n        values = maybe_infer_to_datetimelike(values, convert_dates=True)\n        if not isinstance(values, np.ndarray):\n            values = _convert_to_list_like(values)\n\n            # By convention, empty lists result in object dtype:\n            sanitize_dtype = \"object\" if len(values) == 0 else None\n            null_mask = isna(values)\n            if null_mask.any():\n                values = [values[idx] for idx in np.where(~null_mask)[0]]\n            values = sanitize_array(values, None, dtype=sanitize_dtype)\n\n    if dtype.categories is None:\n        try:\n            codes, categories = factorize(values, sort=True)\n        except TypeError as err:\n            codes, categories = factorize(values, sort=False)\n            if dtype.ordered:\n                # raise, as we don't have a sortable data structure and so\n                # the user should give us one by specifying categories\n                raise TypeError(\n                    \"'values' is not ordered, please \"\n                    \"explicitly specify the categories order \"\n                    \"by passing in a categories argument.\"\n                ) from err\n        except ValueError as err:\n\n            # FIXME\n            raise NotImplementedError(\n                \"> 1 ndim Categorical are not supported at this time\"\n            ) from err\n\n        # we're inferring from values\n        dtype = CategoricalDtype(categories, dtype.ordered)\n\n    elif is_categorical_dtype(values):\n        old_codes = (\n            values._values.codes if isinstance(values, ABCSeries) else values.codes\n        )\n        codes = recode_for_categories(\n            old_codes, values.dtype.categories, dtype.categories\n        )\n\n    else:\n        codes = _get_codes_for_values(values, dtype.categories)\n\n    if null_mask.any():\n        # Reinsert -1 placeholders for previously removed missing values\n        full_codes = -np.ones(null_mask.shape, dtype=codes.dtype)\n        full_codes[~null_mask] = codes\n        codes = full_codes\n\n    self._dtype = self._dtype.update_dtype(dtype)\n    self._codes = coerce_indexer_dtype(codes, dtype.categories)",
                "@property\ndef categories(self):\n    \"\"\"\n    The categories of this categorical.\n\n    Setting assigns new values to each category (effectively a rename of\n    each individual category).\n\n    The assigned value has to be a list-like object. All items must be\n    unique and the number of items in the new categories must be the same\n    as the number of items in the old categories.\n\n    Assigning to `categories` is a inplace operation!\n\n    Raises\n    ------\n    ValueError\n        If the new categories do not validate as categories or if the\n        number of new categories is unequal the number of old categories\n\n    See Also\n    --------\n    rename_categories : Rename categories.\n    reorder_categories : Reorder categories.\n    add_categories : Add new categories.\n    remove_categories : Remove the specified categories.\n    remove_unused_categories : Remove categories which are not used.\n    set_categories : Set the categories to the specified ones.\n    \"\"\"\n    return self.dtype.categories",
                "@categories.setter\ndef categories(self, categories):\n    new_dtype = CategoricalDtype(categories, ordered=self.ordered)\n    if self.dtype.categories is not None and len(self.dtype.categories) != len(\n        new_dtype.categories\n    ):\n        raise ValueError(\n            \"new categories need to have the same number of \"\n            \"items as the old categories!\"\n        )\n    self._dtype = new_dtype",
                "@property\ndef ordered(self) -> Ordered:\n    \"\"\"\n    Whether the categories have an ordered relationship.\n    \"\"\"\n    return self.dtype.ordered",
                "@property\ndef dtype(self) -> CategoricalDtype:\n    \"\"\"\n    The :class:`~pandas.api.types.CategoricalDtype` for this instance.\n    \"\"\"\n    return self._dtype",
                "@property\ndef _constructor(self) -> Type[\"Categorical\"]:\n    return Categorical",
                "@classmethod\ndef _from_sequence(cls, scalars, dtype=None, copy=False):\n    return Categorical(scalars, dtype=dtype)",
                "def _formatter(self, boxed=False):\n    # Defer to CategoricalFormatter's formatter.\n    return None",
                "def copy(self) -> \"Categorical\":\n    \"\"\"\n    Copy constructor.\n    \"\"\"\n    return self._constructor(\n        values=self._codes.copy(), dtype=self.dtype, fastpath=True\n    )",
                "def astype(self, dtype: Dtype, copy: bool = True) -> ArrayLike:\n    \"\"\"\n    Coerce this type to another dtype\n\n    Parameters\n    ----------\n    dtype : numpy dtype or pandas type\n    copy : bool, default True\n        By default, astype always returns a newly allocated object.\n        If copy is set to False and dtype is categorical, the original\n        object is returned.\n    \"\"\"\n    if is_categorical_dtype(dtype):\n        dtype = cast(Union[str, CategoricalDtype], dtype)\n\n        # GH 10696/18593\n        dtype = self.dtype.update_dtype(dtype)\n        self = self.copy() if copy else self\n        if dtype == self.dtype:\n            return self\n        return self._set_dtype(dtype)\n    if is_extension_array_dtype(dtype):\n        return array(self, dtype=dtype, copy=copy)  # type: ignore # GH 28770\n    if is_integer_dtype(dtype) and self.isna().any():\n        raise ValueError(\"Cannot convert float NaN to integer\")\n    return np.array(self, dtype=dtype, copy=copy)",
                "@cache_readonly\ndef size(self) -> int:\n    \"\"\"\n    Return the len of myself.\n    \"\"\"\n    return self._codes.size",
                "@cache_readonly\ndef itemsize(self) -> int:\n    \"\"\"\n    return the size of a single category\n    \"\"\"\n    return self.categories.itemsize",
                "def tolist(self) -> List[Scalar]:\n    \"\"\"\n    Return a list of the values.\n\n    These are each a scalar type, which is a Python scalar\n    (for str, int, float) or a pandas scalar\n    (for Timestamp/Timedelta/Interval/Period)\n    \"\"\"\n    return list(self)",
                "@classmethod\ndef _from_inferred_categories(\n    cls, inferred_categories, inferred_codes, dtype, true_values=None\n):\n    \"\"\"\n    Construct a Categorical from inferred values.\n\n    For inferred categories (`dtype` is None) the categories are sorted.\n    For explicit `dtype`, the `inferred_categories` are cast to the\n    appropriate type.\n\n    Parameters\n    ----------\n    inferred_categories : Index\n    inferred_codes : Index\n    dtype : CategoricalDtype or 'category'\n    true_values : list, optional\n        If none are provided, the default ones are\n        \"True\", \"TRUE\", and \"true.\"\n\n    Returns\n    -------\n    Categorical\n    \"\"\"\n    from pandas import Index, to_numeric, to_datetime, to_timedelta\n\n    cats = Index(inferred_categories)\n    known_categories = (\n        isinstance(dtype, CategoricalDtype) and dtype.categories is not None\n    )\n\n    if known_categories:\n        # Convert to a specialized type with `dtype` if specified.\n        if dtype.categories.is_numeric():\n            cats = to_numeric(inferred_categories, errors=\"coerce\")\n        elif is_datetime64_dtype(dtype.categories):\n            cats = to_datetime(inferred_categories, errors=\"coerce\")\n        elif is_timedelta64_dtype(dtype.categories):\n            cats = to_timedelta(inferred_categories, errors=\"coerce\")\n        elif dtype.categories.is_boolean():\n            if true_values is None:\n                true_values = [\"True\", \"TRUE\", \"true\"]\n\n            cats = cats.isin(true_values)\n\n    if known_categories:\n        # Recode from observation order to dtype.categories order.\n        categories = dtype.categories\n        codes = recode_for_categories(inferred_codes, cats, categories)\n    elif not cats.is_monotonic_increasing:\n        # Sort categories and recode for unknown categories.\n        unsorted = cats.copy()\n        categories = cats.sort_values()\n\n        codes = recode_for_categories(inferred_codes, unsorted, categories)\n        dtype = CategoricalDtype(categories, ordered=False)\n    else:\n        dtype = CategoricalDtype(cats, ordered=False)\n        codes = inferred_codes\n\n    return cls(codes, dtype=dtype, fastpath=True)",
                "@classmethod\ndef from_codes(cls, codes, categories=None, ordered=None, dtype=None):\n    \"\"\"\n    Make a Categorical type from codes and categories or dtype.\n\n    This constructor is useful if you already have codes and\n    categories/dtype and so do not need the (computation intensive)\n    factorization step, which is usually done on the constructor.\n\n    If your data does not follow this convention, please use the normal\n    constructor.\n\n    Parameters\n    ----------\n    codes : array-like of int\n        An integer array, where each integer points to a category in\n        categories or dtype.categories, or else is -1 for NaN.\n    categories : index-like, optional\n        The categories for the categorical. Items need to be unique.\n        If the categories are not given here, then they must be provided\n        in `dtype`.\n    ordered : bool, optional\n        Whether or not this categorical is treated as an ordered\n        categorical. If not given here or in `dtype`, the resulting\n        categorical will be unordered.\n    dtype : CategoricalDtype or \"category\", optional\n        If :class:`CategoricalDtype`, cannot be used together with\n        `categories` or `ordered`.\n\n        .. versionadded:: 0.24.0\n\n           When `dtype` is provided, neither `categories` nor `ordered`\n           should be provided.\n\n    Returns\n    -------\n    Categorical\n\n    Examples\n    --------\n    >>> dtype = pd.CategoricalDtype(['a', 'b'], ordered=True)\n    >>> pd.Categorical.from_codes(codes=[0, 1, 0, 1], dtype=dtype)\n    [a, b, a, b]\n    Categories (2, object): [a < b]\n    \"\"\"\n    dtype = CategoricalDtype._from_values_or_dtype(\n        categories=categories, ordered=ordered, dtype=dtype\n    )\n    if dtype.categories is None:\n        msg = (\n            \"The categories must be provided in 'categories' or \"\n            \"'dtype'. Both were None.\"\n        )\n        raise ValueError(msg)\n\n    if is_extension_array_dtype(codes) and is_integer_dtype(codes):\n        # Avoid the implicit conversion of Int to object\n        if isna(codes).any():\n            raise ValueError(\"codes cannot contain NA values\")\n        codes = codes.to_numpy(dtype=np.int64)\n    else:\n        codes = np.asarray(codes)\n    if len(codes) and not is_integer_dtype(codes):\n        raise ValueError(\"codes need to be array-like integers\")\n\n    if len(codes) and (codes.max() >= len(dtype.categories) or codes.min() < -1):\n        raise ValueError(\"codes need to be between -1 and len(categories)-1\")\n\n    return cls(codes, dtype=dtype, fastpath=True)",
                "def _get_codes(self):\n    \"\"\"\n    Get the codes.\n\n    Returns\n    -------\n    codes : integer array view\n        A non writable view of the `codes` array.\n    \"\"\"\n    v = self._codes.view()\n    v.flags.writeable = False\n    return v",
                "def _set_codes(self, codes):\n    \"\"\"\n    Not settable by the user directly\n    \"\"\"\n    raise ValueError(\"cannot set Categorical codes directly\")",
                "def _set_categories(self, categories, fastpath=False):\n    \"\"\"\n    Sets new categories inplace\n\n    Parameters\n    ----------\n    fastpath : bool, default False\n       Don't perform validation of the categories for uniqueness or nulls\n\n    Examples\n    --------\n    >>> c = pd.Categorical(['a', 'b'])\n    >>> c\n    [a, b]\n    Categories (2, object): [a, b]\n\n    >>> c._set_categories(pd.Index(['a', 'c']))\n    >>> c\n    [a, c]\n    Categories (2, object): [a, c]\n    \"\"\"\n    if fastpath:\n        new_dtype = CategoricalDtype._from_fastpath(categories, self.ordered)\n    else:\n        new_dtype = CategoricalDtype(categories, ordered=self.ordered)\n    if (\n        not fastpath\n        and self.dtype.categories is not None\n        and len(new_dtype.categories) != len(self.dtype.categories)\n    ):\n        raise ValueError(\n            \"new categories need to have the same number of \"\n            \"items than the old categories!\"\n        )\n\n    self._dtype = new_dtype",
                "def _set_dtype(self, dtype: CategoricalDtype) -> \"Categorical\":\n    \"\"\"\n    Internal method for directly updating the CategoricalDtype\n\n    Parameters\n    ----------\n    dtype : CategoricalDtype\n\n    Notes\n    -----\n    We don't do any validation here. It's assumed that the dtype is\n    a (valid) instance of `CategoricalDtype`.\n    \"\"\"\n    codes = recode_for_categories(self.codes, self.categories, dtype.categories)\n    return type(self)(codes, dtype=dtype, fastpath=True)",
                "def set_ordered(self, value, inplace=False):\n    \"\"\"\n    Set the ordered attribute to the boolean value.\n\n    Parameters\n    ----------\n    value : bool\n       Set whether this categorical is ordered (True) or not (False).\n    inplace : bool, default False\n       Whether or not to set the ordered attribute in-place or return\n       a copy of this categorical with ordered set to the value.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    new_dtype = CategoricalDtype(self.categories, ordered=value)\n    cat = self if inplace else self.copy()\n    cat._dtype = new_dtype\n    if not inplace:\n        return cat",
                "def as_ordered(self, inplace=False):\n    \"\"\"\n    Set the Categorical to be ordered.\n\n    Parameters\n    ----------\n    inplace : bool, default False\n       Whether or not to set the ordered attribute in-place or return\n       a copy of this categorical with ordered set to True.\n\n    Returns\n    -------\n    Categorical\n        Ordered Categorical.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    return self.set_ordered(True, inplace=inplace)",
                "def as_unordered(self, inplace=False):\n    \"\"\"\n    Set the Categorical to be unordered.\n\n    Parameters\n    ----------\n    inplace : bool, default False\n       Whether or not to set the ordered attribute in-place or return\n       a copy of this categorical with ordered set to False.\n\n    Returns\n    -------\n    Categorical\n        Unordered Categorical.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    return self.set_ordered(False, inplace=inplace)",
                "def set_categories(self, new_categories, ordered=None, rename=False, inplace=False):\n    \"\"\"\n    Set the categories to the specified new_categories.\n\n    `new_categories` can include new categories (which will result in\n    unused categories) or remove old categories (which results in values\n    set to NaN). If `rename==True`, the categories will simple be renamed\n    (less or more items than in old categories will result in values set to\n    NaN or in unused categories respectively).\n\n    This method can be used to perform more than one action of adding,\n    removing, and reordering simultaneously and is therefore faster than\n    performing the individual steps via the more specialised methods.\n\n    On the other hand this methods does not do checks (e.g., whether the\n    old categories are included in the new categories on a reorder), which\n    can result in surprising changes, for example when using special string\n    dtypes, which does not considers a S1 string equal to a single char\n    python string.\n\n    Parameters\n    ----------\n    new_categories : Index-like\n       The categories in new order.\n    ordered : bool, default False\n       Whether or not the categorical is treated as a ordered categorical.\n       If not given, do not change the ordered information.\n    rename : bool, default False\n       Whether or not the new_categories should be considered as a rename\n       of the old categories or as reordered categories.\n    inplace : bool, default False\n       Whether or not to reorder the categories in-place or return a copy\n       of this categorical with reordered categories.\n\n    Returns\n    -------\n    Categorical with reordered categories or None if inplace.\n\n    Raises\n    ------\n    ValueError\n        If new_categories does not validate as categories\n\n    See Also\n    --------\n    rename_categories : Rename categories.\n    reorder_categories : Reorder categories.\n    add_categories : Add new categories.\n    remove_categories : Remove the specified categories.\n    remove_unused_categories : Remove categories which are not used.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    if ordered is None:\n        ordered = self.dtype.ordered\n    new_dtype = CategoricalDtype(new_categories, ordered=ordered)\n\n    cat = self if inplace else self.copy()\n    if rename:\n        if cat.dtype.categories is not None and len(new_dtype.categories) < len(\n            cat.dtype.categories\n        ):\n            # remove all _codes which are larger and set to -1/NaN\n            cat._codes[cat._codes >= len(new_dtype.categories)] = -1\n    else:\n        codes = recode_for_categories(\n            cat.codes, cat.categories, new_dtype.categories\n        )\n        cat._codes = codes\n    cat._dtype = new_dtype\n\n    if not inplace:\n        return cat",
                "def rename_categories(self, new_categories, inplace=False):\n    \"\"\"\n    Rename categories.\n\n    Parameters\n    ----------\n    new_categories : list-like, dict-like or callable\n\n        New categories which will replace old categories.\n\n        * list-like: all items must be unique and the number of items in\n          the new categories must match the existing number of categories.\n\n        * dict-like: specifies a mapping from\n          old categories to new. Categories not contained in the mapping\n          are passed through and extra categories in the mapping are\n          ignored.\n\n        * callable : a callable that is called on all items in the old\n          categories and whose return values comprise the new categories.\n\n        .. versionadded:: 0.23.0.\n\n    inplace : bool, default False\n        Whether or not to rename the categories inplace or return a copy of\n        this categorical with renamed categories.\n\n    Returns\n    -------\n    cat : Categorical or None\n       With ``inplace=False``, the new categorical is returned.\n       With ``inplace=True``, there is no return value.\n\n    Raises\n    ------\n    ValueError\n        If new categories are list-like and do not have the same number of\n        items than the current categories or do not validate as categories\n\n    See Also\n    --------\n    reorder_categories : Reorder categories.\n    add_categories : Add new categories.\n    remove_categories : Remove the specified categories.\n    remove_unused_categories : Remove categories which are not used.\n    set_categories : Set the categories to the specified ones.\n\n    Examples\n    --------\n    >>> c = pd.Categorical(['a', 'a', 'b'])\n    >>> c.rename_categories([0, 1])\n    [0, 0, 1]\n    Categories (2, int64): [0, 1]\n\n    For dict-like ``new_categories``, extra keys are ignored and\n    categories not in the dictionary are passed through\n\n    >>> c.rename_categories({'a': 'A', 'c': 'C'})\n    [A, A, b]\n    Categories (2, object): [A, b]\n\n    You may also provide a callable to create the new categories\n\n    >>> c.rename_categories(lambda x: x.upper())\n    [A, A, B]\n    Categories (2, object): [A, B]\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    cat = self if inplace else self.copy()\n\n    if is_dict_like(new_categories):\n        cat.categories = [new_categories.get(item, item) for item in cat.categories]\n    elif callable(new_categories):\n        cat.categories = [new_categories(item) for item in cat.categories]\n    else:\n        cat.categories = new_categories\n    if not inplace:\n        return cat",
                "def reorder_categories(self, new_categories, ordered=None, inplace=False):\n    \"\"\"\n    Reorder categories as specified in new_categories.\n\n    `new_categories` need to include all old categories and no new category\n    items.\n\n    Parameters\n    ----------\n    new_categories : Index-like\n       The categories in new order.\n    ordered : bool, optional\n       Whether or not the categorical is treated as a ordered categorical.\n       If not given, do not change the ordered information.\n    inplace : bool, default False\n       Whether or not to reorder the categories inplace or return a copy of\n       this categorical with reordered categories.\n\n    Returns\n    -------\n    cat : Categorical with reordered categories or None if inplace.\n\n    Raises\n    ------\n    ValueError\n        If the new categories do not contain all old category items or any\n        new ones\n\n    See Also\n    --------\n    rename_categories : Rename categories.\n    add_categories : Add new categories.\n    remove_categories : Remove the specified categories.\n    remove_unused_categories : Remove categories which are not used.\n    set_categories : Set the categories to the specified ones.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    if set(self.dtype.categories) != set(new_categories):\n        raise ValueError(\n            \"items in new_categories are not the same as in old categories\"\n        )\n    return self.set_categories(new_categories, ordered=ordered, inplace=inplace)",
                "def add_categories(self, new_categories, inplace=False):\n    \"\"\"\n    Add new categories.\n\n    `new_categories` will be included at the last/highest place in the\n    categories and will be unused directly after this call.\n\n    Parameters\n    ----------\n    new_categories : category or list-like of category\n       The new categories to be included.\n    inplace : bool, default False\n       Whether or not to add the categories inplace or return a copy of\n       this categorical with added categories.\n\n    Returns\n    -------\n    cat : Categorical with new categories added or None if inplace.\n\n    Raises\n    ------\n    ValueError\n        If the new categories include old categories or do not validate as\n        categories\n\n    See Also\n    --------\n    rename_categories : Rename categories.\n    reorder_categories : Reorder categories.\n    remove_categories : Remove the specified categories.\n    remove_unused_categories : Remove categories which are not used.\n    set_categories : Set the categories to the specified ones.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    if not is_list_like(new_categories):\n        new_categories = [new_categories]\n    already_included = set(new_categories) & set(self.dtype.categories)\n    if len(already_included) != 0:\n        raise ValueError(\n            f\"new categories must not include old categories: {already_included}\"\n        )\n    new_categories = list(self.dtype.categories) + list(new_categories)\n    new_dtype = CategoricalDtype(new_categories, self.ordered)\n\n    cat = self if inplace else self.copy()\n    cat._dtype = new_dtype\n    cat._codes = coerce_indexer_dtype(cat._codes, new_dtype.categories)\n    if not inplace:\n        return cat",
                "def remove_categories(self, removals, inplace=False):\n    \"\"\"\n    Remove the specified categories.\n\n    `removals` must be included in the old categories. Values which were in\n    the removed categories will be set to NaN\n\n    Parameters\n    ----------\n    removals : category or list of categories\n       The categories which should be removed.\n    inplace : bool, default False\n       Whether or not to remove the categories inplace or return a copy of\n       this categorical with removed categories.\n\n    Returns\n    -------\n    cat : Categorical with removed categories or None if inplace.\n\n    Raises\n    ------\n    ValueError\n        If the removals are not contained in the categories\n\n    See Also\n    --------\n    rename_categories : Rename categories.\n    reorder_categories : Reorder categories.\n    add_categories : Add new categories.\n    remove_unused_categories : Remove categories which are not used.\n    set_categories : Set the categories to the specified ones.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    if not is_list_like(removals):\n        removals = [removals]\n\n    removal_set = set(removals)\n    not_included = removal_set - set(self.dtype.categories)\n    new_categories = [c for c in self.dtype.categories if c not in removal_set]\n\n    # GH 10156\n    if any(isna(removals)):\n        not_included = {x for x in not_included if notna(x)}\n        new_categories = [x for x in new_categories if notna(x)]\n\n    if len(not_included) != 0:\n        raise ValueError(f\"removals must all be in old categories: {not_included}\")\n\n    return self.set_categories(\n        new_categories, ordered=self.ordered, rename=False, inplace=inplace\n    )",
                "def remove_unused_categories(self, inplace=False):\n    \"\"\"\n    Remove categories which are not used.\n\n    Parameters\n    ----------\n    inplace : bool, default False\n       Whether or not to drop unused categories inplace or return a copy of\n       this categorical with unused categories dropped.\n\n    Returns\n    -------\n    cat : Categorical with unused categories dropped or None if inplace.\n\n    See Also\n    --------\n    rename_categories : Rename categories.\n    reorder_categories : Reorder categories.\n    add_categories : Add new categories.\n    remove_categories : Remove the specified categories.\n    set_categories : Set the categories to the specified ones.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    cat = self if inplace else self.copy()\n    idx, inv = np.unique(cat._codes, return_inverse=True)\n\n    if idx.size != 0 and idx[0] == -1:  # na sentinel\n        idx, inv = idx[1:], inv - 1\n\n    new_categories = cat.dtype.categories.take(idx)\n    new_dtype = CategoricalDtype._from_fastpath(\n        new_categories, ordered=self.ordered\n    )\n    cat._dtype = new_dtype\n    cat._codes = coerce_indexer_dtype(inv, new_dtype.categories)\n\n    if not inplace:\n        return cat",
                "def map(self, mapper):\n    \"\"\"\n    Map categories using input correspondence (dict, Series, or function).\n\n    Maps the categories to new categories. If the mapping correspondence is\n    one-to-one the result is a :class:`~pandas.Categorical` which has the\n    same order property as the original, otherwise a :class:`~pandas.Index`\n    is returned. NaN values are unaffected.\n\n    If a `dict` or :class:`~pandas.Series` is used any unmapped category is\n    mapped to `NaN`. Note that if this happens an :class:`~pandas.Index`\n    will be returned.\n\n    Parameters\n    ----------\n    mapper : function, dict, or Series\n        Mapping correspondence.\n\n    Returns\n    -------\n    pandas.Categorical or pandas.Index\n        Mapped categorical.\n\n    See Also\n    --------\n    CategoricalIndex.map : Apply a mapping correspondence on a\n        :class:`~pandas.CategoricalIndex`.\n    Index.map : Apply a mapping correspondence on an\n        :class:`~pandas.Index`.\n    Series.map : Apply a mapping correspondence on a\n        :class:`~pandas.Series`.\n    Series.apply : Apply more complex functions on a\n        :class:`~pandas.Series`.\n\n    Examples\n    --------\n    >>> cat = pd.Categorical(['a', 'b', 'c'])\n    >>> cat\n    [a, b, c]\n    Categories (3, object): [a, b, c]\n    >>> cat.map(lambda x: x.upper())\n    [A, B, C]\n    Categories (3, object): [A, B, C]\n    >>> cat.map({'a': 'first', 'b': 'second', 'c': 'third'})\n    [first, second, third]\n    Categories (3, object): [first, second, third]\n\n    If the mapping is one-to-one the ordering of the categories is\n    preserved:\n\n    >>> cat = pd.Categorical(['a', 'b', 'c'], ordered=True)\n    >>> cat\n    [a, b, c]\n    Categories (3, object): [a < b < c]\n    >>> cat.map({'a': 3, 'b': 2, 'c': 1})\n    [3, 2, 1]\n    Categories (3, int64): [3 < 2 < 1]\n\n    If the mapping is not one-to-one an :class:`~pandas.Index` is returned:\n\n    >>> cat.map({'a': 'first', 'b': 'second', 'c': 'first'})\n    Index(['first', 'second', 'first'], dtype='object')\n\n    If a `dict` is used, all unmapped categories are mapped to `NaN` and\n    the result is an :class:`~pandas.Index`:\n\n    >>> cat.map({'a': 'first', 'b': 'second'})\n    Index(['first', 'second', nan], dtype='object')\n    \"\"\"\n    new_categories = self.categories.map(mapper)\n    try:\n        return self.from_codes(\n            self._codes.copy(), categories=new_categories, ordered=self.ordered\n        )\n    except ValueError:\n        # NA values are represented in self._codes with -1\n        # np.take causes NA values to take final element in new_categories\n        if np.any(self._codes == -1):\n            new_categories = new_categories.insert(len(new_categories), np.nan)\n        return np.take(new_categories, self._codes)",
                "@property\ndef shape(self):\n    \"\"\"\n    Shape of the Categorical.\n\n    For internal compatibility with numpy arrays.\n\n    Returns\n    -------\n    shape : tuple\n    \"\"\"\n    return tuple([len(self._codes)])",
                "def shift(self, periods, fill_value=None):\n    \"\"\"\n    Shift Categorical by desired number of periods.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to move, can be positive or negative\n    fill_value : object, optional\n        The scalar value to use for newly introduced missing values.\n\n        .. versionadded:: 0.24.0\n\n    Returns\n    -------\n    shifted : Categorical\n    \"\"\"\n    # since categoricals always have ndim == 1, an axis parameter\n    # doesn't make any sense here.\n    codes = self.codes\n    if codes.ndim > 1:\n        raise NotImplementedError(\"Categorical with ndim > 1.\")\n    if np.prod(codes.shape) and (periods != 0):\n        codes = np.roll(codes, ensure_platform_int(periods), axis=0)\n        if isna(fill_value):\n            fill_value = -1\n        elif fill_value in self.categories:\n            fill_value = self.categories.get_loc(fill_value)\n        else:\n            raise ValueError(\n                f\"'fill_value={fill_value}' is not present \"\n                \"in this Categorical's categories\"\n            )\n        if periods > 0:\n            codes[:periods] = fill_value\n        else:\n            codes[periods:] = fill_value\n\n    return self.from_codes(codes, dtype=self.dtype)",
                "def __array__(self, dtype=None) -> np.ndarray:\n    \"\"\"\n    The numpy array interface.\n\n    Returns\n    -------\n    numpy.array\n        A numpy array of either the specified dtype or,\n        if dtype==None (default), the same dtype as\n        categorical.categories.dtype.\n    \"\"\"\n    ret = take_1d(self.categories.values, self._codes)\n    if dtype and not is_dtype_equal(dtype, self.categories.dtype):\n        return np.asarray(ret, dtype)\n    if is_extension_array_dtype(ret):\n        # When we're a Categorical[ExtensionArray], like Interval,\n        # we need to ensure __array__ get's all the way to an\n        # ndarray.\n        ret = np.asarray(ret)\n    return ret",
                "def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n    # for binary ops, use our custom dunder methods\n    result = ops.maybe_dispatch_ufunc_to_dunder_op(\n        self, ufunc, method, *inputs, **kwargs\n    )\n    if result is not NotImplemented:\n        return result\n\n    # for all other cases, raise for now (similarly as what happens in\n    # Series.__array_prepare__)\n    raise TypeError(\n        f\"Object with dtype {self.dtype} cannot perform \"\n        f\"the numpy op {ufunc.__name__}\"\n    )",
                "def __setstate__(self, state):\n    \"\"\"Necessary for making this object picklable\"\"\"\n    if not isinstance(state, dict):\n        raise Exception(\"invalid pickle state\")\n\n    if \"_dtype\" not in state:\n        state[\"_dtype\"] = CategoricalDtype(state[\"_categories\"], state[\"_ordered\"])\n\n    for k, v in state.items():\n        setattr(self, k, v)",
                "@property\ndef T(self) -> \"Categorical\":\n    \"\"\"\n    Return transposed numpy array.\n    \"\"\"\n    return self",
                "@property\ndef nbytes(self):\n    return self._codes.nbytes + self.dtype.categories.values.nbytes",
                "def memory_usage(self, deep=False):\n    \"\"\"\n    Memory usage of my values\n\n    Parameters\n    ----------\n    deep : bool\n        Introspect the data deeply, interrogate\n        `object` dtypes for system-level memory consumption\n\n    Returns\n    -------\n    bytes used\n\n    Notes\n    -----\n    Memory usage does not include memory consumed by elements that\n    are not components of the array if deep=False\n\n    See Also\n    --------\n    numpy.ndarray.nbytes\n    \"\"\"\n    return self._codes.nbytes + self.dtype.categories.memory_usage(deep=deep)",
                "@doc(_shared_docs[\"searchsorted\"], klass=\"Categorical\")\ndef searchsorted(self, value, side=\"left\", sorter=None):\n    # searchsorted is very performance sensitive. By converting codes\n    # to same dtype as self.codes, we get much faster performance.\n    if is_scalar(value):\n        codes = self.categories.get_loc(value)\n        codes = self.codes.dtype.type(codes)\n    else:\n        locs = [self.categories.get_loc(x) for x in value]\n        codes = np.array(locs, dtype=self.codes.dtype)\n    return self.codes.searchsorted(codes, side=side, sorter=sorter)",
                "def isna(self):\n    \"\"\"\n    Detect missing values\n\n    Missing values (-1 in .codes) are detected.\n\n    Returns\n    -------\n    a boolean array of whether my values are null\n\n    See Also\n    --------\n    isna : Top-level isna.\n    isnull : Alias of isna.\n    Categorical.notna : Boolean inverse of Categorical.isna.\n\n    \"\"\"\n    ret = self._codes == -1\n    return ret",
                "def notna(self):\n    \"\"\"\n    Inverse of isna\n\n    Both missing values (-1 in .codes) and NA as a category are detected as\n    null.\n\n    Returns\n    -------\n    a boolean array of whether my values are not null\n\n    See Also\n    --------\n    notna : Top-level notna.\n    notnull : Alias of notna.\n    Categorical.isna : Boolean inverse of Categorical.notna.\n\n    \"\"\"\n    return ~self.isna()",
                "def dropna(self):\n    \"\"\"\n    Return the Categorical without null values.\n\n    Missing values (-1 in .codes) are detected.\n\n    Returns\n    -------\n    valid : Categorical\n    \"\"\"\n    result = self[self.notna()]\n\n    return result",
                "def value_counts(self, dropna=True):\n    \"\"\"\n    Return a Series containing counts of each category.\n\n    Every category will have an entry, even those with a count of 0.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaN.\n\n    Returns\n    -------\n    counts : Series\n\n    See Also\n    --------\n    Series.value_counts\n    \"\"\"\n    from pandas import Series, CategoricalIndex\n\n    code, cat = self._codes, self.categories\n    ncat, mask = len(cat), 0 <= code\n    ix, clean = np.arange(ncat), mask.all()\n\n    if dropna or clean:\n        obs = code if clean else code[mask]\n        count = np.bincount(obs, minlength=ncat or 0)\n    else:\n        count = np.bincount(np.where(mask, code, ncat))\n        ix = np.append(ix, -1)\n\n    ix = self._constructor(ix, dtype=self.dtype, fastpath=True)\n\n    return Series(count, index=CategoricalIndex(ix), dtype=\"int64\")",
                "def _internal_get_values(self):\n    \"\"\"\n    Return the values.\n\n    For internal compatibility with pandas formatting.\n\n    Returns\n    -------\n    np.ndarray or Index\n        A numpy array of the same dtype as categorical.categories.dtype or\n        Index if datetime / periods.\n    \"\"\"\n    # if we are a datetime and period index, return Index to keep metadata\n    if needs_i8_conversion(self.categories):\n        return self.categories.take(self._codes, fill_value=np.nan)\n    elif is_integer_dtype(self.categories) and -1 in self._codes:\n        return self.categories.astype(\"object\").take(self._codes, fill_value=np.nan)\n    return np.array(self)",
                "def check_for_ordered(self, op):\n    \"\"\" assert that we are ordered \"\"\"\n    if not self.ordered:\n        raise TypeError(\n            f\"Categorical is not ordered for operation {op}\\n\"\n            \"you can use .as_ordered() to change the \"\n            \"Categorical to an ordered one\\n\"\n        )",
                "def _values_for_argsort(self):\n    return self._codes",
                "def argsort(self, ascending=True, kind=\"quicksort\", **kwargs):\n    \"\"\"\n    Return the indices that would sort the Categorical.\n\n    .. versionchanged:: 0.25.0\n\n       Changed to sort missing values at the end.\n\n    Parameters\n    ----------\n    ascending : bool, default True\n        Whether the indices should result in an ascending\n        or descending sort.\n    kind : {'quicksort', 'mergesort', 'heapsort'}, optional\n        Sorting algorithm.\n    **kwargs:\n        passed through to :func:`numpy.argsort`.\n\n    Returns\n    -------\n    numpy.array\n\n    See Also\n    --------\n    numpy.ndarray.argsort\n\n    Notes\n    -----\n    While an ordering is applied to the category values, arg-sorting\n    in this context refers more to organizing and grouping together\n    based on matching category values. Thus, this function can be\n    called on an unordered Categorical instance unlike the functions\n    'Categorical.min' and 'Categorical.max'.\n\n    Examples\n    --------\n    >>> pd.Categorical(['b', 'b', 'a', 'c']).argsort()\n    array([2, 0, 1, 3])\n\n    >>> cat = pd.Categorical(['b', 'b', 'a', 'c'],\n    ...                      categories=['c', 'b', 'a'],\n    ...                      ordered=True)\n    >>> cat.argsort()\n    array([3, 0, 1, 2])\n\n    Missing values are placed at the end\n\n    >>> cat = pd.Categorical([2, None, 1])\n    >>> cat.argsort()\n    array([2, 0, 1])\n    \"\"\"\n    return super().argsort(ascending=ascending, kind=kind, **kwargs)",
                "def sort_values(self, inplace=False, ascending=True, na_position=\"last\"):\n    \"\"\"\n    Sort the Categorical by category value returning a new\n    Categorical by default.\n\n    While an ordering is applied to the category values, sorting in this\n    context refers more to organizing and grouping together based on\n    matching category values. Thus, this function can be called on an\n    unordered Categorical instance unlike the functions 'Categorical.min'\n    and 'Categorical.max'.\n\n    Parameters\n    ----------\n    inplace : bool, default False\n        Do operation in place.\n    ascending : bool, default True\n        Order ascending. Passing False orders descending. The\n        ordering parameter provides the method by which the\n        category values are organized.\n    na_position : {'first', 'last'} (optional, default='last')\n        'first' puts NaNs at the beginning\n        'last' puts NaNs at the end\n\n    Returns\n    -------\n    Categorical or None\n\n    See Also\n    --------\n    Categorical.sort\n    Series.sort_values\n\n    Examples\n    --------\n    >>> c = pd.Categorical([1, 2, 2, 1, 5])\n    >>> c\n    [1, 2, 2, 1, 5]\n    Categories (3, int64): [1, 2, 5]\n    >>> c.sort_values()\n    [1, 1, 2, 2, 5]\n    Categories (3, int64): [1, 2, 5]\n    >>> c.sort_values(ascending=False)\n    [5, 2, 2, 1, 1]\n    Categories (3, int64): [1, 2, 5]\n\n    Inplace sorting can be done as well:\n\n    >>> c.sort_values(inplace=True)\n    >>> c\n    [1, 1, 2, 2, 5]\n    Categories (3, int64): [1, 2, 5]\n    >>>\n    >>> c = pd.Categorical([1, 2, 2, 1, 5])\n\n    'sort_values' behaviour with NaNs. Note that 'na_position'\n    is independent of the 'ascending' parameter:\n\n    >>> c = pd.Categorical([np.nan, 2, 2, np.nan, 5])\n    >>> c\n    [NaN, 2, 2, NaN, 5]\n    Categories (2, int64): [2, 5]\n    >>> c.sort_values()\n    [2, 2, 5, NaN, NaN]\n    Categories (2, int64): [2, 5]\n    >>> c.sort_values(ascending=False)\n    [5, 2, 2, NaN, NaN]\n    Categories (2, int64): [2, 5]\n    >>> c.sort_values(na_position='first')\n    [NaN, NaN, 2, 2, 5]\n    Categories (2, int64): [2, 5]\n    >>> c.sort_values(ascending=False, na_position='first')\n    [NaN, NaN, 5, 2, 2]\n    Categories (2, int64): [2, 5]\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    if na_position not in [\"last\", \"first\"]:\n        raise ValueError(f\"invalid na_position: {repr(na_position)}\")\n\n    sorted_idx = nargsort(self, ascending=ascending, na_position=na_position)\n\n    if inplace:\n        self._codes = self._codes[sorted_idx]\n    else:\n        return self._constructor(\n            values=self._codes[sorted_idx], dtype=self.dtype, fastpath=True\n        )",
                "def _values_for_rank(self):\n    \"\"\"\n    For correctly ranking ordered categorical data. See GH#15420\n\n    Ordered categorical data should be ranked on the basis of\n    codes with -1 translated to NaN.\n\n    Returns\n    -------\n    numpy.array\n\n    \"\"\"\n    from pandas import Series\n\n    if self.ordered:\n        values = self.codes\n        mask = values == -1\n        if mask.any():\n            values = values.astype(\"float64\")\n            values[mask] = np.nan\n    elif self.categories.is_numeric():\n        values = np.array(self)\n    else:\n        #  reorder the categories (so rank can use the float codes)\n        #  instead of passing an object array to rank\n        values = np.array(\n            self.rename_categories(Series(self.categories).rank().values)\n        )\n    return values",
                "def view(self, dtype=None):\n    if dtype is not None:\n        raise NotImplementedError(dtype)\n    return self._constructor(values=self._codes, dtype=self.dtype, fastpath=True)",
                "def to_dense(self):\n    \"\"\"\n    Return my 'dense' representation\n\n    For internal compatibility with numpy arrays.\n\n    Returns\n    -------\n    dense : array\n    \"\"\"\n    warn(\n        \"Categorical.to_dense is deprecated and will be removed in \"\n        \"a future version.  Use np.asarray(cat) instead.\",\n        FutureWarning,\n        stacklevel=2,\n    )\n    return np.asarray(self)",
                "def fillna(self, value=None, method=None, limit=None):\n    \"\"\"\n    Fill NA/NaN values using the specified method.\n\n    Parameters\n    ----------\n    value : scalar, dict, Series\n        If a scalar value is passed it is used to fill all missing values.\n        Alternatively, a Series or dict can be used to fill in different\n        values for each index. The value should not be a list. The\n        value(s) passed should either be in the categories or should be\n        NaN.\n    method : {'backfill', 'bfill', 'pad', 'ffill', None}, default None\n        Method to use for filling holes in reindexed Series\n        pad / ffill: propagate last valid observation forward to next valid\n        backfill / bfill: use NEXT valid observation to fill gap\n    limit : int, default None\n        (Not implemented yet for Categorical!)\n        If method is specified, this is the maximum number of consecutive\n        NaN values to forward/backward fill. In other words, if there is\n        a gap with more than this number of consecutive NaNs, it will only\n        be partially filled. If method is not specified, this is the\n        maximum number of entries along the entire axis where NaNs will be\n        filled.\n\n    Returns\n    -------\n    filled : Categorical with NA/NaN filled\n    \"\"\"\n    value, method = validate_fillna_kwargs(\n        value, method, validate_scalar_dict_value=False\n    )\n\n    if value is None:\n        value = np.nan\n    if limit is not None:\n        raise NotImplementedError(\n            \"specifying a limit for fillna has not been implemented yet\"\n        )\n\n    codes = self._codes\n\n    # pad / bfill\n    if method is not None:\n\n        # TODO: dispatch when self.categories is EA-dtype\n        values = np.asarray(self).reshape(-1, len(self))\n        values = interpolate_2d(values, method, 0, None, value).astype(\n            self.categories.dtype\n        )[0]\n        codes = _get_codes_for_values(values, self.categories)\n\n    else:\n\n        # If value is a dict or a Series (a dict value has already\n        # been converted to a Series)\n        if isinstance(value, (np.ndarray, Categorical, ABCSeries)):\n            # We get ndarray or Categorical if called via Series.fillna,\n            #  where it will unwrap another aligned Series before getting here\n\n            mask = ~algorithms.isin(value, self.categories)\n            if not isna(value[mask]).all():\n                raise ValueError(\"fill value must be in categories\")\n\n            values_codes = _get_codes_for_values(value, self.categories)\n            indexer = np.where(codes == -1)\n            codes = codes.copy()\n            codes[indexer] = values_codes[indexer]\n\n        # If value is not a dict or Series it should be a scalar\n        elif is_hashable(value):\n            if not isna(value) and value not in self.categories:\n                raise ValueError(\"fill value must be in categories\")\n\n            mask = codes == -1\n            if mask.any():\n                codes = codes.copy()\n                if isna(value):\n                    codes[mask] = -1\n                else:\n                    codes[mask] = self.categories.get_loc(value)\n\n        else:\n            raise TypeError(\n                f\"'value' parameter must be a scalar, dict \"\n                f\"or Series, but you passed a {type(value).__name__}\"\n            )\n\n    return self._constructor(codes, dtype=self.dtype, fastpath=True)",
                "def take(self, indexer, allow_fill: bool = False, fill_value=None):\n    \"\"\"\n    Take elements from the Categorical.\n\n    Parameters\n    ----------\n    indexer : sequence of int\n        The indices in `self` to take. The meaning of negative values in\n        `indexer` depends on the value of `allow_fill`.\n    allow_fill : bool, default False\n        How to handle negative values in `indexer`.\n\n        * False: negative values in `indices` indicate positional indices\n          from the right. This is similar to\n          :func:`numpy.take`.\n\n        * True: negative values in `indices` indicate missing values\n          (the default). These values are set to `fill_value`. Any other\n          other negative values raise a ``ValueError``.\n\n        .. versionchanged:: 1.0.0\n\n           Default value changed from ``True`` to ``False``.\n\n    fill_value : object\n        The value to use for `indices` that are missing (-1), when\n        ``allow_fill=True``. This should be the category, i.e. a value\n        in ``self.categories``, not a code.\n\n    Returns\n    -------\n    Categorical\n        This Categorical will have the same categories and ordered as\n        `self`.\n\n    See Also\n    --------\n    Series.take : Similar method for Series.\n    numpy.ndarray.take : Similar method for NumPy arrays.\n\n    Examples\n    --------\n    >>> cat = pd.Categorical(['a', 'a', 'b'])\n    >>> cat\n    [a, a, b]\n    Categories (2, object): [a, b]\n\n    Specify ``allow_fill==False`` to have negative indices mean indexing\n    from the right.\n\n    >>> cat.take([0, -1, -2], allow_fill=False)\n    [a, b, a]\n    Categories (2, object): [a, b]\n\n    With ``allow_fill=True``, indices equal to ``-1`` mean \"missing\"\n    values that should be filled with the `fill_value`, which is\n    ``np.nan`` by default.\n\n    >>> cat.take([0, -1, -1], allow_fill=True)\n    [a, NaN, NaN]\n    Categories (2, object): [a, b]\n\n    The fill value can be specified.\n\n    >>> cat.take([0, -1, -1], allow_fill=True, fill_value='a')\n    [a, a, a]\n    Categories (2, object): [a, b]\n\n    Specifying a fill value that's not in ``self.categories``\n    will raise a ``TypeError``.\n    \"\"\"\n    indexer = np.asarray(indexer, dtype=np.intp)\n\n    dtype = self.dtype\n\n    if isna(fill_value):\n        fill_value = -1\n    elif allow_fill:\n        # convert user-provided `fill_value` to codes\n        if fill_value in self.categories:\n            fill_value = self.categories.get_loc(fill_value)\n        else:\n            msg = (\n                f\"'fill_value' ('{fill_value}') is not in this \"\n                \"Categorical's categories.\"\n            )\n            raise TypeError(msg)\n\n    codes = take(self._codes, indexer, allow_fill=allow_fill, fill_value=fill_value)\n    result = type(self).from_codes(codes, dtype=dtype)\n    return result",
                "def take_nd(self, indexer, allow_fill: bool = False, fill_value=None):\n    # GH#27745 deprecate alias that other EAs dont have\n    warn(\n        \"Categorical.take_nd is deprecated, use Categorical.take instead\",\n        FutureWarning,\n        stacklevel=2,\n    )\n    return self.take(indexer, allow_fill=allow_fill, fill_value=fill_value)",
                "def __len__(self) -> int:\n    \"\"\"\n    The length of this Categorical.\n    \"\"\"\n    return len(self._codes)",
                "def __iter__(self):\n    \"\"\"\n    Returns an Iterator over the values of this Categorical.\n    \"\"\"\n    return iter(self._internal_get_values().tolist())",
                "def __contains__(self, key) -> bool:\n    \"\"\"\n    Returns True if `key` is in this Categorical.\n    \"\"\"\n    # if key is a NaN, check if any NaN is in self.\n    if is_scalar(key) and isna(key):\n        return self.isna().any()\n\n    return contains(self, key, container=self._codes)",
                "def _tidy_repr(self, max_vals=10, footer=True) -> str:\n    \"\"\"\n    a short repr displaying only max_vals and an optional (but default\n    footer)\n    \"\"\"\n    num = max_vals // 2\n    head = self[:num]._get_repr(length=False, footer=False)\n    tail = self[-(max_vals - num) :]._get_repr(length=False, footer=False)\n\n    result = f\"{head[:-1]}, ..., {tail[1:]}\"\n    if footer:\n        result = f\"{result}\\n{self._repr_footer()}\"\n\n    return str(result)",
                "def _repr_categories(self):\n    \"\"\"\n    return the base repr for the categories\n    \"\"\"\n    max_categories = (\n        10\n        if get_option(\"display.max_categories\") == 0\n        else get_option(\"display.max_categories\")\n    )\n    from pandas.io.formats import format as fmt\n\n    if len(self.categories) > max_categories:\n        num = max_categories // 2\n        head = fmt.format_array(self.categories[:num], None)\n        tail = fmt.format_array(self.categories[-num:], None)\n        category_strs = head + [\"...\"] + tail\n    else:\n        category_strs = fmt.format_array(self.categories, None)\n\n    # Strip all leading spaces, which format_array adds for columns...\n    category_strs = [x.strip() for x in category_strs]\n    return category_strs",
                "def _repr_categories_info(self) -> str:\n    \"\"\"\n    Returns a string representation of the footer.\n    \"\"\"\n    category_strs = self._repr_categories()\n    dtype = str(self.categories.dtype)\n    levheader = f\"Categories ({len(self.categories)}, {dtype}): \"\n    width, height = get_terminal_size()\n    max_width = get_option(\"display.width\") or width\n    if console.in_ipython_frontend():\n        # 0 = no breaks\n        max_width = 0\n    levstring = \"\"\n    start = True\n    cur_col_len = len(levheader)  # header\n    sep_len, sep = (3, \" < \") if self.ordered else (2, \", \")\n    linesep = sep.rstrip() + \"\\n\"  # remove whitespace\n    for val in category_strs:\n        if max_width != 0 and cur_col_len + sep_len + len(val) > max_width:\n            levstring += linesep + (\" \" * (len(levheader) + 1))\n            cur_col_len = len(levheader) + 1  # header + a whitespace\n        elif not start:\n            levstring += sep\n            cur_col_len += len(val)\n        levstring += val\n        start = False\n    # replace to simple save space by\n    return levheader + \"[\" + levstring.replace(\" < ... < \", \" ... \") + \"]\"",
                "def _repr_footer(self) -> str:\n    info = self._repr_categories_info()\n    return f\"Length: {len(self)}\\n{info}\"",
                "def _get_repr(self, length=True, na_rep=\"NaN\", footer=True) -> str:\n    from pandas.io.formats import format as fmt\n\n    formatter = fmt.CategoricalFormatter(\n        self, length=length, na_rep=na_rep, footer=footer\n    )\n    result = formatter.to_string()\n    return str(result)",
                "def __repr__(self) -> str:\n    \"\"\"\n    String representation.\n    \"\"\"\n    _maxlen = 10\n    if len(self._codes) > _maxlen:\n        result = self._tidy_repr(_maxlen)\n    elif len(self._codes) > 0:\n        result = self._get_repr(length=len(self) > _maxlen)\n    else:\n        msg = self._get_repr(length=False, footer=True).replace(\"\\n\", \", \")\n        result = f\"[], {msg}\"\n\n    return result",
                "def _maybe_coerce_indexer(self, indexer):\n    \"\"\"\n    return an indexer coerced to the codes dtype\n    \"\"\"\n    if isinstance(indexer, np.ndarray) and indexer.dtype.kind == \"i\":\n        indexer = indexer.astype(self._codes.dtype)\n    return indexer",
                "def __getitem__(self, key):\n    \"\"\"\n    Return an item.\n    \"\"\"\n    if isinstance(key, (int, np.integer)):\n        i = self._codes[key]\n        if i == -1:\n            return np.nan\n        else:\n            return self.categories[i]\n\n    key = check_array_indexer(self, key)\n\n    result = self._codes[key]\n    if result.ndim > 1:\n        deprecate_ndim_indexing(result)\n        return result\n    return self._constructor(result, dtype=self.dtype, fastpath=True)",
                "def __setitem__(self, key, value):\n    \"\"\"\n    Item assignment.\n\n    Raises\n    ------\n    ValueError\n        If (one or more) Value is not in categories or if a assigned\n        `Categorical` does not have the same categories\n    \"\"\"\n    value = extract_array(value, extract_numpy=True)\n\n    # require identical categories set\n    if isinstance(value, Categorical):\n        if not is_dtype_equal(self, value):\n            raise ValueError(\n                \"Cannot set a Categorical with another, \"\n                \"without identical categories\"\n            )\n        if not self.categories.equals(value.categories):\n            new_codes = recode_for_categories(\n                value.codes, value.categories, self.categories\n            )\n            value = Categorical.from_codes(new_codes, dtype=self.dtype)\n\n    rvalue = value if is_list_like(value) else [value]\n\n    from pandas import Index\n\n    to_add = Index(rvalue).difference(self.categories)\n\n    # no assignments of values not in categories, but it's always ok to set\n    # something to np.nan\n    if len(to_add) and not isna(to_add).all():\n        raise ValueError(\n            \"Cannot setitem on a Categorical with a new \"\n            \"category, set the categories first\"\n        )\n\n    # set by position\n    if isinstance(key, (int, np.integer)):\n        pass\n\n    # tuple of indexers (dataframe)\n    elif isinstance(key, tuple):\n        # only allow 1 dimensional slicing, but can\n        # in a 2-d case be passd (slice(None),....)\n        if len(key) == 2:\n            if not com.is_null_slice(key[0]):\n                raise AssertionError(\"invalid slicing for a 1-ndim categorical\")\n            key = key[1]\n        elif len(key) == 1:\n            key = key[0]\n        else:\n            raise AssertionError(\"invalid slicing for a 1-ndim categorical\")\n\n    # slicing in Series or Categorical\n    elif isinstance(key, slice):\n        pass\n\n    # else: array of True/False in Series or Categorical\n\n    lindexer = self.categories.get_indexer(rvalue)\n    lindexer = self._maybe_coerce_indexer(lindexer)\n\n    key = check_array_indexer(self, key)\n    self._codes[key] = lindexer",
                "def _reverse_indexer(self) -> Dict[Hashable, np.ndarray]:\n    \"\"\"\n    Compute the inverse of a categorical, returning\n    a dict of categories -> indexers.\n\n    *This is an internal function*\n\n    Returns\n    -------\n    dict of categories -> indexers\n\n    Examples\n    --------\n    >>> c = pd.Categorical(list('aabca'))\n    >>> c\n    [a, a, b, c, a]\n    Categories (3, object): [a, b, c]\n    >>> c.categories\n    Index(['a', 'b', 'c'], dtype='object')\n    >>> c.codes\n    array([0, 0, 1, 2, 0], dtype=int8)\n    >>> c._reverse_indexer()\n    {'a': array([0, 1, 4]), 'b': array([2]), 'c': array([3])}\n\n    \"\"\"\n    categories = self.categories\n    r, counts = libalgos.groupsort_indexer(\n        self.codes.astype(\"int64\"), categories.size\n    )\n    counts = counts.cumsum()\n    _result = (r[start:end] for start, end in zip(counts, counts[1:]))\n    result = dict(zip(categories, _result))\n    return result",
                "def _reduce(self, name, axis=0, **kwargs):\n    func = getattr(self, name, None)\n    if func is None:\n        raise TypeError(f\"Categorical cannot perform the operation {name}\")\n    return func(**kwargs)",
                "@deprecate_kwarg(old_arg_name=\"numeric_only\", new_arg_name=\"skipna\")\ndef min(self, skipna=True):\n    \"\"\"\n    The minimum value of the object.\n\n    Only ordered `Categoricals` have a minimum!\n\n    .. versionchanged:: 1.0.0\n\n       Returns an NA value on empty arrays\n\n    Raises\n    ------\n    TypeError\n        If the `Categorical` is not `ordered`.\n\n    Returns\n    -------\n    min : the minimum of this `Categorical`\n    \"\"\"\n    self.check_for_ordered(\"min\")\n\n    if not len(self._codes):\n        return self.dtype.na_value\n\n    good = self._codes != -1\n    if not good.all():\n        if skipna:\n            pointer = self._codes[good].min()\n        else:\n            return np.nan\n    else:\n        pointer = self._codes.min()\n    return self.categories[pointer]",
                "@deprecate_kwarg(old_arg_name=\"numeric_only\", new_arg_name=\"skipna\")\ndef max(self, skipna=True):\n    \"\"\"\n    The maximum value of the object.\n\n    Only ordered `Categoricals` have a maximum!\n\n    .. versionchanged:: 1.0.0\n\n       Returns an NA value on empty arrays\n\n    Raises\n    ------\n    TypeError\n        If the `Categorical` is not `ordered`.\n\n    Returns\n    -------\n    max : the maximum of this `Categorical`\n    \"\"\"\n    self.check_for_ordered(\"max\")\n\n    if not len(self._codes):\n        return self.dtype.na_value\n\n    good = self._codes != -1\n    if not good.all():\n        if skipna:\n            pointer = self._codes[good].max()\n        else:\n            return np.nan\n    else:\n        pointer = self._codes.max()\n    return self.categories[pointer]",
                "def mode(self, dropna=True):\n    \"\"\"\n    Returns the mode(s) of the Categorical.\n\n    Always returns `Categorical` even if only one value.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't consider counts of NaN/NaT.\n\n        .. versionadded:: 0.24.0\n\n    Returns\n    -------\n    modes : `Categorical` (sorted)\n    \"\"\"\n    codes = self._codes\n    if dropna:\n        good = self._codes != -1\n        codes = self._codes[good]\n    codes = sorted(htable.mode_int64(ensure_int64(codes), dropna))\n    return self._constructor(values=codes, dtype=self.dtype, fastpath=True)",
                "def unique(self):\n    \"\"\"\n    Return the ``Categorical`` which ``categories`` and ``codes`` are\n    unique. Unused categories are NOT returned.\n\n    - unordered category: values and categories are sorted by appearance\n      order.\n    - ordered category: values are sorted by appearance order, categories\n      keeps existing order.\n\n    Returns\n    -------\n    unique values : ``Categorical``\n\n    See Also\n    --------\n    pandas.unique\n    CategoricalIndex.unique\n    Series.unique\n\n    Examples\n    --------\n    An unordered Categorical will return categories in the\n    order of appearance.\n\n    >>> pd.Categorical(list(\"baabc\")).unique()\n    [b, a, c]\n    Categories (3, object): [b, a, c]\n\n    >>> pd.Categorical(list(\"baabc\"), categories=list(\"abc\")).unique()\n    [b, a, c]\n    Categories (3, object): [b, a, c]\n\n    An ordered Categorical preserves the category ordering.\n\n    >>> pd.Categorical(\n    ...     list(\"baabc\"), categories=list(\"abc\"), ordered=True\n    ... ).unique()\n    [b, a, c]\n    Categories (3, object): [a < b < c]\n    \"\"\"\n    # unlike np.unique, unique1d does not sort\n    unique_codes = unique1d(self.codes)\n    cat = self.copy()\n\n    # keep nan in codes\n    cat._codes = unique_codes\n\n    # exclude nan from indexer for categories\n    take_codes = unique_codes[unique_codes != -1]\n    if self.ordered:\n        take_codes = np.sort(take_codes)\n    return cat.set_categories(cat.categories.take(take_codes))",
                "def _values_for_factorize(self):\n    codes = self.codes.astype(\"int64\")\n    return codes, -1",
                "@classmethod\ndef _from_factorized(cls, uniques, original):\n    return original._constructor(\n        original.categories.take(uniques), dtype=original.dtype\n    )",
                "def equals(self, other):\n    \"\"\"\n    Returns True if categorical arrays are equal.\n\n    Parameters\n    ----------\n    other : `Categorical`\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    if self.is_dtype_equal(other):\n        if self.categories.equals(other.categories):\n            # fastpath to avoid re-coding\n            other_codes = other._codes\n        else:\n            other_codes = recode_for_categories(\n                other.codes, other.categories, self.categories\n            )\n        return np.array_equal(self._codes, other_codes)\n    return False",
                "def is_dtype_equal(self, other):\n    \"\"\"\n    Returns True if categoricals are the same dtype\n      same categories, and same ordered\n\n    Parameters\n    ----------\n    other : Categorical\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    try:\n        return hash(self.dtype) == hash(other.dtype)\n    except (AttributeError, TypeError):\n        return False",
                "def describe(self):\n    \"\"\"\n    Describes this Categorical\n\n    Returns\n    -------\n    description: `DataFrame`\n        A dataframe with frequency and counts by category.\n    \"\"\"\n    counts = self.value_counts(dropna=False)\n    freqs = counts / float(counts.sum())\n\n    from pandas.core.reshape.concat import concat\n\n    result = concat([counts, freqs], axis=1)\n    result.columns = [\"counts\", \"freqs\"]\n    result.index.name = \"categories\"\n\n    return result",
                "@Substitution(klass=\"Categorical\")\n@Appender(_extension_array_shared_docs[\"repeat\"])\ndef repeat(self, repeats, axis=None):\n    nv.validate_repeat(tuple(), dict(axis=axis))\n    codes = self._codes.repeat(repeats)\n    return self._constructor(values=codes, dtype=self.dtype, fastpath=True)",
                "@property\ndef _can_hold_na(self):\n    return True",
                "@classmethod\ndef _concat_same_type(self, to_concat):\n    from pandas.core.dtypes.concat import concat_categorical\n\n    return concat_categorical(to_concat)",
                "def isin(self, values):\n    \"\"\"\n    Check whether `values` are contained in Categorical.\n\n    Return a boolean NumPy Array showing whether each element in\n    the Categorical matches an element in the passed sequence of\n    `values` exactly.\n\n    Parameters\n    ----------\n    values : set or list-like\n        The sequence of values to test. Passing in a single string will\n        raise a ``TypeError``. Instead, turn a single string into a\n        list of one element.\n\n    Returns\n    -------\n    isin : numpy.ndarray (bool dtype)\n\n    Raises\n    ------\n    TypeError\n      * If `values` is not a set or list-like\n\n    See Also\n    --------\n    pandas.Series.isin : Equivalent method on Series.\n\n    Examples\n    --------\n    >>> s = pd.Categorical(['lama', 'cow', 'lama', 'beetle', 'lama',\n    ...                'hippo'])\n    >>> s.isin(['cow', 'lama'])\n    array([ True,  True,  True, False,  True, False])\n\n    Passing a single string as ``s.isin('lama')`` will raise an error. Use\n    a list of one element instead:\n\n    >>> s.isin(['lama'])\n    array([ True, False,  True, False,  True, False])\n    \"\"\"\n    if not is_list_like(values):\n        values_type = type(values).__name__\n        raise TypeError(\n            \"only list-like objects are allowed to be passed \"\n            f\"to isin(), you passed a [{values_type}]\"\n        )\n    values = sanitize_array(values, None, None)\n    null_mask = np.asarray(isna(values))\n    code_values = self.categories.get_indexer(values)\n    code_values = code_values[null_mask | (code_values >= 0)]\n    return algorithms.isin(self.codes, code_values)",
                "def replace(self, to_replace, value, inplace: bool = False):\n    \"\"\"\n    Replaces all instances of one value with another\n\n    Parameters\n    ----------\n    to_replace: object\n        The value to be replaced\n\n    value: object\n        The value to replace it with\n\n    inplace: bool\n        Whether the operation is done in-place\n\n    Returns\n    -------\n    None if inplace is True, otherwise the new Categorical after replacement\n\n\n    Examples\n    --------\n    >>> s = pd.Categorical([1, 2, 1, 3])\n    >>> s.replace(1, 3)\n    [3, 2, 3, 3]\n    Categories (2, int64): [2, 3]\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    cat = self if inplace else self.copy()\n\n    # build a dict of (to replace -> value) pairs\n    if is_list_like(to_replace):\n        # if to_replace is list-like and value is scalar\n        replace_dict = {replace_value: value for replace_value in to_replace}\n    else:\n        # if both to_replace and value are scalar\n        replace_dict = {to_replace: value}\n\n    # other cases, like if both to_replace and value are list-like or if\n    # to_replace is a dict, are handled separately in NDFrame\n    for replace_value, new_value in replace_dict.items():\n        if new_value == replace_value:\n            continue\n        if replace_value in cat.categories:\n            if isna(new_value):\n                cat.remove_categories(replace_value, inplace=True)\n                continue\n            categories = cat.categories.tolist()\n            index = categories.index(replace_value)\n            if new_value in cat.categories:\n                value_index = categories.index(new_value)\n                cat._codes[cat._codes == index] = value_index\n                cat.remove_categories(replace_value, inplace=True)\n            else:\n                categories[index] = new_value\n                cat.rename_categories(categories, inplace=True)\n    if not inplace:\n        return cat",
                "def __init__(self, data):\n    self._validate(data)\n    self._parent = data.values\n    self._index = data.index\n    self._name = data.name\n    self._freeze()",
                "@staticmethod\ndef _validate(data):\n    if not is_categorical_dtype(data.dtype):\n        raise AttributeError(\"Can only use .cat accessor with a 'category' dtype\")",
                "def _delegate_property_get(self, name):\n    return getattr(self._parent, name)",
                "def _delegate_property_set(self, name, new_values):\n    return setattr(self._parent, name, new_values)",
                "@property\ndef codes(self):\n    \"\"\"\n    Return Series of codes as well as the index.\n    \"\"\"\n    from pandas import Series\n\n    return Series(self._parent.codes, index=self._index)",
                "def _delegate_method(self, name, *args, **kwargs):\n    from pandas import Series\n\n    method = getattr(self._parent, name)\n    res = method(*args, **kwargs)\n    if res is not None:\n        return Series(res, index=self._index, name=self._name)"
            ],
            "inscope_function_signatures": [
                "_cat_compare_op(op)",
                "contains(cat, key, container)",
                "_get_codes_for_values(values, categories)",
                "recode_for_categories(codes: np.ndarray, old_categories, new_categories)",
                "_convert_to_list_like(list_like)",
                "factorize_from_iterable(values)",
                "factorize_from_iterables(iterables)",
                "func(self, other)",
                "__init__(self, values, categories=None, ordered=None, dtype=None, fastpath=False)",
                "categories(self)",
                "categories(self, categories)",
                "ordered(self) -> Ordered",
                "dtype(self) -> CategoricalDtype",
                "_constructor(self) -> Type['Categorical']",
                "_from_sequence(cls, scalars, dtype=None, copy=False)",
                "_formatter(self, boxed=False)",
                "copy(self) -> 'Categorical'",
                "astype(self, dtype: Dtype, copy: bool=True) -> ArrayLike",
                "size(self) -> int",
                "itemsize(self) -> int",
                "tolist(self) -> List[Scalar]",
                "_from_inferred_categories(cls, inferred_categories, inferred_codes, dtype, true_values=None)",
                "from_codes(cls, codes, categories=None, ordered=None, dtype=None)",
                "_get_codes(self)",
                "_set_codes(self, codes)",
                "_set_categories(self, categories, fastpath=False)",
                "_set_dtype(self, dtype: CategoricalDtype) -> 'Categorical'",
                "set_ordered(self, value, inplace=False)",
                "as_ordered(self, inplace=False)",
                "as_unordered(self, inplace=False)",
                "set_categories(self, new_categories, ordered=None, rename=False, inplace=False)",
                "rename_categories(self, new_categories, inplace=False)",
                "reorder_categories(self, new_categories, ordered=None, inplace=False)",
                "add_categories(self, new_categories, inplace=False)",
                "remove_categories(self, removals, inplace=False)",
                "remove_unused_categories(self, inplace=False)",
                "map(self, mapper)",
                "shape(self)",
                "shift(self, periods, fill_value=None)",
                "__array__(self, dtype=None) -> np.ndarray",
                "__array_ufunc__(self, ufunc, method, *inputs, **kwargs)",
                "__setstate__(self, state)",
                "T(self) -> 'Categorical'",
                "nbytes(self)",
                "memory_usage(self, deep=False)",
                "searchsorted(self, value, side='left', sorter=None)",
                "isna(self)",
                "notna(self)",
                "dropna(self)",
                "value_counts(self, dropna=True)",
                "_internal_get_values(self)",
                "check_for_ordered(self, op)",
                "_values_for_argsort(self)",
                "argsort(self, ascending=True, kind='quicksort', **kwargs)",
                "sort_values(self, inplace=False, ascending=True, na_position='last')",
                "_values_for_rank(self)",
                "view(self, dtype=None)",
                "to_dense(self)",
                "fillna(self, value=None, method=None, limit=None)",
                "take(self, indexer, allow_fill: bool=False, fill_value=None)",
                "take_nd(self, indexer, allow_fill: bool=False, fill_value=None)",
                "__len__(self) -> int",
                "__iter__(self)",
                "__contains__(self, key) -> bool",
                "_tidy_repr(self, max_vals=10, footer=True) -> str",
                "_repr_categories(self)",
                "_repr_categories_info(self) -> str",
                "_repr_footer(self) -> str",
                "_get_repr(self, length=True, na_rep='NaN', footer=True) -> str",
                "__repr__(self) -> str",
                "_maybe_coerce_indexer(self, indexer)",
                "__getitem__(self, key)",
                "__setitem__(self, key, value)",
                "_reverse_indexer(self) -> Dict[Hashable, np.ndarray]",
                "_reduce(self, name, axis=0, **kwargs)",
                "min(self, skipna=True)",
                "max(self, skipna=True)",
                "mode(self, dropna=True)",
                "unique(self)",
                "_values_for_factorize(self)",
                "_from_factorized(cls, uniques, original)",
                "equals(self, other)",
                "is_dtype_equal(self, other)",
                "describe(self)",
                "repeat(self, repeats, axis=None)",
                "_can_hold_na(self)",
                "_concat_same_type(self, to_concat)",
                "isin(self, values)",
                "replace(self, to_replace, value, inplace: bool=False)",
                "__init__(self, data)",
                "_validate(data)",
                "_delegate_property_get(self, name)",
                "_delegate_property_set(self, name, new_values)",
                "codes(self)",
                "_delegate_method(self, name, *args, **kwargs)"
            ],
            "variables_in_file": {
                "opname": [
                    130,
                    67,
                    69,
                    102,
                    137,
                    138,
                    107,
                    76,
                    141,
                    146,
                    116,
                    118,
                    124,
                    126
                ],
                "op.__name__": [
                    67
                ],
                "op": [
                    1474,
                    67
                ],
                "is_list_like": [
                    1062,
                    71,
                    2440,
                    2731,
                    2035,
                    1013,
                    2397
                ],
                "other": [
                    138,
                    2314,
                    142,
                    71,
                    80,
                    85,
                    87,
                    89,
                    92,
                    96,
                    98,
                    100,
                    113,
                    114,
                    115,
                    2289,
                    2290,
                    2292,
                    2295
                ],
                "len": [
                    2176,
                    647,
                    2057,
                    650,
                    1932,
                    2061,
                    1940,
                    1944,
                    1945,
                    1946,
                    1437,
                    1949,
                    1957,
                    427,
                    1198,
                    1074,
                    2738,
                    1973,
                    1975,
                    1976,
                    1721,
                    704,
                    1220,
                    71,
                    842,
                    846,
                    1870,
                    2770,
                    85,
                    344,
                    2141,
                    2660,
                    1016,
                    1914,
                    2043,
                    125,
                    2686,
                    127
                ],
                "self": [
                    519,
                    1021,
                    2039,
                    2072,
                    2073,
                    2075,
                    2076,
                    2600,
                    2601,
                    1066,
                    1067,
                    2602,
                    2603,
                    2604,
                    2612,
                    1077,
                    1078,
                    2103,
                    2615,
                    2105,
                    2624,
                    2114,
                    2629,
                    71,
                    2632,
                    75,
                    1613,
                    1104,
                    1616,
                    1618,
                    1619,
                    85,
                    87,
                    1112,
                    89,
                    2139,
                    92,
                    2141,
                    2142,
                    96,
                    2144,
                    98,
                    2147,
                    1636,
                    1637,
                    102,
                    2151,
                    104,
                    2152,
                    1642,
                    1643,
                    108,
                    1648,
                    114,
                    115,
                    116,
                    1655,
                    120,
                    125,
                    2174,
                    127,
                    2176,
                    2177,
                    2179,
                    2182,
                    1673,
                    138,
                    2186,
                    2187,
                    664,
                    2206,
                    2208,
                    2209,
                    2211,
                    1189,
                    1191,
                    1192,
                    1197,
                    1199,
                    1715,
                    1721,
                    698,
                    1723,
                    700,
                    1725,
                    703,
                    704,
                    1220,
                    711,
                    1735,
                    1739,
                    2255,
                    2256,
                    1746,
                    726,
                    727,
                    2263,
                    1241,
                    1755,
                    2268,
                    1248,
                    1249,
                    1763,
                    742,
                    743,
                    1260,
                    2289,
                    2290,
                    2295,
                    1273,
                    1274,
                    2297,
                    764,
                    1286,
                    2314,
                    782,
                    1294,
                    2327,
                    1307,
                    1314,
                    1318,
                    2342,
                    2343,
                    1838,
                    1844,
                    1845,
                    1853,
                    1854,
                    1343,
                    324,
                    325,
                    837,
                    1350,
                    840,
                    1351,
                    1353,
                    1354,
                    1355,
                    1864,
                    1870,
                    1876,
                    1884,
                    1374,
                    1886,
                    2405,
                    1894,
                    1895,
                    2407,
                    1899,
                    1397,
                    1914,
                    1916,
                    1917,
                    1920,
                    1411,
                    2437,
                    390,
                    391,
                    1930,
                    1931,
                    1932,
                    1941,
                    1436,
                    925,
                    1956,
                    1957,
                    422,
                    1447,
                    426,
                    427,
                    1963,
                    434,
                    1973,
                    1974,
                    1975,
                    1464,
                    441,
                    1465,
                    1466,
                    1467,
                    1468,
                    1976,
                    1978,
                    448,
                    1472,
                    1988,
                    1480,
                    1996,
                    973,
                    2000,
                    977,
                    466,
                    467,
                    2002,
                    2004,
                    2008,
                    486,
                    487,
                    488,
                    489,
                    490,
                    2024,
                    492,
                    493,
                    2029,
                    495,
                    2031,
                    2033,
                    502,
                    1015,
                    1020,
                    509,
                    1023
                ],
                "ValueError": [
                    643,
                    648,
                    651,
                    672,
                    1194,
                    430,
                    1075,
                    706,
                    73,
                    1737,
                    1611,
                    974,
                    1747,
                    1251,
                    2025,
                    363,
                    494,
                    1017,
                    2044,
                    638
                ],
                "self.ordered": [
                    96,
                    1472,
                    700,
                    1636,
                    2263,
                    1192,
                    426,
                    75,
                    1941,
                    1078,
                    87,
                    1112,
                    698,
                    92,
                    1021
                ],
                "TypeError": [
                    129,
                    353,
                    1473,
                    1851,
                    2116,
                    358,
                    2315,
                    140,
                    77,
                    1293,
                    2732,
                    86,
                    88,
                    90,
                    187,
                    93,
                    1758,
                    2399
                ],
                "isinstance": [
                    2050,
                    1731,
                    1987,
                    2054,
                    551,
                    2023,
                    1995,
                    2702,
                    80,
                    336,
                    2704,
                    2067,
                    340,
                    1300,
                    375,
                    2650
                ],
                "Categorical": [
                    1731,
                    452,
                    2023,
                    456,
                    2473,
                    2476,
                    80,
                    2033,
                    2739,
                    2745
                ],
                "msg": [
                    1978,
                    1979,
                    1847,
                    84,
                    86,
                    634,
                    88,
                    90,
                    1851,
                    638
                ],
                "self.categories": [
                    1920,
                    1931,
                    1932,
                    2187,
                    2072,
                    2295,
                    1436,
                    1914,
                    1189,
                    1917,
                    1844,
                    1845,
                    2103,
                    1464,
                    1465,
                    1466,
                    1467,
                    1723,
                    1725,
                    1350,
                    1735,
                    1353,
                    1739,
                    2000,
                    1746,
                    85,
                    726,
                    87,
                    89,
                    1755,
                    96,
                    1248,
                    98,
                    1249,
                    2405,
                    742,
                    2152,
                    1642,
                    2029,
                    2031,
                    1648,
                    114,
                    115,
                    2290,
                    2039,
                    1273,
                    1274,
                    1916,
                    509
                ],
                "other.categories": [
                    96,
                    2290,
                    85,
                    87,
                    89,
                    2295
                ],
                "all": [
                    1736,
                    2043,
                    87
                ],
                "set": [
                    1065,
                    1066,
                    973,
                    1015,
                    89
                ],
                "other.ordered": [
                    92
                ],
                "self.categories.equals": [
                    96,
                    2290,
                    2029
                ],
                "other_codes": [
                    98,
                    100,
                    103,
                    104,
                    108,
                    2292,
                    2294,
                    2297
                ],
                "_get_codes_for_values": [
                    98,
                    1739,
                    1725,
                    382
                ],
                "other._codes": [
                    100,
                    2292
                ],
                "f": [
                    102,
                    103
                ],
                "getattr": [
                    2114,
                    2629,
                    102,
                    138,
                    2612,
                    116
                ],
                "self._codes": [
                    2176,
                    2179,
                    2182,
                    391,
                    2186,
                    664,
                    1436,
                    2076,
                    2206,
                    2208,
                    2209,
                    2297,
                    1318,
                    2342,
                    1192,
                    1197,
                    1199,
                    1715,
                    1973,
                    1975,
                    1465,
                    1466,
                    1467,
                    1853,
                    1343,
                    324,
                    1220,
                    1988,
                    1480,
                    1996,
                    1870,
                    1616,
                    467,
                    1619,
                    2004,
                    2141,
                    1374,
                    1886,
                    2144,
                    2147,
                    102,
                    2151,
                    104,
                    108,
                    116,
                    502,
                    1655,
                    120,
                    1273
                ],
                "ret": [
                    1280,
                    1281,
                    1273,
                    103,
                    108,
                    110,
                    111,
                    116,
                    121,
                    122,
                    1275,
                    1276,
                    1374,
                    1375
                ],
                "mask": [
                    1441,
                    1444,
                    1638,
                    1639,
                    104,
                    105,
                    1641,
                    1735,
                    1736,
                    110,
                    1753,
                    1749,
                    1750,
                    120,
                    121,
                    1755,
                    1437,
                    1438
                ],
                "mask.any": [
                    105,
                    1750,
                    1639
                ],
                "is_scalar": [
                    195,
                    1349,
                    113,
                    2706,
                    1883
                ],
                "i": [
                    1996,
                    1997,
                    2000,
                    115,
                    116
                ],
                "self.categories.get_loc": [
                    1249,
                    1350,
                    1353,
                    115,
                    1845,
                    1755
                ],
                "np.zeros": [
                    125
                ],
                "np": [
                    1280,
                    386,
                    2050,
                    644,
                    646,
                    2184,
                    1673,
                    138,
                    1438,
                    2078,
                    1442,
                    1444,
                    1445,
                    1836,
                    1197,
                    1198,
                    1199,
                    1709,
                    2738,
                    1465,
                    1721,
                    1467,
                    1468,
                    1731,
                    1987,
                    330,
                    1354,
                    1740,
                    1995,
                    1998,
                    1105,
                    340,
                    2264,
                    347,
                    1244,
                    1245,
                    2404,
                    2149,
                    1641,
                    2665,
                    1643,
                    1262,
                    495,
                    1647,
                    2297,
                    1275,
                    125,
                    127
                ],
                "bool": [
                    1857,
                    1765,
                    2409,
                    470,
                    1878,
                    125,
                    127
                ],
                "np.ones": [
                    386,
                    127
                ],
                "np.array": [
                    138,
                    1354,
                    330,
                    1643,
                    495,
                    1647,
                    1468
                ],
                "type": [
                    1760,
                    142,
                    1854,
                    727,
                    2398
                ],
                "unpack_zerodim_and_defer": [
                    69
                ],
                "func.__name__": [
                    146
                ],
                "func": [
                    2114,
                    2115,
                    2117,
                    146,
                    148
                ],
                "hash": [
                    2314,
                    180
                ],
                "key": [
                    2050,
                    2054,
                    2075,
                    2057,
                    2058,
                    1995,
                    1996,
                    2060,
                    2061,
                    2062,
                    2002,
                    2067,
                    180,
                    2004,
                    186,
                    1883,
                    2076,
                    1886
                ],
                "loc": [
                    186,
                    195,
                    196,
                    199
                ],
                "cat.categories.get_loc": [
                    186
                ],
                "cat.categories": [
                    928,
                    930,
                    932,
                    2458,
                    849,
                    2452,
                    2456,
                    2265,
                    186,
                    2746
                ],
                "cat": [
                    1024,
                    1025,
                    1027,
                    2437,
                    2452,
                    2454,
                    2456,
                    2458,
                    1436,
                    925,
                    1437,
                    2460,
                    928,
                    2461,
                    930,
                    2464,
                    932,
                    2466,
                    934,
                    2745,
                    186,
                    2746,
                    2747,
                    840,
                    842,
                    843,
                    846,
                    1104,
                    849,
                    1105,
                    851,
                    852,
                    2256,
                    1110,
                    855,
                    2259,
                    2265,
                    1114,
                    1115,
                    1118,
                    743,
                    744,
                    746,
                    1023
                ],
                "KeyError": [
                    187
                ],
                "container": [
                    196,
                    199
                ],
                "any": [
                    642,
                    199,
                    493,
                    1070,
                    1884
                ],
                "loc_": [
                    199
                ],
                "_codes_doc": [
                    674,
                    202
                ],
                "ExtensionArray": [
                    213
                ],
                "PandasObject": [
                    2489,
                    309,
                    213
                ],
                "__array_priority__": [
                    306
                ],
                "_dtype": [
                    307
                ],
                "CategoricalDtype": [
                    1304,
                    551,
                    426,
                    307,
                    698,
                    700,
                    444,
                    316,
                    578,
                    580,
                    838,
                    713,
                    335,
                    1111,
                    483,
                    742,
                    371,
                    630,
                    1021
                ],
                "_deprecations": [
                    309
                ],
                "PandasObject._deprecations": [
                    309
                ],
                "frozenset": [
                    309
                ],
                "_typ": [
                    310
                ],
                "dtype": [
                    390,
                    391,
                    650,
                    1274,
                    1931,
                    653,
                    1932,
                    551,
                    556,
                    558,
                    1838,
                    560,
                    562,
                    570,
                    316,
                    317,
                    1854,
                    578,
                    324,
                    325,
                    580,
                    583,
                    456,
                    334,
                    335,
                    726,
                    727,
                    350,
                    482,
                    355,
                    483,
                    486,
                    488,
                    490,
                    491,
                    492,
                    493,
                    495,
                    371,
                    1653,
                    630,
                    631,
                    1654,
                    633,
                    378,
                    1275,
                    382
                ],
                "CategoricalDtype._from_values_or_dtype": [
                    316,
                    630
                ],
                "values": [
                    2731,
                    2655,
                    2734,
                    2735,
                    2738,
                    2739,
                    2740,
                    1721,
                    1722,
                    2745,
                    317,
                    1725,
                    324,
                    333,
                    335,
                    336,
                    2642,
                    339,
                    340,
                    341,
                    2644,
                    344,
                    345,
                    2649,
                    347,
                    348,
                    2397,
                    2398,
                    2650,
                    352,
                    2652,
                    354,
                    2403,
                    2404,
                    1637,
                    1638,
                    2405,
                    1640,
                    1641,
                    2658,
                    1643,
                    1647,
                    1648,
                    1650,
                    373,
                    375,
                    378,
                    382
                ],
                "categories": [
                    2456,
                    2457,
                    2459,
                    2463,
                    2464,
                    424,
                    426,
                    2739,
                    2103,
                    2105,
                    698,
                    570,
                    571,
                    2109,
                    700,
                    317,
                    575,
                    577,
                    578,
                    2746,
                    2748,
                    2642,
                    2644,
                    2648,
                    2653,
                    352,
                    2656,
                    354,
                    2659,
                    371,
                    631
                ],
                "ordered": [
                    836,
                    837,
                    838,
                    977,
                    631,
                    317
                ],
                "fastpath": [
                    697,
                    323,
                    702
                ],
                "coerce_indexer_dtype": [
                    1025,
                    324,
                    2692,
                    2662,
                    391,
                    1115
                ],
                "dtype.categories": [
                    382,
                    324,
                    391,
                    551,
                    650,
                    556,
                    334,
                    558,
                    560,
                    562,
                    570,
                    726,
                    633,
                    378,
                    350
                ],
                "self._dtype": [
                    448,
                    325,
                    390,
                    711,
                    434
                ],
                "self._dtype.update_dtype": [
                    325,
                    390
                ],
                "null_mask": [
                    384,
                    386,
                    387,
                    2404,
                    2406,
                    330,
                    345,
                    346,
                    347
                ],
                "is_categorical_dtype": [
                    482,
                    333,
                    2734,
                    2608,
                    373
                ],
                "values.categories": [
                    2738,
                    335
                ],
                "dtype.ordered": [
                    371,
                    355,
                    335
                ],
                "ABCIndexClass": [
                    336
                ],
                "ABCSeries": [
                    336,
                    1731,
                    375
                ],
                "maybe_infer_to_datetimelike": [
                    339
                ],
                "np.ndarray": [
                    1987,
                    1731,
                    2665,
                    1262,
                    340,
                    2078
                ],
                "_convert_to_list_like": [
                    341
                ],
                "sanitize_dtype": [
                    344,
                    348
                ],
                "isna": [
                    1377,
                    642,
                    2404,
                    2043,
                    1736,
                    1070,
                    1840,
                    1746,
                    2453,
                    1752,
                    345,
                    1883,
                    1246
                ],
                "null_mask.any": [
                    384,
                    346
                ],
                "idx": [
                    1105,
                    1107,
                    1108,
                    1110,
                    347
                ],
                "np.where": [
                    1740,
                    347,
                    1444
                ],
                "sanitize_array": [
                    2403,
                    348
                ],
                "codes": [
                    640,
                    2688,
                    386,
                    387,
                    388,
                    642,
                    644,
                    391,
                    646,
                    647,
                    650,
                    2691,
                    2695,
                    653,
                    2206,
                    2209,
                    674,
                    2210,
                    2211,
                    2342,
                    2343,
                    1715,
                    2740,
                    571,
                    2747,
                    1725,
                    1853,
                    1854,
                    2748,
                    577,
                    581,
                    1350,
                    583,
                    1351,
                    1354,
                    1355,
                    1740,
                    1741,
                    1742,
                    848,
                    851,
                    1749,
                    726,
                    727,
                    1751,
                    1241,
                    1242,
                    1753,
                    1244,
                    1245,
                    1755,
                    2268,
                    352,
                    2269,
                    354,
                    1763,
                    1256,
                    1258,
                    1260,
                    377,
                    382
                ],
                "factorize": [
                    352,
                    354
                ],
                "err": [
                    368,
                    362
                ],
                "NotImplementedError": [
                    1654,
                    1243,
                    366,
                    1711
                ],
                "old_codes": [
                    378,
                    374
                ],
                "values._values.codes": [
                    375
                ],
                "values._values": [
                    375
                ],
                "values.codes": [
                    2738,
                    2740,
                    375
                ],
                "recode_for_categories": [
                    577,
                    2030,
                    848,
                    726,
                    2294,
                    377,
                    571
                ],
                "values.dtype.categories": [
                    378
                ],
                "values.dtype": [
                    378,
                    2739,
                    2642
                ],
                "full_codes": [
                    386,
                    387,
                    388
                ],
                "null_mask.shape": [
                    386
                ],
                "codes.dtype": [
                    386
                ],
                "self.dtype.categories": [
                    704,
                    1343,
                    422,
                    1318,
                    1066,
                    427,
                    1067,
                    973,
                    1015,
                    1020,
                    703
                ],
                "self.dtype": [
                    2177,
                    1655,
                    2314,
                    1294,
                    2211,
                    422,
                    1318,
                    1447,
                    2343,
                    1066,
                    427,
                    1067,
                    1838,
                    441,
                    1343,
                    704,
                    703,
                    837,
                    973,
                    467,
                    1619,
                    2008,
                    2142,
                    1763,
                    486,
                    488,
                    1260,
                    2033,
                    1015,
                    1020
                ],
                "property": [
                    674,
                    450,
                    1316,
                    393,
                    2346,
                    2617,
                    436,
                    1209,
                    443,
                    1309
                ],
                "new_dtype": [
                    1024,
                    1025,
                    426,
                    428,
                    434,
                    698,
                    700,
                    704,
                    838,
                    711,
                    842,
                    846,
                    849,
                    852,
                    1111,
                    1114,
                    1115,
                    742,
                    744,
                    1021
                ],
                "new_dtype.categories": [
                    704,
                    1025,
                    842,
                    428,
                    846,
                    849,
                    1115
                ],
                "categories.setter": [
                    424
                ],
                "self.dtype.ordered": [
                    441,
                    837
                ],
                "Ordered": [
                    437
                ],
                "Type": [
                    451
                ],
                "scalars": [
                    456
                ],
                "classmethod": [
                    454,
                    585,
                    523,
                    2350,
                    2271
                ],
                "self._constructor": [
                    1763,
                    2211,
                    1447,
                    2343,
                    466,
                    1618,
                    1655,
                    2008
                ],
                "self._codes.copy": [
                    1192,
                    467
                ],
                "Dtype": [
                    470
                ],
                "cast": [
                    483
                ],
                "Union": [
                    483
                ],
                "str": [
                    1888,
                    483,
                    1955,
                    1926,
                    1959,
                    1931,
                    1901,
                    1966,
                    1968
                ],
                "self.dtype.update_dtype": [
                    486
                ],
                "copy": [
                    495,
                    492,
                    487
                ],
                "self.copy": [
                    2437,
                    743,
                    840,
                    487,
                    1104,
                    2256,
                    925,
                    1023
                ],
                "self._set_dtype": [
                    490
                ],
                "is_extension_array_dtype": [
                    640,
                    491,
                    1276,
                    2644
                ],
                "array": [
                    492
                ],
                "is_integer_dtype": [
                    640,
                    1466,
                    493,
                    647
                ],
                "self.isna": [
                    1397,
                    1884,
                    493
                ],
                "ArrayLike": [
                    470
                ],
                "self._codes.size": [
                    502
                ],
                "cache_readonly": [
                    504,
                    497
                ],
                "int": [
                    2050,
                    1866,
                    1995,
                    498,
                    505
                ],
                "self.categories.itemsize": [
                    509
                ],
                "list": [
                    519,
                    2702,
                    2705,
                    2773,
                    1020
                ],
                "List": [
                    511
                ],
                "Scalar": [
                    511
                ],
                "to_list": [
                    521
                ],
                "tolist": [
                    521,
                    1876
                ],
                "cats": [
                    2659,
                    580,
                    549,
                    2660,
                    2661,
                    2662,
                    557,
                    559,
                    561,
                    566,
                    571,
                    572,
                    574,
                    575
                ],
                "Index": [
                    549,
                    2039
                ],
                "inferred_categories": [
                    561,
                    557,
                    549,
                    559
                ],
                "known_categories": [
                    568,
                    554,
                    550
                ],
                "dtype.categories.is_numeric": [
                    556
                ],
                "to_numeric": [
                    557
                ],
                "is_datetime64_dtype": [
                    558
                ],
                "to_datetime": [
                    559
                ],
                "is_timedelta64_dtype": [
                    560
                ],
                "to_timedelta": [
                    561
                ],
                "dtype.categories.is_boolean": [
                    562
                ],
                "true_values": [
                    563,
                    564,
                    566
                ],
                "cats.isin": [
                    566
                ],
                "inferred_codes": [
                    577,
                    571,
                    581
                ],
                "cats.is_monotonic_increasing": [
                    572
                ],
                "unsorted": [
                    577,
                    574
                ],
                "cats.copy": [
                    574
                ],
                "cats.sort_values": [
                    575
                ],
                "cls": [
                    583,
                    653,
                    2648,
                    2649,
                    2650
                ],
                "codes.to_numpy": [
                    644
                ],
                "np.int64": [
                    644
                ],
                "np.asarray": [
                    1280,
                    2404,
                    646,
                    1673,
                    1836,
                    1721,
                    1275
                ],
                "codes.max": [
                    650
                ],
                "codes.min": [
                    650
                ],
                "v": [
                    1306,
                    664,
                    665,
                    666,
                    1307
                ],
                "self._codes.view": [
                    664
                ],
                "v.flags.writeable": [
                    665
                ],
                "v.flags": [
                    665
                ],
                "_get_codes": [
                    674
                ],
                "_set_codes": [
                    674
                ],
                "CategoricalDtype._from_fastpath": [
                    698,
                    1111
                ],
                "self.codes": [
                    1637,
                    1351,
                    2407,
                    1354,
                    1355,
                    2255,
                    726,
                    1241,
                    2268,
                    2105
                ],
                "inplace": [
                    1026,
                    2436,
                    2437,
                    781,
                    782,
                    924,
                    925,
                    2465,
                    933,
                    1061,
                    1078,
                    835,
                    840,
                    1609,
                    972,
                    1103,
                    1104,
                    977,
                    1615,
                    854,
                    1117,
                    741,
                    743,
                    745,
                    1012,
                    763,
                    764,
                    1023
                ],
                "validate_bool_kwarg": [
                    835,
                    2436,
                    741,
                    1061,
                    1609,
                    972,
                    781,
                    1103,
                    1012,
                    763,
                    924
                ],
                "value": [
                    2442,
                    2445,
                    1704,
                    1705,
                    1708,
                    1709,
                    1722,
                    1731,
                    1349,
                    1350,
                    1735,
                    1736,
                    1353,
                    1739,
                    1745,
                    1746,
                    1752,
                    1755,
                    1760,
                    2020,
                    742,
                    2023,
                    2024,
                    2029,
                    2031,
                    2033,
                    2035
                ],
                "cat._dtype": [
                    744,
                    1024,
                    1114,
                    852
                ],
                "self.set_ordered": [
                    764,
                    782
                ],
                "new_categories": [
                    2689,
                    2693,
                    927,
                    928,
                    929,
                    930,
                    932,
                    1189,
                    1192,
                    1067,
                    1198,
                    1199,
                    1072,
                    1078,
                    838,
                    973,
                    977,
                    1110,
                    1112,
                    1013,
                    1014,
                    1015,
                    1020,
                    1021
                ],
                "rename": [
                    841
                ],
                "cat.dtype.categories": [
                    842,
                    843,
                    1110
                ],
                "cat.dtype": [
                    842,
                    843,
                    1110
                ],
                "cat._codes": [
                    1025,
                    846,
                    1105,
                    851,
                    2259,
                    1115,
                    2460
                ],
                "cat.codes": [
                    849,
                    2747
                ],
                "is_dict_like": [
                    927
                ],
                "new_categories.get": [
                    928
                ],
                "item": [
                    928,
                    930
                ],
                "callable": [
                    929
                ],
                "self.set_categories": [
                    977,
                    1077
                ],
                "already_included": [
                    1016,
                    1018,
                    1015
                ],
                "removals": [
                    1070,
                    1065,
                    1062,
                    1063
                ],
                "removal_set": [
                    1065,
                    1066,
                    1067
                ],
                "not_included": [
                    1066,
                    1075,
                    1074,
                    1071
                ],
                "c": [
                    1067
                ],
                "x": [
                    1072,
                    1353,
                    1923,
                    1071
                ],
                "notna": [
                    1072,
                    1399,
                    1071
                ],
                "inv": [
                    1105,
                    1115,
                    1108
                ],
                "np.unique": [
                    1105
                ],
                "idx.size": [
                    1107
                ],
                "cat.dtype.categories.take": [
                    1110
                ],
                "self.categories.map": [
                    1189
                ],
                "mapper": [
                    1189
                ],
                "self.from_codes": [
                    1260,
                    1191
                ],
                "np.any": [
                    1197
                ],
                "new_categories.insert": [
                    1198
                ],
                "np.nan": [
                    2149,
                    2184,
                    1641,
                    1709,
                    1198,
                    1998,
                    1465,
                    1467
                ],
                "np.take": [
                    1199
                ],
                "__eq__": [
                    1201
                ],
                "_cat_compare_op": [
                    1201,
                    1202,
                    1203,
                    1204,
                    1205,
                    1206
                ],
                "operator.eq": [
                    1201
                ],
                "operator": [
                    1201,
                    1202,
                    1203,
                    1204,
                    1205,
                    1206
                ],
                "__ne__": [
                    1202
                ],
                "operator.ne": [
                    1202
                ],
                "__lt__": [
                    1203
                ],
                "operator.lt": [
                    1203
                ],
                "__gt__": [
                    1204
                ],
                "operator.gt": [
                    1204
                ],
                "__le__": [
                    1205
                ],
                "operator.le": [
                    1205
                ],
                "__ge__": [
                    1206
                ],
                "operator.ge": [
                    1206
                ],
                "tuple": [
                    2704,
                    1220,
                    2341,
                    2054
                ],
                "codes.ndim": [
                    1242
                ],
                "np.prod": [
                    1244
                ],
                "codes.shape": [
                    1244
                ],
                "periods": [
                    1255,
                    1256,
                    1258,
                    1244,
                    1245
                ],
                "np.roll": [
                    1245
                ],
                "ensure_platform_int": [
                    1245
                ],
                "fill_value": [
                    1248,
                    1249,
                    1252,
                    1256,
                    1864,
                    1258,
                    1840,
                    1841,
                    1844,
                    1845,
                    1848,
                    1853,
                    1246,
                    1247
                ],
                "take_1d": [
                    1273,
                    2695
                ],
                "self.categories.values": [
                    1273
                ],
                "is_dtype_equal": [
                    2024,
                    1274,
                    2642
                ],
                "self.categories.dtype": [
                    1274,
                    1723,
                    1931
                ],
                "result": [
                    1411,
                    1285,
                    1413,
                    1288,
                    1289,
                    2332,
                    2333,
                    2334,
                    2336,
                    1965,
                    1966,
                    1974,
                    1976,
                    1979,
                    1981,
                    1854,
                    1855,
                    2109,
                    2110,
                    2004,
                    2005,
                    2006,
                    2007,
                    2008,
                    1897,
                    1899,
                    1901
                ],
                "ops.maybe_dispatch_ufunc_to_dunder_op": [
                    1285
                ],
                "ops": [
                    1285
                ],
                "ufunc": [
                    1286,
                    1295
                ],
                "method": [
                    2629,
                    1286,
                    2630,
                    1704,
                    1705,
                    1718,
                    1722
                ],
                "inputs": [
                    1286
                ],
                "kwargs": [
                    2630,
                    2117,
                    1533,
                    1286
                ],
                "NotImplemented": [
                    1288
                ],
                "ufunc.__name__": [
                    1295
                ],
                "state": [
                    1304,
                    1306,
                    1300,
                    1303
                ],
                "dict": [
                    2341,
                    1300,
                    2109
                ],
                "Exception": [
                    1301
                ],
                "k": [
                    1306,
                    1307
                ],
                "state.items": [
                    1306
                ],
                "setattr": [
                    1307,
                    2615
                ],
                "self._codes.nbytes": [
                    1318,
                    1343
                ],
                "self.dtype.categories.values.nbytes": [
                    1318
                ],
                "self.dtype.categories.values": [
                    1318
                ],
                "self.dtype.categories.memory_usage": [
                    1343
                ],
                "deep": [
                    1343
                ],
                "self.codes.dtype.type": [
                    1351
                ],
                "self.codes.dtype": [
                    1354,
                    1351
                ],
                "locs": [
                    1353,
                    1354
                ],
                "self.codes.searchsorted": [
                    1355
                ],
                "side": [
                    1355
                ],
                "sorter": [
                    1355
                ],
                "doc": [
                    1345
                ],
                "_shared_docs": [
                    1345
                ],
                "isnull": [
                    1377
                ],
                "notnull": [
                    1399
                ],
                "self.notna": [
                    1411
                ],
                "code": [
                    1441,
                    1444,
                    1436,
                    1437
                ],
                "ncat": [
                    1442,
                    1444,
                    1437,
                    1438
                ],
                "ix": [
                    1449,
                    1445,
                    1438,
                    1447
                ],
                "clean": [
                    1440,
                    1441,
                    1438
                ],
                "np.arange": [
                    2738,
                    1438
                ],
                "mask.all": [
                    1438
                ],
                "dropna": [
                    1440,
                    2210,
                    2207
                ],
                "obs": [
                    1441,
                    1442
                ],
                "count": [
                    1449,
                    1442,
                    1444
                ],
                "np.bincount": [
                    1442,
                    1444
                ],
                "np.append": [
                    1445
                ],
                "Series": [
                    1648,
                    1449,
                    2632,
                    2624
                ],
                "CategoricalIndex": [
                    1449
                ],
                "needs_i8_conversion": [
                    1464
                ],
                "self.categories.take": [
                    1465
                ],
                "take": [
                    1467,
                    1853
                ],
                "self.categories.astype": [
                    1467
                ],
                "argsort": [
                    1533
                ],
                "super": [
                    1533
                ],
                "ascending": [
                    1613,
                    1533
                ],
                "kind": [
                    1533
                ],
                "na_position": [
                    1610,
                    1611,
                    1613
                ],
                "repr": [
                    1611
                ],
                "sorted_idx": [
                    1616,
                    1619,
                    1613
                ],
                "nargsort": [
                    1613
                ],
                "values.astype": [
                    1640
                ],
                "self.categories.is_numeric": [
                    1642
                ],
                "self.rename_categories": [
                    1648
                ],
                "rank": [
                    1648
                ],
                "warn": [
                    1859,
                    1667
                ],
                "FutureWarning": [
                    1861,
                    1670
                ],
                "validate_fillna_kwargs": [
                    1704
                ],
                "limit": [
                    1710
                ],
                "reshape": [
                    1721
                ],
                "astype": [
                    1722
                ],
                "interpolate_2d": [
                    1722
                ],
                "algorithms.isin": [
                    2407,
                    1735
                ],
                "algorithms": [
                    2407,
                    1735
                ],
                "values_codes": [
                    1739,
                    1742
                ],
                "indexer": [
                    1987,
                    1988,
                    1989,
                    2692,
                    2695,
                    1864,
                    1836,
                    1740,
                    1742,
                    1853
                ],
                "codes.copy": [
                    2688,
                    2691,
                    2695,
                    1741,
                    1751
                ],
                "is_hashable": [
                    1745
                ],
                "__name__": [
                    1760,
                    2398
                ],
                "np.intp": [
                    1836
                ],
                "allow_fill": [
                    1864,
                    1842,
                    1853
                ],
                "from_codes": [
                    1854
                ],
                "self.take": [
                    1864
                ],
                "iter": [
                    1876
                ],
                "self._internal_get_values": [
                    1876
                ],
                "contains": [
                    1886
                ],
                "num": [
                    1893,
                    1894,
                    1895,
                    1915,
                    1916,
                    1917
                ],
                "max_vals": [
                    1893,
                    1895
                ],
                "head": [
                    1897,
                    1918,
                    1916,
                    1894
                ],
                "_get_repr": [
                    1894,
                    1895
                ],
                "tail": [
                    1897,
                    1917,
                    1918,
                    1895
                ],
                "footer": [
                    1898,
                    1963
                ],
                "self._repr_footer": [
                    1899
                ],
                "max_categories": [
                    1915,
                    1914,
                    1907
                ],
                "get_option": [
                    1934,
                    1909,
                    1910
                ],
                "fmt.format_array": [
                    1920,
                    1916,
                    1917
                ],
                "fmt": [
                    1920,
                    1962,
                    1916,
                    1917
                ],
                "category_strs": [
                    1920,
                    1923,
                    1924,
                    1930,
                    1943,
                    1918
                ],
                "x.strip": [
                    1923
                ],
                "self._repr_categories": [
                    1930
                ],
                "levheader": [
                    1953,
                    1932,
                    1940,
                    1945,
                    1946
                ],
                "width": [
                    1933,
                    1934
                ],
                "height": [
                    1933
                ],
                "get_terminal_size": [
                    1933
                ],
                "max_width": [
                    1944,
                    1937,
                    1934
                ],
                "console.in_ipython_frontend": [
                    1935
                ],
                "console": [
                    1935
                ],
                "levstring": [
                    1953,
                    1938,
                    1945,
                    1948,
                    1950
                ],
                "start": [
                    1939,
                    1947,
                    2108,
                    1951
                ],
                "cur_col_len": [
                    1944,
                    1946,
                    1940,
                    1949
                ],
                "sep_len": [
                    1944,
                    1941
                ],
                "sep": [
                    1948,
                    1941,
                    1942
                ],
                "linesep": [
                    1945,
                    1942
                ],
                "sep.rstrip": [
                    1942
                ],
                "val": [
                    1944,
                    1949,
                    1950,
                    1943
                ],
                "levstring.replace": [
                    1953
                ],
                "info": [
                    1956,
                    1957
                ],
                "self._repr_categories_info": [
                    1956
                ],
                "formatter": [
                    1962,
                    1965
                ],
                "fmt.CategoricalFormatter": [
                    1962
                ],
                "length": [
                    1963
                ],
                "na_rep": [
                    1963
                ],
                "formatter.to_string": [
                    1965
                ],
                "_maxlen": [
                    1976,
                    1972,
                    1973,
                    1974
                ],
                "self._tidy_repr": [
                    1974
                ],
                "self._get_repr": [
                    1976,
                    1978
                ],
                "replace": [
                    1978
                ],
                "indexer.dtype.kind": [
                    1987
                ],
                "indexer.dtype": [
                    1987
                ],
                "indexer.astype": [
                    1988
                ],
                "self._codes.dtype": [
                    1988
                ],
                "np.integer": [
                    2050,
                    1995
                ],
                "check_array_indexer": [
                    2002,
                    2075
                ],
                "result.ndim": [
                    2005
                ],
                "deprecate_ndim_indexing": [
                    2006
                ],
                "extract_array": [
                    2020,
                    2735
                ],
                "value.categories": [
                    2029,
                    2031
                ],
                "new_codes": [
                    2696,
                    2033,
                    2030,
                    2695
                ],
                "value.codes": [
                    2031
                ],
                "Categorical.from_codes": [
                    2033,
                    2739
                ],
                "rvalue": [
                    2072,
                    2035,
                    2039
                ],
                "to_add": [
                    2043,
                    2039
                ],
                "difference": [
                    2039
                ],
                "com.is_null_slice": [
                    2058
                ],
                "com": [
                    2058
                ],
                "AssertionError": [
                    2064,
                    2059
                ],
                "slice": [
                    2067
                ],
                "lindexer": [
                    2072,
                    2073,
                    2076
                ],
                "self.categories.get_indexer": [
                    2072,
                    2405
                ],
                "self._maybe_coerce_indexer": [
                    2073
                ],
                "r": [
                    2104,
                    2108
                ],
                "counts": [
                    2328,
                    2332,
                    2327,
                    2104,
                    2107,
                    2108
                ],
                "libalgos.groupsort_indexer": [
                    2104
                ],
                "libalgos": [
                    2104
                ],
                "self.codes.astype": [
                    2105,
                    2268
                ],
                "categories.size": [
                    2105
                ],
                "counts.cumsum": [
                    2107
                ],
                "_result": [
                    2108,
                    2109
                ],
                "end": [
                    2108
                ],
                "zip": [
                    2773,
                    2108,
                    2109
                ],
                "Dict": [
                    2078
                ],
                "Hashable": [
                    2078
                ],
                "name": [
                    2114,
                    2116,
                    2629,
                    2612,
                    2615
                ],
                "self.check_for_ordered": [
                    2139,
                    2174
                ],
                "self.dtype.na_value": [
                    2177,
                    2142
                ],
                "good": [
                    2144,
                    2145,
                    2208,
                    2147,
                    2179,
                    2180,
                    2182,
                    2209
                ],
                "good.all": [
                    2145,
                    2180
                ],
                "skipna": [
                    2146,
                    2181
                ],
                "pointer": [
                    2147,
                    2182,
                    2151,
                    2152,
                    2186,
                    2187
                ],
                "min": [
                    2147
                ],
                "self._codes.min": [
                    2151
                ],
                "deprecate_kwarg": [
                    2154,
                    2119
                ],
                "max": [
                    2182
                ],
                "self._codes.max": [
                    2186
                ],
                "sorted": [
                    2210
                ],
                "htable.mode_int64": [
                    2210
                ],
                "htable": [
                    2210
                ],
                "ensure_int64": [
                    2210
                ],
                "unique_codes": [
                    2259,
                    2262,
                    2255
                ],
                "unique1d": [
                    2255
                ],
                "take_codes": [
                    2264,
                    2265,
                    2262
                ],
                "np.sort": [
                    2264
                ],
                "cat.set_categories": [
                    2265
                ],
                "cat.categories.take": [
                    2265
                ],
                "original._constructor": [
                    2273
                ],
                "original": [
                    2273,
                    2274
                ],
                "original.categories.take": [
                    2274
                ],
                "original.categories": [
                    2274
                ],
                "uniques": [
                    2274
                ],
                "original.dtype": [
                    2274
                ],
                "self.is_dtype_equal": [
                    2289
                ],
                "other.codes": [
                    2295
                ],
                "np.array_equal": [
                    2297
                ],
                "other.dtype": [
                    2314
                ],
                "AttributeError": [
                    2609,
                    2315
                ],
                "self.value_counts": [
                    2327
                ],
                "freqs": [
                    2328,
                    2332
                ],
                "float": [
                    2328
                ],
                "counts.sum": [
                    2328
                ],
                "concat": [
                    2332
                ],
                "result.columns": [
                    2333
                ],
                "result.index.name": [
                    2334
                ],
                "result.index": [
                    2334
                ],
                "nv.validate_repeat": [
                    2341
                ],
                "nv": [
                    2341
                ],
                "axis": [
                    2341
                ],
                "self._codes.repeat": [
                    2342
                ],
                "repeats": [
                    2342
                ],
                "Substitution": [
                    2338
                ],
                "Appender": [
                    2339
                ],
                "_extension_array_shared_docs": [
                    2339
                ],
                "concat_categorical": [
                    2354
                ],
                "to_concat": [
                    2354
                ],
                "values_type": [
                    2401,
                    2398
                ],
                "code_values": [
                    2405,
                    2406,
                    2407
                ],
                "to_replace": [
                    2440,
                    2442,
                    2445
                ],
                "replace_dict": [
                    2449,
                    2442,
                    2445
                ],
                "replace_value": [
                    2442,
                    2449,
                    2450,
                    2452,
                    2454,
                    2457,
                    2461
                ],
                "new_value": [
                    2449,
                    2450,
                    2453,
                    2458,
                    2459,
                    2463
                ],
                "replace_dict.items": [
                    2449
                ],
                "cat.remove_categories": [
                    2461,
                    2454
                ],
                "cat.categories.tolist": [
                    2456
                ],
                "index": [
                    2457,
                    2460,
                    2463
                ],
                "categories.index": [
                    2457,
                    2459
                ],
                "value_index": [
                    2459,
                    2460
                ],
                "cat.rename_categories": [
                    2464
                ],
                "PandasDelegate": [
                    2489
                ],
                "NoNewAttributesMixin": [
                    2489
                ],
                "self._validate": [
                    2600
                ],
                "data": [
                    2600,
                    2601,
                    2602,
                    2603,
                    2608
                ],
                "self._parent": [
                    2624,
                    2629,
                    2601,
                    2612,
                    2615
                ],
                "data.values": [
                    2601
                ],
                "self._index": [
                    2624,
                    2602,
                    2632
                ],
                "data.index": [
                    2602
                ],
                "self._name": [
                    2632,
                    2603
                ],
                "data.name": [
                    2603
                ],
                "self._freeze": [
                    2604
                ],
                "data.dtype": [
                    2608
                ],
                "staticmethod": [
                    2606
                ],
                "new_values": [
                    2615
                ],
                "self._parent.codes": [
                    2624
                ],
                "res": [
                    2632,
                    2630,
                    2631
                ],
                "args": [
                    2630
                ],
                "delegate_names": [
                    2472,
                    2475
                ],
                "dtype_equal": [
                    2642,
                    2654
                ],
                "categories.dtype": [
                    2648,
                    2642,
                    2644
                ],
                "is_object_dtype": [
                    2644
                ],
                "categories.dtype.construct_array_type": [
                    2648
                ],
                "maybe_cast_to_extension_array": [
                    2649
                ],
                "ensure_object": [
                    2656,
                    2652,
                    2653,
                    2655
                ],
                "hash_klass": [
                    2658,
                    2660
                ],
                "vals": [
                    2658,
                    2662
                ],
                "_get_data_algo": [
                    2658,
                    2659
                ],
                "_": [
                    2659
                ],
                "t": [
                    2660,
                    2661,
                    2662
                ],
                "t.map_locations": [
                    2661
                ],
                "t.lookup": [
                    2662
                ],
                "old_categories": [
                    2689,
                    2693,
                    2686
                ],
                "new_categories.equals": [
                    2689
                ],
                "new_categories.get_indexer": [
                    2693
                ],
                "hasattr": [
                    2700
                ],
                "list_like": [
                    2700,
                    2701,
                    2702,
                    2703,
                    2704,
                    2705,
                    2706,
                    2707,
                    2710
                ],
                "is_sequence": [
                    2704
                ],
                "is_iterator": [
                    2704
                ],
                "cat_codes": [
                    2738,
                    2739
                ],
                "values.codes.dtype": [
                    2738
                ],
                "iterables": [
                    2770,
                    2773
                ],
                "map": [
                    2773
                ],
                "factorize_from_iterable": [
                    2773
                ],
                "it": [
                    2773
                ]
            },
            "filtered_variables_in_file": {
                "opname": [
                    130,
                    67,
                    69,
                    102,
                    137,
                    138,
                    107,
                    76,
                    141,
                    146,
                    116,
                    118,
                    124,
                    126
                ],
                "op.__name__": [
                    67
                ],
                "op": [
                    1474,
                    67
                ],
                "is_list_like": [
                    1062,
                    71,
                    2440,
                    2731,
                    2035,
                    1013,
                    2397
                ],
                "other": [
                    138,
                    2314,
                    142,
                    71,
                    80,
                    85,
                    87,
                    89,
                    92,
                    96,
                    98,
                    100,
                    113,
                    114,
                    115,
                    2289,
                    2290,
                    2292,
                    2295
                ],
                "self": [
                    519,
                    1021,
                    2039,
                    2072,
                    2073,
                    2075,
                    2076,
                    2600,
                    2601,
                    1066,
                    1067,
                    2602,
                    2603,
                    2604,
                    2612,
                    1077,
                    1078,
                    2103,
                    2615,
                    2105,
                    2624,
                    2114,
                    2629,
                    71,
                    2632,
                    75,
                    1613,
                    1104,
                    1616,
                    1618,
                    1619,
                    85,
                    87,
                    1112,
                    89,
                    2139,
                    92,
                    2141,
                    2142,
                    96,
                    2144,
                    98,
                    2147,
                    1636,
                    1637,
                    102,
                    2151,
                    104,
                    2152,
                    1642,
                    1643,
                    108,
                    1648,
                    114,
                    115,
                    116,
                    1655,
                    120,
                    125,
                    2174,
                    127,
                    2176,
                    2177,
                    2179,
                    2182,
                    1673,
                    138,
                    2186,
                    2187,
                    664,
                    2206,
                    2208,
                    2209,
                    2211,
                    1189,
                    1191,
                    1192,
                    1197,
                    1199,
                    1715,
                    1721,
                    698,
                    1723,
                    700,
                    1725,
                    703,
                    704,
                    1220,
                    711,
                    1735,
                    1739,
                    2255,
                    2256,
                    1746,
                    726,
                    727,
                    2263,
                    1241,
                    1755,
                    2268,
                    1248,
                    1249,
                    1763,
                    742,
                    743,
                    1260,
                    2289,
                    2290,
                    2295,
                    1273,
                    1274,
                    2297,
                    764,
                    1286,
                    2314,
                    782,
                    1294,
                    2327,
                    1307,
                    1314,
                    1318,
                    2342,
                    2343,
                    1838,
                    1844,
                    1845,
                    1853,
                    1854,
                    1343,
                    324,
                    325,
                    837,
                    1350,
                    840,
                    1351,
                    1353,
                    1354,
                    1355,
                    1864,
                    1870,
                    1876,
                    1884,
                    1374,
                    1886,
                    2405,
                    1894,
                    1895,
                    2407,
                    1899,
                    1397,
                    1914,
                    1916,
                    1917,
                    1920,
                    1411,
                    2437,
                    390,
                    391,
                    1930,
                    1931,
                    1932,
                    1941,
                    1436,
                    925,
                    1956,
                    1957,
                    422,
                    1447,
                    426,
                    427,
                    1963,
                    434,
                    1973,
                    1974,
                    1975,
                    1464,
                    441,
                    1465,
                    1466,
                    1467,
                    1468,
                    1976,
                    1978,
                    448,
                    1472,
                    1988,
                    1480,
                    1996,
                    973,
                    2000,
                    977,
                    466,
                    467,
                    2002,
                    2004,
                    2008,
                    486,
                    487,
                    488,
                    489,
                    490,
                    2024,
                    492,
                    493,
                    2029,
                    495,
                    2031,
                    2033,
                    502,
                    1015,
                    1020,
                    509,
                    1023
                ],
                "self.ordered": [
                    96,
                    1472,
                    700,
                    1636,
                    2263,
                    1192,
                    426,
                    75,
                    1941,
                    1078,
                    87,
                    1112,
                    698,
                    92,
                    1021
                ],
                "Categorical": [
                    1731,
                    452,
                    2023,
                    456,
                    2473,
                    2476,
                    80,
                    2033,
                    2739,
                    2745
                ],
                "msg": [
                    1978,
                    1979,
                    1847,
                    84,
                    86,
                    634,
                    88,
                    90,
                    1851,
                    638
                ],
                "self.categories": [
                    1920,
                    1931,
                    1932,
                    2187,
                    2072,
                    2295,
                    1436,
                    1914,
                    1189,
                    1917,
                    1844,
                    1845,
                    2103,
                    1464,
                    1465,
                    1466,
                    1467,
                    1723,
                    1725,
                    1350,
                    1735,
                    1353,
                    1739,
                    2000,
                    1746,
                    85,
                    726,
                    87,
                    89,
                    1755,
                    96,
                    1248,
                    98,
                    1249,
                    2405,
                    742,
                    2152,
                    1642,
                    2029,
                    2031,
                    1648,
                    114,
                    115,
                    2290,
                    2039,
                    1273,
                    1274,
                    1916,
                    509
                ],
                "other.categories": [
                    96,
                    2290,
                    85,
                    87,
                    89,
                    2295
                ],
                "other.ordered": [
                    92
                ],
                "self.categories.equals": [
                    96,
                    2290,
                    2029
                ],
                "other_codes": [
                    98,
                    100,
                    103,
                    104,
                    108,
                    2292,
                    2294,
                    2297
                ],
                "_get_codes_for_values": [
                    98,
                    1739,
                    1725,
                    382
                ],
                "other._codes": [
                    100,
                    2292
                ],
                "f": [
                    102,
                    103
                ],
                "self._codes": [
                    2176,
                    2179,
                    2182,
                    391,
                    2186,
                    664,
                    1436,
                    2076,
                    2206,
                    2208,
                    2209,
                    2297,
                    1318,
                    2342,
                    1192,
                    1197,
                    1199,
                    1715,
                    1973,
                    1975,
                    1465,
                    1466,
                    1467,
                    1853,
                    1343,
                    324,
                    1220,
                    1988,
                    1480,
                    1996,
                    1870,
                    1616,
                    467,
                    1619,
                    2004,
                    2141,
                    1374,
                    1886,
                    2144,
                    2147,
                    102,
                    2151,
                    104,
                    108,
                    116,
                    502,
                    1655,
                    120,
                    1273
                ],
                "ret": [
                    1280,
                    1281,
                    1273,
                    103,
                    108,
                    110,
                    111,
                    116,
                    121,
                    122,
                    1275,
                    1276,
                    1374,
                    1375
                ],
                "mask": [
                    1441,
                    1444,
                    1638,
                    1639,
                    104,
                    105,
                    1641,
                    1735,
                    1736,
                    110,
                    1753,
                    1749,
                    1750,
                    120,
                    121,
                    1755,
                    1437,
                    1438
                ],
                "mask.any": [
                    105,
                    1750,
                    1639
                ],
                "is_scalar": [
                    195,
                    1349,
                    113,
                    2706,
                    1883
                ],
                "i": [
                    1996,
                    1997,
                    2000,
                    115,
                    116
                ],
                "self.categories.get_loc": [
                    1249,
                    1350,
                    1353,
                    115,
                    1845,
                    1755
                ],
                "np.zeros": [
                    125
                ],
                "np": [
                    1280,
                    386,
                    2050,
                    644,
                    646,
                    2184,
                    1673,
                    138,
                    1438,
                    2078,
                    1442,
                    1444,
                    1445,
                    1836,
                    1197,
                    1198,
                    1199,
                    1709,
                    2738,
                    1465,
                    1721,
                    1467,
                    1468,
                    1731,
                    1987,
                    330,
                    1354,
                    1740,
                    1995,
                    1998,
                    1105,
                    340,
                    2264,
                    347,
                    1244,
                    1245,
                    2404,
                    2149,
                    1641,
                    2665,
                    1643,
                    1262,
                    495,
                    1647,
                    2297,
                    1275,
                    125,
                    127
                ],
                "np.ones": [
                    386,
                    127
                ],
                "np.array": [
                    138,
                    1354,
                    330,
                    1643,
                    495,
                    1647,
                    1468
                ],
                "unpack_zerodim_and_defer": [
                    69
                ],
                "func.__name__": [
                    146
                ],
                "func": [
                    2114,
                    2115,
                    2117,
                    146,
                    148
                ],
                "key": [
                    2050,
                    2054,
                    2075,
                    2057,
                    2058,
                    1995,
                    1996,
                    2060,
                    2061,
                    2062,
                    2002,
                    2067,
                    180,
                    2004,
                    186,
                    1883,
                    2076,
                    1886
                ],
                "loc": [
                    186,
                    195,
                    196,
                    199
                ],
                "cat.categories.get_loc": [
                    186
                ],
                "cat.categories": [
                    928,
                    930,
                    932,
                    2458,
                    849,
                    2452,
                    2456,
                    2265,
                    186,
                    2746
                ],
                "cat": [
                    1024,
                    1025,
                    1027,
                    2437,
                    2452,
                    2454,
                    2456,
                    2458,
                    1436,
                    925,
                    1437,
                    2460,
                    928,
                    2461,
                    930,
                    2464,
                    932,
                    2466,
                    934,
                    2745,
                    186,
                    2746,
                    2747,
                    840,
                    842,
                    843,
                    846,
                    1104,
                    849,
                    1105,
                    851,
                    852,
                    2256,
                    1110,
                    855,
                    2259,
                    2265,
                    1114,
                    1115,
                    1118,
                    743,
                    744,
                    746,
                    1023
                ],
                "container": [
                    196,
                    199
                ],
                "loc_": [
                    199
                ],
                "_codes_doc": [
                    674,
                    202
                ],
                "ExtensionArray": [
                    213
                ],
                "PandasObject": [
                    2489,
                    309,
                    213
                ],
                "__array_priority__": [
                    306
                ],
                "_dtype": [
                    307
                ],
                "CategoricalDtype": [
                    1304,
                    551,
                    426,
                    307,
                    698,
                    700,
                    444,
                    316,
                    578,
                    580,
                    838,
                    713,
                    335,
                    1111,
                    483,
                    742,
                    371,
                    630,
                    1021
                ],
                "_deprecations": [
                    309
                ],
                "PandasObject._deprecations": [
                    309
                ],
                "_typ": [
                    310
                ],
                "dtype": [
                    390,
                    391,
                    650,
                    1274,
                    1931,
                    653,
                    1932,
                    551,
                    556,
                    558,
                    1838,
                    560,
                    562,
                    570,
                    316,
                    317,
                    1854,
                    578,
                    324,
                    325,
                    580,
                    583,
                    456,
                    334,
                    335,
                    726,
                    727,
                    350,
                    482,
                    355,
                    483,
                    486,
                    488,
                    490,
                    491,
                    492,
                    493,
                    495,
                    371,
                    1653,
                    630,
                    631,
                    1654,
                    633,
                    378,
                    1275,
                    382
                ],
                "CategoricalDtype._from_values_or_dtype": [
                    316,
                    630
                ],
                "values": [
                    2731,
                    2655,
                    2734,
                    2735,
                    2738,
                    2739,
                    2740,
                    1721,
                    1722,
                    2745,
                    317,
                    1725,
                    324,
                    333,
                    335,
                    336,
                    2642,
                    339,
                    340,
                    341,
                    2644,
                    344,
                    345,
                    2649,
                    347,
                    348,
                    2397,
                    2398,
                    2650,
                    352,
                    2652,
                    354,
                    2403,
                    2404,
                    1637,
                    1638,
                    2405,
                    1640,
                    1641,
                    2658,
                    1643,
                    1647,
                    1648,
                    1650,
                    373,
                    375,
                    378,
                    382
                ],
                "categories": [
                    2456,
                    2457,
                    2459,
                    2463,
                    2464,
                    424,
                    426,
                    2739,
                    2103,
                    2105,
                    698,
                    570,
                    571,
                    2109,
                    700,
                    317,
                    575,
                    577,
                    578,
                    2746,
                    2748,
                    2642,
                    2644,
                    2648,
                    2653,
                    352,
                    2656,
                    354,
                    2659,
                    371,
                    631
                ],
                "ordered": [
                    836,
                    837,
                    838,
                    977,
                    631,
                    317
                ],
                "fastpath": [
                    697,
                    323,
                    702
                ],
                "coerce_indexer_dtype": [
                    1025,
                    324,
                    2692,
                    2662,
                    391,
                    1115
                ],
                "dtype.categories": [
                    382,
                    324,
                    391,
                    551,
                    650,
                    556,
                    334,
                    558,
                    560,
                    562,
                    570,
                    726,
                    633,
                    378,
                    350
                ],
                "self._dtype": [
                    448,
                    325,
                    390,
                    711,
                    434
                ],
                "self._dtype.update_dtype": [
                    325,
                    390
                ],
                "null_mask": [
                    384,
                    386,
                    387,
                    2404,
                    2406,
                    330,
                    345,
                    346,
                    347
                ],
                "is_categorical_dtype": [
                    482,
                    333,
                    2734,
                    2608,
                    373
                ],
                "values.categories": [
                    2738,
                    335
                ],
                "dtype.ordered": [
                    371,
                    355,
                    335
                ],
                "ABCIndexClass": [
                    336
                ],
                "ABCSeries": [
                    336,
                    1731,
                    375
                ],
                "maybe_infer_to_datetimelike": [
                    339
                ],
                "np.ndarray": [
                    1987,
                    1731,
                    2665,
                    1262,
                    340,
                    2078
                ],
                "_convert_to_list_like": [
                    341
                ],
                "sanitize_dtype": [
                    344,
                    348
                ],
                "isna": [
                    1377,
                    642,
                    2404,
                    2043,
                    1736,
                    1070,
                    1840,
                    1746,
                    2453,
                    1752,
                    345,
                    1883,
                    1246
                ],
                "null_mask.any": [
                    384,
                    346
                ],
                "idx": [
                    1105,
                    1107,
                    1108,
                    1110,
                    347
                ],
                "np.where": [
                    1740,
                    347,
                    1444
                ],
                "sanitize_array": [
                    2403,
                    348
                ],
                "codes": [
                    640,
                    2688,
                    386,
                    387,
                    388,
                    642,
                    644,
                    391,
                    646,
                    647,
                    650,
                    2691,
                    2695,
                    653,
                    2206,
                    2209,
                    674,
                    2210,
                    2211,
                    2342,
                    2343,
                    1715,
                    2740,
                    571,
                    2747,
                    1725,
                    1853,
                    1854,
                    2748,
                    577,
                    581,
                    1350,
                    583,
                    1351,
                    1354,
                    1355,
                    1740,
                    1741,
                    1742,
                    848,
                    851,
                    1749,
                    726,
                    727,
                    1751,
                    1241,
                    1242,
                    1753,
                    1244,
                    1245,
                    1755,
                    2268,
                    352,
                    2269,
                    354,
                    1763,
                    1256,
                    1258,
                    1260,
                    377,
                    382
                ],
                "factorize": [
                    352,
                    354
                ],
                "err": [
                    368,
                    362
                ],
                "old_codes": [
                    378,
                    374
                ],
                "values._values.codes": [
                    375
                ],
                "values._values": [
                    375
                ],
                "values.codes": [
                    2738,
                    2740,
                    375
                ],
                "recode_for_categories": [
                    577,
                    2030,
                    848,
                    726,
                    2294,
                    377,
                    571
                ],
                "values.dtype.categories": [
                    378
                ],
                "values.dtype": [
                    378,
                    2739,
                    2642
                ],
                "full_codes": [
                    386,
                    387,
                    388
                ],
                "null_mask.shape": [
                    386
                ],
                "codes.dtype": [
                    386
                ],
                "self.dtype.categories": [
                    704,
                    1343,
                    422,
                    1318,
                    1066,
                    427,
                    1067,
                    973,
                    1015,
                    1020,
                    703
                ],
                "self.dtype": [
                    2177,
                    1655,
                    2314,
                    1294,
                    2211,
                    422,
                    1318,
                    1447,
                    2343,
                    1066,
                    427,
                    1067,
                    1838,
                    441,
                    1343,
                    704,
                    703,
                    837,
                    973,
                    467,
                    1619,
                    2008,
                    2142,
                    1763,
                    486,
                    488,
                    1260,
                    2033,
                    1015,
                    1020
                ],
                "new_dtype": [
                    1024,
                    1025,
                    426,
                    428,
                    434,
                    698,
                    700,
                    704,
                    838,
                    711,
                    842,
                    846,
                    849,
                    852,
                    1111,
                    1114,
                    1115,
                    742,
                    744,
                    1021
                ],
                "new_dtype.categories": [
                    704,
                    1025,
                    842,
                    428,
                    846,
                    849,
                    1115
                ],
                "categories.setter": [
                    424
                ],
                "self.dtype.ordered": [
                    441,
                    837
                ],
                "Ordered": [
                    437
                ],
                "Type": [
                    451
                ],
                "scalars": [
                    456
                ],
                "self._constructor": [
                    1763,
                    2211,
                    1447,
                    2343,
                    466,
                    1618,
                    1655,
                    2008
                ],
                "self._codes.copy": [
                    1192,
                    467
                ],
                "Dtype": [
                    470
                ],
                "cast": [
                    483
                ],
                "Union": [
                    483
                ],
                "self.dtype.update_dtype": [
                    486
                ],
                "copy": [
                    495,
                    492,
                    487
                ],
                "self.copy": [
                    2437,
                    743,
                    840,
                    487,
                    1104,
                    2256,
                    925,
                    1023
                ],
                "self._set_dtype": [
                    490
                ],
                "is_extension_array_dtype": [
                    640,
                    491,
                    1276,
                    2644
                ],
                "array": [
                    492
                ],
                "is_integer_dtype": [
                    640,
                    1466,
                    493,
                    647
                ],
                "self.isna": [
                    1397,
                    1884,
                    493
                ],
                "ArrayLike": [
                    470
                ],
                "self._codes.size": [
                    502
                ],
                "cache_readonly": [
                    504,
                    497
                ],
                "self.categories.itemsize": [
                    509
                ],
                "List": [
                    511
                ],
                "Scalar": [
                    511
                ],
                "to_list": [
                    521
                ],
                "tolist": [
                    521,
                    1876
                ],
                "cats": [
                    2659,
                    580,
                    549,
                    2660,
                    2661,
                    2662,
                    557,
                    559,
                    561,
                    566,
                    571,
                    572,
                    574,
                    575
                ],
                "Index": [
                    549,
                    2039
                ],
                "inferred_categories": [
                    561,
                    557,
                    549,
                    559
                ],
                "known_categories": [
                    568,
                    554,
                    550
                ],
                "dtype.categories.is_numeric": [
                    556
                ],
                "to_numeric": [
                    557
                ],
                "is_datetime64_dtype": [
                    558
                ],
                "to_datetime": [
                    559
                ],
                "is_timedelta64_dtype": [
                    560
                ],
                "to_timedelta": [
                    561
                ],
                "dtype.categories.is_boolean": [
                    562
                ],
                "true_values": [
                    563,
                    564,
                    566
                ],
                "cats.isin": [
                    566
                ],
                "inferred_codes": [
                    577,
                    571,
                    581
                ],
                "cats.is_monotonic_increasing": [
                    572
                ],
                "unsorted": [
                    577,
                    574
                ],
                "cats.copy": [
                    574
                ],
                "cats.sort_values": [
                    575
                ],
                "cls": [
                    583,
                    653,
                    2648,
                    2649,
                    2650
                ],
                "codes.to_numpy": [
                    644
                ],
                "np.int64": [
                    644
                ],
                "np.asarray": [
                    1280,
                    2404,
                    646,
                    1673,
                    1836,
                    1721,
                    1275
                ],
                "codes.max": [
                    650
                ],
                "codes.min": [
                    650
                ],
                "v": [
                    1306,
                    664,
                    665,
                    666,
                    1307
                ],
                "self._codes.view": [
                    664
                ],
                "v.flags.writeable": [
                    665
                ],
                "v.flags": [
                    665
                ],
                "_get_codes": [
                    674
                ],
                "_set_codes": [
                    674
                ],
                "CategoricalDtype._from_fastpath": [
                    698,
                    1111
                ],
                "self.codes": [
                    1637,
                    1351,
                    2407,
                    1354,
                    1355,
                    2255,
                    726,
                    1241,
                    2268,
                    2105
                ],
                "inplace": [
                    1026,
                    2436,
                    2437,
                    781,
                    782,
                    924,
                    925,
                    2465,
                    933,
                    1061,
                    1078,
                    835,
                    840,
                    1609,
                    972,
                    1103,
                    1104,
                    977,
                    1615,
                    854,
                    1117,
                    741,
                    743,
                    745,
                    1012,
                    763,
                    764,
                    1023
                ],
                "validate_bool_kwarg": [
                    835,
                    2436,
                    741,
                    1061,
                    1609,
                    972,
                    781,
                    1103,
                    1012,
                    763,
                    924
                ],
                "value": [
                    2442,
                    2445,
                    1704,
                    1705,
                    1708,
                    1709,
                    1722,
                    1731,
                    1349,
                    1350,
                    1735,
                    1736,
                    1353,
                    1739,
                    1745,
                    1746,
                    1752,
                    1755,
                    1760,
                    2020,
                    742,
                    2023,
                    2024,
                    2029,
                    2031,
                    2033,
                    2035
                ],
                "cat._dtype": [
                    744,
                    1024,
                    1114,
                    852
                ],
                "self.set_ordered": [
                    764,
                    782
                ],
                "new_categories": [
                    2689,
                    2693,
                    927,
                    928,
                    929,
                    930,
                    932,
                    1189,
                    1192,
                    1067,
                    1198,
                    1199,
                    1072,
                    1078,
                    838,
                    973,
                    977,
                    1110,
                    1112,
                    1013,
                    1014,
                    1015,
                    1020,
                    1021
                ],
                "rename": [
                    841
                ],
                "cat.dtype.categories": [
                    842,
                    843,
                    1110
                ],
                "cat.dtype": [
                    842,
                    843,
                    1110
                ],
                "cat._codes": [
                    1025,
                    846,
                    1105,
                    851,
                    2259,
                    1115,
                    2460
                ],
                "cat.codes": [
                    849,
                    2747
                ],
                "is_dict_like": [
                    927
                ],
                "new_categories.get": [
                    928
                ],
                "item": [
                    928,
                    930
                ],
                "self.set_categories": [
                    977,
                    1077
                ],
                "already_included": [
                    1016,
                    1018,
                    1015
                ],
                "removals": [
                    1070,
                    1065,
                    1062,
                    1063
                ],
                "removal_set": [
                    1065,
                    1066,
                    1067
                ],
                "not_included": [
                    1066,
                    1075,
                    1074,
                    1071
                ],
                "c": [
                    1067
                ],
                "x": [
                    1072,
                    1353,
                    1923,
                    1071
                ],
                "notna": [
                    1072,
                    1399,
                    1071
                ],
                "inv": [
                    1105,
                    1115,
                    1108
                ],
                "np.unique": [
                    1105
                ],
                "idx.size": [
                    1107
                ],
                "cat.dtype.categories.take": [
                    1110
                ],
                "self.categories.map": [
                    1189
                ],
                "mapper": [
                    1189
                ],
                "self.from_codes": [
                    1260,
                    1191
                ],
                "np.any": [
                    1197
                ],
                "new_categories.insert": [
                    1198
                ],
                "np.nan": [
                    2149,
                    2184,
                    1641,
                    1709,
                    1198,
                    1998,
                    1465,
                    1467
                ],
                "np.take": [
                    1199
                ],
                "__eq__": [
                    1201
                ],
                "_cat_compare_op": [
                    1201,
                    1202,
                    1203,
                    1204,
                    1205,
                    1206
                ],
                "operator.eq": [
                    1201
                ],
                "operator": [
                    1201,
                    1202,
                    1203,
                    1204,
                    1205,
                    1206
                ],
                "__ne__": [
                    1202
                ],
                "operator.ne": [
                    1202
                ],
                "__lt__": [
                    1203
                ],
                "operator.lt": [
                    1203
                ],
                "__gt__": [
                    1204
                ],
                "operator.gt": [
                    1204
                ],
                "__le__": [
                    1205
                ],
                "operator.le": [
                    1205
                ],
                "__ge__": [
                    1206
                ],
                "operator.ge": [
                    1206
                ],
                "codes.ndim": [
                    1242
                ],
                "np.prod": [
                    1244
                ],
                "codes.shape": [
                    1244
                ],
                "periods": [
                    1255,
                    1256,
                    1258,
                    1244,
                    1245
                ],
                "np.roll": [
                    1245
                ],
                "ensure_platform_int": [
                    1245
                ],
                "fill_value": [
                    1248,
                    1249,
                    1252,
                    1256,
                    1864,
                    1258,
                    1840,
                    1841,
                    1844,
                    1845,
                    1848,
                    1853,
                    1246,
                    1247
                ],
                "take_1d": [
                    1273,
                    2695
                ],
                "self.categories.values": [
                    1273
                ],
                "is_dtype_equal": [
                    2024,
                    1274,
                    2642
                ],
                "self.categories.dtype": [
                    1274,
                    1723,
                    1931
                ],
                "result": [
                    1411,
                    1285,
                    1413,
                    1288,
                    1289,
                    2332,
                    2333,
                    2334,
                    2336,
                    1965,
                    1966,
                    1974,
                    1976,
                    1979,
                    1981,
                    1854,
                    1855,
                    2109,
                    2110,
                    2004,
                    2005,
                    2006,
                    2007,
                    2008,
                    1897,
                    1899,
                    1901
                ],
                "ops.maybe_dispatch_ufunc_to_dunder_op": [
                    1285
                ],
                "ops": [
                    1285
                ],
                "ufunc": [
                    1286,
                    1295
                ],
                "method": [
                    2629,
                    1286,
                    2630,
                    1704,
                    1705,
                    1718,
                    1722
                ],
                "inputs": [
                    1286
                ],
                "kwargs": [
                    2630,
                    2117,
                    1533,
                    1286
                ],
                "ufunc.__name__": [
                    1295
                ],
                "state": [
                    1304,
                    1306,
                    1300,
                    1303
                ],
                "k": [
                    1306,
                    1307
                ],
                "state.items": [
                    1306
                ],
                "self._codes.nbytes": [
                    1318,
                    1343
                ],
                "self.dtype.categories.values.nbytes": [
                    1318
                ],
                "self.dtype.categories.values": [
                    1318
                ],
                "self.dtype.categories.memory_usage": [
                    1343
                ],
                "deep": [
                    1343
                ],
                "self.codes.dtype.type": [
                    1351
                ],
                "self.codes.dtype": [
                    1354,
                    1351
                ],
                "locs": [
                    1353,
                    1354
                ],
                "self.codes.searchsorted": [
                    1355
                ],
                "side": [
                    1355
                ],
                "sorter": [
                    1355
                ],
                "doc": [
                    1345
                ],
                "_shared_docs": [
                    1345
                ],
                "isnull": [
                    1377
                ],
                "notnull": [
                    1399
                ],
                "self.notna": [
                    1411
                ],
                "code": [
                    1441,
                    1444,
                    1436,
                    1437
                ],
                "ncat": [
                    1442,
                    1444,
                    1437,
                    1438
                ],
                "ix": [
                    1449,
                    1445,
                    1438,
                    1447
                ],
                "clean": [
                    1440,
                    1441,
                    1438
                ],
                "np.arange": [
                    2738,
                    1438
                ],
                "mask.all": [
                    1438
                ],
                "dropna": [
                    1440,
                    2210,
                    2207
                ],
                "obs": [
                    1441,
                    1442
                ],
                "count": [
                    1449,
                    1442,
                    1444
                ],
                "np.bincount": [
                    1442,
                    1444
                ],
                "np.append": [
                    1445
                ],
                "Series": [
                    1648,
                    1449,
                    2632,
                    2624
                ],
                "CategoricalIndex": [
                    1449
                ],
                "needs_i8_conversion": [
                    1464
                ],
                "self.categories.take": [
                    1465
                ],
                "take": [
                    1467,
                    1853
                ],
                "self.categories.astype": [
                    1467
                ],
                "argsort": [
                    1533
                ],
                "ascending": [
                    1613,
                    1533
                ],
                "kind": [
                    1533
                ],
                "na_position": [
                    1610,
                    1611,
                    1613
                ],
                "sorted_idx": [
                    1616,
                    1619,
                    1613
                ],
                "nargsort": [
                    1613
                ],
                "values.astype": [
                    1640
                ],
                "self.categories.is_numeric": [
                    1642
                ],
                "self.rename_categories": [
                    1648
                ],
                "rank": [
                    1648
                ],
                "warn": [
                    1859,
                    1667
                ],
                "validate_fillna_kwargs": [
                    1704
                ],
                "limit": [
                    1710
                ],
                "reshape": [
                    1721
                ],
                "astype": [
                    1722
                ],
                "interpolate_2d": [
                    1722
                ],
                "algorithms.isin": [
                    2407,
                    1735
                ],
                "algorithms": [
                    2407,
                    1735
                ],
                "values_codes": [
                    1739,
                    1742
                ],
                "indexer": [
                    1987,
                    1988,
                    1989,
                    2692,
                    2695,
                    1864,
                    1836,
                    1740,
                    1742,
                    1853
                ],
                "codes.copy": [
                    2688,
                    2691,
                    2695,
                    1741,
                    1751
                ],
                "is_hashable": [
                    1745
                ],
                "np.intp": [
                    1836
                ],
                "allow_fill": [
                    1864,
                    1842,
                    1853
                ],
                "from_codes": [
                    1854
                ],
                "self.take": [
                    1864
                ],
                "self._internal_get_values": [
                    1876
                ],
                "contains": [
                    1886
                ],
                "num": [
                    1893,
                    1894,
                    1895,
                    1915,
                    1916,
                    1917
                ],
                "max_vals": [
                    1893,
                    1895
                ],
                "head": [
                    1897,
                    1918,
                    1916,
                    1894
                ],
                "_get_repr": [
                    1894,
                    1895
                ],
                "tail": [
                    1897,
                    1917,
                    1918,
                    1895
                ],
                "footer": [
                    1898,
                    1963
                ],
                "self._repr_footer": [
                    1899
                ],
                "max_categories": [
                    1915,
                    1914,
                    1907
                ],
                "get_option": [
                    1934,
                    1909,
                    1910
                ],
                "fmt.format_array": [
                    1920,
                    1916,
                    1917
                ],
                "fmt": [
                    1920,
                    1962,
                    1916,
                    1917
                ],
                "category_strs": [
                    1920,
                    1923,
                    1924,
                    1930,
                    1943,
                    1918
                ],
                "x.strip": [
                    1923
                ],
                "self._repr_categories": [
                    1930
                ],
                "levheader": [
                    1953,
                    1932,
                    1940,
                    1945,
                    1946
                ],
                "width": [
                    1933,
                    1934
                ],
                "height": [
                    1933
                ],
                "get_terminal_size": [
                    1933
                ],
                "max_width": [
                    1944,
                    1937,
                    1934
                ],
                "console.in_ipython_frontend": [
                    1935
                ],
                "console": [
                    1935
                ],
                "levstring": [
                    1953,
                    1938,
                    1945,
                    1948,
                    1950
                ],
                "start": [
                    1939,
                    1947,
                    2108,
                    1951
                ],
                "cur_col_len": [
                    1944,
                    1946,
                    1940,
                    1949
                ],
                "sep_len": [
                    1944,
                    1941
                ],
                "sep": [
                    1948,
                    1941,
                    1942
                ],
                "linesep": [
                    1945,
                    1942
                ],
                "sep.rstrip": [
                    1942
                ],
                "val": [
                    1944,
                    1949,
                    1950,
                    1943
                ],
                "levstring.replace": [
                    1953
                ],
                "info": [
                    1956,
                    1957
                ],
                "self._repr_categories_info": [
                    1956
                ],
                "formatter": [
                    1962,
                    1965
                ],
                "fmt.CategoricalFormatter": [
                    1962
                ],
                "length": [
                    1963
                ],
                "na_rep": [
                    1963
                ],
                "formatter.to_string": [
                    1965
                ],
                "_maxlen": [
                    1976,
                    1972,
                    1973,
                    1974
                ],
                "self._tidy_repr": [
                    1974
                ],
                "self._get_repr": [
                    1976,
                    1978
                ],
                "replace": [
                    1978
                ],
                "indexer.dtype.kind": [
                    1987
                ],
                "indexer.dtype": [
                    1987
                ],
                "indexer.astype": [
                    1988
                ],
                "self._codes.dtype": [
                    1988
                ],
                "np.integer": [
                    2050,
                    1995
                ],
                "check_array_indexer": [
                    2002,
                    2075
                ],
                "result.ndim": [
                    2005
                ],
                "deprecate_ndim_indexing": [
                    2006
                ],
                "extract_array": [
                    2020,
                    2735
                ],
                "value.categories": [
                    2029,
                    2031
                ],
                "new_codes": [
                    2696,
                    2033,
                    2030,
                    2695
                ],
                "value.codes": [
                    2031
                ],
                "Categorical.from_codes": [
                    2033,
                    2739
                ],
                "rvalue": [
                    2072,
                    2035,
                    2039
                ],
                "to_add": [
                    2043,
                    2039
                ],
                "difference": [
                    2039
                ],
                "com.is_null_slice": [
                    2058
                ],
                "com": [
                    2058
                ],
                "lindexer": [
                    2072,
                    2073,
                    2076
                ],
                "self.categories.get_indexer": [
                    2072,
                    2405
                ],
                "self._maybe_coerce_indexer": [
                    2073
                ],
                "r": [
                    2104,
                    2108
                ],
                "counts": [
                    2328,
                    2332,
                    2327,
                    2104,
                    2107,
                    2108
                ],
                "libalgos.groupsort_indexer": [
                    2104
                ],
                "libalgos": [
                    2104
                ],
                "self.codes.astype": [
                    2105,
                    2268
                ],
                "categories.size": [
                    2105
                ],
                "counts.cumsum": [
                    2107
                ],
                "_result": [
                    2108,
                    2109
                ],
                "end": [
                    2108
                ],
                "Dict": [
                    2078
                ],
                "Hashable": [
                    2078
                ],
                "name": [
                    2114,
                    2116,
                    2629,
                    2612,
                    2615
                ],
                "self.check_for_ordered": [
                    2139,
                    2174
                ],
                "self.dtype.na_value": [
                    2177,
                    2142
                ],
                "good": [
                    2144,
                    2145,
                    2208,
                    2147,
                    2179,
                    2180,
                    2182,
                    2209
                ],
                "good.all": [
                    2145,
                    2180
                ],
                "skipna": [
                    2146,
                    2181
                ],
                "pointer": [
                    2147,
                    2182,
                    2151,
                    2152,
                    2186,
                    2187
                ],
                "self._codes.min": [
                    2151
                ],
                "deprecate_kwarg": [
                    2154,
                    2119
                ],
                "self._codes.max": [
                    2186
                ],
                "htable.mode_int64": [
                    2210
                ],
                "htable": [
                    2210
                ],
                "ensure_int64": [
                    2210
                ],
                "unique_codes": [
                    2259,
                    2262,
                    2255
                ],
                "unique1d": [
                    2255
                ],
                "take_codes": [
                    2264,
                    2265,
                    2262
                ],
                "np.sort": [
                    2264
                ],
                "cat.set_categories": [
                    2265
                ],
                "cat.categories.take": [
                    2265
                ],
                "original._constructor": [
                    2273
                ],
                "original": [
                    2273,
                    2274
                ],
                "original.categories.take": [
                    2274
                ],
                "original.categories": [
                    2274
                ],
                "uniques": [
                    2274
                ],
                "original.dtype": [
                    2274
                ],
                "self.is_dtype_equal": [
                    2289
                ],
                "other.codes": [
                    2295
                ],
                "np.array_equal": [
                    2297
                ],
                "other.dtype": [
                    2314
                ],
                "self.value_counts": [
                    2327
                ],
                "freqs": [
                    2328,
                    2332
                ],
                "counts.sum": [
                    2328
                ],
                "concat": [
                    2332
                ],
                "result.columns": [
                    2333
                ],
                "result.index.name": [
                    2334
                ],
                "result.index": [
                    2334
                ],
                "nv.validate_repeat": [
                    2341
                ],
                "nv": [
                    2341
                ],
                "axis": [
                    2341
                ],
                "self._codes.repeat": [
                    2342
                ],
                "repeats": [
                    2342
                ],
                "Substitution": [
                    2338
                ],
                "Appender": [
                    2339
                ],
                "_extension_array_shared_docs": [
                    2339
                ],
                "concat_categorical": [
                    2354
                ],
                "to_concat": [
                    2354
                ],
                "values_type": [
                    2401,
                    2398
                ],
                "code_values": [
                    2405,
                    2406,
                    2407
                ],
                "to_replace": [
                    2440,
                    2442,
                    2445
                ],
                "replace_dict": [
                    2449,
                    2442,
                    2445
                ],
                "replace_value": [
                    2442,
                    2449,
                    2450,
                    2452,
                    2454,
                    2457,
                    2461
                ],
                "new_value": [
                    2449,
                    2450,
                    2453,
                    2458,
                    2459,
                    2463
                ],
                "replace_dict.items": [
                    2449
                ],
                "cat.remove_categories": [
                    2461,
                    2454
                ],
                "cat.categories.tolist": [
                    2456
                ],
                "index": [
                    2457,
                    2460,
                    2463
                ],
                "categories.index": [
                    2457,
                    2459
                ],
                "value_index": [
                    2459,
                    2460
                ],
                "cat.rename_categories": [
                    2464
                ],
                "PandasDelegate": [
                    2489
                ],
                "NoNewAttributesMixin": [
                    2489
                ],
                "self._validate": [
                    2600
                ],
                "data": [
                    2600,
                    2601,
                    2602,
                    2603,
                    2608
                ],
                "self._parent": [
                    2624,
                    2629,
                    2601,
                    2612,
                    2615
                ],
                "data.values": [
                    2601
                ],
                "self._index": [
                    2624,
                    2602,
                    2632
                ],
                "data.index": [
                    2602
                ],
                "self._name": [
                    2632,
                    2603
                ],
                "data.name": [
                    2603
                ],
                "self._freeze": [
                    2604
                ],
                "data.dtype": [
                    2608
                ],
                "new_values": [
                    2615
                ],
                "self._parent.codes": [
                    2624
                ],
                "res": [
                    2632,
                    2630,
                    2631
                ],
                "args": [
                    2630
                ],
                "delegate_names": [
                    2472,
                    2475
                ],
                "dtype_equal": [
                    2642,
                    2654
                ],
                "categories.dtype": [
                    2648,
                    2642,
                    2644
                ],
                "is_object_dtype": [
                    2644
                ],
                "categories.dtype.construct_array_type": [
                    2648
                ],
                "maybe_cast_to_extension_array": [
                    2649
                ],
                "ensure_object": [
                    2656,
                    2652,
                    2653,
                    2655
                ],
                "hash_klass": [
                    2658,
                    2660
                ],
                "vals": [
                    2658,
                    2662
                ],
                "_get_data_algo": [
                    2658,
                    2659
                ],
                "_": [
                    2659
                ],
                "t": [
                    2660,
                    2661,
                    2662
                ],
                "t.map_locations": [
                    2661
                ],
                "t.lookup": [
                    2662
                ],
                "old_categories": [
                    2689,
                    2693,
                    2686
                ],
                "new_categories.equals": [
                    2689
                ],
                "new_categories.get_indexer": [
                    2693
                ],
                "list_like": [
                    2700,
                    2701,
                    2702,
                    2703,
                    2704,
                    2705,
                    2706,
                    2707,
                    2710
                ],
                "is_sequence": [
                    2704
                ],
                "is_iterator": [
                    2704
                ],
                "cat_codes": [
                    2738,
                    2739
                ],
                "values.codes.dtype": [
                    2738
                ],
                "iterables": [
                    2770,
                    2773
                ],
                "factorize_from_iterable": [
                    2773
                ],
                "it": [
                    2773
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_26/pandas/tests/arrays/categorical/test_analytics.py",
                "test_function": "test_min_max_only_nan",
                "test_function_code": "    @pytest.mark.parametrize(\"function\", [\"min\", \"max\"])\n    @pytest.mark.parametrize(\"skipna\", [True, False])\n    def test_min_max_only_nan(self, function, skipna):\n        # https://github.com/pandas-dev/pandas/issues/33450\n        cat = Categorical([np.nan], categories=[1, 2], ordered=True)\n        result = getattr(cat, function)(skipna=skipna)\n        assert result is np.nan",
                "test_error": "ValueError: zero-size array to reduction operation minimum which has no identity",
                "full_test_error": "self = <pandas.tests.arrays.categorical.test_analytics.TestCategoricalAnalytics object at 0x11ea1f9d0>\nfunction = 'min', skipna = True\n\n    @pytest.mark.parametrize(\"function\", [\"min\", \"max\"])\n    @pytest.mark.parametrize(\"skipna\", [True, False])\n    def test_min_max_only_nan(self, function, skipna):\n        # https://github.com/pandas-dev/pandas/issues/33450\n        cat = Categorical([np.nan], categories=[1, 2], ordered=True)\n>       result = getattr(cat, function)(skipna=skipna)\n\npandas/tests/arrays/categorical/test_analytics.py:96: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/util/_decorators.py:199: in wrapper\n    return func(*args, **kwargs)\npandas/core/arrays/categorical.py:2147: in min\n    pointer = self._codes[good].min()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\na = array([], dtype=int8), axis = None, out = None, keepdims = False\ninitial = <no value>, where = True\n\n    def _amin(a, axis=None, out=None, keepdims=False,\n              initial=_NoValue, where=True):\n>       return umr_minimum(a, axis, None, out, keepdims, initial, where)\nE       ValueError: zero-size array to reduction operation minimum which has no identity\n\n../../envs/pandas_26/lib/python3.8/site-packages/numpy/core/_methods.py:34: ValueError",
                "traceback": "pandas/util/_decorators.py:199: in wrapper\n    return func(*args, **kwargs)\npandas/core/arrays/categorical.py:2147: in min\n    pointer = self._codes[good].min()",
                "test_error_location": "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\na = array([], dtype=int8), axis = None, out = None, keepdims = False\ninitial = <no value>, where = True\n\n    def _amin(a, axis=None, out=None, keepdims=False,\n              initial=_NoValue, where=True):\n>       return umr_minimum(a, axis, None, out, keepdims, initial, where)\nE       ValueError: zero-size array to reduction operation minimum which has no identity\n\n../../envs/pandas_26/lib/python3.8/site-packages/numpy/core/_methods.py:34: ValueError",
                "test_function_decorators": [
                    "pytest.mark.parametrize('function', ['min', 'max'])",
                    "pytest.mark.parametrize('skipna', [True, False])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_26/pandas/tests/arrays/categorical/test_analytics.py",
                "test_function": "test_min_max_only_nan",
                "test_function_code": "    @pytest.mark.parametrize(\"function\", [\"min\", \"max\"])\n    @pytest.mark.parametrize(\"skipna\", [True, False])\n    def test_min_max_only_nan(self, function, skipna):\n        # https://github.com/pandas-dev/pandas/issues/33450\n        cat = Categorical([np.nan], categories=[1, 2], ordered=True)\n        result = getattr(cat, function)(skipna=skipna)\n        assert result is np.nan",
                "test_error": "ValueError: zero-size array to reduction operation maximum which has no identity",
                "full_test_error": "self = <pandas.tests.arrays.categorical.test_analytics.TestCategoricalAnalytics object at 0x11ed37640>\nfunction = 'max', skipna = True\n\n    @pytest.mark.parametrize(\"function\", [\"min\", \"max\"])\n    @pytest.mark.parametrize(\"skipna\", [True, False])\n    def test_min_max_only_nan(self, function, skipna):\n        # https://github.com/pandas-dev/pandas/issues/33450\n        cat = Categorical([np.nan], categories=[1, 2], ordered=True)\n>       result = getattr(cat, function)(skipna=skipna)\n\npandas/tests/arrays/categorical/test_analytics.py:96: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/util/_decorators.py:199: in wrapper\n    return func(*args, **kwargs)\npandas/core/arrays/categorical.py:2182: in max\n    pointer = self._codes[good].max()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\na = array([], dtype=int8), axis = None, out = None, keepdims = False\ninitial = <no value>, where = True\n\n    def _amax(a, axis=None, out=None, keepdims=False,\n              initial=_NoValue, where=True):\n>       return umr_maximum(a, axis, None, out, keepdims, initial, where)\nE       ValueError: zero-size array to reduction operation maximum which has no identity\n\n../../envs/pandas_26/lib/python3.8/site-packages/numpy/core/_methods.py:30: ValueError",
                "traceback": "pandas/util/_decorators.py:199: in wrapper\n    return func(*args, **kwargs)\npandas/core/arrays/categorical.py:2182: in max\n    pointer = self._codes[good].max()",
                "test_error_location": "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\na = array([], dtype=int8), axis = None, out = None, keepdims = False\ninitial = <no value>, where = True\n\n    def _amax(a, axis=None, out=None, keepdims=False,\n              initial=_NoValue, where=True):\n>       return umr_maximum(a, axis, None, out, keepdims, initial, where)\nE       ValueError: zero-size array to reduction operation maximum which has no identity\n\n../../envs/pandas_26/lib/python3.8/site-packages/numpy/core/_methods.py:30: ValueError",
                "test_function_decorators": [
                    "pytest.mark.parametrize('function', ['min', 'max'])",
                    "pytest.mark.parametrize('skipna', [True, False])"
                ]
            }
        ]
    }
}