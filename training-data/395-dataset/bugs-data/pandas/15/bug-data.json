{
    "pandas:15": {
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_15/pandas/core/arrays/datetimelike.py": {
            "buggy_functions": [
                {
                    "function_name": "_datetimelike_array_cmp",
                    "function_code": "def _datetimelike_array_cmp(cls, op):\n    \"\"\"\n    Wrap comparison operations to convert Timestamp/Timedelta/Period-like to\n    boxed scalars/arrays.\n    \"\"\"\n    opname = f\"__{op.__name__}__\"\n    nat_result = opname == \"__ne__\"\n\n    class InvalidComparison(Exception):\n        pass\n\n    def _validate_comparison_value(self, other):\n        if isinstance(other, str):\n            try:\n                # GH#18435 strings get a pass from tzawareness compat\n                other = self._scalar_from_string(other)\n            except ValueError:\n                # failed to parse as Timestamp/Timedelta/Period\n                raise InvalidComparison(other)\n\n        if isinstance(other, self._recognized_scalars) or other is NaT:\n            other = self._scalar_type(other)\n            self._check_compatible_with(other)\n\n        elif not is_list_like(other):\n            raise InvalidComparison(other)\n\n        elif len(other) != len(self):\n            raise ValueError(\"Lengths must match\")\n\n        else:\n            if isinstance(other, list):\n                # TODO: could use pd.Index to do inference?\n                other = np.array(other)\n\n            if not isinstance(other, (np.ndarray, type(self))):\n                raise InvalidComparison(other)\n\n            elif is_object_dtype(other.dtype):\n                pass\n\n            elif not type(self)._is_recognized_dtype(other.dtype):\n                raise InvalidComparison(other)\n\n            else:\n                # For PeriodDType this casting is unnecessary\n                # TODO: use Index to do inference?\n                other = type(self)._from_sequence(other)\n                self._check_compatible_with(other)\n\n        return other\n\n    @unpack_zerodim_and_defer(opname)\n    def wrapper(self, other):\n\n        try:\n            other = _validate_comparison_value(self, other)\n        except InvalidComparison:\n            return invalid_comparison(self, other, op)\n\n        dtype = getattr(other, \"dtype\", None)\n        if is_object_dtype(dtype):\n            # We have to use comp_method_OBJECT_ARRAY instead of numpy\n            #  comparison otherwise it would fail to raise when\n            #  comparing tz-aware and tz-naive\n            with np.errstate(all=\"ignore\"):\n                result = ops.comp_method_OBJECT_ARRAY(op, self.astype(object), other)\n            return result\n\n        if isinstance(other, self._scalar_type) or other is NaT:\n            other_i8 = self._unbox_scalar(other)\n        else:\n            # Then type(other) == type(self)\n            other_i8 = other.asi8\n\n        result = op(self.asi8, other_i8)\n\n        o_mask = isna(other)\n        if self._hasnans | np.any(o_mask):\n            result[self._isnan | o_mask] = nat_result\n\n        return result\n\n    return set_function_name(wrapper, opname, cls)\n",
                    "decorators": [],
                    "docstring": "Wrap comparison operations to convert Timestamp/Timedelta/Period-like to\nboxed scalars/arrays.",
                    "start_line": 56,
                    "variables": {
                        "opname": [
                            139,
                            108,
                            61,
                            62
                        ],
                        "op.__name__": [
                            61
                        ],
                        "op": [
                            114,
                            131,
                            61,
                            122
                        ],
                        "nat_result": [
                            62,
                            135
                        ],
                        "Exception": [
                            64
                        ],
                        "isinstance": [
                            68,
                            76,
                            87,
                            91,
                            125
                        ],
                        "other": [
                            129,
                            133,
                            68,
                            71,
                            74,
                            76,
                            77,
                            78,
                            80,
                            81,
                            83,
                            87,
                            89,
                            91,
                            92,
                            94,
                            97,
                            98,
                            103,
                            104,
                            106,
                            112,
                            114,
                            116,
                            122,
                            125,
                            126
                        ],
                        "str": [
                            68
                        ],
                        "self._scalar_from_string": [
                            71
                        ],
                        "self": [
                            97,
                            131,
                            134,
                            71,
                            103,
                            104,
                            135,
                            76,
                            77,
                            78,
                            112,
                            114,
                            83,
                            122,
                            91,
                            125,
                            126
                        ],
                        "ValueError": [
                            72,
                            84
                        ],
                        "InvalidComparison": [
                            98,
                            74,
                            81,
                            113,
                            92
                        ],
                        "self._recognized_scalars": [
                            76
                        ],
                        "NaT": [
                            76,
                            125
                        ],
                        "self._scalar_type": [
                            125,
                            77
                        ],
                        "self._check_compatible_with": [
                            104,
                            78
                        ],
                        "is_list_like": [
                            80
                        ],
                        "len": [
                            83
                        ],
                        "list": [
                            87
                        ],
                        "np.array": [
                            89
                        ],
                        "np": [
                            134,
                            89,
                            91,
                            121
                        ],
                        "np.ndarray": [
                            91
                        ],
                        "type": [
                            97,
                            91,
                            103
                        ],
                        "is_object_dtype": [
                            117,
                            94
                        ],
                        "other.dtype": [
                            97,
                            94
                        ],
                        "_is_recognized_dtype": [
                            97
                        ],
                        "_from_sequence": [
                            103
                        ],
                        "_validate_comparison_value": [
                            112
                        ],
                        "invalid_comparison": [
                            114
                        ],
                        "dtype": [
                            116,
                            117
                        ],
                        "getattr": [
                            116
                        ],
                        "np.errstate": [
                            121
                        ],
                        "result": [
                            131,
                            135,
                            137,
                            122,
                            123
                        ],
                        "ops.comp_method_OBJECT_ARRAY": [
                            122
                        ],
                        "ops": [
                            122
                        ],
                        "self.astype": [
                            122
                        ],
                        "object": [
                            122
                        ],
                        "other_i8": [
                            129,
                            131,
                            126
                        ],
                        "self._unbox_scalar": [
                            126
                        ],
                        "other.asi8": [
                            129
                        ],
                        "self.asi8": [
                            131
                        ],
                        "o_mask": [
                            133,
                            134,
                            135
                        ],
                        "isna": [
                            133
                        ],
                        "self._hasnans": [
                            134
                        ],
                        "np.any": [
                            134
                        ],
                        "self._isnan": [
                            135
                        ],
                        "unpack_zerodim_and_defer": [
                            108
                        ],
                        "set_function_name": [
                            139
                        ],
                        "wrapper": [
                            139
                        ],
                        "cls": [
                            139
                        ]
                    },
                    "filtered_variables": {
                        "opname": [
                            139,
                            108,
                            61,
                            62
                        ],
                        "op.__name__": [
                            61
                        ],
                        "op": [
                            114,
                            131,
                            61,
                            122
                        ],
                        "nat_result": [
                            62,
                            135
                        ],
                        "other": [
                            129,
                            133,
                            68,
                            71,
                            74,
                            76,
                            77,
                            78,
                            80,
                            81,
                            83,
                            87,
                            89,
                            91,
                            92,
                            94,
                            97,
                            98,
                            103,
                            104,
                            106,
                            112,
                            114,
                            116,
                            122,
                            125,
                            126
                        ],
                        "self._scalar_from_string": [
                            71
                        ],
                        "self": [
                            97,
                            131,
                            134,
                            71,
                            103,
                            104,
                            135,
                            76,
                            77,
                            78,
                            112,
                            114,
                            83,
                            122,
                            91,
                            125,
                            126
                        ],
                        "InvalidComparison": [
                            98,
                            74,
                            81,
                            113,
                            92
                        ],
                        "self._recognized_scalars": [
                            76
                        ],
                        "NaT": [
                            76,
                            125
                        ],
                        "self._scalar_type": [
                            125,
                            77
                        ],
                        "self._check_compatible_with": [
                            104,
                            78
                        ],
                        "is_list_like": [
                            80
                        ],
                        "np.array": [
                            89
                        ],
                        "np": [
                            134,
                            89,
                            91,
                            121
                        ],
                        "np.ndarray": [
                            91
                        ],
                        "is_object_dtype": [
                            117,
                            94
                        ],
                        "other.dtype": [
                            97,
                            94
                        ],
                        "_is_recognized_dtype": [
                            97
                        ],
                        "_from_sequence": [
                            103
                        ],
                        "_validate_comparison_value": [
                            112
                        ],
                        "invalid_comparison": [
                            114
                        ],
                        "dtype": [
                            116,
                            117
                        ],
                        "np.errstate": [
                            121
                        ],
                        "result": [
                            131,
                            135,
                            137,
                            122,
                            123
                        ],
                        "ops.comp_method_OBJECT_ARRAY": [
                            122
                        ],
                        "ops": [
                            122
                        ],
                        "self.astype": [
                            122
                        ],
                        "other_i8": [
                            129,
                            131,
                            126
                        ],
                        "self._unbox_scalar": [
                            126
                        ],
                        "other.asi8": [
                            129
                        ],
                        "self.asi8": [
                            131
                        ],
                        "o_mask": [
                            133,
                            134,
                            135
                        ],
                        "isna": [
                            133
                        ],
                        "self._hasnans": [
                            134
                        ],
                        "np.any": [
                            134
                        ],
                        "self._isnan": [
                            135
                        ],
                        "unpack_zerodim_and_defer": [
                            108
                        ],
                        "set_function_name": [
                            139
                        ],
                        "wrapper": [
                            139
                        ],
                        "cls": [
                            139
                        ]
                    },
                    "diff_line_number": 56,
                    "class_data": null,
                    "variable_values": [
                        [
                            {
                                "opname": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "op.__name__": {
                                    "variable_value": "'eq'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function eq>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "InvalidComparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_validate_comparison_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10c8ea950>"
                                }
                            },
                            {
                                "opname": {
                                    "variable_value": "'__eq__'",
                                    "variable_type": "str",
                                    "variable_shape": "6"
                                },
                                "op.__name__": {
                                    "variable_value": "'eq'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function eq>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "InvalidComparison": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike._datetimelike_array_cmp.<locals>.InvalidComparison'>",
                                    "variable_type": "type",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_validate_comparison_value": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>._validate_comparison_value at 0x10d20a310>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>.wrapper at 0x10d20a4c0>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10c8ea950>"
                                }
                            }
                        ],
                        [
                            {
                                "opname": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "op.__name__": {
                                    "variable_value": "'ne'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function ne>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "InvalidComparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_validate_comparison_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10c8ea950>"
                                }
                            },
                            {
                                "opname": {
                                    "variable_value": "'__ne__'",
                                    "variable_type": "str",
                                    "variable_shape": "6"
                                },
                                "op.__name__": {
                                    "variable_value": "'ne'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function ne>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "InvalidComparison": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike._datetimelike_array_cmp.<locals>.InvalidComparison'>",
                                    "variable_type": "type",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_validate_comparison_value": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>._validate_comparison_value at 0x10d20a940>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>.wrapper at 0x10d20aaf0>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10c8ea950>"
                                }
                            }
                        ],
                        [
                            {
                                "opname": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "op.__name__": {
                                    "variable_value": "'lt'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function lt>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "InvalidComparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_validate_comparison_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10c8ea950>"
                                }
                            },
                            {
                                "opname": {
                                    "variable_value": "'__lt__'",
                                    "variable_type": "str",
                                    "variable_shape": "6"
                                },
                                "op.__name__": {
                                    "variable_value": "'lt'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function lt>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "InvalidComparison": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike._datetimelike_array_cmp.<locals>.InvalidComparison'>",
                                    "variable_type": "type",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_validate_comparison_value": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>._validate_comparison_value at 0x10d20af70>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>.wrapper at 0x10d211160>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10c8ea950>"
                                }
                            }
                        ],
                        [
                            {
                                "opname": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "op.__name__": {
                                    "variable_value": "'gt'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function gt>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "InvalidComparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_validate_comparison_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10c8ea950>"
                                }
                            },
                            {
                                "opname": {
                                    "variable_value": "'__gt__'",
                                    "variable_type": "str",
                                    "variable_shape": "6"
                                },
                                "op.__name__": {
                                    "variable_value": "'gt'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function gt>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "InvalidComparison": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike._datetimelike_array_cmp.<locals>.InvalidComparison'>",
                                    "variable_type": "type",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_validate_comparison_value": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>._validate_comparison_value at 0x10d20adc0>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>.wrapper at 0x10d20ad30>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10c8ea950>"
                                }
                            }
                        ],
                        [
                            {
                                "opname": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "op.__name__": {
                                    "variable_value": "'le'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function le>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "InvalidComparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_validate_comparison_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10c8ea950>"
                                }
                            },
                            {
                                "opname": {
                                    "variable_value": "'__le__'",
                                    "variable_type": "str",
                                    "variable_shape": "6"
                                },
                                "op.__name__": {
                                    "variable_value": "'le'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function le>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "InvalidComparison": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike._datetimelike_array_cmp.<locals>.InvalidComparison'>",
                                    "variable_type": "type",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_validate_comparison_value": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>._validate_comparison_value at 0x10d20a700>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>.wrapper at 0x10d20a670>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10c8ea950>"
                                }
                            }
                        ],
                        [
                            {
                                "opname": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "op.__name__": {
                                    "variable_value": "'ge'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function ge>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "InvalidComparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_validate_comparison_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10c8ea950>"
                                }
                            },
                            {
                                "opname": {
                                    "variable_value": "'__ge__'",
                                    "variable_type": "str",
                                    "variable_shape": "6"
                                },
                                "op.__name__": {
                                    "variable_value": "'ge'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function ge>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "InvalidComparison": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike._datetimelike_array_cmp.<locals>.InvalidComparison'>",
                                    "variable_type": "type",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_validate_comparison_value": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>._validate_comparison_value at 0x10d211310>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>.wrapper at 0x10d211670>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10c8ea950>"
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "opname": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "op.__name__": {
                                    "variable_value": "'eq'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function eq>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "InvalidComparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_validate_comparison_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10a77da40>"
                                }
                            },
                            {
                                "opname": {
                                    "variable_value": "'__eq__'",
                                    "variable_type": "str",
                                    "variable_shape": "6"
                                },
                                "op.__name__": {
                                    "variable_value": "'eq'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function eq>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "InvalidComparison": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike._datetimelike_array_cmp.<locals>.InvalidComparison'>",
                                    "variable_type": "type",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_validate_comparison_value": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>._validate_comparison_value at 0x10b09d310>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>.wrapper at 0x10b09d4c0>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10a77da40>"
                                }
                            }
                        ],
                        [
                            {
                                "opname": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "op.__name__": {
                                    "variable_value": "'ne'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function ne>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "InvalidComparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_validate_comparison_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10a77da40>"
                                }
                            },
                            {
                                "opname": {
                                    "variable_value": "'__ne__'",
                                    "variable_type": "str",
                                    "variable_shape": "6"
                                },
                                "op.__name__": {
                                    "variable_value": "'ne'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function ne>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "InvalidComparison": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike._datetimelike_array_cmp.<locals>.InvalidComparison'>",
                                    "variable_type": "type",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_validate_comparison_value": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>._validate_comparison_value at 0x10b09d940>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>.wrapper at 0x10b09daf0>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10a77da40>"
                                }
                            }
                        ],
                        [
                            {
                                "opname": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "op.__name__": {
                                    "variable_value": "'lt'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function lt>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "InvalidComparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_validate_comparison_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10a77da40>"
                                }
                            },
                            {
                                "opname": {
                                    "variable_value": "'__lt__'",
                                    "variable_type": "str",
                                    "variable_shape": "6"
                                },
                                "op.__name__": {
                                    "variable_value": "'lt'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function lt>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "InvalidComparison": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike._datetimelike_array_cmp.<locals>.InvalidComparison'>",
                                    "variable_type": "type",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_validate_comparison_value": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>._validate_comparison_value at 0x10b09df70>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>.wrapper at 0x10b0a5160>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10a77da40>"
                                }
                            }
                        ],
                        [
                            {
                                "opname": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "op.__name__": {
                                    "variable_value": "'gt'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function gt>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "InvalidComparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_validate_comparison_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10a77da40>"
                                }
                            },
                            {
                                "opname": {
                                    "variable_value": "'__gt__'",
                                    "variable_type": "str",
                                    "variable_shape": "6"
                                },
                                "op.__name__": {
                                    "variable_value": "'gt'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function gt>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "InvalidComparison": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike._datetimelike_array_cmp.<locals>.InvalidComparison'>",
                                    "variable_type": "type",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_validate_comparison_value": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>._validate_comparison_value at 0x10b09ddc0>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>.wrapper at 0x10b09dd30>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10a77da40>"
                                }
                            }
                        ],
                        [
                            {
                                "opname": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "op.__name__": {
                                    "variable_value": "'le'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function le>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "InvalidComparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_validate_comparison_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10a77da40>"
                                }
                            },
                            {
                                "opname": {
                                    "variable_value": "'__le__'",
                                    "variable_type": "str",
                                    "variable_shape": "6"
                                },
                                "op.__name__": {
                                    "variable_value": "'le'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function le>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "InvalidComparison": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike._datetimelike_array_cmp.<locals>.InvalidComparison'>",
                                    "variable_type": "type",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_validate_comparison_value": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>._validate_comparison_value at 0x10b09d700>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>.wrapper at 0x10b09d670>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10a77da40>"
                                }
                            }
                        ],
                        [
                            {
                                "opname": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "op.__name__": {
                                    "variable_value": "'ge'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function ge>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "InvalidComparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_validate_comparison_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10a77da40>"
                                }
                            },
                            {
                                "opname": {
                                    "variable_value": "'__ge__'",
                                    "variable_type": "str",
                                    "variable_shape": "6"
                                },
                                "op.__name__": {
                                    "variable_value": "'ge'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function ge>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "InvalidComparison": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike._datetimelike_array_cmp.<locals>.InvalidComparison'>",
                                    "variable_type": "type",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_validate_comparison_value": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>._validate_comparison_value at 0x10b0a5310>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.asi8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>.wrapper at 0x10b0a5670>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10a77da40>"
                                }
                            }
                        ]
                    ]
                },
                {
                    "function_name": "_simple_new",
                    "function_code": "@classmethod\ndef _simple_new(cls, values: np.ndarray, **kwargs):\n    raise AbstractMethodError(cls)\n",
                    "decorators": [
                        "classmethod"
                    ],
                    "docstring": null,
                    "start_line": 145,
                    "variables": {
                        "np.ndarray": [
                            146
                        ],
                        "np": [
                            146
                        ],
                        "AbstractMethodError": [
                            147
                        ],
                        "cls": [
                            147
                        ],
                        "classmethod": [
                            145
                        ]
                    },
                    "filtered_variables": {
                        "np.ndarray": [
                            146
                        ],
                        "np": [
                            146
                        ],
                        "AbstractMethodError": [
                            147
                        ],
                        "cls": [
                            147
                        ]
                    },
                    "diff_line_number": 146,
                    "class_data": {
                        "signature": "class AttributesMixin()",
                        "docstring": null,
                        "constructor_docstring": null,
                        "functions": [
                            "@classmethod\ndef _simple_new(cls, values: np.ndarray, **kwargs):\n    raise AbstractMethodError(cls)",
                            "@property\ndef _scalar_type(self) -> Type[DatetimeLikeScalar]:\n    \"\"\"\n    The scalar associated with this datelike\n\n    * PeriodArray : Period\n    * DatetimeArray : Timestamp\n    * TimedeltaArray : Timedelta\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _scalar_from_string(self, value: str) -> Union[Period, Timestamp, Timedelta, NaTType]:\n    \"\"\"\n    Construct a scalar type from a string.\n\n    Parameters\n    ----------\n    value : str\n\n    Returns\n    -------\n    Period, Timestamp, or Timedelta, or NaT\n        Whatever the type of ``self._scalar_type`` is.\n\n    Notes\n    -----\n    This should call ``self._check_compatible_with`` before\n    unboxing the result.\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _unbox_scalar(self, value: Union[Period, Timestamp, Timedelta, NaTType]) -> int:\n    \"\"\"\n    Unbox the integer value of a scalar `value`.\n\n    Parameters\n    ----------\n    value : Union[Period, Timestamp, Timedelta]\n\n    Returns\n    -------\n    int\n\n    Examples\n    --------\n    >>> self._unbox_scalar(Timedelta(\"10s\"))  # doctest: +SKIP\n    10000000000\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _check_compatible_with(self, other: Union[Period, Timestamp, Timedelta, NaTType], setitem: bool=False) -> None:\n    \"\"\"\n    Verify that `self` and `other` are compatible.\n\n    * DatetimeArray verifies that the timezones (if any) match\n    * PeriodArray verifies that the freq matches\n    * Timedelta has no verification\n\n    In each case, NaT is considered compatible.\n\n    Parameters\n    ----------\n    other\n    setitem : bool, default False\n        For __setitem__ we may have stricter compatibility resrictions than\n        for comparisons.\n\n    Raises\n    ------\n    Exception\n    \"\"\"\n    raise AbstractMethodError(self)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_data"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_simple_new(cls, values: np.ndarray, **kwargs)",
                            "_scalar_type(self) -> Type[DatetimeLikeScalar]",
                            "_scalar_from_string(self, value: str) -> Union[Period, Timestamp, Timedelta, NaTType]",
                            "_unbox_scalar(self, value: Union[Period, Timestamp, Timedelta, NaTType]) -> int",
                            "_check_compatible_with(self, other: Union[Period, Timestamp, Timedelta, NaTType], setitem: bool=False) -> None"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_scalar_type",
                    "function_code": "@property\ndef _scalar_type(self) -> Type[DatetimeLikeScalar]:\n    \"\"\"\n    The scalar associated with this datelike\n\n    * PeriodArray : Period\n    * DatetimeArray : Timestamp\n    * TimedeltaArray : Timedelta\n    \"\"\"\n    raise AbstractMethodError(self)\n",
                    "decorators": [
                        "property"
                    ],
                    "docstring": "The scalar associated with this datelike\n\n* PeriodArray : Period\n* DatetimeArray : Timestamp\n* TimedeltaArray : Timedelta",
                    "start_line": 149,
                    "variables": {
                        "AbstractMethodError": [
                            158
                        ],
                        "self": [
                            158
                        ],
                        "property": [
                            149
                        ],
                        "Type": [
                            150
                        ],
                        "DatetimeLikeScalar": [
                            150
                        ]
                    },
                    "filtered_variables": {
                        "AbstractMethodError": [
                            158
                        ],
                        "self": [
                            158
                        ],
                        "Type": [
                            150
                        ],
                        "DatetimeLikeScalar": [
                            150
                        ]
                    },
                    "diff_line_number": 150,
                    "class_data": {
                        "signature": "class AttributesMixin()",
                        "docstring": null,
                        "constructor_docstring": null,
                        "functions": [
                            "@classmethod\ndef _simple_new(cls, values: np.ndarray, **kwargs):\n    raise AbstractMethodError(cls)",
                            "@property\ndef _scalar_type(self) -> Type[DatetimeLikeScalar]:\n    \"\"\"\n    The scalar associated with this datelike\n\n    * PeriodArray : Period\n    * DatetimeArray : Timestamp\n    * TimedeltaArray : Timedelta\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _scalar_from_string(self, value: str) -> Union[Period, Timestamp, Timedelta, NaTType]:\n    \"\"\"\n    Construct a scalar type from a string.\n\n    Parameters\n    ----------\n    value : str\n\n    Returns\n    -------\n    Period, Timestamp, or Timedelta, or NaT\n        Whatever the type of ``self._scalar_type`` is.\n\n    Notes\n    -----\n    This should call ``self._check_compatible_with`` before\n    unboxing the result.\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _unbox_scalar(self, value: Union[Period, Timestamp, Timedelta, NaTType]) -> int:\n    \"\"\"\n    Unbox the integer value of a scalar `value`.\n\n    Parameters\n    ----------\n    value : Union[Period, Timestamp, Timedelta]\n\n    Returns\n    -------\n    int\n\n    Examples\n    --------\n    >>> self._unbox_scalar(Timedelta(\"10s\"))  # doctest: +SKIP\n    10000000000\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _check_compatible_with(self, other: Union[Period, Timestamp, Timedelta, NaTType], setitem: bool=False) -> None:\n    \"\"\"\n    Verify that `self` and `other` are compatible.\n\n    * DatetimeArray verifies that the timezones (if any) match\n    * PeriodArray verifies that the freq matches\n    * Timedelta has no verification\n\n    In each case, NaT is considered compatible.\n\n    Parameters\n    ----------\n    other\n    setitem : bool, default False\n        For __setitem__ we may have stricter compatibility resrictions than\n        for comparisons.\n\n    Raises\n    ------\n    Exception\n    \"\"\"\n    raise AbstractMethodError(self)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_data"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_simple_new(cls, values: np.ndarray, **kwargs)",
                            "_scalar_type(self) -> Type[DatetimeLikeScalar]",
                            "_scalar_from_string(self, value: str) -> Union[Period, Timestamp, Timedelta, NaTType]",
                            "_unbox_scalar(self, value: Union[Period, Timestamp, Timedelta, NaTType]) -> int",
                            "_check_compatible_with(self, other: Union[Period, Timestamp, Timedelta, NaTType], setitem: bool=False) -> None"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_scalar_from_string",
                    "function_code": "def _scalar_from_string(\n    self, value: str\n) -> Union[Period, Timestamp, Timedelta, NaTType]:\n    \"\"\"\n    Construct a scalar type from a string.\n\n    Parameters\n    ----------\n    value : str\n\n    Returns\n    -------\n    Period, Timestamp, or Timedelta, or NaT\n        Whatever the type of ``self._scalar_type`` is.\n\n    Notes\n    -----\n    This should call ``self._check_compatible_with`` before\n    unboxing the result.\n    \"\"\"\n    raise AbstractMethodError(self)\n",
                    "decorators": [],
                    "docstring": "Construct a scalar type from a string.\n\nParameters\n----------\nvalue : str\n\nReturns\n-------\nPeriod, Timestamp, or Timedelta, or NaT\n    Whatever the type of ``self._scalar_type`` is.\n\nNotes\n-----\nThis should call ``self._check_compatible_with`` before\nunboxing the result.",
                    "start_line": 160,
                    "variables": {
                        "str": [
                            161
                        ],
                        "AbstractMethodError": [
                            180
                        ],
                        "self": [
                            180
                        ],
                        "Union": [
                            162
                        ],
                        "Period": [
                            162
                        ],
                        "Timestamp": [
                            162
                        ],
                        "Timedelta": [
                            162
                        ],
                        "NaTType": [
                            162
                        ]
                    },
                    "filtered_variables": {
                        "AbstractMethodError": [
                            180
                        ],
                        "self": [
                            180
                        ],
                        "Union": [
                            162
                        ],
                        "Period": [
                            162
                        ],
                        "Timestamp": [
                            162
                        ],
                        "Timedelta": [
                            162
                        ],
                        "NaTType": [
                            162
                        ]
                    },
                    "diff_line_number": 160,
                    "class_data": {
                        "signature": "class AttributesMixin()",
                        "docstring": null,
                        "constructor_docstring": null,
                        "functions": [
                            "@classmethod\ndef _simple_new(cls, values: np.ndarray, **kwargs):\n    raise AbstractMethodError(cls)",
                            "@property\ndef _scalar_type(self) -> Type[DatetimeLikeScalar]:\n    \"\"\"\n    The scalar associated with this datelike\n\n    * PeriodArray : Period\n    * DatetimeArray : Timestamp\n    * TimedeltaArray : Timedelta\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _scalar_from_string(self, value: str) -> Union[Period, Timestamp, Timedelta, NaTType]:\n    \"\"\"\n    Construct a scalar type from a string.\n\n    Parameters\n    ----------\n    value : str\n\n    Returns\n    -------\n    Period, Timestamp, or Timedelta, or NaT\n        Whatever the type of ``self._scalar_type`` is.\n\n    Notes\n    -----\n    This should call ``self._check_compatible_with`` before\n    unboxing the result.\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _unbox_scalar(self, value: Union[Period, Timestamp, Timedelta, NaTType]) -> int:\n    \"\"\"\n    Unbox the integer value of a scalar `value`.\n\n    Parameters\n    ----------\n    value : Union[Period, Timestamp, Timedelta]\n\n    Returns\n    -------\n    int\n\n    Examples\n    --------\n    >>> self._unbox_scalar(Timedelta(\"10s\"))  # doctest: +SKIP\n    10000000000\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _check_compatible_with(self, other: Union[Period, Timestamp, Timedelta, NaTType], setitem: bool=False) -> None:\n    \"\"\"\n    Verify that `self` and `other` are compatible.\n\n    * DatetimeArray verifies that the timezones (if any) match\n    * PeriodArray verifies that the freq matches\n    * Timedelta has no verification\n\n    In each case, NaT is considered compatible.\n\n    Parameters\n    ----------\n    other\n    setitem : bool, default False\n        For __setitem__ we may have stricter compatibility resrictions than\n        for comparisons.\n\n    Raises\n    ------\n    Exception\n    \"\"\"\n    raise AbstractMethodError(self)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_data"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_simple_new(cls, values: np.ndarray, **kwargs)",
                            "_scalar_type(self) -> Type[DatetimeLikeScalar]",
                            "_scalar_from_string(self, value: str) -> Union[Period, Timestamp, Timedelta, NaTType]",
                            "_unbox_scalar(self, value: Union[Period, Timestamp, Timedelta, NaTType]) -> int",
                            "_check_compatible_with(self, other: Union[Period, Timestamp, Timedelta, NaTType], setitem: bool=False) -> None"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_unbox_scalar",
                    "function_code": "def _unbox_scalar(self, value: Union[Period, Timestamp, Timedelta, NaTType]) -> int:\n    \"\"\"\n    Unbox the integer value of a scalar `value`.\n\n    Parameters\n    ----------\n    value : Union[Period, Timestamp, Timedelta]\n\n    Returns\n    -------\n    int\n\n    Examples\n    --------\n    >>> self._unbox_scalar(Timedelta(\"10s\"))  # doctest: +SKIP\n    10000000000\n    \"\"\"\n    raise AbstractMethodError(self)\n",
                    "decorators": [],
                    "docstring": "Unbox the integer value of a scalar `value`.\n\nParameters\n----------\nvalue : Union[Period, Timestamp, Timedelta]\n\nReturns\n-------\nint\n\nExamples\n--------\n>>> self._unbox_scalar(Timedelta(\"10s\"))  # doctest: +SKIP\n10000000000",
                    "start_line": 182,
                    "variables": {
                        "Union": [
                            182
                        ],
                        "Period": [
                            182
                        ],
                        "Timestamp": [
                            182
                        ],
                        "Timedelta": [
                            182
                        ],
                        "NaTType": [
                            182
                        ],
                        "AbstractMethodError": [
                            199
                        ],
                        "self": [
                            199
                        ],
                        "int": [
                            182
                        ]
                    },
                    "filtered_variables": {
                        "Union": [
                            182
                        ],
                        "Period": [
                            182
                        ],
                        "Timestamp": [
                            182
                        ],
                        "Timedelta": [
                            182
                        ],
                        "NaTType": [
                            182
                        ],
                        "AbstractMethodError": [
                            199
                        ],
                        "self": [
                            199
                        ]
                    },
                    "diff_line_number": 182,
                    "class_data": {
                        "signature": "class AttributesMixin()",
                        "docstring": null,
                        "constructor_docstring": null,
                        "functions": [
                            "@classmethod\ndef _simple_new(cls, values: np.ndarray, **kwargs):\n    raise AbstractMethodError(cls)",
                            "@property\ndef _scalar_type(self) -> Type[DatetimeLikeScalar]:\n    \"\"\"\n    The scalar associated with this datelike\n\n    * PeriodArray : Period\n    * DatetimeArray : Timestamp\n    * TimedeltaArray : Timedelta\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _scalar_from_string(self, value: str) -> Union[Period, Timestamp, Timedelta, NaTType]:\n    \"\"\"\n    Construct a scalar type from a string.\n\n    Parameters\n    ----------\n    value : str\n\n    Returns\n    -------\n    Period, Timestamp, or Timedelta, or NaT\n        Whatever the type of ``self._scalar_type`` is.\n\n    Notes\n    -----\n    This should call ``self._check_compatible_with`` before\n    unboxing the result.\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _unbox_scalar(self, value: Union[Period, Timestamp, Timedelta, NaTType]) -> int:\n    \"\"\"\n    Unbox the integer value of a scalar `value`.\n\n    Parameters\n    ----------\n    value : Union[Period, Timestamp, Timedelta]\n\n    Returns\n    -------\n    int\n\n    Examples\n    --------\n    >>> self._unbox_scalar(Timedelta(\"10s\"))  # doctest: +SKIP\n    10000000000\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _check_compatible_with(self, other: Union[Period, Timestamp, Timedelta, NaTType], setitem: bool=False) -> None:\n    \"\"\"\n    Verify that `self` and `other` are compatible.\n\n    * DatetimeArray verifies that the timezones (if any) match\n    * PeriodArray verifies that the freq matches\n    * Timedelta has no verification\n\n    In each case, NaT is considered compatible.\n\n    Parameters\n    ----------\n    other\n    setitem : bool, default False\n        For __setitem__ we may have stricter compatibility resrictions than\n        for comparisons.\n\n    Raises\n    ------\n    Exception\n    \"\"\"\n    raise AbstractMethodError(self)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_data"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_simple_new(cls, values: np.ndarray, **kwargs)",
                            "_scalar_type(self) -> Type[DatetimeLikeScalar]",
                            "_scalar_from_string(self, value: str) -> Union[Period, Timestamp, Timedelta, NaTType]",
                            "_unbox_scalar(self, value: Union[Period, Timestamp, Timedelta, NaTType]) -> int",
                            "_check_compatible_with(self, other: Union[Period, Timestamp, Timedelta, NaTType], setitem: bool=False) -> None"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_check_compatible_with",
                    "function_code": "def _check_compatible_with(\n    self, other: Union[Period, Timestamp, Timedelta, NaTType], setitem: bool = False\n) -> None:\n    \"\"\"\n    Verify that `self` and `other` are compatible.\n\n    * DatetimeArray verifies that the timezones (if any) match\n    * PeriodArray verifies that the freq matches\n    * Timedelta has no verification\n\n    In each case, NaT is considered compatible.\n\n    Parameters\n    ----------\n    other\n    setitem : bool, default False\n        For __setitem__ we may have stricter compatibility resrictions than\n        for comparisons.\n\n    Raises\n    ------\n    Exception\n    \"\"\"\n    raise AbstractMethodError(self)\n",
                    "decorators": [],
                    "docstring": "Verify that `self` and `other` are compatible.\n\n* DatetimeArray verifies that the timezones (if any) match\n* PeriodArray verifies that the freq matches\n* Timedelta has no verification\n\nIn each case, NaT is considered compatible.\n\nParameters\n----------\nother\nsetitem : bool, default False\n    For __setitem__ we may have stricter compatibility resrictions than\n    for comparisons.\n\nRaises\n------\nException",
                    "start_line": 201,
                    "variables": {
                        "Union": [
                            202
                        ],
                        "Period": [
                            202
                        ],
                        "Timestamp": [
                            202
                        ],
                        "Timedelta": [
                            202
                        ],
                        "NaTType": [
                            202
                        ],
                        "bool": [
                            202
                        ],
                        "AbstractMethodError": [
                            224
                        ],
                        "self": [
                            224
                        ]
                    },
                    "filtered_variables": {
                        "Union": [
                            202
                        ],
                        "Period": [
                            202
                        ],
                        "Timestamp": [
                            202
                        ],
                        "Timedelta": [
                            202
                        ],
                        "NaTType": [
                            202
                        ],
                        "AbstractMethodError": [
                            224
                        ],
                        "self": [
                            224
                        ]
                    },
                    "diff_line_number": 201,
                    "class_data": {
                        "signature": "class AttributesMixin()",
                        "docstring": null,
                        "constructor_docstring": null,
                        "functions": [
                            "@classmethod\ndef _simple_new(cls, values: np.ndarray, **kwargs):\n    raise AbstractMethodError(cls)",
                            "@property\ndef _scalar_type(self) -> Type[DatetimeLikeScalar]:\n    \"\"\"\n    The scalar associated with this datelike\n\n    * PeriodArray : Period\n    * DatetimeArray : Timestamp\n    * TimedeltaArray : Timedelta\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _scalar_from_string(self, value: str) -> Union[Period, Timestamp, Timedelta, NaTType]:\n    \"\"\"\n    Construct a scalar type from a string.\n\n    Parameters\n    ----------\n    value : str\n\n    Returns\n    -------\n    Period, Timestamp, or Timedelta, or NaT\n        Whatever the type of ``self._scalar_type`` is.\n\n    Notes\n    -----\n    This should call ``self._check_compatible_with`` before\n    unboxing the result.\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _unbox_scalar(self, value: Union[Period, Timestamp, Timedelta, NaTType]) -> int:\n    \"\"\"\n    Unbox the integer value of a scalar `value`.\n\n    Parameters\n    ----------\n    value : Union[Period, Timestamp, Timedelta]\n\n    Returns\n    -------\n    int\n\n    Examples\n    --------\n    >>> self._unbox_scalar(Timedelta(\"10s\"))  # doctest: +SKIP\n    10000000000\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _check_compatible_with(self, other: Union[Period, Timestamp, Timedelta, NaTType], setitem: bool=False) -> None:\n    \"\"\"\n    Verify that `self` and `other` are compatible.\n\n    * DatetimeArray verifies that the timezones (if any) match\n    * PeriodArray verifies that the freq matches\n    * Timedelta has no verification\n\n    In each case, NaT is considered compatible.\n\n    Parameters\n    ----------\n    other\n    setitem : bool, default False\n        For __setitem__ we may have stricter compatibility resrictions than\n        for comparisons.\n\n    Raises\n    ------\n    Exception\n    \"\"\"\n    raise AbstractMethodError(self)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_data"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_simple_new(cls, values: np.ndarray, **kwargs)",
                            "_scalar_type(self) -> Type[DatetimeLikeScalar]",
                            "_scalar_from_string(self, value: str) -> Union[Period, Timestamp, Timedelta, NaTType]",
                            "_unbox_scalar(self, value: Union[Period, Timestamp, Timedelta, NaTType]) -> int",
                            "_check_compatible_with(self, other: Union[Period, Timestamp, Timedelta, NaTType], setitem: bool=False) -> None"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "strftime",
                    "function_code": "@Substitution(\n    URL=\"https://docs.python.org/3/library/datetime.html\"\n    \"#strftime-and-strptime-behavior\"\n)\ndef strftime(self, date_format):\n    \"\"\"\n    Convert to Index using specified date_format.\n\n    Return an Index of formatted strings specified by date_format, which\n    supports the same string format as the python standard library. Details\n    of the string format can be found in `python string format\n    doc <%(URL)s>`__.\n\n    Parameters\n    ----------\n    date_format : str\n        Date format string (e.g. \"%%Y-%%m-%%d\").\n\n    Returns\n    -------\n    ndarray\n        NumPy ndarray of formatted strings.\n\n    See Also\n    --------\n    to_datetime : Convert the given argument to datetime.\n    DatetimeIndex.normalize : Return DatetimeIndex with times to midnight.\n    DatetimeIndex.round : Round the DatetimeIndex to the specified freq.\n    DatetimeIndex.floor : Floor the DatetimeIndex to the specified freq.\n\n    Examples\n    --------\n    >>> rng = pd.date_range(pd.Timestamp(\"2018-03-10 09:00\"),\n    ...                     periods=3, freq='s')\n    >>> rng.strftime('%%B %%d, %%Y, %%r')\n    Index(['March 10, 2018, 09:00:00 AM', 'March 10, 2018, 09:00:01 AM',\n           'March 10, 2018, 09:00:02 AM'],\n          dtype='object')\n    \"\"\"\n    result = self._format_native_types(date_format=date_format, na_rep=np.nan)\n    return result.astype(object)\n",
                    "decorators": [
                        "Substitution(URL='https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior')"
                    ],
                    "docstring": "Convert to Index using specified date_format.\n\nReturn an Index of formatted strings specified by date_format, which\nsupports the same string format as the python standard library. Details\nof the string format can be found in `python string format\ndoc <%(URL)s>`__.\n\nParameters\n----------\ndate_format : str\n    Date format string (e.g. \"%%Y-%%m-%%d\").\n\nReturns\n-------\nndarray\n    NumPy ndarray of formatted strings.\n\nSee Also\n--------\nto_datetime : Convert the given argument to datetime.\nDatetimeIndex.normalize : Return DatetimeIndex with times to midnight.\nDatetimeIndex.round : Round the DatetimeIndex to the specified freq.\nDatetimeIndex.floor : Floor the DatetimeIndex to the specified freq.\n\nExamples\n--------\n>>> rng = pd.date_range(pd.Timestamp(\"2018-03-10 09:00\"),\n...                     periods=3, freq='s')\n>>> rng.strftime('%%B %%d, %%Y, %%r')\nIndex(['March 10, 2018, 09:00:00 AM', 'March 10, 2018, 09:00:01 AM',\n       'March 10, 2018, 09:00:02 AM'],\n      dtype='object')",
                    "start_line": 232,
                    "variables": {
                        "result": [
                            272,
                            271
                        ],
                        "self._format_native_types": [
                            271
                        ],
                        "self": [
                            271
                        ],
                        "date_format": [
                            271
                        ],
                        "np.nan": [
                            271
                        ],
                        "np": [
                            271
                        ],
                        "result.astype": [
                            272
                        ],
                        "object": [
                            272
                        ],
                        "Substitution": [
                            232
                        ]
                    },
                    "filtered_variables": {
                        "result": [
                            272,
                            271
                        ],
                        "self._format_native_types": [
                            271
                        ],
                        "self": [
                            271
                        ],
                        "date_format": [
                            271
                        ],
                        "np.nan": [
                            271
                        ],
                        "np": [
                            271
                        ],
                        "result.astype": [
                            272
                        ],
                        "Substitution": [
                            232
                        ]
                    },
                    "diff_line_number": 236,
                    "class_data": {
                        "signature": "class DatelikeOps()",
                        "docstring": "Common ops for DatetimeIndex/PeriodIndex, but not TimedeltaIndex.",
                        "constructor_docstring": null,
                        "functions": [
                            "@Substitution(URL='https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior')\ndef strftime(self, date_format):\n    \"\"\"\n    Convert to Index using specified date_format.\n\n    Return an Index of formatted strings specified by date_format, which\n    supports the same string format as the python standard library. Details\n    of the string format can be found in `python string format\n    doc <%(URL)s>`__.\n\n    Parameters\n    ----------\n    date_format : str\n        Date format string (e.g. \"%%Y-%%m-%%d\").\n\n    Returns\n    -------\n    ndarray\n        NumPy ndarray of formatted strings.\n\n    See Also\n    --------\n    to_datetime : Convert the given argument to datetime.\n    DatetimeIndex.normalize : Return DatetimeIndex with times to midnight.\n    DatetimeIndex.round : Round the DatetimeIndex to the specified freq.\n    DatetimeIndex.floor : Floor the DatetimeIndex to the specified freq.\n\n    Examples\n    --------\n    >>> rng = pd.date_range(pd.Timestamp(\"2018-03-10 09:00\"),\n    ...                     periods=3, freq='s')\n    >>> rng.strftime('%%B %%d, %%Y, %%r')\n    Index(['March 10, 2018, 09:00:00 AM', 'March 10, 2018, 09:00:01 AM',\n           'March 10, 2018, 09:00:02 AM'],\n          dtype='object')\n    \"\"\"\n    result = self._format_native_types(date_format=date_format, na_rep=np.nan)\n    return result.astype(object)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [],
                        "class_decorators": [],
                        "function_signatures": [
                            "strftime(self, date_format)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_round",
                    "function_code": "def _round(self, freq, mode, ambiguous, nonexistent):\n    # round the local times\n    if is_datetime64tz_dtype(self):\n        # operate on naive timestamps, then convert back to aware\n        naive = self.tz_localize(None)\n        result = naive._round(freq, mode, ambiguous, nonexistent)\n        aware = result.tz_localize(\n            self.tz, ambiguous=ambiguous, nonexistent=nonexistent\n        )\n        return aware\n\n    values = self.view(\"i8\")\n    result = round_nsint64(values, mode, freq)\n    result = self._maybe_mask_results(result, fill_value=NaT)\n    return self._simple_new(result, dtype=self.dtype)\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 383,
                    "variables": {
                        "is_datetime64tz_dtype": [
                            385
                        ],
                        "self": [
                            385,
                            387,
                            390,
                            394,
                            396,
                            397
                        ],
                        "naive": [
                            387,
                            388
                        ],
                        "self.tz_localize": [
                            387
                        ],
                        "result": [
                            388,
                            389,
                            395,
                            396,
                            397
                        ],
                        "naive._round": [
                            388
                        ],
                        "freq": [
                            395,
                            388
                        ],
                        "mode": [
                            395,
                            388
                        ],
                        "ambiguous": [
                            388,
                            390
                        ],
                        "nonexistent": [
                            388,
                            390
                        ],
                        "aware": [
                            392,
                            389
                        ],
                        "result.tz_localize": [
                            389
                        ],
                        "self.tz": [
                            390
                        ],
                        "values": [
                            394,
                            395
                        ],
                        "self.view": [
                            394
                        ],
                        "round_nsint64": [
                            395
                        ],
                        "self._maybe_mask_results": [
                            396
                        ],
                        "NaT": [
                            396
                        ],
                        "self._simple_new": [
                            397
                        ],
                        "self.dtype": [
                            397
                        ]
                    },
                    "filtered_variables": {
                        "is_datetime64tz_dtype": [
                            385
                        ],
                        "self": [
                            385,
                            387,
                            390,
                            394,
                            396,
                            397
                        ],
                        "naive": [
                            387,
                            388
                        ],
                        "self.tz_localize": [
                            387
                        ],
                        "result": [
                            388,
                            389,
                            395,
                            396,
                            397
                        ],
                        "naive._round": [
                            388
                        ],
                        "freq": [
                            395,
                            388
                        ],
                        "mode": [
                            395,
                            388
                        ],
                        "ambiguous": [
                            388,
                            390
                        ],
                        "nonexistent": [
                            388,
                            390
                        ],
                        "aware": [
                            392,
                            389
                        ],
                        "result.tz_localize": [
                            389
                        ],
                        "self.tz": [
                            390
                        ],
                        "values": [
                            394,
                            395
                        ],
                        "self.view": [
                            394
                        ],
                        "round_nsint64": [
                            395
                        ],
                        "self._maybe_mask_results": [
                            396
                        ],
                        "NaT": [
                            396
                        ],
                        "self._simple_new": [
                            397
                        ],
                        "self.dtype": [
                            397
                        ]
                    },
                    "diff_line_number": 383,
                    "class_data": {
                        "signature": "class TimelikeOps()",
                        "docstring": "Common ops for TimedeltaIndex/DatetimeIndex, but not PeriodIndex.",
                        "constructor_docstring": null,
                        "functions": [
                            "def _round(self, freq, mode, ambiguous, nonexistent):\n    if is_datetime64tz_dtype(self):\n        naive = self.tz_localize(None)\n        result = naive._round(freq, mode, ambiguous, nonexistent)\n        aware = result.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n        return aware\n    values = self.view('i8')\n    result = round_nsint64(values, mode, freq)\n    result = self._maybe_mask_results(result, fill_value=NaT)\n    return self._simple_new(result, dtype=self.dtype)",
                            "@Appender((_round_doc + _round_example).format(op='round'))\ndef round(self, freq, ambiguous='raise', nonexistent='raise'):\n    return self._round(freq, RoundTo.NEAREST_HALF_EVEN, ambiguous, nonexistent)",
                            "@Appender((_round_doc + _floor_example).format(op='floor'))\ndef floor(self, freq, ambiguous='raise', nonexistent='raise'):\n    return self._round(freq, RoundTo.MINUS_INFTY, ambiguous, nonexistent)",
                            "@Appender((_round_doc + _ceil_example).format(op='ceil'))\ndef ceil(self, freq, ambiguous='raise', nonexistent='raise'):\n    return self._round(freq, RoundTo.PLUS_INFTY, ambiguous, nonexistent)",
                            "def _with_freq(self, freq):\n    \"\"\"\n    Helper to set our freq in-place, returning self to allow method chaining.\n\n    Parameters\n    ----------\n    freq : DateOffset, None, or \"infer\"\n\n    Returns\n    -------\n    self\n    \"\"\"\n    if freq is None:\n        pass\n    elif len(self) == 0 and isinstance(freq, DateOffset):\n        pass\n    else:\n        assert freq == 'infer'\n        freq = frequencies.to_offset(self.inferred_freq)\n    self._freq = freq\n    return self"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_round_doc",
                            "_round_example",
                            "_floor_example",
                            "_ceil_example"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_round(self, freq, mode, ambiguous, nonexistent)",
                            "round(self, freq, ambiguous='raise', nonexistent='raise')",
                            "floor(self, freq, ambiguous='raise', nonexistent='raise')",
                            "ceil(self, freq, ambiguous='raise', nonexistent='raise')",
                            "_with_freq(self, freq)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "round",
                    "function_code": "@Appender((_round_doc + _round_example).format(op=\"round\"))\ndef round(self, freq, ambiguous=\"raise\", nonexistent=\"raise\"):\n    return self._round(freq, RoundTo.NEAREST_HALF_EVEN, ambiguous, nonexistent)\n",
                    "decorators": [
                        "Appender((_round_doc + _round_example).format(op='round'))"
                    ],
                    "docstring": null,
                    "start_line": 399,
                    "variables": {
                        "self._round": [
                            401
                        ],
                        "self": [
                            401
                        ],
                        "freq": [
                            401
                        ],
                        "RoundTo.NEAREST_HALF_EVEN": [
                            401
                        ],
                        "RoundTo": [
                            401
                        ],
                        "ambiguous": [
                            401
                        ],
                        "nonexistent": [
                            401
                        ],
                        "Appender": [
                            399
                        ],
                        "format": [
                            399
                        ],
                        "_round_doc": [
                            399
                        ],
                        "_round_example": [
                            399
                        ]
                    },
                    "filtered_variables": {
                        "self._round": [
                            401
                        ],
                        "self": [
                            401
                        ],
                        "freq": [
                            401
                        ],
                        "RoundTo.NEAREST_HALF_EVEN": [
                            401
                        ],
                        "RoundTo": [
                            401
                        ],
                        "ambiguous": [
                            401
                        ],
                        "nonexistent": [
                            401
                        ],
                        "Appender": [
                            399
                        ],
                        "_round_doc": [
                            399
                        ],
                        "_round_example": [
                            399
                        ]
                    },
                    "diff_line_number": 400,
                    "class_data": {
                        "signature": "class TimelikeOps()",
                        "docstring": "Common ops for TimedeltaIndex/DatetimeIndex, but not PeriodIndex.",
                        "constructor_docstring": null,
                        "functions": [
                            "def _round(self, freq, mode, ambiguous, nonexistent):\n    if is_datetime64tz_dtype(self):\n        naive = self.tz_localize(None)\n        result = naive._round(freq, mode, ambiguous, nonexistent)\n        aware = result.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n        return aware\n    values = self.view('i8')\n    result = round_nsint64(values, mode, freq)\n    result = self._maybe_mask_results(result, fill_value=NaT)\n    return self._simple_new(result, dtype=self.dtype)",
                            "@Appender((_round_doc + _round_example).format(op='round'))\ndef round(self, freq, ambiguous='raise', nonexistent='raise'):\n    return self._round(freq, RoundTo.NEAREST_HALF_EVEN, ambiguous, nonexistent)",
                            "@Appender((_round_doc + _floor_example).format(op='floor'))\ndef floor(self, freq, ambiguous='raise', nonexistent='raise'):\n    return self._round(freq, RoundTo.MINUS_INFTY, ambiguous, nonexistent)",
                            "@Appender((_round_doc + _ceil_example).format(op='ceil'))\ndef ceil(self, freq, ambiguous='raise', nonexistent='raise'):\n    return self._round(freq, RoundTo.PLUS_INFTY, ambiguous, nonexistent)",
                            "def _with_freq(self, freq):\n    \"\"\"\n    Helper to set our freq in-place, returning self to allow method chaining.\n\n    Parameters\n    ----------\n    freq : DateOffset, None, or \"infer\"\n\n    Returns\n    -------\n    self\n    \"\"\"\n    if freq is None:\n        pass\n    elif len(self) == 0 and isinstance(freq, DateOffset):\n        pass\n    else:\n        assert freq == 'infer'\n        freq = frequencies.to_offset(self.inferred_freq)\n    self._freq = freq\n    return self"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_round_doc",
                            "_round_example",
                            "_floor_example",
                            "_ceil_example"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_round(self, freq, mode, ambiguous, nonexistent)",
                            "round(self, freq, ambiguous='raise', nonexistent='raise')",
                            "floor(self, freq, ambiguous='raise', nonexistent='raise')",
                            "ceil(self, freq, ambiguous='raise', nonexistent='raise')",
                            "_with_freq(self, freq)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "floor",
                    "function_code": "@Appender((_round_doc + _floor_example).format(op=\"floor\"))\ndef floor(self, freq, ambiguous=\"raise\", nonexistent=\"raise\"):\n    return self._round(freq, RoundTo.MINUS_INFTY, ambiguous, nonexistent)\n",
                    "decorators": [
                        "Appender((_round_doc + _floor_example).format(op='floor'))"
                    ],
                    "docstring": null,
                    "start_line": 403,
                    "variables": {
                        "self._round": [
                            405
                        ],
                        "self": [
                            405
                        ],
                        "freq": [
                            405
                        ],
                        "RoundTo.MINUS_INFTY": [
                            405
                        ],
                        "RoundTo": [
                            405
                        ],
                        "ambiguous": [
                            405
                        ],
                        "nonexistent": [
                            405
                        ],
                        "Appender": [
                            403
                        ],
                        "format": [
                            403
                        ],
                        "_round_doc": [
                            403
                        ],
                        "_floor_example": [
                            403
                        ]
                    },
                    "filtered_variables": {
                        "self._round": [
                            405
                        ],
                        "self": [
                            405
                        ],
                        "freq": [
                            405
                        ],
                        "RoundTo.MINUS_INFTY": [
                            405
                        ],
                        "RoundTo": [
                            405
                        ],
                        "ambiguous": [
                            405
                        ],
                        "nonexistent": [
                            405
                        ],
                        "Appender": [
                            403
                        ],
                        "_round_doc": [
                            403
                        ],
                        "_floor_example": [
                            403
                        ]
                    },
                    "diff_line_number": 404,
                    "class_data": {
                        "signature": "class TimelikeOps()",
                        "docstring": "Common ops for TimedeltaIndex/DatetimeIndex, but not PeriodIndex.",
                        "constructor_docstring": null,
                        "functions": [
                            "def _round(self, freq, mode, ambiguous, nonexistent):\n    if is_datetime64tz_dtype(self):\n        naive = self.tz_localize(None)\n        result = naive._round(freq, mode, ambiguous, nonexistent)\n        aware = result.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n        return aware\n    values = self.view('i8')\n    result = round_nsint64(values, mode, freq)\n    result = self._maybe_mask_results(result, fill_value=NaT)\n    return self._simple_new(result, dtype=self.dtype)",
                            "@Appender((_round_doc + _round_example).format(op='round'))\ndef round(self, freq, ambiguous='raise', nonexistent='raise'):\n    return self._round(freq, RoundTo.NEAREST_HALF_EVEN, ambiguous, nonexistent)",
                            "@Appender((_round_doc + _floor_example).format(op='floor'))\ndef floor(self, freq, ambiguous='raise', nonexistent='raise'):\n    return self._round(freq, RoundTo.MINUS_INFTY, ambiguous, nonexistent)",
                            "@Appender((_round_doc + _ceil_example).format(op='ceil'))\ndef ceil(self, freq, ambiguous='raise', nonexistent='raise'):\n    return self._round(freq, RoundTo.PLUS_INFTY, ambiguous, nonexistent)",
                            "def _with_freq(self, freq):\n    \"\"\"\n    Helper to set our freq in-place, returning self to allow method chaining.\n\n    Parameters\n    ----------\n    freq : DateOffset, None, or \"infer\"\n\n    Returns\n    -------\n    self\n    \"\"\"\n    if freq is None:\n        pass\n    elif len(self) == 0 and isinstance(freq, DateOffset):\n        pass\n    else:\n        assert freq == 'infer'\n        freq = frequencies.to_offset(self.inferred_freq)\n    self._freq = freq\n    return self"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_round_doc",
                            "_round_example",
                            "_floor_example",
                            "_ceil_example"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_round(self, freq, mode, ambiguous, nonexistent)",
                            "round(self, freq, ambiguous='raise', nonexistent='raise')",
                            "floor(self, freq, ambiguous='raise', nonexistent='raise')",
                            "ceil(self, freq, ambiguous='raise', nonexistent='raise')",
                            "_with_freq(self, freq)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "ceil",
                    "function_code": "@Appender((_round_doc + _ceil_example).format(op=\"ceil\"))\ndef ceil(self, freq, ambiguous=\"raise\", nonexistent=\"raise\"):\n    return self._round(freq, RoundTo.PLUS_INFTY, ambiguous, nonexistent)\n",
                    "decorators": [
                        "Appender((_round_doc + _ceil_example).format(op='ceil'))"
                    ],
                    "docstring": null,
                    "start_line": 407,
                    "variables": {
                        "self._round": [
                            409
                        ],
                        "self": [
                            409
                        ],
                        "freq": [
                            409
                        ],
                        "RoundTo.PLUS_INFTY": [
                            409
                        ],
                        "RoundTo": [
                            409
                        ],
                        "ambiguous": [
                            409
                        ],
                        "nonexistent": [
                            409
                        ],
                        "Appender": [
                            407
                        ],
                        "format": [
                            407
                        ],
                        "_round_doc": [
                            407
                        ],
                        "_ceil_example": [
                            407
                        ]
                    },
                    "filtered_variables": {
                        "self._round": [
                            409
                        ],
                        "self": [
                            409
                        ],
                        "freq": [
                            409
                        ],
                        "RoundTo.PLUS_INFTY": [
                            409
                        ],
                        "RoundTo": [
                            409
                        ],
                        "ambiguous": [
                            409
                        ],
                        "nonexistent": [
                            409
                        ],
                        "Appender": [
                            407
                        ],
                        "_round_doc": [
                            407
                        ],
                        "_ceil_example": [
                            407
                        ]
                    },
                    "diff_line_number": 408,
                    "class_data": {
                        "signature": "class TimelikeOps()",
                        "docstring": "Common ops for TimedeltaIndex/DatetimeIndex, but not PeriodIndex.",
                        "constructor_docstring": null,
                        "functions": [
                            "def _round(self, freq, mode, ambiguous, nonexistent):\n    if is_datetime64tz_dtype(self):\n        naive = self.tz_localize(None)\n        result = naive._round(freq, mode, ambiguous, nonexistent)\n        aware = result.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n        return aware\n    values = self.view('i8')\n    result = round_nsint64(values, mode, freq)\n    result = self._maybe_mask_results(result, fill_value=NaT)\n    return self._simple_new(result, dtype=self.dtype)",
                            "@Appender((_round_doc + _round_example).format(op='round'))\ndef round(self, freq, ambiguous='raise', nonexistent='raise'):\n    return self._round(freq, RoundTo.NEAREST_HALF_EVEN, ambiguous, nonexistent)",
                            "@Appender((_round_doc + _floor_example).format(op='floor'))\ndef floor(self, freq, ambiguous='raise', nonexistent='raise'):\n    return self._round(freq, RoundTo.MINUS_INFTY, ambiguous, nonexistent)",
                            "@Appender((_round_doc + _ceil_example).format(op='ceil'))\ndef ceil(self, freq, ambiguous='raise', nonexistent='raise'):\n    return self._round(freq, RoundTo.PLUS_INFTY, ambiguous, nonexistent)",
                            "def _with_freq(self, freq):\n    \"\"\"\n    Helper to set our freq in-place, returning self to allow method chaining.\n\n    Parameters\n    ----------\n    freq : DateOffset, None, or \"infer\"\n\n    Returns\n    -------\n    self\n    \"\"\"\n    if freq is None:\n        pass\n    elif len(self) == 0 and isinstance(freq, DateOffset):\n        pass\n    else:\n        assert freq == 'infer'\n        freq = frequencies.to_offset(self.inferred_freq)\n    self._freq = freq\n    return self"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_round_doc",
                            "_round_example",
                            "_floor_example",
                            "_ceil_example"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_round(self, freq, mode, ambiguous, nonexistent)",
                            "round(self, freq, ambiguous='raise', nonexistent='raise')",
                            "floor(self, freq, ambiguous='raise', nonexistent='raise')",
                            "ceil(self, freq, ambiguous='raise', nonexistent='raise')",
                            "_with_freq(self, freq)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_with_freq",
                    "function_code": "def _with_freq(self, freq):\n    \"\"\"\n    Helper to set our freq in-place, returning self to allow method chaining.\n\n    Parameters\n    ----------\n    freq : DateOffset, None, or \"infer\"\n\n    Returns\n    -------\n    self\n    \"\"\"\n    # GH#29843\n    if freq is None:\n        # Always valid\n        pass\n    elif len(self) == 0 and isinstance(freq, DateOffset):\n        # Always valid.  In the TimedeltaArray case, we assume this\n        #  is a Tick offset.\n        pass\n    else:\n        # As an internal method, we can ensure this assertion always holds\n        assert freq == \"infer\"\n        freq = frequencies.to_offset(self.inferred_freq)\n\n    self._freq = freq\n    return self\n",
                    "decorators": [],
                    "docstring": "Helper to set our freq in-place, returning self to allow method chaining.\n\nParameters\n----------\nfreq : DateOffset, None, or \"infer\"\n\nReturns\n-------\nself",
                    "start_line": 411,
                    "variables": {
                        "freq": [
                            424,
                            427,
                            433,
                            434,
                            436
                        ],
                        "len": [
                            427
                        ],
                        "self": [
                            434,
                            427,
                            436,
                            437
                        ],
                        "isinstance": [
                            427
                        ],
                        "DateOffset": [
                            427
                        ],
                        "frequencies.to_offset": [
                            434
                        ],
                        "frequencies": [
                            434
                        ],
                        "self.inferred_freq": [
                            434
                        ],
                        "self._freq": [
                            436
                        ]
                    },
                    "filtered_variables": {
                        "freq": [
                            424,
                            427,
                            433,
                            434,
                            436
                        ],
                        "self": [
                            434,
                            427,
                            436,
                            437
                        ],
                        "DateOffset": [
                            427
                        ],
                        "frequencies.to_offset": [
                            434
                        ],
                        "frequencies": [
                            434
                        ],
                        "self.inferred_freq": [
                            434
                        ],
                        "self._freq": [
                            436
                        ]
                    },
                    "diff_line_number": 411,
                    "class_data": {
                        "signature": "class TimelikeOps()",
                        "docstring": "Common ops for TimedeltaIndex/DatetimeIndex, but not PeriodIndex.",
                        "constructor_docstring": null,
                        "functions": [
                            "def _round(self, freq, mode, ambiguous, nonexistent):\n    if is_datetime64tz_dtype(self):\n        naive = self.tz_localize(None)\n        result = naive._round(freq, mode, ambiguous, nonexistent)\n        aware = result.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n        return aware\n    values = self.view('i8')\n    result = round_nsint64(values, mode, freq)\n    result = self._maybe_mask_results(result, fill_value=NaT)\n    return self._simple_new(result, dtype=self.dtype)",
                            "@Appender((_round_doc + _round_example).format(op='round'))\ndef round(self, freq, ambiguous='raise', nonexistent='raise'):\n    return self._round(freq, RoundTo.NEAREST_HALF_EVEN, ambiguous, nonexistent)",
                            "@Appender((_round_doc + _floor_example).format(op='floor'))\ndef floor(self, freq, ambiguous='raise', nonexistent='raise'):\n    return self._round(freq, RoundTo.MINUS_INFTY, ambiguous, nonexistent)",
                            "@Appender((_round_doc + _ceil_example).format(op='ceil'))\ndef ceil(self, freq, ambiguous='raise', nonexistent='raise'):\n    return self._round(freq, RoundTo.PLUS_INFTY, ambiguous, nonexistent)",
                            "def _with_freq(self, freq):\n    \"\"\"\n    Helper to set our freq in-place, returning self to allow method chaining.\n\n    Parameters\n    ----------\n    freq : DateOffset, None, or \"infer\"\n\n    Returns\n    -------\n    self\n    \"\"\"\n    if freq is None:\n        pass\n    elif len(self) == 0 and isinstance(freq, DateOffset):\n        pass\n    else:\n        assert freq == 'infer'\n        freq = frequencies.to_offset(self.inferred_freq)\n    self._freq = freq\n    return self"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_round_doc",
                            "_round_example",
                            "_floor_example",
                            "_ceil_example"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_round(self, freq, mode, ambiguous, nonexistent)",
                            "round(self, freq, ambiguous='raise', nonexistent='raise')",
                            "floor(self, freq, ambiguous='raise', nonexistent='raise')",
                            "ceil(self, freq, ambiguous='raise', nonexistent='raise')",
                            "_with_freq(self, freq)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.inferred_freq": {
                                    "variable_value": "'D'",
                                    "variable_type": "str",
                                    "variable_shape": "1"
                                },
                                "arr": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.view": {
                                    "variable_value": "<bound method DatetimeLikeArrayMixin.view of <DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "arr._freq": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.inferred_freq": {
                                    "variable_value": "'D'",
                                    "variable_type": "str",
                                    "variable_shape": "1"
                                },
                                "arr": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                },
                                "self.view": {
                                    "variable_value": "<bound method DatetimeLikeArrayMixin.view of <DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "arr._freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                },
                {
                    "function_name": "_ndarray",
                    "function_code": "@property\ndef _ndarray(self) -> np.ndarray:\n    # NB: A bunch of Interval tests fail if we use ._data\n    return self.asi8\n",
                    "decorators": [
                        "property"
                    ],
                    "docstring": null,
                    "start_line": 457,
                    "variables": {
                        "self.asi8": [
                            460
                        ],
                        "self": [
                            460
                        ],
                        "property": [
                            457
                        ],
                        "np.ndarray": [
                            458
                        ],
                        "np": [
                            458
                        ]
                    },
                    "filtered_variables": {
                        "self.asi8": [
                            460
                        ],
                        "self": [
                            460
                        ],
                        "np.ndarray": [
                            458
                        ],
                        "np": [
                            458
                        ]
                    },
                    "diff_line_number": 458,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_from_backing_data",
                    "function_code": "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    # Note: we do not retain `freq`\n    return type(self)(arr, dtype=self.dtype)  # type: ignore\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 462,
                    "variables": {
                        "_T": [
                            462
                        ],
                        "np.ndarray": [
                            462
                        ],
                        "np": [
                            462
                        ],
                        "type": [
                            464
                        ],
                        "self": [
                            464
                        ],
                        "arr": [
                            464
                        ],
                        "self.dtype": [
                            464
                        ]
                    },
                    "filtered_variables": {
                        "_T": [
                            462
                        ],
                        "np.ndarray": [
                            462
                        ],
                        "np": [
                            462
                        ],
                        "self": [
                            464
                        ],
                        "arr": [
                            464
                        ],
                        "self.dtype": [
                            464
                        ]
                    },
                    "diff_line_number": 462,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {
                                "_T": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                },
                                "arr": {
                                    "variable_value": "array([1357016400000000000, 1357102800000000000, 1357189200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self.dtype": {
                                    "variable_value": "datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeTZDtype",
                                    "variable_shape": "()"
                                }
                            },
                            {
                                "_T": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                },
                                "arr": {
                                    "variable_value": "array([1357016400000000000, 1357102800000000000, 1357189200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self.dtype": {
                                    "variable_value": "datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeTZDtype",
                                    "variable_shape": "()"
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "_T": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                },
                                "arr": {
                                    "variable_value": "array([1357016400000000000, 1357102800000000000, 1357189200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self.dtype": {
                                    "variable_value": "datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeTZDtype",
                                    "variable_shape": "()"
                                }
                            },
                            {
                                "_T": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                },
                                "arr": {
                                    "variable_value": "array([1357016400000000000, 1357102800000000000, 1357189200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self.dtype": {
                                    "variable_value": "datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeTZDtype",
                                    "variable_shape": "()"
                                }
                            }
                        ]
                    ]
                },
                {
                    "function_name": "_box_func",
                    "function_code": "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)\n",
                    "decorators": [
                        "property"
                    ],
                    "docstring": "box function to get object from internal representation",
                    "start_line": 468,
                    "variables": {
                        "AbstractMethodError": [
                            473
                        ],
                        "self": [
                            473
                        ],
                        "property": [
                            468
                        ]
                    },
                    "filtered_variables": {
                        "AbstractMethodError": [
                            473
                        ],
                        "self": [
                            473
                        ]
                    },
                    "diff_line_number": 469,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_box_values",
                    "function_code": "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)\n",
                    "decorators": [],
                    "docstring": "apply box func to passed values",
                    "start_line": 475,
                    "variables": {
                        "lib.map_infer": [
                            479
                        ],
                        "lib": [
                            479
                        ],
                        "values": [
                            479
                        ],
                        "self._box_func": [
                            479
                        ],
                        "self": [
                            479
                        ]
                    },
                    "filtered_variables": {
                        "lib.map_infer": [
                            479
                        ],
                        "lib": [
                            479
                        ],
                        "values": [
                            479
                        ],
                        "self._box_func": [
                            479
                        ],
                        "self": [
                            479
                        ]
                    },
                    "diff_line_number": 475,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "__iter__",
                    "function_code": "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 481,
                    "variables": {
                        "self._box_func": [
                            482
                        ],
                        "self": [
                            482
                        ],
                        "v": [
                            482
                        ],
                        "self.asi8": [
                            482
                        ]
                    },
                    "filtered_variables": {
                        "self._box_func": [
                            482
                        ],
                        "self": [
                            482
                        ],
                        "v": [
                            482
                        ],
                        "self.asi8": [
                            482
                        ]
                    },
                    "diff_line_number": 481,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "asi8",
                    "function_code": "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    # do not cache or you'll create a memory leak\n    return self._data.view(\"i8\")\n",
                    "decorators": [
                        "property"
                    ],
                    "docstring": "Integer representation of the values.\n\nReturns\n-------\nndarray\n    An ndarray with int64 dtype.",
                    "start_line": 484,
                    "variables": {
                        "self._data.view": [
                            495
                        ],
                        "self._data": [
                            495
                        ],
                        "self": [
                            495
                        ],
                        "property": [
                            484
                        ],
                        "np.ndarray": [
                            485
                        ],
                        "np": [
                            485
                        ]
                    },
                    "filtered_variables": {
                        "self._data.view": [
                            495
                        ],
                        "self._data": [
                            495
                        ],
                        "self": [
                            495
                        ],
                        "np.ndarray": [
                            485
                        ],
                        "np": [
                            485
                        ]
                    },
                    "diff_line_number": 485,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_format_native_types",
                    "function_code": "def _format_native_types(self, na_rep=\"NaT\", date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)\n",
                    "decorators": [],
                    "docstring": "Helper method for astype when converting to strings.\n\nReturns\n-------\nndarray[str]",
                    "start_line": 500,
                    "variables": {
                        "AbstractMethodError": [
                            508
                        ],
                        "self": [
                            508
                        ]
                    },
                    "filtered_variables": {
                        "AbstractMethodError": [
                            508
                        ],
                        "self": [
                            508
                        ]
                    },
                    "diff_line_number": 500,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_formatter",
                    "function_code": "def _formatter(self, boxed=False):\n    # TODO: Remove Datetime & DatetimeTZ formatters.\n    return \"'{}'\".format\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 510,
                    "variables": {
                        "format": [
                            512
                        ]
                    },
                    "filtered_variables": {},
                    "diff_line_number": 510,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "__array__",
                    "function_code": "def __array__(self, dtype=None) -> np.ndarray:\n    # used for Timedelta/DatetimeArray, overwritten by PeriodArray\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 517,
                    "variables": {
                        "is_object_dtype": [
                            519
                        ],
                        "dtype": [
                            519
                        ],
                        "np.array": [
                            520
                        ],
                        "np": [
                            520,
                            517
                        ],
                        "list": [
                            520
                        ],
                        "self": [
                            520,
                            521
                        ],
                        "object": [
                            520
                        ],
                        "self._data": [
                            521
                        ],
                        "np.ndarray": [
                            517
                        ]
                    },
                    "filtered_variables": {
                        "is_object_dtype": [
                            519
                        ],
                        "dtype": [
                            519
                        ],
                        "np.array": [
                            520
                        ],
                        "np": [
                            520,
                            517
                        ],
                        "self": [
                            520,
                            521
                        ],
                        "self._data": [
                            521
                        ],
                        "np.ndarray": [
                            517
                        ]
                    },
                    "diff_line_number": 517,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "__getitem__",
                    "function_code": "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n\n    if com.is_bool_indexer(key):\n        # first convert to boolean, because check_array_indexer doesn't\n        # allow object dtype\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        # see https://github.com/pandas-dev/pandas/issues/31299, need to allow\n        # this for now (would otherwise raise in check_array_indexer)\n        pass\n    else:\n        key = check_array_indexer(self, key)\n\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)\n",
                    "decorators": [],
                    "docstring": "This getitem defers to the underlying array, which by-definition can\nonly handle list-likes, slices, and integer scalars",
                    "start_line": 523,
                    "variables": {
                        "com.is_bool_indexer": [
                            529
                        ],
                        "com": [
                            529
                        ],
                        "key": [
                            544,
                            545,
                            529,
                            532,
                            533,
                            535,
                            536,
                            537,
                            542
                        ],
                        "is_object_dtype": [
                            532
                        ],
                        "np.asarray": [
                            533
                        ],
                        "np": [
                            536,
                            533
                        ],
                        "bool": [
                            533
                        ],
                        "check_array_indexer": [
                            542,
                            535
                        ],
                        "self": [
                            544,
                            545,
                            547,
                            548,
                            535,
                            542
                        ],
                        "lib.maybe_booleans_to_slice": [
                            536
                        ],
                        "lib": [
                            536,
                            546
                        ],
                        "key.view": [
                            536
                        ],
                        "np.uint8": [
                            536
                        ],
                        "isinstance": [
                            537
                        ],
                        "list": [
                            537
                        ],
                        "len": [
                            537
                        ],
                        "slice": [
                            537
                        ],
                        "freq": [
                            544,
                            548
                        ],
                        "self._get_getitem_freq": [
                            544
                        ],
                        "result": [
                            545,
                            546,
                            547,
                            548
                        ],
                        "self._data": [
                            545
                        ],
                        "lib.is_scalar": [
                            546
                        ],
                        "self._box_func": [
                            547
                        ],
                        "self._simple_new": [
                            548
                        ],
                        "self.dtype": [
                            548
                        ]
                    },
                    "filtered_variables": {
                        "com.is_bool_indexer": [
                            529
                        ],
                        "com": [
                            529
                        ],
                        "key": [
                            544,
                            545,
                            529,
                            532,
                            533,
                            535,
                            536,
                            537,
                            542
                        ],
                        "is_object_dtype": [
                            532
                        ],
                        "np.asarray": [
                            533
                        ],
                        "np": [
                            536,
                            533
                        ],
                        "check_array_indexer": [
                            542,
                            535
                        ],
                        "self": [
                            544,
                            545,
                            547,
                            548,
                            535,
                            542
                        ],
                        "lib.maybe_booleans_to_slice": [
                            536
                        ],
                        "lib": [
                            536,
                            546
                        ],
                        "key.view": [
                            536
                        ],
                        "np.uint8": [
                            536
                        ],
                        "freq": [
                            544,
                            548
                        ],
                        "self._get_getitem_freq": [
                            544
                        ],
                        "result": [
                            545,
                            546,
                            547,
                            548
                        ],
                        "self._data": [
                            545
                        ],
                        "lib.is_scalar": [
                            546
                        ],
                        "self._box_func": [
                            547
                        ],
                        "self._simple_new": [
                            548
                        ],
                        "self.dtype": [
                            548
                        ]
                    },
                    "diff_line_number": 523,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_get_getitem_freq",
                    "function_code": "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            # GH#21282 indexing with Ellipsis is similar to a full slice,\n            #  should preserve `freq` attribute\n            freq = self.freq\n    return freq\n",
                    "decorators": [],
                    "docstring": "Find the `freq` attribute to assign to the result of a __getitem__ lookup.",
                    "start_line": 550,
                    "variables": {
                        "is_period": [
                            554,
                            555
                        ],
                        "is_period_dtype": [
                            554
                        ],
                        "self.dtype": [
                            554
                        ],
                        "self": [
                            554,
                            556,
                            560,
                            561,
                            563,
                            567
                        ],
                        "freq": [
                            556,
                            558,
                            561,
                            563,
                            567,
                            568
                        ],
                        "self.freq": [
                            556,
                            560,
                            561,
                            563,
                            567
                        ],
                        "isinstance": [
                            559
                        ],
                        "key": [
                            560,
                            561,
                            564,
                            559
                        ],
                        "slice": [
                            559
                        ],
                        "key.step": [
                            560,
                            561
                        ],
                        "Ellipsis": [
                            564
                        ]
                    },
                    "filtered_variables": {
                        "is_period": [
                            554,
                            555
                        ],
                        "is_period_dtype": [
                            554
                        ],
                        "self.dtype": [
                            554
                        ],
                        "self": [
                            554,
                            556,
                            560,
                            561,
                            563,
                            567
                        ],
                        "freq": [
                            556,
                            558,
                            561,
                            563,
                            567,
                            568
                        ],
                        "self.freq": [
                            556,
                            560,
                            561,
                            563,
                            567
                        ],
                        "key": [
                            560,
                            561,
                            564,
                            559
                        ],
                        "key.step": [
                            560,
                            561
                        ]
                    },
                    "diff_line_number": 550,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "__setitem__",
                    "function_code": "def __setitem__(\n    self,\n    key: Union[int, Sequence[int], Sequence[bool], slice],\n    value: Union[NaTType, Any, Sequence[Any]],\n) -> None:\n    # I'm fudging the types a bit here. \"Any\" above really depends\n    # on type(self). For PeriodArray, it's Period (or stuff coercible\n    # to a period in from_sequence). For DatetimeArray, it's Timestamp...\n    # I don't know if mypy can do that, possibly with Generics.\n    # https://mypy.readthedocs.io/en/latest/generics.html\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n\n        if lib.is_scalar(key):\n            raise ValueError(\"setting an array element with a sequence.\")\n\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and not com.is_bool_indexer(key):\n                msg = (\n                    f\"shape mismatch: value array of length '{len(key)}' \"\n                    \"does not match indexing result of length \"\n                    f\"'{len(value)}'.\"\n                )\n                raise ValueError(msg)\n            elif not len(key):\n                return\n\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 570,
                    "variables": {
                        "Union": [
                            572,
                            573
                        ],
                        "int": [
                            572
                        ],
                        "Sequence": [
                            587,
                            572,
                            573
                        ],
                        "bool": [
                            572
                        ],
                        "slice": [
                            572,
                            581
                        ],
                        "NaTType": [
                            573
                        ],
                        "Any": [
                            573
                        ],
                        "is_list_like": [
                            580
                        ],
                        "value": [
                            580,
                            588,
                            592,
                            598,
                            600
                        ],
                        "is_slice": [
                            586,
                            581
                        ],
                        "isinstance": [
                            581
                        ],
                        "key": [
                            581,
                            583,
                            587,
                            588,
                            590,
                            595,
                            599,
                            600
                        ],
                        "lib.is_scalar": [
                            583
                        ],
                        "lib": [
                            583
                        ],
                        "ValueError": [
                            584,
                            594
                        ],
                        "cast": [
                            587
                        ],
                        "len": [
                            592,
                            595,
                            588,
                            590
                        ],
                        "com.is_bool_indexer": [
                            588
                        ],
                        "com": [
                            588
                        ],
                        "msg": [
                            594,
                            589
                        ],
                        "self._validate_setitem_value": [
                            598
                        ],
                        "self": [
                            600,
                            601,
                            598,
                            599
                        ],
                        "check_array_indexer": [
                            599
                        ],
                        "self._data": [
                            600
                        ],
                        "self._maybe_clear_freq": [
                            601
                        ]
                    },
                    "filtered_variables": {
                        "Union": [
                            572,
                            573
                        ],
                        "Sequence": [
                            587,
                            572,
                            573
                        ],
                        "NaTType": [
                            573
                        ],
                        "Any": [
                            573
                        ],
                        "is_list_like": [
                            580
                        ],
                        "value": [
                            580,
                            588,
                            592,
                            598,
                            600
                        ],
                        "is_slice": [
                            586,
                            581
                        ],
                        "key": [
                            581,
                            583,
                            587,
                            588,
                            590,
                            595,
                            599,
                            600
                        ],
                        "lib.is_scalar": [
                            583
                        ],
                        "lib": [
                            583
                        ],
                        "cast": [
                            587
                        ],
                        "com.is_bool_indexer": [
                            588
                        ],
                        "com": [
                            588
                        ],
                        "msg": [
                            594,
                            589
                        ],
                        "self._validate_setitem_value": [
                            598
                        ],
                        "self": [
                            600,
                            601,
                            598,
                            599
                        ],
                        "check_array_indexer": [
                            599
                        ],
                        "self._data": [
                            600
                        ],
                        "self._maybe_clear_freq": [
                            601
                        ]
                    },
                    "diff_line_number": 570,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_maybe_clear_freq",
                    "function_code": "def _maybe_clear_freq(self):\n    # inplace operations like __setitem__ may invalidate the freq of\n    # DatetimeArray and TimedeltaArray\n    pass\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 603,
                    "variables": {},
                    "filtered_variables": {},
                    "diff_line_number": 603,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "astype",
                    "function_code": "def astype(self, dtype, copy=True):\n    # Some notes on cases we don't have to handle here in the base class:\n    #   1. PeriodArray.astype handles period -> period\n    #   2. DatetimeArray.astype handles conversion between tz.\n    #   3. DatetimeArray.astype handles datetime -> period\n    dtype = pandas_dtype(dtype)\n\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and not is_categorical_dtype(dtype):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        # we deliberately ignore int32 vs. int64 here.\n        # See https://github.com/pandas-dev/pandas/issues/24381 for more.\n        values = self.asi8\n\n        if is_unsigned_integer_dtype(dtype):\n            # Again, we ignore int32 vs. int64\n            values = values.view(\"uint64\")\n\n        if copy:\n            values = values.copy()\n        return values\n    elif (\n        is_datetime_or_timedelta_dtype(dtype)\n        and not is_dtype_equal(self.dtype, dtype)\n    ) or is_float_dtype(dtype):\n        # disallow conversion between datetime/timedelta,\n        # and conversions for any datetimelike to float\n        msg = f\"Cannot cast {type(self).__name__} to dtype {dtype}\"\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 608,
                    "variables": {
                        "dtype": [
                            640,
                            641,
                            643,
                            613,
                            615,
                            617,
                            619,
                            624,
                            632,
                            633,
                            634,
                            637,
                            639
                        ],
                        "pandas_dtype": [
                            613
                        ],
                        "is_object_dtype": [
                            615
                        ],
                        "reshape": [
                            616
                        ],
                        "self._box_values": [
                            616
                        ],
                        "self": [
                            641,
                            643,
                            616,
                            618,
                            622,
                            633,
                            637
                        ],
                        "self.asi8.ravel": [
                            616
                        ],
                        "self.asi8": [
                            616,
                            622
                        ],
                        "self.shape": [
                            616
                        ],
                        "is_string_dtype": [
                            617
                        ],
                        "is_categorical_dtype": [
                            617,
                            639
                        ],
                        "self._format_native_types": [
                            618
                        ],
                        "is_integer_dtype": [
                            619
                        ],
                        "values": [
                            626,
                            630,
                            629,
                            622
                        ],
                        "is_unsigned_integer_dtype": [
                            624
                        ],
                        "values.view": [
                            626
                        ],
                        "copy": [
                            628
                        ],
                        "values.copy": [
                            629
                        ],
                        "is_datetime_or_timedelta_dtype": [
                            632
                        ],
                        "is_dtype_equal": [
                            633
                        ],
                        "self.dtype": [
                            633
                        ],
                        "is_float_dtype": [
                            634
                        ],
                        "msg": [
                            637,
                            638
                        ],
                        "__name__": [
                            637
                        ],
                        "type": [
                            637
                        ],
                        "TypeError": [
                            638
                        ],
                        "arr_cls": [
                            640,
                            641
                        ],
                        "dtype.construct_array_type": [
                            640
                        ],
                        "np.asarray": [
                            643
                        ],
                        "np": [
                            643
                        ]
                    },
                    "filtered_variables": {
                        "dtype": [
                            640,
                            641,
                            643,
                            613,
                            615,
                            617,
                            619,
                            624,
                            632,
                            633,
                            634,
                            637,
                            639
                        ],
                        "pandas_dtype": [
                            613
                        ],
                        "is_object_dtype": [
                            615
                        ],
                        "reshape": [
                            616
                        ],
                        "self._box_values": [
                            616
                        ],
                        "self": [
                            641,
                            643,
                            616,
                            618,
                            622,
                            633,
                            637
                        ],
                        "self.asi8.ravel": [
                            616
                        ],
                        "self.asi8": [
                            616,
                            622
                        ],
                        "self.shape": [
                            616
                        ],
                        "is_string_dtype": [
                            617
                        ],
                        "is_categorical_dtype": [
                            617,
                            639
                        ],
                        "self._format_native_types": [
                            618
                        ],
                        "is_integer_dtype": [
                            619
                        ],
                        "values": [
                            626,
                            630,
                            629,
                            622
                        ],
                        "is_unsigned_integer_dtype": [
                            624
                        ],
                        "values.view": [
                            626
                        ],
                        "copy": [
                            628
                        ],
                        "values.copy": [
                            629
                        ],
                        "is_datetime_or_timedelta_dtype": [
                            632
                        ],
                        "is_dtype_equal": [
                            633
                        ],
                        "self.dtype": [
                            633
                        ],
                        "is_float_dtype": [
                            634
                        ],
                        "msg": [
                            637,
                            638
                        ],
                        "arr_cls": [
                            640,
                            641
                        ],
                        "dtype.construct_array_type": [
                            640
                        ],
                        "np.asarray": [
                            643
                        ],
                        "np": [
                            643
                        ]
                    },
                    "diff_line_number": 608,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "view",
                    "function_code": "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 645,
                    "variables": {
                        "dtype": [
                            648,
                            646
                        ],
                        "self.dtype": [
                            646,
                            647
                        ],
                        "self": [
                            648,
                            646,
                            647
                        ],
                        "type": [
                            647
                        ],
                        "self._data": [
                            648,
                            647
                        ],
                        "self._data.view": [
                            648
                        ]
                    },
                    "filtered_variables": {
                        "dtype": [
                            648,
                            646
                        ],
                        "self.dtype": [
                            646,
                            647
                        ],
                        "self": [
                            648,
                            646,
                            647
                        ],
                        "self._data": [
                            648,
                            647
                        ],
                        "self._data.view": [
                            648
                        ]
                    },
                    "diff_line_number": 645,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeTZDtype",
                                    "variable_shape": "()"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                },
                                "self._data": {
                                    "variable_value": "array(['2013-01-01T05:00:00.000000000', '2013-01-02T05:00:00.000000000',\n       '2013-01-03T05:00:00.000000000'], dtype='datetime64[ns]')",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self._data.view": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            },
                            {
                                "dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeTZDtype",
                                    "variable_shape": "()"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                },
                                "self._data": {
                                    "variable_value": "array(['2013-01-01T05:00:00.000000000', '2013-01-02T05:00:00.000000000',\n       '2013-01-03T05:00:00.000000000'], dtype='datetime64[ns]')",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self._data.view": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                },
                {
                    "function_name": "_concat_same_type",
                    "function_code": "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int = 0):\n\n    # do not pass tz to set because tzlocal cannot be hashed\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError(\"to_concat must have the same dtype (tz)\", dtypes)\n\n    obj = to_concat[0]\n    dtype = obj.dtype\n\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        # GH 3232: If the concat result is evenly spaced, we can retain the\n        # original frequency\n        to_concat = [x for x in to_concat if len(x)]\n\n        if obj.freq is not None and all(x.freq == obj.freq for x in to_concat):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all(pair[0][-1] + obj.freq == pair[1][0] for pair in pairs):\n                new_freq = obj.freq\n\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)\n",
                    "decorators": [
                        "classmethod"
                    ],
                    "docstring": null,
                    "start_line": 653,
                    "variables": {
                        "int": [
                            654
                        ],
                        "dtypes": [
                            657,
                            658,
                            659
                        ],
                        "str": [
                            657
                        ],
                        "x.dtype": [
                            657
                        ],
                        "x": [
                            664,
                            657,
                            673,
                            675
                        ],
                        "to_concat": [
                            673,
                            675,
                            676,
                            657,
                            661,
                            664
                        ],
                        "len": [
                            673,
                            658
                        ],
                        "ValueError": [
                            659
                        ],
                        "obj": [
                            675,
                            677,
                            678,
                            661,
                            662,
                            669
                        ],
                        "dtype": [
                            680,
                            668,
                            662
                        ],
                        "obj.dtype": [
                            662
                        ],
                        "i8values": [
                            664,
                            665
                        ],
                        "x.asi8": [
                            664
                        ],
                        "values": [
                            680,
                            665
                        ],
                        "np.concatenate": [
                            665
                        ],
                        "np": [
                            665
                        ],
                        "axis": [
                            665,
                            670
                        ],
                        "new_freq": [
                            680,
                            667,
                            669,
                            678
                        ],
                        "is_period_dtype": [
                            668
                        ],
                        "obj.freq": [
                            675,
                            669,
                            678,
                            677
                        ],
                        "all": [
                            675,
                            677
                        ],
                        "x.freq": [
                            675
                        ],
                        "pairs": [
                            676,
                            677
                        ],
                        "zip": [
                            676
                        ],
                        "pair": [
                            677
                        ],
                        "cls._simple_new": [
                            680
                        ],
                        "cls": [
                            680
                        ],
                        "classmethod": [
                            653
                        ]
                    },
                    "filtered_variables": {
                        "dtypes": [
                            657,
                            658,
                            659
                        ],
                        "x.dtype": [
                            657
                        ],
                        "x": [
                            664,
                            657,
                            673,
                            675
                        ],
                        "to_concat": [
                            673,
                            675,
                            676,
                            657,
                            661,
                            664
                        ],
                        "obj": [
                            675,
                            677,
                            678,
                            661,
                            662,
                            669
                        ],
                        "dtype": [
                            680,
                            668,
                            662
                        ],
                        "obj.dtype": [
                            662
                        ],
                        "i8values": [
                            664,
                            665
                        ],
                        "x.asi8": [
                            664
                        ],
                        "values": [
                            680,
                            665
                        ],
                        "np.concatenate": [
                            665
                        ],
                        "np": [
                            665
                        ],
                        "axis": [
                            665,
                            670
                        ],
                        "new_freq": [
                            680,
                            667,
                            669,
                            678
                        ],
                        "is_period_dtype": [
                            668
                        ],
                        "obj.freq": [
                            675,
                            669,
                            678,
                            677
                        ],
                        "x.freq": [
                            675
                        ],
                        "pairs": [
                            676,
                            677
                        ],
                        "pair": [
                            677
                        ],
                        "cls._simple_new": [
                            680
                        ],
                        "cls": [
                            680
                        ]
                    },
                    "diff_line_number": 654,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "copy",
                    "function_code": "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 682,
                    "variables": {
                        "values": [
                            683,
                            684
                        ],
                        "self.asi8.copy": [
                            683
                        ],
                        "self.asi8": [
                            683
                        ],
                        "self": [
                            683,
                            684
                        ],
                        "_simple_new": [
                            684
                        ],
                        "type": [
                            684
                        ],
                        "self.dtype": [
                            684
                        ],
                        "self.freq": [
                            684
                        ]
                    },
                    "filtered_variables": {
                        "values": [
                            683,
                            684
                        ],
                        "self.asi8.copy": [
                            683
                        ],
                        "self.asi8": [
                            683
                        ],
                        "self": [
                            683,
                            684
                        ],
                        "_simple_new": [
                            684
                        ],
                        "self.dtype": [
                            684
                        ],
                        "self.freq": [
                            684
                        ]
                    },
                    "diff_line_number": 682,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_values_for_factorize",
                    "function_code": "def _values_for_factorize(self):\n    return self.asi8, iNaT\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 686,
                    "variables": {
                        "self.asi8": [
                            687
                        ],
                        "self": [
                            687
                        ],
                        "iNaT": [
                            687
                        ]
                    },
                    "filtered_variables": {
                        "self.asi8": [
                            687
                        ],
                        "self": [
                            687
                        ],
                        "iNaT": [
                            687
                        ]
                    },
                    "diff_line_number": 686,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {
                                "self.asi8": {
                                    "variable_value": "array([1357016400000000000, 1357102800000000000, 1357189200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "self.asi8": {
                                    "variable_value": "array([1357016400000000000, 1357102800000000000, 1357189200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "self.asi8": {
                                    "variable_value": "array([1357016400000000000, 1357102800000000000, 1357189200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "self.asi8": {
                                    "variable_value": "array([1357016400000000000, 1357102800000000000, 1357189200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                },
                {
                    "function_name": "_from_factorized",
                    "function_code": "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)\n",
                    "decorators": [
                        "classmethod"
                    ],
                    "docstring": null,
                    "start_line": 689,
                    "variables": {
                        "cls": [
                            691
                        ],
                        "values": [
                            691
                        ],
                        "original.dtype": [
                            691
                        ],
                        "original": [
                            691
                        ],
                        "classmethod": [
                            689
                        ]
                    },
                    "filtered_variables": {
                        "cls": [
                            691
                        ],
                        "values": [
                            691
                        ],
                        "original.dtype": [
                            691
                        ],
                        "original": [
                            691
                        ]
                    },
                    "diff_line_number": 690,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimes.DatetimeArray'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10ed11a40>"
                                },
                                "values": {
                                    "variable_value": "array([1357016400000000000, 1357102800000000000, 1357189200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "original.dtype": {
                                    "variable_value": "datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeTZDtype",
                                    "variable_shape": "()"
                                },
                                "original": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                }
                            },
                            {
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimes.DatetimeArray'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10ed11a40>"
                                },
                                "values": {
                                    "variable_value": "array([1357016400000000000, 1357102800000000000, 1357189200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "original.dtype": {
                                    "variable_value": "datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeTZDtype",
                                    "variable_shape": "()"
                                },
                                "original": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimes.DatetimeArray'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x1149aa900>"
                                },
                                "values": {
                                    "variable_value": "array([1357016400000000000, 1357102800000000000, 1357189200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "original.dtype": {
                                    "variable_value": "datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeTZDtype",
                                    "variable_shape": "()"
                                },
                                "original": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                }
                            },
                            {
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimes.DatetimeArray'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x1149aa900>"
                                },
                                "values": {
                                    "variable_value": "array([1357016400000000000, 1357102800000000000, 1357189200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "original.dtype": {
                                    "variable_value": "datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeTZDtype",
                                    "variable_shape": "()"
                                },
                                "original": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                }
                            }
                        ]
                    ]
                },
                {
                    "function_name": "_values_for_argsort",
                    "function_code": "def _values_for_argsort(self):\n    return self._data\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 693,
                    "variables": {
                        "self._data": [
                            694
                        ],
                        "self": [
                            694
                        ]
                    },
                    "filtered_variables": {
                        "self._data": [
                            694
                        ],
                        "self": [
                            694
                        ]
                    },
                    "diff_line_number": 693,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {
                                "self._data": {
                                    "variable_value": "array(['2013-01-01T05:00:00.000000000', '2013-01-02T05:00:00.000000000',\n       '2013-01-03T05:00:00.000000000'], dtype='datetime64[ns]')",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                }
                            },
                            {
                                "self._data": {
                                    "variable_value": "array(['2013-01-01T05:00:00.000000000', '2013-01-02T05:00:00.000000000',\n       '2013-01-03T05:00:00.000000000'], dtype='datetime64[ns]')",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                }
                            }
                        ],
                        [
                            {
                                "self._data": {
                                    "variable_value": "array(['2013-01-01T05:00:00.000000000', '2013-01-02T05:00:00.000000000',\n       '2013-01-03T05:00:00.000000000'], dtype='datetime64[ns]')",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                }
                            },
                            {
                                "self._data": {
                                    "variable_value": "array(['2013-01-01T05:00:00.000000000', '2013-01-02T05:00:00.000000000',\n       '2013-01-03T05:00:00.000000000'], dtype='datetime64[ns]')",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "self._data": {
                                    "variable_value": "array(['2013-01-01T05:00:00.000000000', '2013-01-02T05:00:00.000000000',\n       '2013-01-03T05:00:00.000000000'], dtype='datetime64[ns]')",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                }
                            },
                            {
                                "self._data": {
                                    "variable_value": "array(['2013-01-01T05:00:00.000000000', '2013-01-02T05:00:00.000000000',\n       '2013-01-03T05:00:00.000000000'], dtype='datetime64[ns]')",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                }
                            }
                        ],
                        [
                            {
                                "self._data": {
                                    "variable_value": "array(['2013-01-01T05:00:00.000000000', '2013-01-02T05:00:00.000000000',\n       '2013-01-03T05:00:00.000000000'], dtype='datetime64[ns]')",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                }
                            },
                            {
                                "self._data": {
                                    "variable_value": "array(['2013-01-01T05:00:00.000000000', '2013-01-02T05:00:00.000000000',\n       '2013-01-03T05:00:00.000000000'], dtype='datetime64[ns]')",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                }
                            }
                        ]
                    ]
                },
                {
                    "function_name": "shift",
                    "function_code": "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n\n    return type(self)._simple_new(new_values, dtype=self.dtype)\n",
                    "decorators": [
                        "Appender(ExtensionArray.shift.__doc__)"
                    ],
                    "docstring": null,
                    "start_line": 696,
                    "variables": {
                        "self.size": [
                            698
                        ],
                        "self": [
                            704,
                            698,
                            699,
                            701,
                            702
                        ],
                        "periods": [
                            698,
                            702
                        ],
                        "self.copy": [
                            699
                        ],
                        "fill_value": [
                            701,
                            702
                        ],
                        "self._validate_shift_value": [
                            701
                        ],
                        "new_values": [
                            704,
                            702
                        ],
                        "shift": [
                            702
                        ],
                        "self._data": [
                            702
                        ],
                        "axis": [
                            702
                        ],
                        "_simple_new": [
                            704
                        ],
                        "type": [
                            704
                        ],
                        "self.dtype": [
                            704
                        ],
                        "Appender": [
                            696
                        ],
                        "ExtensionArray.shift.__doc__": [
                            696
                        ],
                        "ExtensionArray.shift": [
                            696
                        ],
                        "ExtensionArray": [
                            696
                        ]
                    },
                    "filtered_variables": {
                        "self.size": [
                            698
                        ],
                        "self": [
                            704,
                            698,
                            699,
                            701,
                            702
                        ],
                        "periods": [
                            698,
                            702
                        ],
                        "self.copy": [
                            699
                        ],
                        "fill_value": [
                            701,
                            702
                        ],
                        "self._validate_shift_value": [
                            701
                        ],
                        "new_values": [
                            704,
                            702
                        ],
                        "shift": [
                            702
                        ],
                        "self._data": [
                            702
                        ],
                        "axis": [
                            702
                        ],
                        "_simple_new": [
                            704
                        ],
                        "self.dtype": [
                            704
                        ],
                        "Appender": [
                            696
                        ],
                        "ExtensionArray.shift.__doc__": [
                            696
                        ],
                        "ExtensionArray.shift": [
                            696
                        ],
                        "ExtensionArray": [
                            696
                        ]
                    },
                    "diff_line_number": 697,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_validate_fill_value",
                    "function_code": "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(\n            f\"'fill_value' should be a {self._scalar_type}. \"\n            f\"Got '{str(fill_value)}'.\"\n        )\n    return fill_value\n",
                    "decorators": [],
                    "docstring": "If a fill_value is passed to `take` convert it to an i8 representation,\nraising ValueError if this is not possible.\n\nParameters\n----------\nfill_value : object\n\nReturns\n-------\nfill_value : np.int64\n\nRaises\n------\nValueError",
                    "start_line": 710,
                    "variables": {
                        "is_valid_nat_for_dtype": [
                            727
                        ],
                        "fill_value": [
                            736,
                            738,
                            727,
                            728,
                            729,
                            730,
                            731,
                            732
                        ],
                        "self.dtype": [
                            727
                        ],
                        "self": [
                            727,
                            729,
                            730,
                            731,
                            732,
                            735
                        ],
                        "iNaT": [
                            728
                        ],
                        "isinstance": [
                            729
                        ],
                        "self._recognized_scalars": [
                            729
                        ],
                        "self._check_compatible_with": [
                            730
                        ],
                        "self._scalar_type": [
                            731,
                            735
                        ],
                        "self._unbox_scalar": [
                            732
                        ],
                        "ValueError": [
                            734
                        ],
                        "str": [
                            736
                        ]
                    },
                    "filtered_variables": {
                        "is_valid_nat_for_dtype": [
                            727
                        ],
                        "fill_value": [
                            736,
                            738,
                            727,
                            728,
                            729,
                            730,
                            731,
                            732
                        ],
                        "self.dtype": [
                            727
                        ],
                        "self": [
                            727,
                            729,
                            730,
                            731,
                            732,
                            735
                        ],
                        "iNaT": [
                            728
                        ],
                        "self._recognized_scalars": [
                            729
                        ],
                        "self._check_compatible_with": [
                            730
                        ],
                        "self._scalar_type": [
                            731,
                            735
                        ],
                        "self._unbox_scalar": [
                            732
                        ]
                    },
                    "diff_line_number": 710,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_validate_shift_value",
                    "function_code": "def _validate_shift_value(self, fill_value):\n    # TODO(2.0): once this deprecation is enforced, used _validate_fill_value\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        # only warn if we're not going to raise\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            # kludge for #31971 since Period(integer) tries to cast to str\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n\n        # stacklevel here is chosen to be correct when called from\n        #  DataFrame.shift or Series.shift\n        warnings.warn(\n            f\"Passing {type(fill_value)} to shift is deprecated and \"\n            \"will raise in a future version, pass \"\n            f\"{self._scalar_type.__name__} instead.\",\n            FutureWarning,\n            stacklevel=10,\n        )\n        fill_value = new_fill\n\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 740,
                    "variables": {
                        "is_valid_nat_for_dtype": [
                            742
                        ],
                        "fill_value": [
                            742,
                            743,
                            744,
                            746,
                            748,
                            750,
                            755,
                            761,
                            763,
                            764
                        ],
                        "self.dtype": [
                            742
                        ],
                        "self": [
                            742,
                            744,
                            746,
                            748,
                            750,
                            757,
                            763
                        ],
                        "NaT": [
                            743
                        ],
                        "isinstance": [
                            744
                        ],
                        "self._recognized_scalars": [
                            744
                        ],
                        "self._scalar_type": [
                            746,
                            757,
                            750
                        ],
                        "Period": [
                            746,
                            748
                        ],
                        "lib.is_integer": [
                            746
                        ],
                        "lib": [
                            746
                        ],
                        "new_fill": [
                            761,
                            748,
                            750
                        ],
                        "Period._from_ordinal": [
                            748
                        ],
                        "self.freq": [
                            748
                        ],
                        "warnings.warn": [
                            754
                        ],
                        "warnings": [
                            754
                        ],
                        "type": [
                            755
                        ],
                        "self._scalar_type.__name__": [
                            757
                        ],
                        "FutureWarning": [
                            758
                        ],
                        "self._unbox_scalar": [
                            763
                        ]
                    },
                    "filtered_variables": {
                        "is_valid_nat_for_dtype": [
                            742
                        ],
                        "fill_value": [
                            742,
                            743,
                            744,
                            746,
                            748,
                            750,
                            755,
                            761,
                            763,
                            764
                        ],
                        "self.dtype": [
                            742
                        ],
                        "self": [
                            742,
                            744,
                            746,
                            748,
                            750,
                            757,
                            763
                        ],
                        "NaT": [
                            743
                        ],
                        "self._recognized_scalars": [
                            744
                        ],
                        "self._scalar_type": [
                            746,
                            757,
                            750
                        ],
                        "Period": [
                            746,
                            748
                        ],
                        "lib.is_integer": [
                            746
                        ],
                        "lib": [
                            746
                        ],
                        "new_fill": [
                            761,
                            748,
                            750
                        ],
                        "Period._from_ordinal": [
                            748
                        ],
                        "self.freq": [
                            748
                        ],
                        "warnings.warn": [
                            754
                        ],
                        "warnings": [
                            754
                        ],
                        "self._scalar_type.__name__": [
                            757
                        ],
                        "self._unbox_scalar": [
                            763
                        ]
                    },
                    "diff_line_number": 740,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_validate_searchsorted_value",
                    "function_code": "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError(\n                \"searchsorted requires compatible dtype or scalar\"\n            ) from err\n\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n\n    elif is_list_like(value) and not isinstance(value, type(self)):\n        value = array(value)\n\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(\n                \"searchsorted requires compatible dtype or scalar, \"\n                f\"not {type(value).__name__}\"\n            )\n\n    if not (isinstance(value, (self._scalar_type, type(self))) or (value is NaT)):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n\n    return value\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 766,
                    "variables": {
                        "isinstance": [
                            778,
                            781,
                            790,
                            793,
                            767
                        ],
                        "value": [
                            769,
                            775,
                            776,
                            778,
                            779,
                            781,
                            782,
                            784,
                            787,
                            799,
                            790,
                            791,
                            793,
                            794,
                            795,
                            797,
                            767
                        ],
                        "str": [
                            767
                        ],
                        "self._scalar_from_string": [
                            769
                        ],
                        "self": [
                            769,
                            775,
                            778,
                            779,
                            781,
                            784,
                            790,
                            793,
                            794,
                            797
                        ],
                        "ValueError": [
                            770
                        ],
                        "TypeError": [
                            785,
                            771,
                            791
                        ],
                        "err": [
                            773
                        ],
                        "is_valid_nat_for_dtype": [
                            775
                        ],
                        "self.dtype": [
                            775
                        ],
                        "NaT": [
                            776,
                            790
                        ],
                        "self._recognized_scalars": [
                            778
                        ],
                        "self._scalar_type": [
                            779,
                            790
                        ],
                        "is_list_like": [
                            781
                        ],
                        "type": [
                            781,
                            784,
                            787,
                            790,
                            791,
                            793
                        ],
                        "array": [
                            782
                        ],
                        "_is_recognized_dtype": [
                            784
                        ],
                        "__name__": [
                            787
                        ],
                        "self._check_compatible_with": [
                            794
                        ],
                        "value.asi8": [
                            795
                        ],
                        "self._unbox_scalar": [
                            797
                        ]
                    },
                    "filtered_variables": {
                        "value": [
                            769,
                            775,
                            776,
                            778,
                            779,
                            781,
                            782,
                            784,
                            787,
                            799,
                            790,
                            791,
                            793,
                            794,
                            795,
                            797,
                            767
                        ],
                        "self._scalar_from_string": [
                            769
                        ],
                        "self": [
                            769,
                            775,
                            778,
                            779,
                            781,
                            784,
                            790,
                            793,
                            794,
                            797
                        ],
                        "err": [
                            773
                        ],
                        "is_valid_nat_for_dtype": [
                            775
                        ],
                        "self.dtype": [
                            775
                        ],
                        "NaT": [
                            776,
                            790
                        ],
                        "self._recognized_scalars": [
                            778
                        ],
                        "self._scalar_type": [
                            779,
                            790
                        ],
                        "is_list_like": [
                            781
                        ],
                        "array": [
                            782
                        ],
                        "_is_recognized_dtype": [
                            784
                        ],
                        "self._check_compatible_with": [
                            794
                        ],
                        "value.asi8": [
                            795
                        ],
                        "self._unbox_scalar": [
                            797
                        ]
                    },
                    "diff_line_number": 766,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_validate_setitem_value",
                    "function_code": "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and not isna(value):\n        value = com.maybe_box_datetimelike(value)\n\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = (\n            f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', \"\n            f\"or array of those. Got '{type(value).__name__}' instead.\"\n        )\n        raise TypeError(msg)\n\n    return value\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 801,
                    "variables": {
                        "lib.is_scalar": [
                            802
                        ],
                        "lib": [
                            802
                        ],
                        "value": [
                            802,
                            803,
                            805,
                            806,
                            807,
                            808,
                            809,
                            810,
                            811,
                            812,
                            813,
                            817,
                            821
                        ],
                        "isna": [
                            802
                        ],
                        "com.maybe_box_datetimelike": [
                            803
                        ],
                        "com": [
                            803
                        ],
                        "is_list_like": [
                            805
                        ],
                        "_from_sequence": [
                            806
                        ],
                        "type": [
                            817,
                            806
                        ],
                        "self": [
                            806,
                            807,
                            809,
                            810,
                            811,
                            812,
                            816
                        ],
                        "self.dtype": [
                            812,
                            806
                        ],
                        "self._check_compatible_with": [
                            810,
                            807
                        ],
                        "value.asi8": [
                            808
                        ],
                        "isinstance": [
                            809
                        ],
                        "self._scalar_type": [
                            816,
                            809
                        ],
                        "self._unbox_scalar": [
                            811
                        ],
                        "is_valid_nat_for_dtype": [
                            812
                        ],
                        "iNaT": [
                            813
                        ],
                        "msg": [
                            819,
                            815
                        ],
                        "self._scalar_type.__name__": [
                            816
                        ],
                        "__name__": [
                            817
                        ],
                        "TypeError": [
                            819
                        ]
                    },
                    "filtered_variables": {
                        "lib.is_scalar": [
                            802
                        ],
                        "lib": [
                            802
                        ],
                        "value": [
                            802,
                            803,
                            805,
                            806,
                            807,
                            808,
                            809,
                            810,
                            811,
                            812,
                            813,
                            817,
                            821
                        ],
                        "isna": [
                            802
                        ],
                        "com.maybe_box_datetimelike": [
                            803
                        ],
                        "com": [
                            803
                        ],
                        "is_list_like": [
                            805
                        ],
                        "_from_sequence": [
                            806
                        ],
                        "self": [
                            806,
                            807,
                            809,
                            810,
                            811,
                            812,
                            816
                        ],
                        "self.dtype": [
                            812,
                            806
                        ],
                        "self._check_compatible_with": [
                            810,
                            807
                        ],
                        "value.asi8": [
                            808
                        ],
                        "self._scalar_type": [
                            816,
                            809
                        ],
                        "self._unbox_scalar": [
                            811
                        ],
                        "is_valid_nat_for_dtype": [
                            812
                        ],
                        "iNaT": [
                            813
                        ],
                        "msg": [
                            819,
                            815
                        ],
                        "self._scalar_type.__name__": [
                            816
                        ]
                    },
                    "diff_line_number": 801,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_validate_insert_value",
                    "function_code": "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n        # TODO: if we dont have compat, should we raise or astype(object)?\n        #  PeriodIndex does astype(object)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        # GH#18295\n        value = NaT\n    else:\n        raise TypeError(\n            f\"cannot insert {type(self).__name__} with incompatible label\"\n        )\n\n    return value\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 823,
                    "variables": {
                        "isinstance": [
                            824
                        ],
                        "value": [
                            837,
                            824,
                            825,
                            826,
                            829,
                            831
                        ],
                        "self._recognized_scalars": [
                            824
                        ],
                        "self": [
                            834,
                            824,
                            825,
                            826,
                            829
                        ],
                        "self._scalar_type": [
                            825
                        ],
                        "self._check_compatible_with": [
                            826
                        ],
                        "is_valid_nat_for_dtype": [
                            829
                        ],
                        "self.dtype": [
                            829
                        ],
                        "NaT": [
                            831
                        ],
                        "TypeError": [
                            833
                        ],
                        "__name__": [
                            834
                        ],
                        "type": [
                            834
                        ]
                    },
                    "filtered_variables": {
                        "value": [
                            837,
                            824,
                            825,
                            826,
                            829,
                            831
                        ],
                        "self._recognized_scalars": [
                            824
                        ],
                        "self": [
                            834,
                            824,
                            825,
                            826,
                            829
                        ],
                        "self._scalar_type": [
                            825
                        ],
                        "self._check_compatible_with": [
                            826
                        ],
                        "is_valid_nat_for_dtype": [
                            829
                        ],
                        "self.dtype": [
                            829
                        ],
                        "NaT": [
                            831
                        ]
                    },
                    "diff_line_number": 823,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_validate_where_value",
                    "function_code": "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f\"Where requires matching dtype, not {type(other)}\")\n\n    else:\n        # Do type inference if necessary up front\n        # e.g. we passed PeriodIndex.values and got an ndarray of Periods\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n\n        if is_categorical_dtype(other.dtype):\n            # e.g. we have a Categorical holding self.dtype\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f\"Where requires matching dtype, not {other.dtype}\")\n        self._check_compatible_with(other, setitem=True)\n\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view(\"i8\")\n\n    return other\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 839,
                    "variables": {
                        "is_valid_nat_for_dtype": [
                            840
                        ],
                        "other": [
                            840,
                            841,
                            842,
                            843,
                            844,
                            845,
                            846,
                            851,
                            852,
                            854,
                            856,
                            857,
                            859,
                            860,
                            861,
                            863,
                            864,
                            866,
                            868
                        ],
                        "self.dtype": [
                            840,
                            856
                        ],
                        "self": [
                            864,
                            840,
                            842,
                            843,
                            844,
                            856,
                            859,
                            861
                        ],
                        "NaT": [
                            841
                        ],
                        "isinstance": [
                            842
                        ],
                        "self._recognized_scalars": [
                            842
                        ],
                        "self._scalar_type": [
                            843
                        ],
                        "self._check_compatible_with": [
                            844,
                            861
                        ],
                        "is_list_like": [
                            845
                        ],
                        "TypeError": [
                            860,
                            846
                        ],
                        "type": [
                            859,
                            846
                        ],
                        "array": [
                            851
                        ],
                        "extract_array": [
                            852
                        ],
                        "is_categorical_dtype": [
                            854
                        ],
                        "other.dtype": [
                            859,
                            860,
                            854
                        ],
                        "is_dtype_equal": [
                            856
                        ],
                        "other.categories.dtype": [
                            856
                        ],
                        "other.categories": [
                            856
                        ],
                        "other._internal_get_values": [
                            857
                        ],
                        "_is_recognized_dtype": [
                            859
                        ],
                        "lib.is_scalar": [
                            863
                        ],
                        "lib": [
                            863
                        ],
                        "self._unbox_scalar": [
                            864
                        ],
                        "other.view": [
                            866
                        ]
                    },
                    "filtered_variables": {
                        "is_valid_nat_for_dtype": [
                            840
                        ],
                        "other": [
                            840,
                            841,
                            842,
                            843,
                            844,
                            845,
                            846,
                            851,
                            852,
                            854,
                            856,
                            857,
                            859,
                            860,
                            861,
                            863,
                            864,
                            866,
                            868
                        ],
                        "self.dtype": [
                            840,
                            856
                        ],
                        "self": [
                            864,
                            840,
                            842,
                            843,
                            844,
                            856,
                            859,
                            861
                        ],
                        "NaT": [
                            841
                        ],
                        "self._recognized_scalars": [
                            842
                        ],
                        "self._scalar_type": [
                            843
                        ],
                        "self._check_compatible_with": [
                            844,
                            861
                        ],
                        "is_list_like": [
                            845
                        ],
                        "array": [
                            851
                        ],
                        "extract_array": [
                            852
                        ],
                        "is_categorical_dtype": [
                            854
                        ],
                        "other.dtype": [
                            859,
                            860,
                            854
                        ],
                        "is_dtype_equal": [
                            856
                        ],
                        "other.categories.dtype": [
                            856
                        ],
                        "other.categories": [
                            856
                        ],
                        "other._internal_get_values": [
                            857
                        ],
                        "_is_recognized_dtype": [
                            859
                        ],
                        "lib.is_scalar": [
                            863
                        ],
                        "lib": [
                            863
                        ],
                        "self._unbox_scalar": [
                            864
                        ],
                        "other.view": [
                            866
                        ]
                    },
                    "diff_line_number": 839,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "searchsorted",
                    "function_code": "def searchsorted(self, value, side=\"left\", sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n\n    # TODO: Use datetime64 semantics for sorting, xref GH#29844\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)\n",
                    "decorators": [],
                    "docstring": "Find indices where elements should be inserted to maintain order.\n\nFind the indices into a sorted array `self` such that, if the\ncorresponding elements in `value` were inserted before the indices,\nthe order of `self` would be preserved.\n\nParameters\n----------\nvalue : array_like\n    Values to insert into `self`.\nside : {'left', 'right'}, optional\n    If 'left', the index of the first suitable location found is given.\n    If 'right', return the last such index.  If there is no suitable\n    index, return either 0 or N (where N is the length of `self`).\nsorter : 1-D array_like, optional\n    Optional array of integer indices that sort `self` into ascending\n    order. They are typically the result of ``np.argsort``.\n\nReturns\n-------\nindices : array of ints\n    Array of insertion points with the same shape as `value`.",
                    "start_line": 875,
                    "variables": {
                        "value": [
                            900,
                            903
                        ],
                        "self._validate_searchsorted_value": [
                            900
                        ],
                        "self": [
                            900,
                            903
                        ],
                        "self.asi8.searchsorted": [
                            903
                        ],
                        "self.asi8": [
                            903
                        ],
                        "side": [
                            903
                        ],
                        "sorter": [
                            903
                        ]
                    },
                    "filtered_variables": {
                        "value": [
                            900,
                            903
                        ],
                        "self._validate_searchsorted_value": [
                            900
                        ],
                        "self": [
                            900,
                            903
                        ],
                        "self.asi8.searchsorted": [
                            903
                        ],
                        "self.asi8": [
                            903
                        ],
                        "side": [
                            903
                        ],
                        "sorter": [
                            903
                        ]
                    },
                    "diff_line_number": 875,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "value_counts",
                    "function_code": "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n\n    cls = type(self)\n\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(\n        cls(result.index.view(\"i8\"), dtype=self.dtype), name=result.index.name\n    )\n    return Series(result._values, index=index, name=result.name)\n",
                    "decorators": [],
                    "docstring": "Return a Series containing counts of unique values.\n\nParameters\n----------\ndropna : bool, default True\n    Don't include counts of NaT values.\n\nReturns\n-------\nSeries",
                    "start_line": 905,
                    "variables": {
                        "dropna": [
                            920,
                            927
                        ],
                        "values": [
                            921,
                            923,
                            927
                        ],
                        "_data": [
                            921
                        ],
                        "self": [
                            929,
                            921,
                            923,
                            925
                        ],
                        "self.isna": [
                            921
                        ],
                        "self._data": [
                            923
                        ],
                        "cls": [
                            929,
                            925
                        ],
                        "type": [
                            925
                        ],
                        "result": [
                            929,
                            931,
                            927
                        ],
                        "value_counts": [
                            927
                        ],
                        "index": [
                            928,
                            931
                        ],
                        "Index": [
                            928
                        ],
                        "result.index.view": [
                            929
                        ],
                        "result.index": [
                            929
                        ],
                        "self.dtype": [
                            929
                        ],
                        "result.index.name": [
                            929
                        ],
                        "Series": [
                            931
                        ],
                        "result._values": [
                            931
                        ],
                        "result.name": [
                            931
                        ]
                    },
                    "filtered_variables": {
                        "dropna": [
                            920,
                            927
                        ],
                        "values": [
                            921,
                            923,
                            927
                        ],
                        "_data": [
                            921
                        ],
                        "self": [
                            929,
                            921,
                            923,
                            925
                        ],
                        "self.isna": [
                            921
                        ],
                        "self._data": [
                            923
                        ],
                        "cls": [
                            929,
                            925
                        ],
                        "result": [
                            929,
                            931,
                            927
                        ],
                        "value_counts": [
                            927
                        ],
                        "index": [
                            928,
                            931
                        ],
                        "Index": [
                            928
                        ],
                        "result.index.view": [
                            929
                        ],
                        "result.index": [
                            929
                        ],
                        "self.dtype": [
                            929
                        ],
                        "result.index.name": [
                            929
                        ],
                        "Series": [
                            931
                        ],
                        "result._values": [
                            931
                        ],
                        "result.name": [
                            931
                        ]
                    },
                    "diff_line_number": 905,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "map",
                    "function_code": "def map(self, mapper):\n    # TODO(GH-23179): Add ExtensionArray.map\n    # Need to figure out if we want ExtensionArray.map first.\n    # If so, then we can refactor IndexOpsMixin._map_values to\n    # a standalone function and call from here..\n    # Else, just rewrite _map_infer_values to do the right thing.\n    from pandas import Index\n\n    return Index(self).map(mapper).array\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 933,
                    "variables": {
                        "array": [
                            941
                        ],
                        "map": [
                            941
                        ],
                        "Index": [
                            941
                        ],
                        "self": [
                            941
                        ],
                        "mapper": [
                            941
                        ]
                    },
                    "filtered_variables": {
                        "array": [
                            941
                        ],
                        "Index": [
                            941
                        ],
                        "self": [
                            941
                        ],
                        "mapper": [
                            941
                        ]
                    },
                    "diff_line_number": 933,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "isna",
                    "function_code": "def isna(self):\n    return self._isnan\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 946,
                    "variables": {
                        "self._isnan": [
                            947
                        ],
                        "self": [
                            947
                        ]
                    },
                    "filtered_variables": {
                        "self._isnan": [
                            947
                        ],
                        "self": [
                            947
                        ]
                    },
                    "diff_line_number": 946,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {
                                "self._isnan": {
                                    "variable_value": "array([False, False, False])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                }
                            },
                            {
                                "self._isnan": {
                                    "variable_value": "array([False, False, False])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                }
                            }
                        ],
                        [
                            {
                                "self._isnan": {
                                    "variable_value": "array([False, False, False])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                }
                            },
                            {
                                "self._isnan": {
                                    "variable_value": "array([False, False, False])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "self._isnan": {
                                    "variable_value": "array([False, False, False])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                }
                            },
                            {
                                "self._isnan": {
                                    "variable_value": "array([False, False, False])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                }
                            }
                        ],
                        [
                            {
                                "self._isnan": {
                                    "variable_value": "array([False, False, False])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                }
                            },
                            {
                                "self._isnan": {
                                    "variable_value": "array([False, False, False])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                }
                            }
                        ]
                    ]
                },
                {
                    "function_name": "_isnan",
                    "function_code": "@property  # NB: override with cache_readonly in immutable subclasses\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT\n",
                    "decorators": [
                        "property"
                    ],
                    "docstring": "return if each value is nan",
                    "start_line": 949,
                    "variables": {
                        "self.asi8": [
                            954
                        ],
                        "self": [
                            954
                        ],
                        "iNaT": [
                            954
                        ],
                        "property": [
                            949
                        ]
                    },
                    "filtered_variables": {
                        "self.asi8": [
                            954
                        ],
                        "self": [
                            954
                        ],
                        "iNaT": [
                            954
                        ]
                    },
                    "diff_line_number": 950,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {
                                "self.asi8": {
                                    "variable_value": "array([1357016400000000000, 1357102800000000000, 1357189200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "self.asi8": {
                                    "variable_value": "array([1357016400000000000, 1357102800000000000, 1357189200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "self.asi8": {
                                    "variable_value": "array([1357016400000000000, 1357102800000000000, 1357189200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "self.asi8": {
                                    "variable_value": "array([1357016400000000000, 1357102800000000000, 1357189200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "self.asi8": {
                                    "variable_value": "array([1357016400000000000, 1357102800000000000, 1357189200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "self.asi8": {
                                    "variable_value": "array([1357016400000000000, 1357102800000000000, 1357189200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "self.asi8": {
                                    "variable_value": "array([1357016400000000000, 1357102800000000000, 1357189200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "self.asi8": {
                                    "variable_value": "array([1357016400000000000, 1357102800000000000, 1357189200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "self.asi8": {
                                    "variable_value": "array([1357016400000000000, 1357102800000000000, 1357189200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "self.asi8": {
                                    "variable_value": "array([1357016400000000000, 1357102800000000000, 1357189200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "self.asi8": {
                                    "variable_value": "array([1357016400000000000, 1357102800000000000, 1357189200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "self.asi8": {
                                    "variable_value": "array([1357016400000000000, 1357102800000000000, 1357189200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n '2013-01-03 00:00:00-05:00']\nLength: 3, dtype: datetime64[ns, US/Eastern]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "3"
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                },
                {
                    "function_name": "_hasnans",
                    "function_code": "@property  # NB: override with cache_readonly in immutable subclasses\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())\n",
                    "decorators": [
                        "property"
                    ],
                    "docstring": "return if I have any nans; enables various perf speedups",
                    "start_line": 956,
                    "variables": {
                        "bool": [
                            961
                        ],
                        "self._isnan.any": [
                            961
                        ],
                        "self._isnan": [
                            961
                        ],
                        "self": [
                            961
                        ],
                        "property": [
                            956
                        ]
                    },
                    "filtered_variables": {
                        "self._isnan.any": [
                            961
                        ],
                        "self._isnan": [
                            961
                        ],
                        "self": [
                            961
                        ]
                    },
                    "diff_line_number": 957,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {
                                "self._isnan.any": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": "array([False, False, False])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n               '2013-01-03 00:00:00-05:00'],\n              dtype='datetime64[ns, US/Eastern]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "3"
                                }
                            },
                            {
                                "self._isnan.any": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": "array([False, False, False])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n               '2013-01-03 00:00:00-05:00'],\n              dtype='datetime64[ns, US/Eastern]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "3"
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "self._isnan.any": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": "array([False, False, False])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n               '2013-01-03 00:00:00-05:00'],\n              dtype='datetime64[ns, US/Eastern]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "3"
                                }
                            },
                            {
                                "self._isnan.any": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": "array([False, False, False])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['2013-01-01 00:00:00-05:00', '2013-01-02 00:00:00-05:00',\n               '2013-01-03 00:00:00-05:00'],\n              dtype='datetime64[ns, US/Eastern]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "3"
                                }
                            }
                        ]
                    ]
                },
                {
                    "function_name": "_maybe_mask_results",
                    "function_code": "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result\n",
                    "decorators": [],
                    "docstring": "Parameters\n----------\nresult : a ndarray\nfill_value : object, default iNaT\nconvert : str, dtype or None\n\nReturns\n-------\nresult : ndarray with values replace by the fill_value\n\nmask the result if needed, convert to the provided dtype if its not\nNone\n\nThis is an internal routine.",
                    "start_line": 963,
                    "variables": {
                        "iNaT": [
                            963
                        ],
                        "self._hasnans": [
                            980
                        ],
                        "self": [
                            985,
                            980
                        ],
                        "convert": [
                            981,
                            982
                        ],
                        "result": [
                            985,
                            986,
                            982
                        ],
                        "result.astype": [
                            982
                        ],
                        "fill_value": [
                            984,
                            985,
                            983
                        ],
                        "np.nan": [
                            984
                        ],
                        "np": [
                            984
                        ],
                        "self._isnan": [
                            985
                        ]
                    },
                    "filtered_variables": {
                        "iNaT": [
                            963
                        ],
                        "self._hasnans": [
                            980
                        ],
                        "self": [
                            985,
                            980
                        ],
                        "convert": [
                            981,
                            982
                        ],
                        "result": [
                            985,
                            986,
                            982
                        ],
                        "result.astype": [
                            982
                        ],
                        "fill_value": [
                            984,
                            985,
                            983
                        ],
                        "np.nan": [
                            984
                        ],
                        "np": [
                            984
                        ],
                        "self._isnan": [
                            985
                        ]
                    },
                    "diff_line_number": 963,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "fillna",
                    "function_code": "def fillna(self, value=None, method=None, limit=None):\n    # TODO(GH-20300): remove this\n    # Just overriding to ensure that we avoid an astype(object).\n    # Either 20300 or a `_values_for_fillna` would avoid this duplication.\n    if isinstance(value, ABCSeries):\n        value = value.array\n\n    value, method = validate_fillna_kwargs(value, method)\n\n    mask = self.isna()\n\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(\n                f\"Length of 'value' does not match. Got ({len(value)}) \"\n                f\" expected {len(self)}\"\n            )\n        value = value[mask]\n\n    if mask.any():\n        if method is not None:\n            if method == \"pad\":\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n\n            values = self._data\n            if not is_period_dtype(self):\n                # For PeriodArray self._data is i8, which gets copied\n                #  by `func`.  Otherwise we need to make a copy manually\n                # to avoid modifying `self` in-place.\n                values = values.copy()\n\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                # we need to pass int64 values to the constructor to avoid\n                #  re-localizing incorrectly\n                new_values = new_values.view(\"i8\")\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            # fill with value\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 988,
                    "variables": {
                        "isinstance": [
                            992
                        ],
                        "value": [
                            992,
                            993,
                            995,
                            1030,
                            999,
                            1000,
                            1002,
                            1005
                        ],
                        "ABCSeries": [
                            992
                        ],
                        "value.array": [
                            993
                        ],
                        "method": [
                            1008,
                            1009,
                            995
                        ],
                        "validate_fillna_kwargs": [
                            995
                        ],
                        "mask": [
                            997,
                            1030,
                            1005,
                            1007,
                            1021
                        ],
                        "self.isna": [
                            997
                        ],
                        "self": [
                            1026,
                            997,
                            1029,
                            1000,
                            1032,
                            1003,
                            1014,
                            1015,
                            1022
                        ],
                        "is_array_like": [
                            999
                        ],
                        "len": [
                            1000,
                            1002,
                            1003
                        ],
                        "ValueError": [
                            1001
                        ],
                        "mask.any": [
                            1007
                        ],
                        "func": [
                            1010,
                            1012,
                            1021
                        ],
                        "missing.pad_1d": [
                            1010
                        ],
                        "missing": [
                            1010,
                            1012
                        ],
                        "missing.backfill_1d": [
                            1012
                        ],
                        "values": [
                            1019,
                            1021,
                            1014
                        ],
                        "self._data": [
                            1014
                        ],
                        "is_period_dtype": [
                            1015
                        ],
                        "values.copy": [
                            1019
                        ],
                        "new_values": [
                            1025,
                            1026,
                            1029,
                            1030,
                            1032,
                            1033,
                            1021
                        ],
                        "limit": [
                            1021
                        ],
                        "is_datetime64tz_dtype": [
                            1022
                        ],
                        "new_values.view": [
                            1025
                        ],
                        "type": [
                            1026
                        ],
                        "self.dtype": [
                            1026
                        ],
                        "self.copy": [
                            1032,
                            1029
                        ]
                    },
                    "filtered_variables": {
                        "value": [
                            992,
                            993,
                            995,
                            1030,
                            999,
                            1000,
                            1002,
                            1005
                        ],
                        "ABCSeries": [
                            992
                        ],
                        "value.array": [
                            993
                        ],
                        "method": [
                            1008,
                            1009,
                            995
                        ],
                        "validate_fillna_kwargs": [
                            995
                        ],
                        "mask": [
                            997,
                            1030,
                            1005,
                            1007,
                            1021
                        ],
                        "self.isna": [
                            997
                        ],
                        "self": [
                            1026,
                            997,
                            1029,
                            1000,
                            1032,
                            1003,
                            1014,
                            1015,
                            1022
                        ],
                        "is_array_like": [
                            999
                        ],
                        "mask.any": [
                            1007
                        ],
                        "func": [
                            1010,
                            1012,
                            1021
                        ],
                        "missing.pad_1d": [
                            1010
                        ],
                        "missing": [
                            1010,
                            1012
                        ],
                        "missing.backfill_1d": [
                            1012
                        ],
                        "values": [
                            1019,
                            1021,
                            1014
                        ],
                        "self._data": [
                            1014
                        ],
                        "is_period_dtype": [
                            1015
                        ],
                        "values.copy": [
                            1019
                        ],
                        "new_values": [
                            1025,
                            1026,
                            1029,
                            1030,
                            1032,
                            1033,
                            1021
                        ],
                        "limit": [
                            1021
                        ],
                        "is_datetime64tz_dtype": [
                            1022
                        ],
                        "new_values.view": [
                            1025
                        ],
                        "self.dtype": [
                            1026
                        ],
                        "self.copy": [
                            1032,
                            1029
                        ]
                    },
                    "diff_line_number": 988,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "freq",
                    "function_code": "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq\n",
                    "decorators": [
                        "property"
                    ],
                    "docstring": "Return the frequency object if it is set, otherwise None.",
                    "start_line": 1038,
                    "variables": {
                        "self._freq": [
                            1043
                        ],
                        "self": [
                            1043
                        ],
                        "property": [
                            1038
                        ]
                    },
                    "filtered_variables": {
                        "self._freq": [
                            1043
                        ],
                        "self": [
                            1043
                        ]
                    },
                    "diff_line_number": 1041,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ],
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "freq",
                    "function_code": "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n\n    self._freq = value\n",
                    "decorators": [
                        "freq.setter"
                    ],
                    "docstring": null,
                    "start_line": 1045,
                    "variables": {
                        "value": [
                            1048,
                            1049,
                            1051,
                            1047
                        ],
                        "frequencies.to_offset": [
                            1048
                        ],
                        "frequencies": [
                            1048
                        ],
                        "self._validate_frequency": [
                            1049
                        ],
                        "self": [
                            1049,
                            1051
                        ],
                        "self._freq": [
                            1051
                        ],
                        "freq.setter": [
                            1045
                        ],
                        "freq": [
                            1045
                        ]
                    },
                    "filtered_variables": {
                        "value": [
                            1048,
                            1049,
                            1051,
                            1047
                        ],
                        "frequencies.to_offset": [
                            1048
                        ],
                        "frequencies": [
                            1048
                        ],
                        "self._validate_frequency": [
                            1049
                        ],
                        "self": [
                            1049,
                            1051
                        ],
                        "self._freq": [
                            1051
                        ],
                        "freq.setter": [
                            1045
                        ],
                        "freq": [
                            1045
                        ]
                    },
                    "diff_line_number": 1046,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "inferred_freq",
                    "function_code": "@property  # NB: override with cache_readonly in immutable subclasses\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None\n",
                    "decorators": [
                        "property"
                    ],
                    "docstring": "Tryies to return a string representing a frequency guess,\ngenerated by infer_freq.  Returns None if it can't autodetect the\nfrequency.",
                    "start_line": 1062,
                    "variables": {
                        "self.ndim": [
                            1069
                        ],
                        "self": [
                            1072,
                            1069
                        ],
                        "frequencies.infer_freq": [
                            1072
                        ],
                        "frequencies": [
                            1072
                        ],
                        "ValueError": [
                            1073
                        ],
                        "property": [
                            1062
                        ]
                    },
                    "filtered_variables": {
                        "self.ndim": [
                            1069
                        ],
                        "self": [
                            1072,
                            1069
                        ],
                        "frequencies.infer_freq": [
                            1072
                        ],
                        "frequencies": [
                            1072
                        ]
                    },
                    "diff_line_number": 1063,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_resolution",
                    "function_code": "@property  # NB: override with cache_readonly in immutable subclasses\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)\n",
                    "decorators": [
                        "property"
                    ],
                    "docstring": null,
                    "start_line": 1076,
                    "variables": {
                        "frequencies.Resolution.get_reso_from_freq": [
                            1078
                        ],
                        "frequencies.Resolution": [
                            1078
                        ],
                        "frequencies": [
                            1078
                        ],
                        "self.freqstr": [
                            1078
                        ],
                        "self": [
                            1078
                        ],
                        "property": [
                            1076
                        ]
                    },
                    "filtered_variables": {
                        "frequencies.Resolution.get_reso_from_freq": [
                            1078
                        ],
                        "frequencies.Resolution": [
                            1078
                        ],
                        "frequencies": [
                            1078
                        ],
                        "self.freqstr": [
                            1078
                        ],
                        "self": [
                            1078
                        ]
                    },
                    "diff_line_number": 1077,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "resolution",
                    "function_code": "@property  # NB: override with cache_readonly in immutable subclasses\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)\n",
                    "decorators": [
                        "property"
                    ],
                    "docstring": "Returns day, hour, minute, second, millisecond or microsecond",
                    "start_line": 1080,
                    "variables": {
                        "frequencies.Resolution.get_str": [
                            1085
                        ],
                        "frequencies.Resolution": [
                            1085
                        ],
                        "frequencies": [
                            1085
                        ],
                        "self._resolution": [
                            1085
                        ],
                        "self": [
                            1085
                        ],
                        "property": [
                            1080
                        ]
                    },
                    "filtered_variables": {
                        "frequencies.Resolution.get_str": [
                            1085
                        ],
                        "frequencies.Resolution": [
                            1085
                        ],
                        "frequencies": [
                            1085
                        ],
                        "self._resolution": [
                            1085
                        ],
                        "self": [
                            1085
                        ]
                    },
                    "diff_line_number": 1081,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_validate_frequency",
                    "function_code": "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        # Frequency validation is not meaningful for Period Array/Index\n        return None\n\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n\n    try:\n        on_freq = cls._generate_range(\n            start=index[0], end=None, periods=len(index), freq=freq, **kwargs\n        )\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if \"non-fixed\" in str(e):\n            # non-fixed frequencies are not meaningful for timedelta64;\n            #  we retain that error message\n            raise e\n        # GH#11587 the main way this is reached is if the `np.array_equal`\n        #  check above is False.  This can also be reached if index[0]\n        #  is `NaT`, in which case the call to `cls._generate_range` will\n        #  raise a ValueError, which we re-raise with a more targeted\n        #  message.\n        raise ValueError(\n            f\"Inferred frequency {inferred} from passed values \"\n            f\"does not conform to passed frequency {freq.freqstr}\"\n        ) from e\n",
                    "decorators": [
                        "classmethod"
                    ],
                    "docstring": "Validate that a frequency is compatible with the values of a given\nDatetime Array/Index or Timedelta Array/Index\n\nParameters\n----------\nindex : DatetimeIndex or TimedeltaIndex\n    The index on which to determine if the given frequency is valid\nfreq : DateOffset\n    The frequency to validate",
                    "start_line": 1087,
                    "variables": {
                        "is_period_dtype": [
                            1100
                        ],
                        "cls": [
                            1100,
                            1109
                        ],
                        "inferred": [
                            1104,
                            1105,
                            1125
                        ],
                        "index.inferred_freq": [
                            1104
                        ],
                        "index": [
                            1104,
                            1105,
                            1112,
                            1110
                        ],
                        "index.size": [
                            1105
                        ],
                        "freq.freqstr": [
                            1105,
                            1126
                        ],
                        "freq": [
                            1105,
                            1126,
                            1110
                        ],
                        "on_freq": [
                            1112,
                            1109
                        ],
                        "cls._generate_range": [
                            1109
                        ],
                        "len": [
                            1110
                        ],
                        "kwargs": [
                            1110
                        ],
                        "np.array_equal": [
                            1112
                        ],
                        "np": [
                            1112
                        ],
                        "index.asi8": [
                            1112
                        ],
                        "on_freq.asi8": [
                            1112
                        ],
                        "ValueError": [
                            1113,
                            1114,
                            1124
                        ],
                        "str": [
                            1115
                        ],
                        "e": [
                            1115,
                            1118,
                            1127
                        ],
                        "classmethod": [
                            1087
                        ]
                    },
                    "filtered_variables": {
                        "is_period_dtype": [
                            1100
                        ],
                        "cls": [
                            1100,
                            1109
                        ],
                        "inferred": [
                            1104,
                            1105,
                            1125
                        ],
                        "index.inferred_freq": [
                            1104
                        ],
                        "index": [
                            1104,
                            1105,
                            1112,
                            1110
                        ],
                        "index.size": [
                            1105
                        ],
                        "freq.freqstr": [
                            1105,
                            1126
                        ],
                        "freq": [
                            1105,
                            1126,
                            1110
                        ],
                        "on_freq": [
                            1112,
                            1109
                        ],
                        "cls._generate_range": [
                            1109
                        ],
                        "kwargs": [
                            1110
                        ],
                        "np.array_equal": [
                            1112
                        ],
                        "np": [
                            1112
                        ],
                        "index.asi8": [
                            1112
                        ],
                        "on_freq.asi8": [
                            1112
                        ],
                        "e": [
                            1115,
                            1118,
                            1127
                        ]
                    },
                    "diff_line_number": 1088,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_is_monotonic_increasing",
                    "function_code": "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]\n",
                    "decorators": [
                        "property"
                    ],
                    "docstring": null,
                    "start_line": 1132,
                    "variables": {
                        "algos.is_monotonic": [
                            1134
                        ],
                        "algos": [
                            1134
                        ],
                        "self.asi8": [
                            1134
                        ],
                        "self": [
                            1134
                        ],
                        "property": [
                            1132
                        ]
                    },
                    "filtered_variables": {
                        "algos.is_monotonic": [
                            1134
                        ],
                        "algos": [
                            1134
                        ],
                        "self.asi8": [
                            1134
                        ],
                        "self": [
                            1134
                        ]
                    },
                    "diff_line_number": 1133,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_is_monotonic_decreasing",
                    "function_code": "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]\n",
                    "decorators": [
                        "property"
                    ],
                    "docstring": null,
                    "start_line": 1136,
                    "variables": {
                        "algos.is_monotonic": [
                            1138
                        ],
                        "algos": [
                            1138
                        ],
                        "self.asi8": [
                            1138
                        ],
                        "self": [
                            1138
                        ],
                        "property": [
                            1136
                        ]
                    },
                    "filtered_variables": {
                        "algos.is_monotonic": [
                            1138
                        ],
                        "algos": [
                            1138
                        ],
                        "self.asi8": [
                            1138
                        ],
                        "self": [
                            1138
                        ]
                    },
                    "diff_line_number": 1137,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_is_unique",
                    "function_code": "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)\n",
                    "decorators": [
                        "property"
                    ],
                    "docstring": null,
                    "start_line": 1140,
                    "variables": {
                        "len": [
                            1142
                        ],
                        "unique1d": [
                            1142
                        ],
                        "self.asi8": [
                            1142
                        ],
                        "self": [
                            1142
                        ],
                        "property": [
                            1140
                        ]
                    },
                    "filtered_variables": {
                        "unique1d": [
                            1142
                        ],
                        "self.asi8": [
                            1142
                        ],
                        "self": [
                            1142
                        ]
                    },
                    "diff_line_number": 1141,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_add_datetimelike_scalar",
                    "function_code": "def _add_datetimelike_scalar(self, other):\n    # Overridden by TimedeltaArray\n    raise TypeError(f\"cannot add {type(self).__name__} and {type(other).__name__}\")\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 1163,
                    "variables": {
                        "TypeError": [
                            1165
                        ],
                        "__name__": [
                            1165
                        ],
                        "type": [
                            1165
                        ],
                        "self": [
                            1165
                        ],
                        "other": [
                            1165
                        ]
                    },
                    "filtered_variables": {
                        "self": [
                            1165
                        ],
                        "other": [
                            1165
                        ]
                    },
                    "diff_line_number": 1163,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_sub_datetimelike_scalar",
                    "function_code": "def _sub_datetimelike_scalar(self, other):\n    # Overridden by DatetimeArray\n    assert other is not NaT\n    raise TypeError(f\"cannot subtract a datelike from a {type(self).__name__}\")\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 1169,
                    "variables": {
                        "other": [
                            1171
                        ],
                        "NaT": [
                            1171
                        ],
                        "TypeError": [
                            1172
                        ],
                        "__name__": [
                            1172
                        ],
                        "type": [
                            1172
                        ],
                        "self": [
                            1172
                        ]
                    },
                    "filtered_variables": {
                        "other": [
                            1171
                        ],
                        "NaT": [
                            1171
                        ],
                        "self": [
                            1172
                        ]
                    },
                    "diff_line_number": 1169,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_sub_period",
                    "function_code": "def _sub_period(self, other):\n    # Overridden by PeriodArray\n    raise TypeError(f\"cannot subtract Period from a {type(self).__name__}\")\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 1176,
                    "variables": {
                        "TypeError": [
                            1178
                        ],
                        "__name__": [
                            1178
                        ],
                        "type": [
                            1178
                        ],
                        "self": [
                            1178
                        ]
                    },
                    "filtered_variables": {
                        "self": [
                            1178
                        ]
                    },
                    "diff_line_number": 1176,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_add_offset",
                    "function_code": "def _add_offset(self, offset):\n    raise AbstractMethodError(self)\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 1180,
                    "variables": {
                        "AbstractMethodError": [
                            1181
                        ],
                        "self": [
                            1181
                        ]
                    },
                    "filtered_variables": {
                        "AbstractMethodError": [
                            1181
                        ],
                        "self": [
                            1181
                        ]
                    },
                    "diff_line_number": 1180,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_add_timedeltalike_scalar",
                    "function_code": "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        # i.e np.timedelta64(\"NaT\"), not recognized by delta_to_nanoseconds\n        new_values = np.empty(self.shape, dtype=\"i8\")\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view(\n        \"i8\"\n    )\n    new_values = self._maybe_mask_results(new_values)\n\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        # adding a scalar preserves freq\n        new_freq = self.freq\n\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)\n",
                    "decorators": [],
                    "docstring": "Add a delta of a timedeltalike\n\nReturns\n-------\nSame type as self",
                    "start_line": 1183,
                    "variables": {
                        "isna": [
                            1191
                        ],
                        "other": [
                            1197,
                            1191
                        ],
                        "new_values": [
                            1193,
                            1194,
                            1195,
                            1198,
                            1201,
                            1208
                        ],
                        "np.empty": [
                            1193
                        ],
                        "np": [
                            1193
                        ],
                        "self.shape": [
                            1193
                        ],
                        "self": [
                            1193,
                            1195,
                            1198,
                            1201,
                            1204,
                            1206,
                            1208
                        ],
                        "iNaT": [
                            1194
                        ],
                        "type": [
                            1208,
                            1195
                        ],
                        "self.dtype": [
                            1208,
                            1195,
                            1204
                        ],
                        "inc": [
                            1197,
                            1198
                        ],
                        "delta_to_nanoseconds": [
                            1197
                        ],
                        "view": [
                            1198
                        ],
                        "checked_add_with_arr": [
                            1198
                        ],
                        "self.asi8": [
                            1198
                        ],
                        "self._isnan": [
                            1198
                        ],
                        "self._maybe_mask_results": [
                            1201
                        ],
                        "new_freq": [
                            1208,
                            1203,
                            1206
                        ],
                        "isinstance": [
                            1204
                        ],
                        "self.freq": [
                            1204,
                            1206
                        ],
                        "Tick": [
                            1204
                        ],
                        "is_period_dtype": [
                            1204
                        ]
                    },
                    "filtered_variables": {
                        "isna": [
                            1191
                        ],
                        "other": [
                            1197,
                            1191
                        ],
                        "new_values": [
                            1193,
                            1194,
                            1195,
                            1198,
                            1201,
                            1208
                        ],
                        "np.empty": [
                            1193
                        ],
                        "np": [
                            1193
                        ],
                        "self.shape": [
                            1193
                        ],
                        "self": [
                            1193,
                            1195,
                            1198,
                            1201,
                            1204,
                            1206,
                            1208
                        ],
                        "iNaT": [
                            1194
                        ],
                        "self.dtype": [
                            1208,
                            1195,
                            1204
                        ],
                        "inc": [
                            1197,
                            1198
                        ],
                        "delta_to_nanoseconds": [
                            1197
                        ],
                        "view": [
                            1198
                        ],
                        "checked_add_with_arr": [
                            1198
                        ],
                        "self.asi8": [
                            1198
                        ],
                        "self._isnan": [
                            1198
                        ],
                        "self._maybe_mask_results": [
                            1201
                        ],
                        "new_freq": [
                            1208,
                            1203,
                            1206
                        ],
                        "self.freq": [
                            1204,
                            1206
                        ],
                        "Tick": [
                            1204
                        ],
                        "is_period_dtype": [
                            1204
                        ]
                    },
                    "diff_line_number": 1183,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_add_timedelta_arraylike",
                    "function_code": "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    # overridden by PeriodArray\n\n    if len(self) != len(other):\n        raise ValueError(\"cannot add indices of unequal length\")\n\n    if isinstance(other, np.ndarray):\n        # ndarray[timedelta64]; wrap in TimedeltaIndex for op\n        from pandas.core.arrays import TimedeltaArray\n\n        other = TimedeltaArray._from_sequence(other)\n\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(\n        self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan\n    )\n    if self._hasnans or other._hasnans:\n        mask = (self._isnan) | (other._isnan)\n        new_values[mask] = iNaT\n\n    return type(self)(new_values, dtype=self.dtype)\n",
                    "decorators": [],
                    "docstring": "Add a delta of a TimedeltaIndex\n\nReturns\n-------\nSame type as self",
                    "start_line": 1210,
                    "variables": {
                        "len": [
                            1220
                        ],
                        "self": [
                            1220,
                            1229,
                            1232,
                            1234,
                            1235,
                            1238
                        ],
                        "other": [
                            1220,
                            1223,
                            1227,
                            1230,
                            1232,
                            1234,
                            1235
                        ],
                        "ValueError": [
                            1221
                        ],
                        "isinstance": [
                            1223
                        ],
                        "np.ndarray": [
                            1223
                        ],
                        "np": [
                            1223
                        ],
                        "TimedeltaArray._from_sequence": [
                            1227
                        ],
                        "TimedeltaArray": [
                            1227
                        ],
                        "self_i8": [
                            1232,
                            1229
                        ],
                        "self.asi8": [
                            1229
                        ],
                        "other_i8": [
                            1232,
                            1230
                        ],
                        "other.asi8": [
                            1230
                        ],
                        "new_values": [
                            1236,
                            1238,
                            1231
                        ],
                        "checked_add_with_arr": [
                            1231
                        ],
                        "self._isnan": [
                            1232,
                            1235
                        ],
                        "other._isnan": [
                            1232,
                            1235
                        ],
                        "self._hasnans": [
                            1234
                        ],
                        "other._hasnans": [
                            1234
                        ],
                        "mask": [
                            1235,
                            1236
                        ],
                        "iNaT": [
                            1236
                        ],
                        "type": [
                            1238
                        ],
                        "self.dtype": [
                            1238
                        ]
                    },
                    "filtered_variables": {
                        "self": [
                            1220,
                            1229,
                            1232,
                            1234,
                            1235,
                            1238
                        ],
                        "other": [
                            1220,
                            1223,
                            1227,
                            1230,
                            1232,
                            1234,
                            1235
                        ],
                        "np.ndarray": [
                            1223
                        ],
                        "np": [
                            1223
                        ],
                        "TimedeltaArray._from_sequence": [
                            1227
                        ],
                        "TimedeltaArray": [
                            1227
                        ],
                        "self_i8": [
                            1232,
                            1229
                        ],
                        "self.asi8": [
                            1229
                        ],
                        "other_i8": [
                            1232,
                            1230
                        ],
                        "other.asi8": [
                            1230
                        ],
                        "new_values": [
                            1236,
                            1238,
                            1231
                        ],
                        "checked_add_with_arr": [
                            1231
                        ],
                        "self._isnan": [
                            1232,
                            1235
                        ],
                        "other._isnan": [
                            1232,
                            1235
                        ],
                        "self._hasnans": [
                            1234
                        ],
                        "other._hasnans": [
                            1234
                        ],
                        "mask": [
                            1235,
                            1236
                        ],
                        "iNaT": [
                            1236
                        ],
                        "self.dtype": [
                            1238
                        ]
                    },
                    "diff_line_number": 1210,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_add_nat",
                    "function_code": "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(\n            f\"Cannot add {type(self).__name__} and {type(NaT).__name__}\"\n        )\n\n    # GH#19124 pd.NaT is treated like a timedelta for both timedelta\n    # and datetime dtypes\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)\n",
                    "decorators": [],
                    "docstring": "Add pd.NaT to self",
                    "start_line": 1240,
                    "variables": {
                        "is_period_dtype": [
                            1244
                        ],
                        "self": [
                            1251,
                            1244,
                            1253,
                            1246
                        ],
                        "TypeError": [
                            1245
                        ],
                        "__name__": [
                            1246
                        ],
                        "type": [
                            1253,
                            1246
                        ],
                        "NaT": [
                            1246
                        ],
                        "result": [
                            1251,
                            1252,
                            1253
                        ],
                        "np.zeros": [
                            1251
                        ],
                        "np": [
                            1251
                        ],
                        "self.shape": [
                            1251
                        ],
                        "np.int64": [
                            1251
                        ],
                        "result.fill": [
                            1252
                        ],
                        "iNaT": [
                            1252
                        ],
                        "self.dtype": [
                            1253
                        ]
                    },
                    "filtered_variables": {
                        "is_period_dtype": [
                            1244
                        ],
                        "self": [
                            1251,
                            1244,
                            1253,
                            1246
                        ],
                        "NaT": [
                            1246
                        ],
                        "result": [
                            1251,
                            1252,
                            1253
                        ],
                        "np.zeros": [
                            1251
                        ],
                        "np": [
                            1251
                        ],
                        "self.shape": [
                            1251
                        ],
                        "np.int64": [
                            1251
                        ],
                        "result.fill": [
                            1252
                        ],
                        "iNaT": [
                            1252
                        ],
                        "self.dtype": [
                            1253
                        ]
                    },
                    "diff_line_number": 1240,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_sub_nat",
                    "function_code": "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    # GH#19124 Timedelta - datetime is not in general well-defined.\n    # We make an exception for pd.NaT, which in this case quacks\n    # like a timedelta.\n    # For datetime64 dtypes by convention we treat NaT as a datetime, so\n    # this subtraction returns a timedelta64 dtype.\n    # For period dtype, timedelta64 is a close-enough return dtype.\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view(\"timedelta64[ns]\")\n",
                    "decorators": [],
                    "docstring": "Subtract pd.NaT from self",
                    "start_line": 1255,
                    "variables": {
                        "result": [
                            1265,
                            1266,
                            1267
                        ],
                        "np.zeros": [
                            1265
                        ],
                        "np": [
                            1265
                        ],
                        "self.shape": [
                            1265
                        ],
                        "self": [
                            1265
                        ],
                        "np.int64": [
                            1265
                        ],
                        "result.fill": [
                            1266
                        ],
                        "iNaT": [
                            1266
                        ],
                        "result.view": [
                            1267
                        ]
                    },
                    "filtered_variables": {
                        "result": [
                            1265,
                            1266,
                            1267
                        ],
                        "np.zeros": [
                            1265
                        ],
                        "np": [
                            1265
                        ],
                        "self.shape": [
                            1265
                        ],
                        "self": [
                            1265
                        ],
                        "np.int64": [
                            1265
                        ],
                        "result.fill": [
                            1266
                        ],
                        "iNaT": [
                            1266
                        ],
                        "result.view": [
                            1267
                        ]
                    },
                    "diff_line_number": 1255,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_sub_period_array",
                    "function_code": "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(\n            f\"cannot subtract {other.dtype}-dtype from {type(self).__name__}\"\n        )\n\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(\n            cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr\n        )\n        raise IncompatibleFrequency(msg)\n\n    new_values = checked_add_with_arr(\n        self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan\n    )\n\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = (self._isnan) | (other._isnan)\n        new_values[mask] = NaT\n    return new_values\n",
                    "decorators": [],
                    "docstring": "Subtract a Period Array/Index from self.  This is only valid if self\nis itself a Period Array/Index, raises otherwise.  Both objects must\nhave the same frequency.\n\nParameters\n----------\nother : PeriodIndex or PeriodArray\n\nReturns\n-------\nresult : np.ndarray[object]\n    Array of DateOffset objects; nulls represented by NaT.",
                    "start_line": 1269,
                    "variables": {
                        "is_period_dtype": [
                            1284
                        ],
                        "self": [
                            1284,
                            1286,
                            1289,
                            1291,
                            1296,
                            1299,
                            1300,
                            1301
                        ],
                        "TypeError": [
                            1285
                        ],
                        "other.dtype": [
                            1286
                        ],
                        "other": [
                            1286,
                            1289,
                            1291,
                            1296,
                            1300,
                            1301
                        ],
                        "__name__": [
                            1291,
                            1286
                        ],
                        "type": [
                            1291,
                            1286
                        ],
                        "self.freq": [
                            1289,
                            1299
                        ],
                        "other.freq": [
                            1289
                        ],
                        "msg": [
                            1290,
                            1293
                        ],
                        "DIFFERENT_FREQ.format": [
                            1290
                        ],
                        "DIFFERENT_FREQ": [
                            1290
                        ],
                        "self.freqstr": [
                            1291
                        ],
                        "other.freqstr": [
                            1291
                        ],
                        "IncompatibleFrequency": [
                            1293
                        ],
                        "new_values": [
                            1299,
                            1303,
                            1302,
                            1295
                        ],
                        "checked_add_with_arr": [
                            1295
                        ],
                        "self.asi8": [
                            1296
                        ],
                        "other.asi8": [
                            1296
                        ],
                        "self._isnan": [
                            1296,
                            1301
                        ],
                        "other._isnan": [
                            1296,
                            1301
                        ],
                        "np.array": [
                            1299
                        ],
                        "np": [
                            1299
                        ],
                        "self.freq.base": [
                            1299
                        ],
                        "x": [
                            1299
                        ],
                        "self._hasnans": [
                            1300
                        ],
                        "other._hasnans": [
                            1300
                        ],
                        "mask": [
                            1301,
                            1302
                        ],
                        "NaT": [
                            1302
                        ]
                    },
                    "filtered_variables": {
                        "is_period_dtype": [
                            1284
                        ],
                        "self": [
                            1284,
                            1286,
                            1289,
                            1291,
                            1296,
                            1299,
                            1300,
                            1301
                        ],
                        "other.dtype": [
                            1286
                        ],
                        "other": [
                            1286,
                            1289,
                            1291,
                            1296,
                            1300,
                            1301
                        ],
                        "self.freq": [
                            1289,
                            1299
                        ],
                        "other.freq": [
                            1289
                        ],
                        "msg": [
                            1290,
                            1293
                        ],
                        "DIFFERENT_FREQ.format": [
                            1290
                        ],
                        "DIFFERENT_FREQ": [
                            1290
                        ],
                        "self.freqstr": [
                            1291
                        ],
                        "other.freqstr": [
                            1291
                        ],
                        "IncompatibleFrequency": [
                            1293
                        ],
                        "new_values": [
                            1299,
                            1303,
                            1302,
                            1295
                        ],
                        "checked_add_with_arr": [
                            1295
                        ],
                        "self.asi8": [
                            1296
                        ],
                        "other.asi8": [
                            1296
                        ],
                        "self._isnan": [
                            1296,
                            1301
                        ],
                        "other._isnan": [
                            1296,
                            1301
                        ],
                        "np.array": [
                            1299
                        ],
                        "np": [
                            1299
                        ],
                        "self.freq.base": [
                            1299
                        ],
                        "x": [
                            1299
                        ],
                        "self._hasnans": [
                            1300
                        ],
                        "other._hasnans": [
                            1300
                        ],
                        "mask": [
                            1301,
                            1302
                        ],
                        "NaT": [
                            1302
                        ]
                    },
                    "diff_line_number": 1269,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_addsub_object_array",
                    "function_code": "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n\n    warnings.warn(\n        \"Adding/subtracting array of DateOffsets to \"\n        f\"{type(self).__name__} not vectorized\",\n        PerformanceWarning,\n    )\n\n    # Caller is responsible for broadcasting if necessary\n    assert self.shape == other.shape, (self.shape, other.shape)\n\n    res_values = op(self.astype(\"O\"), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result\n",
                    "decorators": [],
                    "docstring": "Add or subtract array-like of DateOffset objects\n\nParameters\n----------\nother : np.ndarray[object]\nop : {operator.add, operator.sub}\n\nReturns\n-------\nresult : same class as self",
                    "start_line": 1305,
                    "variables": {
                        "np.ndarray": [
                            1305
                        ],
                        "np": [
                            1305,
                            1331
                        ],
                        "op": [
                            1320,
                            1331,
                            1318
                        ],
                        "operator.add": [
                            1318
                        ],
                        "operator": [
                            1318
                        ],
                        "operator.sub": [
                            1318
                        ],
                        "len": [
                            1319
                        ],
                        "other": [
                            1320,
                            1329,
                            1331,
                            1319
                        ],
                        "self": [
                            1320,
                            1324,
                            1329,
                            1331,
                            1333
                        ],
                        "warnings.warn": [
                            1322
                        ],
                        "warnings": [
                            1322
                        ],
                        "__name__": [
                            1324
                        ],
                        "type": [
                            1324
                        ],
                        "PerformanceWarning": [
                            1325
                        ],
                        "self.shape": [
                            1329,
                            1333
                        ],
                        "other.shape": [
                            1329
                        ],
                        "res_values": [
                            1331,
                            1332
                        ],
                        "self.astype": [
                            1331
                        ],
                        "np.array": [
                            1331
                        ],
                        "result": [
                            1332,
                            1333,
                            1334
                        ],
                        "array": [
                            1332
                        ],
                        "res_values.ravel": [
                            1332
                        ],
                        "reshape": [
                            1333
                        ],
                        "extract_array": [
                            1333
                        ]
                    },
                    "filtered_variables": {
                        "np.ndarray": [
                            1305
                        ],
                        "np": [
                            1305,
                            1331
                        ],
                        "op": [
                            1320,
                            1331,
                            1318
                        ],
                        "operator.add": [
                            1318
                        ],
                        "operator": [
                            1318
                        ],
                        "operator.sub": [
                            1318
                        ],
                        "other": [
                            1320,
                            1329,
                            1331,
                            1319
                        ],
                        "self": [
                            1320,
                            1324,
                            1329,
                            1331,
                            1333
                        ],
                        "warnings.warn": [
                            1322
                        ],
                        "warnings": [
                            1322
                        ],
                        "PerformanceWarning": [
                            1325
                        ],
                        "self.shape": [
                            1329,
                            1333
                        ],
                        "other.shape": [
                            1329
                        ],
                        "res_values": [
                            1331,
                            1332
                        ],
                        "self.astype": [
                            1331
                        ],
                        "np.array": [
                            1331
                        ],
                        "result": [
                            1332,
                            1333,
                            1334
                        ],
                        "array": [
                            1332
                        ],
                        "res_values.ravel": [
                            1332
                        ],
                        "reshape": [
                            1333
                        ],
                        "extract_array": [
                            1333
                        ]
                    },
                    "diff_line_number": 1305,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_time_shift",
                    "function_code": "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n\n    if periods == 0:\n        # immutable so OK\n        return self.copy()\n\n    if self.freq is None:\n        raise NullFrequencyError(\"Cannot shift with no freq\")\n\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n\n    # Note: in the DatetimeTZ case, _generate_range will infer the\n    #  appropriate timezone from `start` and `end`, so tz does not need\n    #  to be passed explicitly.\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)\n",
                    "decorators": [],
                    "docstring": "Shift each value by `periods`.\n\nNote this is different from ExtensionArray.shift, which\nshifts the *position* of each element, padding the end with\nmissing values.\n\nParameters\n----------\nperiods : int\n    Number of periods to shift by.\nfreq : pandas.DateOffset, pandas.Timedelta, or str\n    Frequency increment to shift by.",
                    "start_line": 1336,
                    "variables": {
                        "freq": [
                            1352,
                            1353,
                            1354,
                            1351
                        ],
                        "self.freq": [
                            1351,
                            1362,
                            1365,
                            1366,
                            1371
                        ],
                        "self": [
                            1351,
                            1355,
                            1360,
                            1362,
                            1365,
                            1366,
                            1371
                        ],
                        "isinstance": [
                            1352
                        ],
                        "str": [
                            1352
                        ],
                        "frequencies.to_offset": [
                            1353
                        ],
                        "frequencies": [
                            1353
                        ],
                        "offset": [
                            1354,
                            1355
                        ],
                        "periods": [
                            1366,
                            1354,
                            1365,
                            1358
                        ],
                        "result": [
                            1355,
                            1356
                        ],
                        "self.copy": [
                            1360
                        ],
                        "NullFrequencyError": [
                            1363
                        ],
                        "start": [
                            1371,
                            1365
                        ],
                        "end": [
                            1371,
                            1366
                        ],
                        "self._generate_range": [
                            1371
                        ]
                    },
                    "filtered_variables": {
                        "freq": [
                            1352,
                            1353,
                            1354,
                            1351
                        ],
                        "self.freq": [
                            1351,
                            1362,
                            1365,
                            1366,
                            1371
                        ],
                        "self": [
                            1351,
                            1355,
                            1360,
                            1362,
                            1365,
                            1366,
                            1371
                        ],
                        "frequencies.to_offset": [
                            1353
                        ],
                        "frequencies": [
                            1353
                        ],
                        "offset": [
                            1354,
                            1355
                        ],
                        "periods": [
                            1366,
                            1354,
                            1365,
                            1358
                        ],
                        "result": [
                            1355,
                            1356
                        ],
                        "self.copy": [
                            1360
                        ],
                        "NullFrequencyError": [
                            1363
                        ],
                        "start": [
                            1371,
                            1365
                        ],
                        "end": [
                            1371,
                            1366
                        ],
                        "self._generate_range": [
                            1371
                        ]
                    },
                    "diff_line_number": 1336,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "__add__",
                    "function_code": "@unpack_zerodim_and_defer(\"__add__\")\ndef __add__(self, other):\n\n    # scalar others\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        # specifically _not_ a Tick\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        # This check must come after the check for np.timedelta64\n        # as is_integer returns True for these\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n\n    # array-like others\n    elif is_timedelta64_dtype(other):\n        # TimedeltaIndex, ndarray[timedelta64]\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        # e.g. Array/Index of DateOffset objects\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        # DatetimeIndex, ndarray[datetime64]\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        # Includes Categorical, other ExtensionArrays\n        # For PeriodDtype, if self is a TimedeltaArray and other is a\n        #  PeriodArray with  a timedelta-like (i.e. Tick) freq, this\n        #  operation is valid.  Defer to the PeriodArray implementation.\n        #  In remaining cases, this will end up raising TypeError.\n        return NotImplemented\n\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n\n        return TimedeltaArray(result)\n    return result\n",
                    "decorators": [
                        "unpack_zerodim_and_defer('__add__')"
                    ],
                    "docstring": null,
                    "start_line": 1373,
                    "variables": {
                        "other": [
                            1377,
                            1379,
                            1380,
                            1381,
                            1383,
                            1384,
                            1385,
                            1386,
                            1391,
                            1394,
                            1396,
                            1397,
                            1399,
                            1400,
                            1402,
                            1403,
                            1406
                        ],
                        "NaT": [
                            1377
                        ],
                        "result": [
                            1378,
                            1380,
                            1383,
                            1415,
                            1385,
                            1418,
                            1419,
                            1391,
                            1396,
                            1399,
                            1406
                        ],
                        "self._add_nat": [
                            1378
                        ],
                        "self": [
                            1378,
                            1380,
                            1383,
                            1385,
                            1389,
                            1390,
                            1391,
                            1396,
                            1399,
                            1402,
                            1404,
                            1405,
                            1406
                        ],
                        "isinstance": [
                            1384,
                            1379,
                            1381,
                            1415
                        ],
                        "Tick": [
                            1379
                        ],
                        "timedelta": [
                            1379
                        ],
                        "np.timedelta64": [
                            1379
                        ],
                        "np": [
                            1384,
                            1379,
                            1415
                        ],
                        "self._add_timedeltalike_scalar": [
                            1380
                        ],
                        "DateOffset": [
                            1381
                        ],
                        "self._add_offset": [
                            1383
                        ],
                        "datetime": [
                            1384
                        ],
                        "np.datetime64": [
                            1384
                        ],
                        "self._add_datetimelike_scalar": [
                            1385
                        ],
                        "lib.is_integer": [
                            1386
                        ],
                        "lib": [
                            1386
                        ],
                        "is_period_dtype": [
                            1404,
                            1389
                        ],
                        "integer_op_not_supported": [
                            1405,
                            1390
                        ],
                        "self._time_shift": [
                            1391
                        ],
                        "is_timedelta64_dtype": [
                            1394,
                            1415
                        ],
                        "self._add_timedelta_arraylike": [
                            1396
                        ],
                        "is_object_dtype": [
                            1397
                        ],
                        "self._addsub_object_array": [
                            1399
                        ],
                        "operator.add": [
                            1406,
                            1399
                        ],
                        "operator": [
                            1406,
                            1399
                        ],
                        "is_datetime64_dtype": [
                            1400
                        ],
                        "is_datetime64tz_dtype": [
                            1400
                        ],
                        "self._add_datetime_arraylike": [
                            1402
                        ],
                        "is_integer_dtype": [
                            1403
                        ],
                        "self._addsub_int_array": [
                            1406
                        ],
                        "NotImplemented": [
                            1413
                        ],
                        "np.ndarray": [
                            1415
                        ],
                        "TimedeltaArray": [
                            1418
                        ],
                        "unpack_zerodim_and_defer": [
                            1373
                        ]
                    },
                    "filtered_variables": {
                        "other": [
                            1377,
                            1379,
                            1380,
                            1381,
                            1383,
                            1384,
                            1385,
                            1386,
                            1391,
                            1394,
                            1396,
                            1397,
                            1399,
                            1400,
                            1402,
                            1403,
                            1406
                        ],
                        "NaT": [
                            1377
                        ],
                        "result": [
                            1378,
                            1380,
                            1383,
                            1415,
                            1385,
                            1418,
                            1419,
                            1391,
                            1396,
                            1399,
                            1406
                        ],
                        "self._add_nat": [
                            1378
                        ],
                        "self": [
                            1378,
                            1380,
                            1383,
                            1385,
                            1389,
                            1390,
                            1391,
                            1396,
                            1399,
                            1402,
                            1404,
                            1405,
                            1406
                        ],
                        "Tick": [
                            1379
                        ],
                        "timedelta": [
                            1379
                        ],
                        "np.timedelta64": [
                            1379
                        ],
                        "np": [
                            1384,
                            1379,
                            1415
                        ],
                        "self._add_timedeltalike_scalar": [
                            1380
                        ],
                        "DateOffset": [
                            1381
                        ],
                        "self._add_offset": [
                            1383
                        ],
                        "datetime": [
                            1384
                        ],
                        "np.datetime64": [
                            1384
                        ],
                        "self._add_datetimelike_scalar": [
                            1385
                        ],
                        "lib.is_integer": [
                            1386
                        ],
                        "lib": [
                            1386
                        ],
                        "is_period_dtype": [
                            1404,
                            1389
                        ],
                        "integer_op_not_supported": [
                            1405,
                            1390
                        ],
                        "self._time_shift": [
                            1391
                        ],
                        "is_timedelta64_dtype": [
                            1394,
                            1415
                        ],
                        "self._add_timedelta_arraylike": [
                            1396
                        ],
                        "is_object_dtype": [
                            1397
                        ],
                        "self._addsub_object_array": [
                            1399
                        ],
                        "operator.add": [
                            1406,
                            1399
                        ],
                        "operator": [
                            1406,
                            1399
                        ],
                        "is_datetime64_dtype": [
                            1400
                        ],
                        "is_datetime64tz_dtype": [
                            1400
                        ],
                        "self._add_datetime_arraylike": [
                            1402
                        ],
                        "is_integer_dtype": [
                            1403
                        ],
                        "self._addsub_int_array": [
                            1406
                        ],
                        "np.ndarray": [
                            1415
                        ],
                        "TimedeltaArray": [
                            1418
                        ],
                        "unpack_zerodim_and_defer": [
                            1373
                        ]
                    },
                    "diff_line_number": 1374,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "__radd__",
                    "function_code": "def __radd__(self, other):\n    # alias for __add__\n    return self.__add__(other)\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 1421,
                    "variables": {
                        "self.__add__": [
                            1423
                        ],
                        "self": [
                            1423
                        ],
                        "other": [
                            1423
                        ]
                    },
                    "filtered_variables": {
                        "self.__add__": [
                            1423
                        ],
                        "self": [
                            1423
                        ],
                        "other": [
                            1423
                        ]
                    },
                    "diff_line_number": 1421,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "__sub__",
                    "function_code": "@unpack_zerodim_and_defer(\"__sub__\")\ndef __sub__(self, other):\n\n    # scalar others\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        # specifically _not_ a Tick\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        # This check must come after the check for np.timedelta64\n        # as is_integer returns True for these\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n\n    # array-like others\n    elif is_timedelta64_dtype(other):\n        # TimedeltaIndex, ndarray[timedelta64]\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        # e.g. Array/Index of DateOffset objects\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        # DatetimeIndex, ndarray[datetime64]\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        # PeriodIndex\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        # Includes ExtensionArrays, float_dtype\n        return NotImplemented\n\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n\n        return TimedeltaArray(result)\n    return result\n",
                    "decorators": [
                        "unpack_zerodim_and_defer('__sub__')"
                    ],
                    "docstring": null,
                    "start_line": 1425,
                    "variables": {
                        "other": [
                            1429,
                            1431,
                            1432,
                            1433,
                            1435,
                            1436,
                            1437,
                            1438,
                            1443,
                            1445,
                            1446,
                            1449,
                            1451,
                            1452,
                            1454,
                            1455,
                            1457,
                            1458,
                            1460,
                            1461,
                            1464
                        ],
                        "NaT": [
                            1429
                        ],
                        "result": [
                            1472,
                            1473,
                            1443,
                            1446,
                            1464,
                            1451,
                            1454,
                            1457,
                            1460,
                            1430,
                            1432,
                            1435,
                            1437,
                            1469
                        ],
                        "self._sub_nat": [
                            1430
                        ],
                        "self": [
                            1441,
                            1442,
                            1443,
                            1463,
                            1446,
                            1464,
                            1451,
                            1454,
                            1457,
                            1460,
                            1430,
                            1462,
                            1432,
                            1435,
                            1437
                        ],
                        "isinstance": [
                            1445,
                            1431,
                            1433,
                            1436,
                            1469
                        ],
                        "Tick": [
                            1431
                        ],
                        "timedelta": [
                            1431
                        ],
                        "np.timedelta64": [
                            1431
                        ],
                        "np": [
                            1436,
                            1469,
                            1431
                        ],
                        "self._add_timedeltalike_scalar": [
                            1432
                        ],
                        "DateOffset": [
                            1433
                        ],
                        "self._add_offset": [
                            1435
                        ],
                        "datetime": [
                            1436
                        ],
                        "np.datetime64": [
                            1436
                        ],
                        "self._sub_datetimelike_scalar": [
                            1437
                        ],
                        "lib.is_integer": [
                            1438
                        ],
                        "lib": [
                            1438
                        ],
                        "is_period_dtype": [
                            1441,
                            1458,
                            1462
                        ],
                        "integer_op_not_supported": [
                            1442,
                            1463
                        ],
                        "self._time_shift": [
                            1443
                        ],
                        "Period": [
                            1445
                        ],
                        "self._sub_period": [
                            1446
                        ],
                        "is_timedelta64_dtype": [
                            1449,
                            1469
                        ],
                        "self._add_timedelta_arraylike": [
                            1451
                        ],
                        "is_object_dtype": [
                            1452
                        ],
                        "self._addsub_object_array": [
                            1454
                        ],
                        "operator.sub": [
                            1464,
                            1454
                        ],
                        "operator": [
                            1464,
                            1454
                        ],
                        "is_datetime64_dtype": [
                            1455
                        ],
                        "is_datetime64tz_dtype": [
                            1455
                        ],
                        "self._sub_datetime_arraylike": [
                            1457
                        ],
                        "self._sub_period_array": [
                            1460
                        ],
                        "is_integer_dtype": [
                            1461
                        ],
                        "self._addsub_int_array": [
                            1464
                        ],
                        "NotImplemented": [
                            1467
                        ],
                        "np.ndarray": [
                            1469
                        ],
                        "TimedeltaArray": [
                            1472
                        ],
                        "unpack_zerodim_and_defer": [
                            1425
                        ]
                    },
                    "filtered_variables": {
                        "other": [
                            1429,
                            1431,
                            1432,
                            1433,
                            1435,
                            1436,
                            1437,
                            1438,
                            1443,
                            1445,
                            1446,
                            1449,
                            1451,
                            1452,
                            1454,
                            1455,
                            1457,
                            1458,
                            1460,
                            1461,
                            1464
                        ],
                        "NaT": [
                            1429
                        ],
                        "result": [
                            1472,
                            1473,
                            1443,
                            1446,
                            1464,
                            1451,
                            1454,
                            1457,
                            1460,
                            1430,
                            1432,
                            1435,
                            1437,
                            1469
                        ],
                        "self._sub_nat": [
                            1430
                        ],
                        "self": [
                            1441,
                            1442,
                            1443,
                            1463,
                            1446,
                            1464,
                            1451,
                            1454,
                            1457,
                            1460,
                            1430,
                            1462,
                            1432,
                            1435,
                            1437
                        ],
                        "Tick": [
                            1431
                        ],
                        "timedelta": [
                            1431
                        ],
                        "np.timedelta64": [
                            1431
                        ],
                        "np": [
                            1436,
                            1469,
                            1431
                        ],
                        "self._add_timedeltalike_scalar": [
                            1432
                        ],
                        "DateOffset": [
                            1433
                        ],
                        "self._add_offset": [
                            1435
                        ],
                        "datetime": [
                            1436
                        ],
                        "np.datetime64": [
                            1436
                        ],
                        "self._sub_datetimelike_scalar": [
                            1437
                        ],
                        "lib.is_integer": [
                            1438
                        ],
                        "lib": [
                            1438
                        ],
                        "is_period_dtype": [
                            1441,
                            1458,
                            1462
                        ],
                        "integer_op_not_supported": [
                            1442,
                            1463
                        ],
                        "self._time_shift": [
                            1443
                        ],
                        "Period": [
                            1445
                        ],
                        "self._sub_period": [
                            1446
                        ],
                        "is_timedelta64_dtype": [
                            1449,
                            1469
                        ],
                        "self._add_timedelta_arraylike": [
                            1451
                        ],
                        "is_object_dtype": [
                            1452
                        ],
                        "self._addsub_object_array": [
                            1454
                        ],
                        "operator.sub": [
                            1464,
                            1454
                        ],
                        "operator": [
                            1464,
                            1454
                        ],
                        "is_datetime64_dtype": [
                            1455
                        ],
                        "is_datetime64tz_dtype": [
                            1455
                        ],
                        "self._sub_datetime_arraylike": [
                            1457
                        ],
                        "self._sub_period_array": [
                            1460
                        ],
                        "is_integer_dtype": [
                            1461
                        ],
                        "self._addsub_int_array": [
                            1464
                        ],
                        "np.ndarray": [
                            1469
                        ],
                        "TimedeltaArray": [
                            1472
                        ],
                        "unpack_zerodim_and_defer": [
                            1425
                        ]
                    },
                    "diff_line_number": 1426,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "__rsub__",
                    "function_code": "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        # ndarray[datetime64] cannot be subtracted from self, so\n        # we need to wrap in DatetimeArray/Index and flip the operation\n        if lib.is_scalar(other):\n            # i.e. np.datetime64 object\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            # Avoid down-casting DatetimeIndex\n            from pandas.core.arrays import DatetimeArray\n\n            other = DatetimeArray(other)\n        return other - self\n    elif (\n        is_datetime64_any_dtype(self.dtype)\n        and hasattr(other, \"dtype\")\n        and not is_datetime64_any_dtype(other.dtype)\n    ):\n        # GH#19959 datetime - datetime is well-defined as timedelta,\n        # but any other type - datetime is not well-defined.\n        raise TypeError(\n            f\"cannot subtract {type(self).__name__} from {type(other).__name__}\"\n        )\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        # TODO: Can we simplify/generalize these cases at all?\n        raise TypeError(f\"cannot subtract {type(self).__name__} from {other.dtype}\")\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            # need to subtract before negating, since that flips freq\n            # -self flips self.freq, messing up results\n            return -(self - other)\n\n        return (-self) + other\n\n    return -(self - other)\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 1475,
                    "variables": {
                        "is_datetime64_any_dtype": [
                            1489,
                            1491,
                            1476
                        ],
                        "other": [
                            1505,
                            1507,
                            1476,
                            1509,
                            1479,
                            1481,
                            1482,
                            1486,
                            1487,
                            1490,
                            1491,
                            1496,
                            1498,
                            1500,
                            1502
                        ],
                        "is_timedelta64_dtype": [
                            1498,
                            1476,
                            1501
                        ],
                        "self.dtype": [
                            1489,
                            1498,
                            1476,
                            1501
                        ],
                        "self": [
                            1505,
                            1507,
                            1476,
                            1509,
                            1481,
                            1487,
                            1489,
                            1496,
                            1498,
                            1500,
                            1501
                        ],
                        "lib.is_scalar": [
                            1479
                        ],
                        "lib": [
                            1502,
                            1479
                        ],
                        "Timestamp": [
                            1481
                        ],
                        "isinstance": [
                            1482
                        ],
                        "DatetimeLikeArrayMixin": [
                            1482
                        ],
                        "DatetimeArray": [
                            1486
                        ],
                        "hasattr": [
                            1490
                        ],
                        "other.dtype": [
                            1491,
                            1500
                        ],
                        "TypeError": [
                            1500,
                            1495
                        ],
                        "__name__": [
                            1496,
                            1500
                        ],
                        "type": [
                            1496,
                            1500
                        ],
                        "is_period_dtype": [
                            1498
                        ],
                        "lib.is_integer": [
                            1502
                        ],
                        "is_integer_dtype": [
                            1502
                        ]
                    },
                    "filtered_variables": {
                        "is_datetime64_any_dtype": [
                            1489,
                            1491,
                            1476
                        ],
                        "other": [
                            1505,
                            1507,
                            1476,
                            1509,
                            1479,
                            1481,
                            1482,
                            1486,
                            1487,
                            1490,
                            1491,
                            1496,
                            1498,
                            1500,
                            1502
                        ],
                        "is_timedelta64_dtype": [
                            1498,
                            1476,
                            1501
                        ],
                        "self.dtype": [
                            1489,
                            1498,
                            1476,
                            1501
                        ],
                        "self": [
                            1505,
                            1507,
                            1476,
                            1509,
                            1481,
                            1487,
                            1489,
                            1496,
                            1498,
                            1500,
                            1501
                        ],
                        "lib.is_scalar": [
                            1479
                        ],
                        "lib": [
                            1502,
                            1479
                        ],
                        "Timestamp": [
                            1481
                        ],
                        "DatetimeLikeArrayMixin": [
                            1482
                        ],
                        "DatetimeArray": [
                            1486
                        ],
                        "other.dtype": [
                            1491,
                            1500
                        ],
                        "is_period_dtype": [
                            1498
                        ],
                        "lib.is_integer": [
                            1502
                        ],
                        "is_integer_dtype": [
                            1502
                        ]
                    },
                    "diff_line_number": 1475,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "__iadd__",
                    "function_code": "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n\n    if not is_period_dtype(self):\n        # restore freq, which is invalidated by setitem\n        self._freq = result._freq\n    return self\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 1511,
                    "variables": {
                        "result": [
                            1512,
                            1513,
                            1517
                        ],
                        "self": [
                            1512,
                            1513,
                            1515,
                            1517,
                            1518
                        ],
                        "other": [
                            1512
                        ],
                        "is_period_dtype": [
                            1515
                        ],
                        "self._freq": [
                            1517
                        ],
                        "result._freq": [
                            1517
                        ]
                    },
                    "filtered_variables": {
                        "result": [
                            1512,
                            1513,
                            1517
                        ],
                        "self": [
                            1512,
                            1513,
                            1515,
                            1517,
                            1518
                        ],
                        "other": [
                            1512
                        ],
                        "is_period_dtype": [
                            1515
                        ],
                        "self._freq": [
                            1517
                        ],
                        "result._freq": [
                            1517
                        ]
                    },
                    "diff_line_number": 1511,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "__isub__",
                    "function_code": "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n\n    if not is_period_dtype(self):\n        # restore freq, which is invalidated by setitem\n        self._freq = result._freq\n    return self\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 1520,
                    "variables": {
                        "result": [
                            1521,
                            1522,
                            1526
                        ],
                        "self": [
                            1521,
                            1522,
                            1524,
                            1526,
                            1527
                        ],
                        "other": [
                            1521
                        ],
                        "is_period_dtype": [
                            1524
                        ],
                        "self._freq": [
                            1526
                        ],
                        "result._freq": [
                            1526
                        ]
                    },
                    "filtered_variables": {
                        "result": [
                            1521,
                            1522,
                            1526
                        ],
                        "self": [
                            1521,
                            1522,
                            1524,
                            1526,
                            1527
                        ],
                        "other": [
                            1521
                        ],
                        "is_period_dtype": [
                            1524
                        ],
                        "self._freq": [
                            1526
                        ],
                        "result._freq": [
                            1526
                        ]
                    },
                    "diff_line_number": 1520,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_reduce",
                    "function_code": "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 1532,
                    "variables": {
                        "op": [
                            1533,
                            1534,
                            1535
                        ],
                        "getattr": [
                            1533
                        ],
                        "self": [
                            1533
                        ],
                        "name": [
                            1537,
                            1533
                        ],
                        "skipna": [
                            1537,
                            1535
                        ],
                        "kwargs": [
                            1537,
                            1535
                        ],
                        "_reduce": [
                            1537
                        ],
                        "super": [
                            1537
                        ]
                    },
                    "filtered_variables": {
                        "op": [
                            1533,
                            1534,
                            1535
                        ],
                        "self": [
                            1533
                        ],
                        "name": [
                            1537,
                            1533
                        ],
                        "skipna": [
                            1537,
                            1535
                        ],
                        "kwargs": [
                            1537,
                            1535
                        ],
                        "_reduce": [
                            1537
                        ]
                    },
                    "diff_line_number": 1532,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "min",
                    "function_code": "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        # Period._from_ordinal does not handle np.nan gracefully\n        return NaT\n    return self._box_func(result)\n",
                    "decorators": [],
                    "docstring": "Return the minimum value of the Array or minimum along\nan axis.\n\nSee Also\n--------\nnumpy.ndarray.min\nIndex.min : Return the minimum value in an Index.\nSeries.min : Return the minimum value in a Series.",
                    "start_line": 1539,
                    "variables": {
                        "nv.validate_min": [
                            1550
                        ],
                        "nv": [
                            1550,
                            1551
                        ],
                        "args": [
                            1550
                        ],
                        "kwargs": [
                            1550
                        ],
                        "nv.validate_minmax_axis": [
                            1551
                        ],
                        "axis": [
                            1551
                        ],
                        "result": [
                            1553,
                            1554,
                            1557
                        ],
                        "nanops.nanmin": [
                            1553
                        ],
                        "nanops": [
                            1553
                        ],
                        "self.asi8": [
                            1553
                        ],
                        "self": [
                            1553,
                            1557
                        ],
                        "skipna": [
                            1553
                        ],
                        "self.isna": [
                            1553
                        ],
                        "isna": [
                            1554
                        ],
                        "NaT": [
                            1556
                        ],
                        "self._box_func": [
                            1557
                        ]
                    },
                    "filtered_variables": {
                        "nv.validate_min": [
                            1550
                        ],
                        "nv": [
                            1550,
                            1551
                        ],
                        "args": [
                            1550
                        ],
                        "kwargs": [
                            1550
                        ],
                        "nv.validate_minmax_axis": [
                            1551
                        ],
                        "axis": [
                            1551
                        ],
                        "result": [
                            1553,
                            1554,
                            1557
                        ],
                        "nanops.nanmin": [
                            1553
                        ],
                        "nanops": [
                            1553
                        ],
                        "self.asi8": [
                            1553
                        ],
                        "self": [
                            1553,
                            1557
                        ],
                        "skipna": [
                            1553
                        ],
                        "self.isna": [
                            1553
                        ],
                        "isna": [
                            1554
                        ],
                        "NaT": [
                            1556
                        ],
                        "self._box_func": [
                            1557
                        ]
                    },
                    "diff_line_number": 1539,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "max",
                    "function_code": "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    # TODO: skipna is broken with max.\n    # See https://github.com/pandas-dev/pandas/issues/24265\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n\n    if not len(values):\n        # short-circuit for empty max / min\n        return NaT\n\n    result = nanops.nanmax(values, skipna=skipna)\n    # Don't have to worry about NA `result`, since no NA went in.\n    return self._box_func(result)\n",
                    "decorators": [],
                    "docstring": "Return the maximum value of the Array or maximum along\nan axis.\n\nSee Also\n--------\nnumpy.ndarray.max\nIndex.max : Return the maximum value in an Index.\nSeries.max : Return the maximum value in a Series.",
                    "start_line": 1559,
                    "variables": {
                        "nv.validate_max": [
                            1572
                        ],
                        "nv": [
                            1572,
                            1573
                        ],
                        "args": [
                            1572
                        ],
                        "kwargs": [
                            1572
                        ],
                        "nv.validate_minmax_axis": [
                            1573
                        ],
                        "axis": [
                            1573
                        ],
                        "mask": [
                            1577,
                            1578,
                            1575
                        ],
                        "self.isna": [
                            1575
                        ],
                        "self": [
                            1577,
                            1589,
                            1581,
                            1575
                        ],
                        "skipna": [
                            1576,
                            1587
                        ],
                        "values": [
                            1577,
                            1587,
                            1581,
                            1583
                        ],
                        "asi8": [
                            1577
                        ],
                        "mask.any": [
                            1578
                        ],
                        "NaT": [
                            1585,
                            1579
                        ],
                        "self.asi8": [
                            1581
                        ],
                        "len": [
                            1583
                        ],
                        "result": [
                            1587,
                            1589
                        ],
                        "nanops.nanmax": [
                            1587
                        ],
                        "nanops": [
                            1587
                        ],
                        "self._box_func": [
                            1589
                        ]
                    },
                    "filtered_variables": {
                        "nv.validate_max": [
                            1572
                        ],
                        "nv": [
                            1572,
                            1573
                        ],
                        "args": [
                            1572
                        ],
                        "kwargs": [
                            1572
                        ],
                        "nv.validate_minmax_axis": [
                            1573
                        ],
                        "axis": [
                            1573
                        ],
                        "mask": [
                            1577,
                            1578,
                            1575
                        ],
                        "self.isna": [
                            1575
                        ],
                        "self": [
                            1577,
                            1589,
                            1581,
                            1575
                        ],
                        "skipna": [
                            1576,
                            1587
                        ],
                        "values": [
                            1577,
                            1587,
                            1581,
                            1583
                        ],
                        "asi8": [
                            1577
                        ],
                        "mask.any": [
                            1578
                        ],
                        "NaT": [
                            1585,
                            1579
                        ],
                        "self.asi8": [
                            1581
                        ],
                        "result": [
                            1587,
                            1589
                        ],
                        "nanops.nanmax": [
                            1587
                        ],
                        "nanops": [
                            1587
                        ],
                        "self._box_func": [
                            1589
                        ]
                    },
                    "diff_line_number": 1559,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "mean",
                    "function_code": "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        # See discussion in GH#24757\n        raise TypeError(\n            f\"mean is not implemented for {type(self).__name__} since the \"\n            \"meaning is ambiguous.  An alternative is \"\n            \"obj.to_timestamp(how='start').mean()\"\n        )\n\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n\n    if not len(values):\n        # short-circuit for empty max / min\n        return NaT\n\n    result = nanops.nanmean(values.view(\"i8\"), skipna=skipna)\n    # Don't have to worry about NA `result`, since no NA went in.\n    return self._box_func(result)\n",
                    "decorators": [],
                    "docstring": "Return the mean value of the Array.\n\n.. versionadded:: 0.25.0\n\nParameters\n----------\nskipna : bool, default True\n    Whether to ignore any NaT elements.\n\nReturns\n-------\nscalar\n    Timestamp or Timedelta.\n\nSee Also\n--------\nnumpy.ndarray.mean : Returns the average of array elements along a given axis.\nSeries.mean : Return the mean value in a Series.\n\nNotes\n-----\nmean is only defined for Datetime and Timedelta dtypes, not for Period.",
                    "start_line": 1591,
                    "variables": {
                        "is_period_dtype": [
                            1616
                        ],
                        "self": [
                            1638,
                            1616,
                            1619,
                            1624,
                            1626,
                            1630
                        ],
                        "TypeError": [
                            1618
                        ],
                        "__name__": [
                            1619
                        ],
                        "type": [
                            1619
                        ],
                        "mask": [
                            1624,
                            1626,
                            1627
                        ],
                        "self.isna": [
                            1624
                        ],
                        "skipna": [
                            1625,
                            1636
                        ],
                        "values": [
                            1632,
                            1626,
                            1636,
                            1630
                        ],
                        "mask.any": [
                            1627
                        ],
                        "NaT": [
                            1634,
                            1628
                        ],
                        "len": [
                            1632
                        ],
                        "result": [
                            1636,
                            1638
                        ],
                        "nanops.nanmean": [
                            1636
                        ],
                        "nanops": [
                            1636
                        ],
                        "values.view": [
                            1636
                        ],
                        "self._box_func": [
                            1638
                        ]
                    },
                    "filtered_variables": {
                        "is_period_dtype": [
                            1616
                        ],
                        "self": [
                            1638,
                            1616,
                            1619,
                            1624,
                            1626,
                            1630
                        ],
                        "mask": [
                            1624,
                            1626,
                            1627
                        ],
                        "self.isna": [
                            1624
                        ],
                        "skipna": [
                            1625,
                            1636
                        ],
                        "values": [
                            1632,
                            1626,
                            1636,
                            1630
                        ],
                        "mask.any": [
                            1627
                        ],
                        "NaT": [
                            1634,
                            1628
                        ],
                        "result": [
                            1636,
                            1638
                        ],
                        "nanops.nanmean": [
                            1636
                        ],
                        "nanops": [
                            1636
                        ],
                        "values.view": [
                            1636
                        ],
                        "self._box_func": [
                            1638
                        ]
                    },
                    "diff_line_number": 1591,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _ndarray(self) -> np.ndarray:\n    return self.asi8",
                            "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    return type(self)(arr, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    if com.is_bool_indexer(key):\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        pass\n    else:\n        key = check_array_indexer(self, key)\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    return freq",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int=0):\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError('to_concat must have the same dtype (tz)', dtypes)\n    obj = to_concat[0]\n    dtype = obj.dtype\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        to_concat = [x for x in to_concat if len(x)]\n        if obj.freq is not None and all((x.freq == obj.freq for x in to_concat)):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all((pair[0][-1] + obj.freq == pair[1][0] for pair in pairs)):\n                new_freq = obj.freq\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{str(fill_value)}'.\")\n    return fill_value",
                            "def _validate_shift_value(self, fill_value):\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n        warnings.warn(f'Passing {type(fill_value)} to shift is deprecated and will raise in a future version, pass {self._scalar_type.__name__} instead.', FutureWarning, stacklevel=10)\n        fill_value = new_fill\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                            "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError('searchsorted requires compatible dtype or scalar') from err\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n    elif is_list_like(value) and (not isinstance(value, type(self))):\n        value = array(value)\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(f'searchsorted requires compatible dtype or scalar, not {type(value).__name__}')\n    if not (isinstance(value, (self._scalar_type, type(self))) or value is NaT):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return value",
                            "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    return value",
                            "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n    else:\n        raise TypeError(f'cannot insert {type(self).__name__} with incompatible label')\n    return value",
                            "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f'Where requires matching dtype, not {type(other)}')\n    else:\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n        if is_categorical_dtype(other.dtype):\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f'Where requires matching dtype, not {other.dtype}')\n        self._check_compatible_with(other, setitem=True)\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view('i8')\n    return other",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result._values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}') from e",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        new_freq = self.freq\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                            "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return type(self)(new_values, dtype=self.dtype)",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    assert self.shape == other.shape, (self.shape, other.shape)\n    res_values = op(self.astype('O'), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_ndarray(self) -> np.ndarray",
                            "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__getitem__(self, key)",
                            "_get_getitem_freq(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "_concat_same_type(cls, to_concat, axis: int=0)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "shift(self, periods=1, fill_value=None, axis=0)",
                            "_validate_fill_value(self, fill_value)",
                            "_validate_shift_value(self, fill_value)",
                            "_validate_searchsorted_value(self, value)",
                            "_validate_setitem_value(self, value)",
                            "_validate_insert_value(self, value)",
                            "_validate_where_value(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_timedelta_arraylike(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "validate_periods",
                    "function_code": "def validate_periods(periods):\n    \"\"\"\n    If a `periods` argument is passed to the Datetime/Timedelta Array/Index\n    constructor, cast it to an integer.\n\n    Parameters\n    ----------\n    periods : None, float, int\n\n    Returns\n    -------\n    periods : None or int\n\n    Raises\n    ------\n    TypeError\n        if periods is None, float, or int\n    \"\"\"\n    if periods is not None:\n        if lib.is_float(periods):\n            periods = int(periods)\n        elif not lib.is_integer(periods):\n            raise TypeError(f\"periods must be a number, got {periods}\")\n    return periods\n",
                    "decorators": [],
                    "docstring": "If a `periods` argument is passed to the Datetime/Timedelta Array/Index\nconstructor, cast it to an integer.\n\nParameters\n----------\nperiods : None, float, int\n\nReturns\n-------\nperiods : None or int\n\nRaises\n------\nTypeError\n    if periods is None, float, or int",
                    "start_line": 1647,
                    "variables": {
                        "periods": [
                            1665,
                            1666,
                            1667,
                            1668,
                            1669,
                            1670
                        ],
                        "lib.is_float": [
                            1666
                        ],
                        "lib": [
                            1666,
                            1668
                        ],
                        "int": [
                            1667
                        ],
                        "lib.is_integer": [
                            1668
                        ],
                        "TypeError": [
                            1669
                        ]
                    },
                    "filtered_variables": {
                        "periods": [
                            1665,
                            1666,
                            1667,
                            1668,
                            1669,
                            1670
                        ],
                        "lib.is_float": [
                            1666
                        ],
                        "lib": [
                            1666,
                            1668
                        ],
                        "lib.is_integer": [
                            1668
                        ]
                    },
                    "diff_line_number": 1647,
                    "class_data": null,
                    "variable_values": [
                        [
                            {
                                "periods": {
                                    "variable_value": "100",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "periods": {
                                    "variable_value": "100",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "periods": {
                                    "variable_value": "100",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "periods": {
                                    "variable_value": "100",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "periods": {
                                    "variable_value": "100",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "periods": {
                                    "variable_value": "100",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "periods": {
                                    "variable_value": "100",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "periods": {
                                    "variable_value": "100",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "periods": {
                                    "variable_value": "3",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "periods": {
                                    "variable_value": "3",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "periods": {
                                    "variable_value": "3",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "periods": {
                                    "variable_value": "3",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "periods": {
                                    "variable_value": "100",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "periods": {
                                    "variable_value": "100",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "periods": {
                                    "variable_value": "100",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "periods": {
                                    "variable_value": "100",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "periods": {
                                    "variable_value": "100",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "periods": {
                                    "variable_value": "100",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "periods": {
                                    "variable_value": "100",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "periods": {
                                    "variable_value": "100",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "periods": {
                                    "variable_value": "3",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "periods": {
                                    "variable_value": "3",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "periods": {
                                    "variable_value": "3",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "periods": {
                                    "variable_value": "3",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                },
                {
                    "function_name": "validate_endpoints",
                    "function_code": "def validate_endpoints(closed):\n    \"\"\"\n    Check that the `closed` argument is among [None, \"left\", \"right\"]\n\n    Parameters\n    ----------\n    closed : {None, \"left\", \"right\"}\n\n    Returns\n    -------\n    left_closed : bool\n    right_closed : bool\n\n    Raises\n    ------\n    ValueError : if argument is not among valid values\n    \"\"\"\n    left_closed = False\n    right_closed = False\n\n    if closed is None:\n        left_closed = True\n        right_closed = True\n    elif closed == \"left\":\n        left_closed = True\n    elif closed == \"right\":\n        right_closed = True\n    else:\n        raise ValueError(\"Closed has to be either 'left', 'right' or None\")\n\n    return left_closed, right_closed\n",
                    "decorators": [],
                    "docstring": "Check that the `closed` argument is among [None, \"left\", \"right\"]\n\nParameters\n----------\nclosed : {None, \"left\", \"right\"}\n\nReturns\n-------\nleft_closed : bool\nright_closed : bool\n\nRaises\n------\nValueError : if argument is not among valid values",
                    "start_line": 1673,
                    "variables": {
                        "left_closed": [
                            1697,
                            1690,
                            1694,
                            1703
                        ],
                        "right_closed": [
                            1703,
                            1691,
                            1699,
                            1695
                        ],
                        "closed": [
                            1696,
                            1698,
                            1693
                        ],
                        "ValueError": [
                            1701
                        ]
                    },
                    "filtered_variables": {
                        "left_closed": [
                            1697,
                            1690,
                            1694,
                            1703
                        ],
                        "right_closed": [
                            1703,
                            1691,
                            1699,
                            1695
                        ],
                        "closed": [
                            1696,
                            1698,
                            1693
                        ]
                    },
                    "diff_line_number": 1673,
                    "class_data": null,
                    "variable_values": [
                        [
                            {
                                "left_closed": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_closed": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "closed": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            },
                            {
                                "left_closed": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "right_closed": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "closed": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "left_closed": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_closed": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "closed": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            },
                            {
                                "left_closed": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "right_closed": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "closed": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "left_closed": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_closed": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "closed": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            },
                            {
                                "left_closed": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "right_closed": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "closed": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "left_closed": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_closed": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "closed": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            },
                            {
                                "left_closed": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "right_closed": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "closed": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "left_closed": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_closed": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "closed": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            },
                            {
                                "left_closed": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "right_closed": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "closed": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "left_closed": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_closed": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "closed": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            },
                            {
                                "left_closed": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "right_closed": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "closed": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "left_closed": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_closed": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "closed": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            },
                            {
                                "left_closed": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "right_closed": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "closed": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "left_closed": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_closed": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "closed": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            },
                            {
                                "left_closed": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "right_closed": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "closed": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "left_closed": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_closed": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "closed": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            },
                            {
                                "left_closed": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "right_closed": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "closed": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "left_closed": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_closed": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "closed": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            },
                            {
                                "left_closed": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "right_closed": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "closed": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                },
                {
                    "function_name": "validate_inferred_freq",
                    "function_code": "def validate_inferred_freq(freq, inferred_freq, freq_infer):\n    \"\"\"\n    If the user passes a freq and another freq is inferred from passed data,\n    require that they match.\n\n    Parameters\n    ----------\n    freq : DateOffset or None\n    inferred_freq : DateOffset or None\n    freq_infer : bool\n\n    Returns\n    -------\n    freq : DateOffset or None\n    freq_infer : bool\n\n    Notes\n    -----\n    We assume at this point that `maybe_infer_freq` has been called, so\n    `freq` is either a DateOffset object or None.\n    \"\"\"\n    if inferred_freq is not None:\n        if freq is not None and freq != inferred_freq:\n            raise ValueError(\n                f\"Inferred frequency {inferred_freq} from passed \"\n                \"values does not conform to passed frequency \"\n                f\"{freq.freqstr}\"\n            )\n        elif freq is None:\n            freq = inferred_freq\n        freq_infer = False\n\n    return freq, freq_infer\n",
                    "decorators": [],
                    "docstring": "If the user passes a freq and another freq is inferred from passed data,\nrequire that they match.\n\nParameters\n----------\nfreq : DateOffset or None\ninferred_freq : DateOffset or None\nfreq_infer : bool\n\nReturns\n-------\nfreq : DateOffset or None\nfreq_infer : bool\n\nNotes\n-----\nWe assume at this point that `maybe_infer_freq` has been called, so\n`freq` is either a DateOffset object or None.",
                    "start_line": 1706,
                    "variables": {
                        "inferred_freq": [
                            1728,
                            1730,
                            1735,
                            1727
                        ],
                        "freq": [
                            1728,
                            1732,
                            1734,
                            1735,
                            1738
                        ],
                        "ValueError": [
                            1729
                        ],
                        "freq.freqstr": [
                            1732
                        ],
                        "freq_infer": [
                            1736,
                            1738
                        ]
                    },
                    "filtered_variables": {
                        "inferred_freq": [
                            1728,
                            1730,
                            1735,
                            1727
                        ],
                        "freq": [
                            1728,
                            1732,
                            1734,
                            1735,
                            1738
                        ],
                        "freq.freqstr": [
                            1732
                        ],
                        "freq_infer": [
                            1736,
                            1738
                        ]
                    },
                    "diff_line_number": 1706,
                    "class_data": null,
                    "variable_values": [
                        [
                            {
                                "inferred_freq": {
                                    "variable_value": "<BusinessDay>",
                                    "variable_type": "BusinessDay",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            },
                            {
                                "inferred_freq": {
                                    "variable_value": "<BusinessDay>",
                                    "variable_type": "BusinessDay",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "<BusinessDay>",
                                    "variable_type": "BusinessDay",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "'B'",
                                    "variable_type": "str",
                                    "variable_shape": "1"
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "inferred_freq": {
                                    "variable_value": "<BusinessDay>",
                                    "variable_type": "BusinessDay",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            },
                            {
                                "inferred_freq": {
                                    "variable_value": "<BusinessDay>",
                                    "variable_type": "BusinessDay",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "<BusinessDay>",
                                    "variable_type": "BusinessDay",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "'B'",
                                    "variable_type": "str",
                                    "variable_shape": "1"
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "inferred_freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            },
                            {
                                "inferred_freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "inferred_freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            },
                            {
                                "inferred_freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "inferred_freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            },
                            {
                                "inferred_freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "inferred_freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            },
                            {
                                "inferred_freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "inferred_freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            },
                            {
                                "inferred_freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "inferred_freq": {
                                    "variable_value": "<BusinessDay>",
                                    "variable_type": "BusinessDay",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            },
                            {
                                "inferred_freq": {
                                    "variable_value": "<BusinessDay>",
                                    "variable_type": "BusinessDay",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "<BusinessDay>",
                                    "variable_type": "BusinessDay",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "'B'",
                                    "variable_type": "str",
                                    "variable_shape": "1"
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "inferred_freq": {
                                    "variable_value": "<BusinessDay>",
                                    "variable_type": "BusinessDay",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            },
                            {
                                "inferred_freq": {
                                    "variable_value": "<BusinessDay>",
                                    "variable_type": "BusinessDay",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "<BusinessDay>",
                                    "variable_type": "BusinessDay",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "'B'",
                                    "variable_type": "str",
                                    "variable_shape": "1"
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "inferred_freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            },
                            {
                                "inferred_freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "inferred_freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            },
                            {
                                "inferred_freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "inferred_freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            },
                            {
                                "inferred_freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "inferred_freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            },
                            {
                                "inferred_freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "inferred_freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            },
                            {
                                "inferred_freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                },
                {
                    "function_name": "maybe_infer_freq",
                    "function_code": "def maybe_infer_freq(freq):\n    \"\"\"\n    Comparing a DateOffset to the string \"infer\" raises, so we need to\n    be careful about comparisons.  Make a dummy variable `freq_infer` to\n    signify the case where the given freq is \"infer\" and set freq to None\n    to avoid comparison trouble later on.\n\n    Parameters\n    ----------\n    freq : {DateOffset, None, str}\n\n    Returns\n    -------\n    freq : {DateOffset, None}\n    freq_infer : bool\n        Whether we should inherit the freq of passed data.\n    \"\"\"\n    freq_infer = False\n    if not isinstance(freq, DateOffset):\n        # if a passed freq is None, don't infer automatically\n        if freq != \"infer\":\n            freq = frequencies.to_offset(freq)\n        else:\n            freq_infer = True\n            freq = None\n    return freq, freq_infer\n",
                    "decorators": [],
                    "docstring": "Comparing a DateOffset to the string \"infer\" raises, so we need to\nbe careful about comparisons.  Make a dummy variable `freq_infer` to\nsignify the case where the given freq is \"infer\" and set freq to None\nto avoid comparison trouble later on.\n\nParameters\n----------\nfreq : {DateOffset, None, str}\n\nReturns\n-------\nfreq : {DateOffset, None}\nfreq_infer : bool\n    Whether we should inherit the freq of passed data.",
                    "start_line": 1741,
                    "variables": {
                        "freq_infer": [
                            1766,
                            1764,
                            1758
                        ],
                        "isinstance": [
                            1759
                        ],
                        "freq": [
                            1761,
                            1762,
                            1765,
                            1766,
                            1759
                        ],
                        "DateOffset": [
                            1759
                        ],
                        "frequencies.to_offset": [
                            1762
                        ],
                        "frequencies": [
                            1762
                        ]
                    },
                    "filtered_variables": {
                        "freq_infer": [
                            1766,
                            1764,
                            1758
                        ],
                        "freq": [
                            1761,
                            1762,
                            1765,
                            1766,
                            1759
                        ],
                        "DateOffset": [
                            1759
                        ],
                        "frequencies.to_offset": [
                            1762
                        ],
                        "frequencies": [
                            1762
                        ]
                    },
                    "diff_line_number": 1741,
                    "class_data": null,
                    "variable_values": [
                        [
                            {
                                "freq_infer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "freq_infer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "freq_infer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "'D'",
                                    "variable_type": "str",
                                    "variable_shape": "1"
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "<Day>",
                                    "variable_type": "Day",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "freq_infer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "freq_infer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "freq_infer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "freq_infer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "freq_infer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "freq_infer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "freq_infer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "freq_infer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "'D'",
                                    "variable_type": "str",
                                    "variable_shape": "1"
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "<Day>",
                                    "variable_type": "Day",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "freq_infer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "freq_infer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "freq_infer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "freq_infer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "freq_infer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                }
            ],
            "snippets": [
                {
                    "snippet_code": "class AttributesMixin:\n    _data: np.ndarray\n\n    @classmethod",
                    "start_line": 140,
                    "end_line": 145
                },
                {
                    "snippet_code": "class DatelikeOps:\n    \"\"\"\n    Common ops for DatetimeIndex/PeriodIndex, but not TimedeltaIndex.\n    \"\"\"\n\n    @Substitution(\n        URL=\"https://docs.python.org/3/library/datetime.html\"\n        \"#strftime-and-strptime-behavior\"\n    )",
                    "start_line": 225,
                    "end_line": 235
                },
                {
                    "snippet_code": "class TimelikeOps:\n    \"\"\"\n    Common ops for TimedeltaIndex/DatetimeIndex, but not PeriodIndex.\n    \"\"\"\n\n    _round_doc = \"\"\"\n        Perform {op} operation on the data to the specified `freq`.\n\n        Parameters\n        ----------\n        freq : str or Offset\n            The frequency level to {op} the index to. Must be a fixed\n            frequency like 'S' (second) not 'ME' (month end). See\n            :ref:`frequency aliases <timeseries.offset_aliases>` for\n            a list of possible `freq` values.\n        ambiguous : 'infer', bool-ndarray, 'NaT', default 'raise'\n            Only relevant for DatetimeIndex:\n\n            - 'infer' will attempt to infer fall dst-transition hours based on\n              order\n            - bool-ndarray where True signifies a DST time, False designates\n              a non-DST time (note that this flag is only applicable for\n              ambiguous times)\n            - 'NaT' will return NaT where there are ambiguous times\n            - 'raise' will raise an AmbiguousTimeError if there are ambiguous\n              times.\n\n            .. versionadded:: 0.24.0\n\n        nonexistent : 'shift_forward', 'shift_backward', 'NaT', timedelta, \\\ndefault 'raise'\n            A nonexistent time does not exist in a particular timezone\n            where clocks moved forward due to DST.\n\n            - 'shift_forward' will shift the nonexistent time forward to the\n              closest existing time\n            - 'shift_backward' will shift the nonexistent time backward to the\n              closest existing time\n            - 'NaT' will return NaT where there are nonexistent times\n            - timedelta objects will shift nonexistent times by the timedelta\n            - 'raise' will raise an NonExistentTimeError if there are\n              nonexistent times.\n\n            .. versionadded:: 0.24.0\n\n        Returns\n        -------\n        DatetimeIndex, TimedeltaIndex, or Series\n            Index of the same type for a DatetimeIndex or TimedeltaIndex,\n            or a Series with the same index for a Series.\n\n        Raises\n        ------\n        ValueError if the `freq` cannot be converted.\n\n        Examples\n        --------\n        **DatetimeIndex**\n\n        >>> rng = pd.date_range('1/1/2018 11:59:00', periods=3, freq='min')\n        >>> rng\n        DatetimeIndex(['2018-01-01 11:59:00', '2018-01-01 12:00:00',\n                       '2018-01-01 12:01:00'],\n                      dtype='datetime64[ns]', freq='T')\n        \"\"\"\n\n    _round_example = \"\"\">>> rng.round('H')\n        DatetimeIndex(['2018-01-01 12:00:00', '2018-01-01 12:00:00',\n                       '2018-01-01 12:00:00'],\n                      dtype='datetime64[ns]', freq=None)\n\n        **Series**\n\n        >>> pd.Series(rng).dt.round(\"H\")\n        0   2018-01-01 12:00:00\n        1   2018-01-01 12:00:00\n        2   2018-01-01 12:00:00\n        dtype: datetime64[ns]\n        \"\"\"\n\n    _floor_example = \"\"\">>> rng.floor('H')\n        DatetimeIndex(['2018-01-01 11:00:00', '2018-01-01 12:00:00',\n                       '2018-01-01 12:00:00'],\n                      dtype='datetime64[ns]', freq=None)\n\n        **Series**\n\n        >>> pd.Series(rng).dt.floor(\"H\")\n        0   2018-01-01 11:00:00\n        1   2018-01-01 12:00:00\n        2   2018-01-01 12:00:00\n        dtype: datetime64[ns]\n        \"\"\"\n\n    _ceil_example = \"\"\">>> rng.ceil('H')\n        DatetimeIndex(['2018-01-01 12:00:00', '2018-01-01 12:00:00',\n                       '2018-01-01 13:00:00'],\n                      dtype='datetime64[ns]', freq=None)\n\n        **Series**\n\n        >>> pd.Series(rng).dt.ceil(\"H\")\n        0   2018-01-01 12:00:00\n        1   2018-01-01 12:00:00\n        2   2018-01-01 13:00:00\n        dtype: datetime64[ns]\n        \"\"\"",
                    "start_line": 273,
                    "end_line": 382
                },
                {
                    "snippet_code": "@Appender((_round_doc + _round_example).format(op=\"round\"))",
                    "start_line": 398,
                    "end_line": 399
                },
                {
                    "snippet_code": "@Appender((_round_doc + _floor_example).format(op=\"floor\"))",
                    "start_line": 402,
                    "end_line": 403
                },
                {
                    "snippet_code": "@Appender((_round_doc + _ceil_example).format(op=\"ceil\"))",
                    "start_line": 406,
                    "end_line": 407
                },
                {
                    "snippet_code": "class DatetimeLikeArrayMixin(\n    ExtensionOpsMixin, AttributesMixin, NDArrayBackedExtensionArray\n):\n    \"\"\"\n    Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\n    Assumes that __new__/__init__ defines:\n        _data\n        _freq\n\n    and that the inheriting class has methods:\n        _generate_range\n    \"\"\"\n\n    # ------------------------------------------------------------------\n    # NDArrayBackedExtensionArray compat\n\n    @property",
                    "start_line": 438,
                    "end_line": 457
                },
                {
                    "snippet_code": "# ------------------------------------------------------------------",
                    "start_line": 465,
                    "end_line": 467
                },
                {
                    "snippet_code": "@property",
                    "start_line": 483,
                    "end_line": 484
                },
                {
                    "snippet_code": "# ----------------------------------------------------------------\n    # Rendering Methods",
                    "start_line": 496,
                    "end_line": 499
                },
                {
                    "snippet_code": "# ----------------------------------------------------------------\n    # Array-Like / EA-Interface Methods",
                    "start_line": 513,
                    "end_line": 516
                },
                {
                    "snippet_code": "# ------------------------------------------------------------------\n    # ExtensionArray Interface\n\n    @classmethod",
                    "start_line": 649,
                    "end_line": 653
                },
                {
                    "snippet_code": "@classmethod",
                    "start_line": 688,
                    "end_line": 689
                },
                {
                    "snippet_code": "@Appender(ExtensionArray.shift.__doc__)",
                    "start_line": 695,
                    "end_line": 696
                },
                {
                    "snippet_code": "# ------------------------------------------------------------------\n    # Validation Methods\n    # TODO: try to de-duplicate these, ensure identical behavior",
                    "start_line": 705,
                    "end_line": 709
                },
                {
                    "snippet_code": "# ------------------------------------------------------------------\n    # Additional array methods\n    #  These are not part of the EA API, but we implement them because\n    #  pandas assumes they're there.",
                    "start_line": 869,
                    "end_line": 874
                },
                {
                    "snippet_code": "# ------------------------------------------------------------------\n    # Null Handling",
                    "start_line": 942,
                    "end_line": 945
                },
                {
                    "snippet_code": "@property  # NB: override with cache_readonly in immutable subclasses",
                    "start_line": 948,
                    "end_line": 949
                },
                {
                    "snippet_code": "@property  # NB: override with cache_readonly in immutable subclasses",
                    "start_line": 955,
                    "end_line": 956
                },
                {
                    "snippet_code": "# ------------------------------------------------------------------\n    # Frequency Properties/Methods",
                    "start_line": 1034,
                    "end_line": 1037
                },
                {
                    "snippet_code": "@freq.setter",
                    "start_line": 1044,
                    "end_line": 1045
                },
                {
                    "snippet_code": "@property  # NB: override with cache_readonly in immutable subclasses",
                    "start_line": 1062,
                    "end_line": 1062
                },
                {
                    "snippet_code": "@property  # NB: override with cache_readonly in immutable subclasses",
                    "start_line": 1075,
                    "end_line": 1076
                },
                {
                    "snippet_code": "@property  # NB: override with cache_readonly in immutable subclasses",
                    "start_line": 1079,
                    "end_line": 1080
                },
                {
                    "snippet_code": "@classmethod",
                    "start_line": 1086,
                    "end_line": 1087
                },
                {
                    "snippet_code": "# monotonicity/uniqueness properties are called via frequencies.infer_freq,\n    #  see GH#23789\n\n    @property",
                    "start_line": 1128,
                    "end_line": 1132
                },
                {
                    "snippet_code": "@property",
                    "start_line": 1135,
                    "end_line": 1136
                },
                {
                    "snippet_code": "@property",
                    "start_line": 1139,
                    "end_line": 1140
                },
                {
                    "snippet_code": "# ------------------------------------------------------------------\n    # Arithmetic Methods\n    _create_comparison_method = classmethod(_datetimelike_array_cmp)\n\n    # pow is invalid for all three subclasses; TimedeltaArray will override\n    #  the multiplication and division ops\n    __pow__ = make_invalid_op(\"__pow__\")\n    __rpow__ = make_invalid_op(\"__rpow__\")\n    __mul__ = make_invalid_op(\"__mul__\")\n    __rmul__ = make_invalid_op(\"__rmul__\")\n    __truediv__ = make_invalid_op(\"__truediv__\")\n    __rtruediv__ = make_invalid_op(\"__rtruediv__\")\n    __floordiv__ = make_invalid_op(\"__floordiv__\")\n    __rfloordiv__ = make_invalid_op(\"__rfloordiv__\")\n    __mod__ = make_invalid_op(\"__mod__\")\n    __rmod__ = make_invalid_op(\"__rmod__\")\n    __divmod__ = make_invalid_op(\"__divmod__\")\n    __rdivmod__ = make_invalid_op(\"__rdivmod__\")",
                    "start_line": 1143,
                    "end_line": 1162
                },
                {
                    "snippet_code": "_add_datetime_arraylike = _add_datetimelike_scalar",
                    "start_line": 1166,
                    "end_line": 1168
                },
                {
                    "snippet_code": "_sub_datetime_arraylike = _sub_datetimelike_scalar",
                    "start_line": 1173,
                    "end_line": 1175
                },
                {
                    "snippet_code": "@unpack_zerodim_and_defer(\"__add__\")",
                    "start_line": 1372,
                    "end_line": 1373
                },
                {
                    "snippet_code": "@unpack_zerodim_and_defer(\"__sub__\")",
                    "start_line": 1424,
                    "end_line": 1425
                },
                {
                    "snippet_code": "# --------------------------------------------------------------\n    # Reductions",
                    "start_line": 1528,
                    "end_line": 1531
                },
                {
                    "snippet_code": "DatetimeLikeArrayMixin._add_comparison_ops()\n\n# -------------------------------------------------------------------\n# Shared Constructor Helpers",
                    "start_line": 1639,
                    "end_line": 1646
                }
            ],
            "inscope_functions": [
                "def _datetimelike_array_cmp(cls, op):\n    \"\"\"\n    Wrap comparison operations to convert Timestamp/Timedelta/Period-like to\n    boxed scalars/arrays.\n    \"\"\"\n    opname = f\"__{op.__name__}__\"\n    nat_result = opname == \"__ne__\"\n\n    class InvalidComparison(Exception):\n        pass\n\n    def _validate_comparison_value(self, other):\n        if isinstance(other, str):\n            try:\n                # GH#18435 strings get a pass from tzawareness compat\n                other = self._scalar_from_string(other)\n            except ValueError:\n                # failed to parse as Timestamp/Timedelta/Period\n                raise InvalidComparison(other)\n\n        if isinstance(other, self._recognized_scalars) or other is NaT:\n            other = self._scalar_type(other)\n            self._check_compatible_with(other)\n\n        elif not is_list_like(other):\n            raise InvalidComparison(other)\n\n        elif len(other) != len(self):\n            raise ValueError(\"Lengths must match\")\n\n        else:\n            if isinstance(other, list):\n                # TODO: could use pd.Index to do inference?\n                other = np.array(other)\n\n            if not isinstance(other, (np.ndarray, type(self))):\n                raise InvalidComparison(other)\n\n            elif is_object_dtype(other.dtype):\n                pass\n\n            elif not type(self)._is_recognized_dtype(other.dtype):\n                raise InvalidComparison(other)\n\n            else:\n                # For PeriodDType this casting is unnecessary\n                # TODO: use Index to do inference?\n                other = type(self)._from_sequence(other)\n                self._check_compatible_with(other)\n\n        return other\n\n    @unpack_zerodim_and_defer(opname)\n    def wrapper(self, other):\n\n        try:\n            other = _validate_comparison_value(self, other)\n        except InvalidComparison:\n            return invalid_comparison(self, other, op)\n\n        dtype = getattr(other, \"dtype\", None)\n        if is_object_dtype(dtype):\n            # We have to use comp_method_OBJECT_ARRAY instead of numpy\n            #  comparison otherwise it would fail to raise when\n            #  comparing tz-aware and tz-naive\n            with np.errstate(all=\"ignore\"):\n                result = ops.comp_method_OBJECT_ARRAY(op, self.astype(object), other)\n            return result\n\n        if isinstance(other, self._scalar_type) or other is NaT:\n            other_i8 = self._unbox_scalar(other)\n        else:\n            # Then type(other) == type(self)\n            other_i8 = other.asi8\n\n        result = op(self.asi8, other_i8)\n\n        o_mask = isna(other)\n        if self._hasnans | np.any(o_mask):\n            result[self._isnan | o_mask] = nat_result\n\n        return result\n\n    return set_function_name(wrapper, opname, cls)",
                "def validate_periods(periods):\n    \"\"\"\n    If a `periods` argument is passed to the Datetime/Timedelta Array/Index\n    constructor, cast it to an integer.\n\n    Parameters\n    ----------\n    periods : None, float, int\n\n    Returns\n    -------\n    periods : None or int\n\n    Raises\n    ------\n    TypeError\n        if periods is None, float, or int\n    \"\"\"\n    if periods is not None:\n        if lib.is_float(periods):\n            periods = int(periods)\n        elif not lib.is_integer(periods):\n            raise TypeError(f\"periods must be a number, got {periods}\")\n    return periods",
                "def validate_endpoints(closed):\n    \"\"\"\n    Check that the `closed` argument is among [None, \"left\", \"right\"]\n\n    Parameters\n    ----------\n    closed : {None, \"left\", \"right\"}\n\n    Returns\n    -------\n    left_closed : bool\n    right_closed : bool\n\n    Raises\n    ------\n    ValueError : if argument is not among valid values\n    \"\"\"\n    left_closed = False\n    right_closed = False\n\n    if closed is None:\n        left_closed = True\n        right_closed = True\n    elif closed == \"left\":\n        left_closed = True\n    elif closed == \"right\":\n        right_closed = True\n    else:\n        raise ValueError(\"Closed has to be either 'left', 'right' or None\")\n\n    return left_closed, right_closed",
                "def validate_inferred_freq(freq, inferred_freq, freq_infer):\n    \"\"\"\n    If the user passes a freq and another freq is inferred from passed data,\n    require that they match.\n\n    Parameters\n    ----------\n    freq : DateOffset or None\n    inferred_freq : DateOffset or None\n    freq_infer : bool\n\n    Returns\n    -------\n    freq : DateOffset or None\n    freq_infer : bool\n\n    Notes\n    -----\n    We assume at this point that `maybe_infer_freq` has been called, so\n    `freq` is either a DateOffset object or None.\n    \"\"\"\n    if inferred_freq is not None:\n        if freq is not None and freq != inferred_freq:\n            raise ValueError(\n                f\"Inferred frequency {inferred_freq} from passed \"\n                \"values does not conform to passed frequency \"\n                f\"{freq.freqstr}\"\n            )\n        elif freq is None:\n            freq = inferred_freq\n        freq_infer = False\n\n    return freq, freq_infer",
                "def maybe_infer_freq(freq):\n    \"\"\"\n    Comparing a DateOffset to the string \"infer\" raises, so we need to\n    be careful about comparisons.  Make a dummy variable `freq_infer` to\n    signify the case where the given freq is \"infer\" and set freq to None\n    to avoid comparison trouble later on.\n\n    Parameters\n    ----------\n    freq : {DateOffset, None, str}\n\n    Returns\n    -------\n    freq : {DateOffset, None}\n    freq_infer : bool\n        Whether we should inherit the freq of passed data.\n    \"\"\"\n    freq_infer = False\n    if not isinstance(freq, DateOffset):\n        # if a passed freq is None, don't infer automatically\n        if freq != \"infer\":\n            freq = frequencies.to_offset(freq)\n        else:\n            freq_infer = True\n            freq = None\n    return freq, freq_infer",
                "def _validate_comparison_value(self, other):\n    if isinstance(other, str):\n        try:\n            # GH#18435 strings get a pass from tzawareness compat\n            other = self._scalar_from_string(other)\n        except ValueError:\n            # failed to parse as Timestamp/Timedelta/Period\n            raise InvalidComparison(other)\n\n    if isinstance(other, self._recognized_scalars) or other is NaT:\n        other = self._scalar_type(other)\n        self._check_compatible_with(other)\n\n    elif not is_list_like(other):\n        raise InvalidComparison(other)\n\n    elif len(other) != len(self):\n        raise ValueError(\"Lengths must match\")\n\n    else:\n        if isinstance(other, list):\n            # TODO: could use pd.Index to do inference?\n            other = np.array(other)\n\n        if not isinstance(other, (np.ndarray, type(self))):\n            raise InvalidComparison(other)\n\n        elif is_object_dtype(other.dtype):\n            pass\n\n        elif not type(self)._is_recognized_dtype(other.dtype):\n            raise InvalidComparison(other)\n\n        else:\n            # For PeriodDType this casting is unnecessary\n            # TODO: use Index to do inference?\n            other = type(self)._from_sequence(other)\n            self._check_compatible_with(other)\n\n    return other",
                "@unpack_zerodim_and_defer(opname)\ndef wrapper(self, other):\n\n    try:\n        other = _validate_comparison_value(self, other)\n    except InvalidComparison:\n        return invalid_comparison(self, other, op)\n\n    dtype = getattr(other, \"dtype\", None)\n    if is_object_dtype(dtype):\n        # We have to use comp_method_OBJECT_ARRAY instead of numpy\n        #  comparison otherwise it would fail to raise when\n        #  comparing tz-aware and tz-naive\n        with np.errstate(all=\"ignore\"):\n            result = ops.comp_method_OBJECT_ARRAY(op, self.astype(object), other)\n        return result\n\n    if isinstance(other, self._scalar_type) or other is NaT:\n        other_i8 = self._unbox_scalar(other)\n    else:\n        # Then type(other) == type(self)\n        other_i8 = other.asi8\n\n    result = op(self.asi8, other_i8)\n\n    o_mask = isna(other)\n    if self._hasnans | np.any(o_mask):\n        result[self._isnan | o_mask] = nat_result\n\n    return result",
                "@classmethod\ndef _simple_new(cls, values: np.ndarray, **kwargs):\n    raise AbstractMethodError(cls)",
                "@property\ndef _scalar_type(self) -> Type[DatetimeLikeScalar]:\n    \"\"\"\n    The scalar associated with this datelike\n\n    * PeriodArray : Period\n    * DatetimeArray : Timestamp\n    * TimedeltaArray : Timedelta\n    \"\"\"\n    raise AbstractMethodError(self)",
                "def _scalar_from_string(\n    self, value: str\n) -> Union[Period, Timestamp, Timedelta, NaTType]:\n    \"\"\"\n    Construct a scalar type from a string.\n\n    Parameters\n    ----------\n    value : str\n\n    Returns\n    -------\n    Period, Timestamp, or Timedelta, or NaT\n        Whatever the type of ``self._scalar_type`` is.\n\n    Notes\n    -----\n    This should call ``self._check_compatible_with`` before\n    unboxing the result.\n    \"\"\"\n    raise AbstractMethodError(self)",
                "def _unbox_scalar(self, value: Union[Period, Timestamp, Timedelta, NaTType]) -> int:\n    \"\"\"\n    Unbox the integer value of a scalar `value`.\n\n    Parameters\n    ----------\n    value : Union[Period, Timestamp, Timedelta]\n\n    Returns\n    -------\n    int\n\n    Examples\n    --------\n    >>> self._unbox_scalar(Timedelta(\"10s\"))  # doctest: +SKIP\n    10000000000\n    \"\"\"\n    raise AbstractMethodError(self)",
                "def _check_compatible_with(\n    self, other: Union[Period, Timestamp, Timedelta, NaTType], setitem: bool = False\n) -> None:\n    \"\"\"\n    Verify that `self` and `other` are compatible.\n\n    * DatetimeArray verifies that the timezones (if any) match\n    * PeriodArray verifies that the freq matches\n    * Timedelta has no verification\n\n    In each case, NaT is considered compatible.\n\n    Parameters\n    ----------\n    other\n    setitem : bool, default False\n        For __setitem__ we may have stricter compatibility resrictions than\n        for comparisons.\n\n    Raises\n    ------\n    Exception\n    \"\"\"\n    raise AbstractMethodError(self)",
                "@Substitution(\n    URL=\"https://docs.python.org/3/library/datetime.html\"\n    \"#strftime-and-strptime-behavior\"\n)\ndef strftime(self, date_format):\n    \"\"\"\n    Convert to Index using specified date_format.\n\n    Return an Index of formatted strings specified by date_format, which\n    supports the same string format as the python standard library. Details\n    of the string format can be found in `python string format\n    doc <%(URL)s>`__.\n\n    Parameters\n    ----------\n    date_format : str\n        Date format string (e.g. \"%%Y-%%m-%%d\").\n\n    Returns\n    -------\n    ndarray\n        NumPy ndarray of formatted strings.\n\n    See Also\n    --------\n    to_datetime : Convert the given argument to datetime.\n    DatetimeIndex.normalize : Return DatetimeIndex with times to midnight.\n    DatetimeIndex.round : Round the DatetimeIndex to the specified freq.\n    DatetimeIndex.floor : Floor the DatetimeIndex to the specified freq.\n\n    Examples\n    --------\n    >>> rng = pd.date_range(pd.Timestamp(\"2018-03-10 09:00\"),\n    ...                     periods=3, freq='s')\n    >>> rng.strftime('%%B %%d, %%Y, %%r')\n    Index(['March 10, 2018, 09:00:00 AM', 'March 10, 2018, 09:00:01 AM',\n           'March 10, 2018, 09:00:02 AM'],\n          dtype='object')\n    \"\"\"\n    result = self._format_native_types(date_format=date_format, na_rep=np.nan)\n    return result.astype(object)",
                "def _round(self, freq, mode, ambiguous, nonexistent):\n    # round the local times\n    if is_datetime64tz_dtype(self):\n        # operate on naive timestamps, then convert back to aware\n        naive = self.tz_localize(None)\n        result = naive._round(freq, mode, ambiguous, nonexistent)\n        aware = result.tz_localize(\n            self.tz, ambiguous=ambiguous, nonexistent=nonexistent\n        )\n        return aware\n\n    values = self.view(\"i8\")\n    result = round_nsint64(values, mode, freq)\n    result = self._maybe_mask_results(result, fill_value=NaT)\n    return self._simple_new(result, dtype=self.dtype)",
                "@Appender((_round_doc + _round_example).format(op=\"round\"))\ndef round(self, freq, ambiguous=\"raise\", nonexistent=\"raise\"):\n    return self._round(freq, RoundTo.NEAREST_HALF_EVEN, ambiguous, nonexistent)",
                "@Appender((_round_doc + _floor_example).format(op=\"floor\"))\ndef floor(self, freq, ambiguous=\"raise\", nonexistent=\"raise\"):\n    return self._round(freq, RoundTo.MINUS_INFTY, ambiguous, nonexistent)",
                "@Appender((_round_doc + _ceil_example).format(op=\"ceil\"))\ndef ceil(self, freq, ambiguous=\"raise\", nonexistent=\"raise\"):\n    return self._round(freq, RoundTo.PLUS_INFTY, ambiguous, nonexistent)",
                "def _with_freq(self, freq):\n    \"\"\"\n    Helper to set our freq in-place, returning self to allow method chaining.\n\n    Parameters\n    ----------\n    freq : DateOffset, None, or \"infer\"\n\n    Returns\n    -------\n    self\n    \"\"\"\n    # GH#29843\n    if freq is None:\n        # Always valid\n        pass\n    elif len(self) == 0 and isinstance(freq, DateOffset):\n        # Always valid.  In the TimedeltaArray case, we assume this\n        #  is a Tick offset.\n        pass\n    else:\n        # As an internal method, we can ensure this assertion always holds\n        assert freq == \"infer\"\n        freq = frequencies.to_offset(self.inferred_freq)\n\n    self._freq = freq\n    return self",
                "@property\ndef _ndarray(self) -> np.ndarray:\n    # NB: A bunch of Interval tests fail if we use ._data\n    return self.asi8",
                "def _from_backing_data(self: _T, arr: np.ndarray) -> _T:\n    # Note: we do not retain `freq`\n    return type(self)(arr, dtype=self.dtype)  # type: ignore",
                "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    # do not cache or you'll create a memory leak\n    return self._data.view(\"i8\")",
                "def _format_native_types(self, na_rep=\"NaT\", date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                "def _formatter(self, boxed=False):\n    # TODO: Remove Datetime & DatetimeTZ formatters.\n    return \"'{}'\".format",
                "def __array__(self, dtype=None) -> np.ndarray:\n    # used for Timedelta/DatetimeArray, overwritten by PeriodArray\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n\n    if com.is_bool_indexer(key):\n        # first convert to boolean, because check_array_indexer doesn't\n        # allow object dtype\n        if is_object_dtype(key):\n            key = np.asarray(key, dtype=bool)\n\n        key = check_array_indexer(self, key)\n        key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    elif isinstance(key, list) and len(key) == 1 and isinstance(key[0], slice):\n        # see https://github.com/pandas-dev/pandas/issues/31299, need to allow\n        # this for now (would otherwise raise in check_array_indexer)\n        pass\n    else:\n        key = check_array_indexer(self, key)\n\n    freq = self._get_getitem_freq(key)\n    result = self._data[key]\n    if lib.is_scalar(result):\n        return self._box_func(result)\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                "def _get_getitem_freq(self, key):\n    \"\"\"\n    Find the `freq` attribute to assign to the result of a __getitem__ lookup.\n    \"\"\"\n    is_period = is_period_dtype(self.dtype)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            # GH#21282 indexing with Ellipsis is similar to a full slice,\n            #  should preserve `freq` attribute\n            freq = self.freq\n    return freq",
                "def __setitem__(\n    self,\n    key: Union[int, Sequence[int], Sequence[bool], slice],\n    value: Union[NaTType, Any, Sequence[Any]],\n) -> None:\n    # I'm fudging the types a bit here. \"Any\" above really depends\n    # on type(self). For PeriodArray, it's Period (or stuff coercible\n    # to a period in from_sequence). For DatetimeArray, it's Timestamp...\n    # I don't know if mypy can do that, possibly with Generics.\n    # https://mypy.readthedocs.io/en/latest/generics.html\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n\n        if lib.is_scalar(key):\n            raise ValueError(\"setting an array element with a sequence.\")\n\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and not com.is_bool_indexer(key):\n                msg = (\n                    f\"shape mismatch: value array of length '{len(key)}' \"\n                    \"does not match indexing result of length \"\n                    f\"'{len(value)}'.\"\n                )\n                raise ValueError(msg)\n            elif not len(key):\n                return\n\n    value = self._validate_setitem_value(value)\n    key = check_array_indexer(self, key)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                "def _maybe_clear_freq(self):\n    # inplace operations like __setitem__ may invalidate the freq of\n    # DatetimeArray and TimedeltaArray\n    pass",
                "def astype(self, dtype, copy=True):\n    # Some notes on cases we don't have to handle here in the base class:\n    #   1. PeriodArray.astype handles period -> period\n    #   2. DatetimeArray.astype handles conversion between tz.\n    #   3. DatetimeArray.astype handles datetime -> period\n    dtype = pandas_dtype(dtype)\n\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8.ravel()).reshape(self.shape)\n    elif is_string_dtype(dtype) and not is_categorical_dtype(dtype):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        # we deliberately ignore int32 vs. int64 here.\n        # See https://github.com/pandas-dev/pandas/issues/24381 for more.\n        values = self.asi8\n\n        if is_unsigned_integer_dtype(dtype):\n            # Again, we ignore int32 vs. int64\n            values = values.view(\"uint64\")\n\n        if copy:\n            values = values.copy()\n        return values\n    elif (\n        is_datetime_or_timedelta_dtype(dtype)\n        and not is_dtype_equal(self.dtype, dtype)\n    ) or is_float_dtype(dtype):\n        # disallow conversion between datetime/timedelta,\n        # and conversions for any datetimelike to float\n        msg = f\"Cannot cast {type(self).__name__} to dtype {dtype}\"\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        arr_cls = dtype.construct_array_type()\n        return arr_cls(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                "@classmethod\ndef _concat_same_type(cls, to_concat, axis: int = 0):\n\n    # do not pass tz to set because tzlocal cannot be hashed\n    dtypes = {str(x.dtype) for x in to_concat}\n    if len(dtypes) != 1:\n        raise ValueError(\"to_concat must have the same dtype (tz)\", dtypes)\n\n    obj = to_concat[0]\n    dtype = obj.dtype\n\n    i8values = [x.asi8 for x in to_concat]\n    values = np.concatenate(i8values, axis=axis)\n\n    new_freq = None\n    if is_period_dtype(dtype):\n        new_freq = obj.freq\n    elif axis == 0:\n        # GH 3232: If the concat result is evenly spaced, we can retain the\n        # original frequency\n        to_concat = [x for x in to_concat if len(x)]\n\n        if obj.freq is not None and all(x.freq == obj.freq for x in to_concat):\n            pairs = zip(to_concat[:-1], to_concat[1:])\n            if all(pair[0][-1] + obj.freq == pair[1][0] for pair in pairs):\n                new_freq = obj.freq\n\n    return cls._simple_new(values, dtype=dtype, freq=new_freq)",
                "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                "def _values_for_factorize(self):\n    return self.asi8, iNaT",
                "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                "def _values_for_argsort(self):\n    return self._data",
                "@Appender(ExtensionArray.shift.__doc__)\ndef shift(self, periods=1, fill_value=None, axis=0):\n    if not self.size or periods == 0:\n        return self.copy()\n\n    fill_value = self._validate_shift_value(fill_value)\n    new_values = shift(self._data, periods, axis, fill_value)\n\n    return type(self)._simple_new(new_values, dtype=self.dtype)",
                "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(\n            f\"'fill_value' should be a {self._scalar_type}. \"\n            f\"Got '{str(fill_value)}'.\"\n        )\n    return fill_value",
                "def _validate_shift_value(self, fill_value):\n    # TODO(2.0): once this deprecation is enforced, used _validate_fill_value\n    if is_valid_nat_for_dtype(fill_value, self.dtype):\n        fill_value = NaT\n    elif not isinstance(fill_value, self._recognized_scalars):\n        # only warn if we're not going to raise\n        if self._scalar_type is Period and lib.is_integer(fill_value):\n            # kludge for #31971 since Period(integer) tries to cast to str\n            new_fill = Period._from_ordinal(fill_value, freq=self.freq)\n        else:\n            new_fill = self._scalar_type(fill_value)\n\n        # stacklevel here is chosen to be correct when called from\n        #  DataFrame.shift or Series.shift\n        warnings.warn(\n            f\"Passing {type(fill_value)} to shift is deprecated and \"\n            \"will raise in a future version, pass \"\n            f\"{self._scalar_type.__name__} instead.\",\n            FutureWarning,\n            stacklevel=10,\n        )\n        fill_value = new_fill\n\n    fill_value = self._unbox_scalar(fill_value)\n    return fill_value",
                "def _validate_searchsorted_value(self, value):\n    if isinstance(value, str):\n        try:\n            value = self._scalar_from_string(value)\n        except ValueError as err:\n            raise TypeError(\n                \"searchsorted requires compatible dtype or scalar\"\n            ) from err\n\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = NaT\n\n    elif isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n\n    elif is_list_like(value) and not isinstance(value, type(self)):\n        value = array(value)\n\n        if not type(self)._is_recognized_dtype(value):\n            raise TypeError(\n                \"searchsorted requires compatible dtype or scalar, \"\n                f\"not {type(value).__name__}\"\n            )\n\n    if not (isinstance(value, (self._scalar_type, type(self))) or (value is NaT)):\n        raise TypeError(f\"Unexpected type for 'value': {type(value)}\")\n\n    if isinstance(value, type(self)):\n        self._check_compatible_with(value)\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n\n    return value",
                "def _validate_setitem_value(self, value):\n    if lib.is_scalar(value) and not isna(value):\n        value = com.maybe_box_datetimelike(value)\n\n    if is_list_like(value):\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = (\n            f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', \"\n            f\"or array of those. Got '{type(value).__name__}' instead.\"\n        )\n        raise TypeError(msg)\n\n    return value",
                "def _validate_insert_value(self, value):\n    if isinstance(value, self._recognized_scalars):\n        value = self._scalar_type(value)\n        self._check_compatible_with(value, setitem=True)\n        # TODO: if we dont have compat, should we raise or astype(object)?\n        #  PeriodIndex does astype(object)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        # GH#18295\n        value = NaT\n    else:\n        raise TypeError(\n            f\"cannot insert {type(self).__name__} with incompatible label\"\n        )\n\n    return value",
                "def _validate_where_value(self, other):\n    if is_valid_nat_for_dtype(other, self.dtype):\n        other = NaT\n    elif isinstance(other, self._recognized_scalars):\n        other = self._scalar_type(other)\n        self._check_compatible_with(other, setitem=True)\n    elif not is_list_like(other):\n        raise TypeError(f\"Where requires matching dtype, not {type(other)}\")\n\n    else:\n        # Do type inference if necessary up front\n        # e.g. we passed PeriodIndex.values and got an ndarray of Periods\n        other = array(other)\n        other = extract_array(other, extract_numpy=True)\n\n        if is_categorical_dtype(other.dtype):\n            # e.g. we have a Categorical holding self.dtype\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n\n        if not type(self)._is_recognized_dtype(other.dtype):\n            raise TypeError(f\"Where requires matching dtype, not {other.dtype}\")\n        self._check_compatible_with(other, setitem=True)\n\n    if lib.is_scalar(other):\n        other = self._unbox_scalar(other)\n    else:\n        other = other.view(\"i8\")\n\n    return other",
                "def searchsorted(self, value, side=\"left\", sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    value = self._validate_searchsorted_value(value)\n\n    # TODO: Use datetime64 semantics for sorting, xref GH#29844\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n\n    cls = type(self)\n\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(\n        cls(result.index.view(\"i8\"), dtype=self.dtype), name=result.index.name\n    )\n    return Series(result._values, index=index, name=result.name)",
                "def map(self, mapper):\n    # TODO(GH-23179): Add ExtensionArray.map\n    # Need to figure out if we want ExtensionArray.map first.\n    # If so, then we can refactor IndexOpsMixin._map_values to\n    # a standalone function and call from here..\n    # Else, just rewrite _map_infer_values to do the right thing.\n    from pandas import Index\n\n    return Index(self).map(mapper).array",
                "def isna(self):\n    return self._isnan",
                "@property  # NB: override with cache_readonly in immutable subclasses\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                "@property  # NB: override with cache_readonly in immutable subclasses\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                "def fillna(self, value=None, method=None, limit=None):\n    # TODO(GH-20300): remove this\n    # Just overriding to ensure that we avoid an astype(object).\n    # Either 20300 or a `_values_for_fillna` would avoid this duplication.\n    if isinstance(value, ABCSeries):\n        value = value.array\n\n    value, method = validate_fillna_kwargs(value, method)\n\n    mask = self.isna()\n\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(\n                f\"Length of 'value' does not match. Got ({len(value)}) \"\n                f\" expected {len(self)}\"\n            )\n        value = value[mask]\n\n    if mask.any():\n        if method is not None:\n            if method == \"pad\":\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n\n            values = self._data\n            if not is_period_dtype(self):\n                # For PeriodArray self._data is i8, which gets copied\n                #  by `func`.  Otherwise we need to make a copy manually\n                # to avoid modifying `self` in-place.\n                values = values.copy()\n\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                # we need to pass int64 values to the constructor to avoid\n                #  re-localizing incorrectly\n                new_values = new_values.view(\"i8\")\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            # fill with value\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n\n    self._freq = value",
                "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None.\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                "@property  # NB: override with cache_readonly in immutable subclasses\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                "@property  # NB: override with cache_readonly in immutable subclasses\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                "@property  # NB: override with cache_readonly in immutable subclasses\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        # Frequency validation is not meaningful for Period Array/Index\n        return None\n\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n\n    try:\n        on_freq = cls._generate_range(\n            start=index[0], end=None, periods=len(index), freq=freq, **kwargs\n        )\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if \"non-fixed\" in str(e):\n            # non-fixed frequencies are not meaningful for timedelta64;\n            #  we retain that error message\n            raise e\n        # GH#11587 the main way this is reached is if the `np.array_equal`\n        #  check above is False.  This can also be reached if index[0]\n        #  is `NaT`, in which case the call to `cls._generate_range` will\n        #  raise a ValueError, which we re-raise with a more targeted\n        #  message.\n        raise ValueError(\n            f\"Inferred frequency {inferred} from passed values \"\n            f\"does not conform to passed frequency {freq.freqstr}\"\n        ) from e",
                "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                "def _add_datetimelike_scalar(self, other):\n    # Overridden by TimedeltaArray\n    raise TypeError(f\"cannot add {type(self).__name__} and {type(other).__name__}\")",
                "def _sub_datetimelike_scalar(self, other):\n    # Overridden by DatetimeArray\n    assert other is not NaT\n    raise TypeError(f\"cannot subtract a datelike from a {type(self).__name__}\")",
                "def _sub_period(self, other):\n    # Overridden by PeriodArray\n    raise TypeError(f\"cannot subtract Period from a {type(self).__name__}\")",
                "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    if isna(other):\n        # i.e np.timedelta64(\"NaT\"), not recognized by delta_to_nanoseconds\n        new_values = np.empty(self.shape, dtype=\"i8\")\n        new_values[:] = iNaT\n        return type(self)(new_values, dtype=self.dtype)\n\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view(\n        \"i8\"\n    )\n    new_values = self._maybe_mask_results(new_values)\n\n    new_freq = None\n    if isinstance(self.freq, Tick) or is_period_dtype(self.dtype):\n        # adding a scalar preserves freq\n        new_freq = self.freq\n\n    return type(self)(new_values, dtype=self.dtype, freq=new_freq)",
                "def _add_timedelta_arraylike(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n\n    Returns\n    -------\n    Same type as self\n    \"\"\"\n    # overridden by PeriodArray\n\n    if len(self) != len(other):\n        raise ValueError(\"cannot add indices of unequal length\")\n\n    if isinstance(other, np.ndarray):\n        # ndarray[timedelta64]; wrap in TimedeltaIndex for op\n        from pandas.core.arrays import TimedeltaArray\n\n        other = TimedeltaArray._from_sequence(other)\n\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(\n        self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan\n    )\n    if self._hasnans or other._hasnans:\n        mask = (self._isnan) | (other._isnan)\n        new_values[mask] = iNaT\n\n    return type(self)(new_values, dtype=self.dtype)",
                "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(\n            f\"Cannot add {type(self).__name__} and {type(NaT).__name__}\"\n        )\n\n    # GH#19124 pd.NaT is treated like a timedelta for both timedelta\n    # and datetime dtypes\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    # GH#19124 Timedelta - datetime is not in general well-defined.\n    # We make an exception for pd.NaT, which in this case quacks\n    # like a timedelta.\n    # For datetime64 dtypes by convention we treat NaT as a datetime, so\n    # this subtraction returns a timedelta64 dtype.\n    # For period dtype, timedelta64 is a close-enough return dtype.\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view(\"timedelta64[ns]\")",
                "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(\n            f\"cannot subtract {other.dtype}-dtype from {type(self).__name__}\"\n        )\n\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(\n            cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr\n        )\n        raise IncompatibleFrequency(msg)\n\n    new_values = checked_add_with_arr(\n        self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan\n    )\n\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = (self._isnan) | (other._isnan)\n        new_values[mask] = NaT\n    return new_values",
                "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n\n    warnings.warn(\n        \"Adding/subtracting array of DateOffsets to \"\n        f\"{type(self).__name__} not vectorized\",\n        PerformanceWarning,\n    )\n\n    # Caller is responsible for broadcasting if necessary\n    assert self.shape == other.shape, (self.shape, other.shape)\n\n    res_values = op(self.astype(\"O\"), np.array(other))\n    result = array(res_values.ravel())\n    result = extract_array(result, extract_numpy=True).reshape(self.shape)\n    return result",
                "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n\n    if periods == 0:\n        # immutable so OK\n        return self.copy()\n\n    if self.freq is None:\n        raise NullFrequencyError(\"Cannot shift with no freq\")\n\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n\n    # Note: in the DatetimeTZ case, _generate_range will infer the\n    #  appropriate timezone from `start` and `end`, so tz does not need\n    #  to be passed explicitly.\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                "@unpack_zerodim_and_defer(\"__add__\")\ndef __add__(self, other):\n\n    # scalar others\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(other)\n    elif isinstance(other, DateOffset):\n        # specifically _not_ a Tick\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        # This check must come after the check for np.timedelta64\n        # as is_integer returns True for these\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n\n    # array-like others\n    elif is_timedelta64_dtype(other):\n        # TimedeltaIndex, ndarray[timedelta64]\n        result = self._add_timedelta_arraylike(other)\n    elif is_object_dtype(other):\n        # e.g. Array/Index of DateOffset objects\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        # DatetimeIndex, ndarray[datetime64]\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        # Includes Categorical, other ExtensionArrays\n        # For PeriodDtype, if self is a TimedeltaArray and other is a\n        #  PeriodArray with  a timedelta-like (i.e. Tick) freq, this\n        #  operation is valid.  Defer to the PeriodArray implementation.\n        #  In remaining cases, this will end up raising TypeError.\n        return NotImplemented\n\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n\n        return TimedeltaArray(result)\n    return result",
                "def __radd__(self, other):\n    # alias for __add__\n    return self.__add__(other)",
                "@unpack_zerodim_and_defer(\"__sub__\")\ndef __sub__(self, other):\n\n    # scalar others\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_timedeltalike_scalar(-other)\n    elif isinstance(other, DateOffset):\n        # specifically _not_ a Tick\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        # This check must come after the check for np.timedelta64\n        # as is_integer returns True for these\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n\n    # array-like others\n    elif is_timedelta64_dtype(other):\n        # TimedeltaIndex, ndarray[timedelta64]\n        result = self._add_timedelta_arraylike(-other)\n    elif is_object_dtype(other):\n        # e.g. Array/Index of DateOffset objects\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        # DatetimeIndex, ndarray[datetime64]\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        # PeriodIndex\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        # Includes ExtensionArrays, float_dtype\n        return NotImplemented\n\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n\n        return TimedeltaArray(result)\n    return result",
                "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        # ndarray[datetime64] cannot be subtracted from self, so\n        # we need to wrap in DatetimeArray/Index and flip the operation\n        if lib.is_scalar(other):\n            # i.e. np.datetime64 object\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            # Avoid down-casting DatetimeIndex\n            from pandas.core.arrays import DatetimeArray\n\n            other = DatetimeArray(other)\n        return other - self\n    elif (\n        is_datetime64_any_dtype(self.dtype)\n        and hasattr(other, \"dtype\")\n        and not is_datetime64_any_dtype(other.dtype)\n    ):\n        # GH#19959 datetime - datetime is well-defined as timedelta,\n        # but any other type - datetime is not well-defined.\n        raise TypeError(\n            f\"cannot subtract {type(self).__name__} from {type(other).__name__}\"\n        )\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        # TODO: Can we simplify/generalize these cases at all?\n        raise TypeError(f\"cannot subtract {type(self).__name__} from {other.dtype}\")\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            # need to subtract before negating, since that flips freq\n            # -self flips self.freq, messing up results\n            return -(self - other)\n\n        return (-self) + other\n\n    return -(self - other)",
                "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n\n    if not is_period_dtype(self):\n        # restore freq, which is invalidated by setitem\n        self._freq = result._freq\n    return self",
                "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n\n    if not is_period_dtype(self):\n        # restore freq, which is invalidated by setitem\n        self._freq = result._freq\n    return self",
                "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        # Period._from_ordinal does not handle np.nan gracefully\n        return NaT\n    return self._box_func(result)",
                "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    # TODO: skipna is broken with max.\n    # See https://github.com/pandas-dev/pandas/issues/24265\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n\n    if not len(values):\n        # short-circuit for empty max / min\n        return NaT\n\n    result = nanops.nanmax(values, skipna=skipna)\n    # Don't have to worry about NA `result`, since no NA went in.\n    return self._box_func(result)",
                "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        # See discussion in GH#24757\n        raise TypeError(\n            f\"mean is not implemented for {type(self).__name__} since the \"\n            \"meaning is ambiguous.  An alternative is \"\n            \"obj.to_timestamp(how='start').mean()\"\n        )\n\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n\n    if not len(values):\n        # short-circuit for empty max / min\n        return NaT\n\n    result = nanops.nanmean(values.view(\"i8\"), skipna=skipna)\n    # Don't have to worry about NA `result`, since no NA went in.\n    return self._box_func(result)"
            ],
            "inscope_function_signatures": [
                "_datetimelike_array_cmp(cls, op)",
                "validate_periods(periods)",
                "validate_endpoints(closed)",
                "validate_inferred_freq(freq, inferred_freq, freq_infer)",
                "maybe_infer_freq(freq)",
                "_validate_comparison_value(self, other)",
                "wrapper(self, other)",
                "_simple_new(cls, values: np.ndarray, **kwargs)",
                "_scalar_type(self) -> Type[DatetimeLikeScalar]",
                "_scalar_from_string(self, value: str) -> Union[Period, Timestamp, Timedelta, NaTType]",
                "_unbox_scalar(self, value: Union[Period, Timestamp, Timedelta, NaTType]) -> int",
                "_check_compatible_with(self, other: Union[Period, Timestamp, Timedelta, NaTType], setitem: bool=False) -> None",
                "strftime(self, date_format)",
                "_round(self, freq, mode, ambiguous, nonexistent)",
                "round(self, freq, ambiguous='raise', nonexistent='raise')",
                "floor(self, freq, ambiguous='raise', nonexistent='raise')",
                "ceil(self, freq, ambiguous='raise', nonexistent='raise')",
                "_with_freq(self, freq)",
                "_ndarray(self) -> np.ndarray",
                "_from_backing_data(self: _T, arr: np.ndarray) -> _T",
                "_box_func(self)",
                "_box_values(self, values)",
                "__iter__(self)",
                "asi8(self) -> np.ndarray",
                "_format_native_types(self, na_rep='NaT', date_format=None)",
                "_formatter(self, boxed=False)",
                "__array__(self, dtype=None) -> np.ndarray",
                "__getitem__(self, key)",
                "_get_getitem_freq(self, key)",
                "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                "_maybe_clear_freq(self)",
                "astype(self, dtype, copy=True)",
                "view(self, dtype=None)",
                "_concat_same_type(cls, to_concat, axis: int=0)",
                "copy(self)",
                "_values_for_factorize(self)",
                "_from_factorized(cls, values, original)",
                "_values_for_argsort(self)",
                "shift(self, periods=1, fill_value=None, axis=0)",
                "_validate_fill_value(self, fill_value)",
                "_validate_shift_value(self, fill_value)",
                "_validate_searchsorted_value(self, value)",
                "_validate_setitem_value(self, value)",
                "_validate_insert_value(self, value)",
                "_validate_where_value(self, other)",
                "searchsorted(self, value, side='left', sorter=None)",
                "value_counts(self, dropna=False)",
                "map(self, mapper)",
                "isna(self)",
                "_isnan(self)",
                "_hasnans(self)",
                "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                "fillna(self, value=None, method=None, limit=None)",
                "freq(self)",
                "freq(self, value)",
                "freqstr(self)",
                "inferred_freq(self)",
                "_resolution(self)",
                "resolution(self)",
                "_validate_frequency(cls, index, freq, **kwargs)",
                "_is_monotonic_increasing(self)",
                "_is_monotonic_decreasing(self)",
                "_is_unique(self)",
                "_add_datetimelike_scalar(self, other)",
                "_sub_datetimelike_scalar(self, other)",
                "_sub_period(self, other)",
                "_add_offset(self, offset)",
                "_add_timedeltalike_scalar(self, other)",
                "_add_timedelta_arraylike(self, other)",
                "_add_nat(self)",
                "_sub_nat(self)",
                "_sub_period_array(self, other)",
                "_addsub_object_array(self, other: np.ndarray, op)",
                "_time_shift(self, periods, freq=None)",
                "__add__(self, other)",
                "__radd__(self, other)",
                "__sub__(self, other)",
                "__rsub__(self, other)",
                "__iadd__(self, other)",
                "__isub__(self, other)",
                "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                "min(self, axis=None, skipna=True, *args, **kwargs)",
                "max(self, axis=None, skipna=True, *args, **kwargs)",
                "mean(self, skipna=True)"
            ],
            "variables_in_file": {
                "opname": [
                    139,
                    108,
                    61,
                    62
                ],
                "op.__name__": [
                    61
                ],
                "op": [
                    1533,
                    131,
                    1318,
                    1320,
                    114,
                    1331,
                    122,
                    61,
                    1534,
                    1535
                ],
                "nat_result": [
                    62,
                    135
                ],
                "Exception": [
                    64
                ],
                "isinstance": [
                    1415,
                    778,
                    781,
                    790,
                    1431,
                    793,
                    537,
                    1433,
                    1436,
                    1445,
                    809,
                    427,
                    559,
                    1204,
                    824,
                    1469,
                    68,
                    581,
                    1223,
                    1352,
                    842,
                    1482,
                    76,
                    87,
                    729,
                    91,
                    1759,
                    992,
                    1379,
                    1381,
                    744,
                    1384,
                    125,
                    767
                ],
                "other": [
                    68,
                    71,
                    74,
                    76,
                    77,
                    78,
                    80,
                    81,
                    83,
                    87,
                    89,
                    91,
                    92,
                    94,
                    97,
                    98,
                    103,
                    104,
                    106,
                    112,
                    114,
                    116,
                    122,
                    125,
                    126,
                    129,
                    133,
                    1165,
                    1171,
                    1191,
                    1197,
                    1220,
                    1223,
                    1227,
                    1230,
                    1232,
                    1234,
                    1235,
                    1286,
                    1289,
                    1291,
                    1296,
                    1300,
                    1301,
                    1319,
                    1320,
                    1329,
                    1331,
                    840,
                    841,
                    842,
                    843,
                    844,
                    845,
                    846,
                    851,
                    852,
                    854,
                    856,
                    857,
                    859,
                    860,
                    861,
                    863,
                    864,
                    1377,
                    866,
                    1379,
                    868,
                    1380,
                    1381,
                    1383,
                    1384,
                    1385,
                    1386,
                    1391,
                    1394,
                    1396,
                    1397,
                    1399,
                    1400,
                    1402,
                    1403,
                    1406,
                    1423,
                    1429,
                    1431,
                    1432,
                    1433,
                    1435,
                    1436,
                    1437,
                    1438,
                    1443,
                    1445,
                    1446,
                    1449,
                    1451,
                    1452,
                    1454,
                    1455,
                    1457,
                    1458,
                    1460,
                    1461,
                    1464,
                    1476,
                    1479,
                    1481,
                    1482,
                    1486,
                    1487,
                    1490,
                    1491,
                    1496,
                    1498,
                    1500,
                    1502,
                    1505,
                    1507,
                    1509,
                    1512,
                    1521
                ],
                "str": [
                    736,
                    161,
                    68,
                    1352,
                    657,
                    1115,
                    767
                ],
                "self._scalar_from_string": [
                    769,
                    71
                ],
                "self": [
                    1026,
                    1527,
                    1029,
                    520,
                    521,
                    1032,
                    1553,
                    1043,
                    1557,
                    535,
                    1049,
                    1051,
                    542,
                    544,
                    545,
                    1058,
                    547,
                    548,
                    1060,
                    1575,
                    1577,
                    554,
                    556,
                    1069,
                    1581,
                    560,
                    561,
                    1072,
                    563,
                    1589,
                    1078,
                    567,
                    1085,
                    71,
                    76,
                    77,
                    78,
                    1616,
                    83,
                    1619,
                    598,
                    599,
                    600,
                    601,
                    1624,
                    91,
                    1626,
                    1630,
                    97,
                    1638,
                    103,
                    104,
                    616,
                    618,
                    622,
                    1134,
                    112,
                    114,
                    1138,
                    1142,
                    633,
                    122,
                    637,
                    125,
                    126,
                    641,
                    131,
                    643,
                    134,
                    135,
                    646,
                    647,
                    648,
                    1165,
                    1172,
                    1178,
                    1181,
                    158,
                    1193,
                    683,
                    684,
                    1195,
                    1198,
                    687,
                    1201,
                    180,
                    1204,
                    694,
                    1206,
                    1208,
                    698,
                    699,
                    701,
                    702,
                    704,
                    1220,
                    199,
                    1229,
                    1232,
                    1234,
                    1235,
                    1238,
                    727,
                    729,
                    730,
                    731,
                    732,
                    1244,
                    1246,
                    735,
                    224,
                    1251,
                    1253,
                    742,
                    744,
                    746,
                    748,
                    750,
                    1265,
                    757,
                    763,
                    769,
                    1284,
                    1286,
                    775,
                    1289,
                    778,
                    779,
                    1291,
                    781,
                    271,
                    784,
                    1296,
                    1299,
                    1300,
                    1301,
                    790,
                    793,
                    794,
                    797,
                    806,
                    807,
                    1320,
                    809,
                    810,
                    811,
                    812,
                    1324,
                    816,
                    1329,
                    1331,
                    1333,
                    824,
                    825,
                    826,
                    829,
                    834,
                    1351,
                    840,
                    842,
                    843,
                    844,
                    1355,
                    1360,
                    1362,
                    1365,
                    1366,
                    856,
                    859,
                    1371,
                    861,
                    864,
                    1378,
                    1380,
                    1383,
                    1385,
                    1389,
                    1390,
                    1391,
                    1396,
                    1399,
                    1402,
                    1404,
                    1405,
                    1406,
                    385,
                    387,
                    900,
                    390,
                    903,
                    394,
                    396,
                    397,
                    1423,
                    401,
                    405,
                    1430,
                    1432,
                    409,
                    921,
                    923,
                    1435,
                    925,
                    1437,
                    929,
                    1441,
                    1442,
                    1443,
                    1446,
                    427,
                    1451,
                    941,
                    1454,
                    1457,
                    434,
                    947,
                    436,
                    437,
                    1460,
                    1462,
                    1463,
                    1464,
                    954,
                    961,
                    1476,
                    1481,
                    460,
                    1487,
                    464,
                    1489,
                    980,
                    1496,
                    473,
                    985,
                    1498,
                    1500,
                    1501,
                    479,
                    1505,
                    482,
                    1507,
                    997,
                    1509,
                    1000,
                    1512,
                    1513,
                    1003,
                    1515,
                    1517,
                    1518,
                    495,
                    1521,
                    1522,
                    1524,
                    1014,
                    1015,
                    1526,
                    508,
                    1533,
                    1022
                ],
                "ValueError": [
                    1729,
                    770,
                    1124,
                    1221,
                    1701,
                    72,
                    584,
                    1001,
                    1073,
                    594,
                    659,
                    84,
                    1113,
                    1114,
                    734
                ],
                "InvalidComparison": [
                    98,
                    74,
                    81,
                    113,
                    92
                ],
                "self._recognized_scalars": [
                    744,
                    778,
                    842,
                    76,
                    824,
                    729
                ],
                "NaT": [
                    1377,
                    1634,
                    743,
                    776,
                    841,
                    1579,
                    396,
                    76,
                    1585,
                    1171,
                    1556,
                    1429,
                    790,
                    1302,
                    1628,
                    125,
                    1246,
                    831
                ],
                "self._scalar_type": [
                    809,
                    746,
                    779,
                    843,
                    77,
                    750,
                    816,
                    757,
                    790,
                    825,
                    731,
                    125,
                    735
                ],
                "self._check_compatible_with": [
                    807,
                    104,
                    810,
                    844,
                    78,
                    730,
                    794,
                    826,
                    861
                ],
                "is_list_like": [
                    580,
                    805,
                    845,
                    781,
                    80
                ],
                "len": [
                    1632,
                    673,
                    1220,
                    1319,
                    1000,
                    1002,
                    427,
                    588,
                    1003,
                    590,
                    1583,
                    592,
                    658,
                    83,
                    595,
                    1110,
                    1142,
                    537
                ],
                "list": [
                    520,
                    537,
                    87
                ],
                "np.array": [
                    520,
                    89,
                    1299,
                    1331
                ],
                "np": [
                    643,
                    517,
                    134,
                    1415,
                    520,
                    143,
                    271,
                    146,
                    1299,
                    533,
                    1431,
                    536,
                    665,
                    1305,
                    1436,
                    1193,
                    1331,
                    1469,
                    1223,
                    458,
                    462,
                    1112,
                    984,
                    89,
                    91,
                    1251,
                    1379,
                    485,
                    1384,
                    1265,
                    121
                ],
                "np.ndarray": [
                    485,
                    517,
                    1223,
                    1415,
                    458,
                    462,
                    143,
                    146,
                    1305,
                    91,
                    1469
                ],
                "type": [
                    1026,
                    1286,
                    647,
                    1291,
                    781,
                    1165,
                    784,
                    787,
                    1172,
                    790,
                    791,
                    793,
                    1178,
                    925,
                    806,
                    1195,
                    684,
                    1324,
                    817,
                    1208,
                    704,
                    834,
                    846,
                    464,
                    1619,
                    1238,
                    1496,
                    91,
                    859,
                    1500,
                    1246,
                    97,
                    1253,
                    103,
                    755,
                    637
                ],
                "is_object_dtype": [
                    615,
                    519,
                    1452,
                    532,
                    117,
                    1397,
                    94
                ],
                "other.dtype": [
                    97,
                    1286,
                    1500,
                    1491,
                    854,
                    859,
                    860,
                    94
                ],
                "_is_recognized_dtype": [
                    784,
                    97,
                    859
                ],
                "_from_sequence": [
                    806,
                    103
                ],
                "_validate_comparison_value": [
                    112
                ],
                "invalid_comparison": [
                    114
                ],
                "dtype": [
                    640,
                    641,
                    643,
                    646,
                    519,
                    648,
                    662,
                    668,
                    680,
                    613,
                    615,
                    617,
                    619,
                    624,
                    116,
                    117,
                    632,
                    633,
                    634,
                    637,
                    639
                ],
                "getattr": [
                    116,
                    1533
                ],
                "np.errstate": [
                    121
                ],
                "result": [
                    131,
                    388,
                    389,
                    135,
                    1415,
                    137,
                    1418,
                    395,
                    396,
                    397,
                    1419,
                    271,
                    272,
                    1553,
                    1554,
                    1557,
                    1430,
                    1432,
                    1435,
                    1437,
                    927,
                    545,
                    546,
                    547,
                    548,
                    929,
                    931,
                    1443,
                    1446,
                    1451,
                    1454,
                    1457,
                    1587,
                    1332,
                    1333,
                    1334,
                    1460,
                    1464,
                    1589,
                    1469,
                    1472,
                    1473,
                    1355,
                    1356,
                    982,
                    985,
                    986,
                    1378,
                    1251,
                    1252,
                    1253,
                    1380,
                    1383,
                    1512,
                    1385,
                    1513,
                    1636,
                    1638,
                    1517,
                    1391,
                    1265,
                    1266,
                    1267,
                    1396,
                    1521,
                    1522,
                    1399,
                    1526,
                    122,
                    123,
                    1406
                ],
                "ops.comp_method_OBJECT_ARRAY": [
                    122
                ],
                "ops": [
                    122
                ],
                "self.astype": [
                    122,
                    1331
                ],
                "object": [
                    272,
                    520,
                    122
                ],
                "other_i8": [
                    129,
                    131,
                    1230,
                    1232,
                    126
                ],
                "self._unbox_scalar": [
                    864,
                    811,
                    763,
                    732,
                    797,
                    126
                ],
                "other.asi8": [
                    1296,
                    129,
                    1230
                ],
                "self.asi8": [
                    482,
                    131,
                    903,
                    616,
                    683,
                    460,
                    1229,
                    622,
                    687,
                    1134,
                    1198,
                    1138,
                    1296,
                    1553,
                    1581,
                    1142,
                    954
                ],
                "o_mask": [
                    133,
                    134,
                    135
                ],
                "isna": [
                    802,
                    1554,
                    133,
                    1191
                ],
                "self._hasnans": [
                    1234,
                    980,
                    1300,
                    134
                ],
                "np.any": [
                    134
                ],
                "self._isnan": [
                    961,
                    135,
                    1198,
                    1232,
                    1296,
                    947,
                    1235,
                    1301,
                    985
                ],
                "unpack_zerodim_and_defer": [
                    1425,
                    108,
                    1373
                ],
                "set_function_name": [
                    139
                ],
                "wrapper": [
                    139
                ],
                "cls": [
                    929,
                    680,
                    139,
                    1100,
                    147,
                    691,
                    1109,
                    925
                ],
                "_data": [
                    921,
                    143
                ],
                "AbstractMethodError": [
                    224,
                    199,
                    147,
                    180,
                    473,
                    508,
                    1181,
                    158
                ],
                "classmethod": [
                    653,
                    145,
                    689,
                    1146,
                    1087
                ],
                "property": [
                    484,
                    1062,
                    457,
                    1132,
                    1038,
                    1136,
                    468,
                    149,
                    949,
                    1076,
                    1080,
                    1140,
                    956,
                    1053
                ],
                "Type": [
                    150
                ],
                "DatetimeLikeScalar": [
                    150
                ],
                "Union": [
                    162,
                    202,
                    182,
                    572,
                    573
                ],
                "Period": [
                    162,
                    1445,
                    202,
                    746,
                    748,
                    182
                ],
                "Timestamp": [
                    202,
                    162,
                    1481,
                    182
                ],
                "Timedelta": [
                    202,
                    162,
                    182
                ],
                "NaTType": [
                    202,
                    162,
                    573,
                    182
                ],
                "int": [
                    654,
                    572,
                    182,
                    1667
                ],
                "bool": [
                    961,
                    202,
                    572,
                    533
                ],
                "self._format_native_types": [
                    618,
                    271
                ],
                "date_format": [
                    271
                ],
                "np.nan": [
                    984,
                    271
                ],
                "result.astype": [
                    272,
                    982
                ],
                "Substitution": [
                    232
                ],
                "_round_doc": [
                    280,
                    407,
                    403,
                    399
                ],
                "_round_example": [
                    341,
                    399
                ],
                "_floor_example": [
                    355,
                    403
                ],
                "_ceil_example": [
                    369,
                    407
                ],
                "is_datetime64tz_dtype": [
                    1400,
                    385,
                    1022,
                    1455
                ],
                "naive": [
                    387,
                    388
                ],
                "self.tz_localize": [
                    387
                ],
                "naive._round": [
                    388
                ],
                "freq": [
                    388,
                    395,
                    401,
                    405,
                    1045,
                    409,
                    544,
                    548,
                    424,
                    427,
                    556,
                    558,
                    433,
                    434,
                    561,
                    436,
                    563,
                    567,
                    568,
                    1728,
                    1732,
                    1734,
                    1351,
                    1352,
                    1353,
                    1354,
                    1735,
                    1738,
                    1105,
                    1110,
                    1759,
                    1761,
                    1762,
                    1765,
                    1126,
                    1766
                ],
                "mode": [
                    395,
                    388
                ],
                "ambiguous": [
                    388,
                    390,
                    401,
                    405,
                    409
                ],
                "nonexistent": [
                    388,
                    390,
                    401,
                    405,
                    409
                ],
                "aware": [
                    392,
                    389
                ],
                "result.tz_localize": [
                    389
                ],
                "self.tz": [
                    390
                ],
                "values": [
                    394,
                    395,
                    665,
                    921,
                    923,
                    927,
                    680,
                    1577,
                    683,
                    684,
                    1581,
                    1583,
                    691,
                    1587,
                    1626,
                    1630,
                    479,
                    1632,
                    1636,
                    622,
                    626,
                    629,
                    630,
                    1014,
                    1019,
                    1021
                ],
                "self.view": [
                    394
                ],
                "round_nsint64": [
                    395
                ],
                "self._maybe_mask_results": [
                    1201,
                    396
                ],
                "self._simple_new": [
                    548,
                    397
                ],
                "self.dtype": [
                    1026,
                    646,
                    647,
                    775,
                    397,
                    929,
                    548,
                    806,
                    554,
                    1195,
                    684,
                    812,
                    1204,
                    1208,
                    829,
                    704,
                    1476,
                    840,
                    464,
                    1489,
                    1238,
                    727,
                    856,
                    1498,
                    1501,
                    1253,
                    742,
                    633
                ],
                "self._round": [
                    401,
                    409,
                    405
                ],
                "RoundTo.NEAREST_HALF_EVEN": [
                    401
                ],
                "RoundTo": [
                    401,
                    409,
                    405
                ],
                "Appender": [
                    407,
                    403,
                    696,
                    399
                ],
                "format": [
                    407,
                    512,
                    403,
                    399
                ],
                "RoundTo.MINUS_INFTY": [
                    405
                ],
                "RoundTo.PLUS_INFTY": [
                    409
                ],
                "DateOffset": [
                    1433,
                    427,
                    1381,
                    1759
                ],
                "frequencies.to_offset": [
                    1048,
                    1353,
                    434,
                    1762
                ],
                "frequencies": [
                    1762,
                    1353,
                    1072,
                    434,
                    1078,
                    1048,
                    1085
                ],
                "self.inferred_freq": [
                    434
                ],
                "self._freq": [
                    1517,
                    1043,
                    436,
                    1526,
                    1051
                ],
                "ExtensionOpsMixin": [
                    441
                ],
                "AttributesMixin": [
                    441
                ],
                "NDArrayBackedExtensionArray": [
                    441
                ],
                "_T": [
                    462
                ],
                "arr": [
                    464
                ],
                "lib.map_infer": [
                    479
                ],
                "lib": [
                    546,
                    802,
                    1666,
                    1502,
                    1668,
                    583,
                    1479,
                    746,
                    1386,
                    863,
                    536,
                    1438,
                    479
                ],
                "self._box_func": [
                    482,
                    547,
                    1638,
                    1589,
                    1557,
                    479
                ],
                "v": [
                    482
                ],
                "self._data.view": [
                    648,
                    495
                ],
                "self._data": [
                    545,
                    647,
                    648,
                    521,
                    495,
                    694,
                    1014,
                    600,
                    923,
                    702
                ],
                "com.is_bool_indexer": [
                    529,
                    588
                ],
                "com": [
                    529,
                    803,
                    588
                ],
                "key": [
                    529,
                    532,
                    533,
                    535,
                    536,
                    537,
                    542,
                    544,
                    545,
                    559,
                    560,
                    561,
                    564,
                    581,
                    583,
                    587,
                    588,
                    590,
                    595,
                    599,
                    600
                ],
                "np.asarray": [
                    643,
                    533
                ],
                "check_array_indexer": [
                    599,
                    542,
                    535
                ],
                "lib.maybe_booleans_to_slice": [
                    536
                ],
                "key.view": [
                    536
                ],
                "np.uint8": [
                    536
                ],
                "slice": [
                    537,
                    572,
                    581,
                    559
                ],
                "self._get_getitem_freq": [
                    544
                ],
                "lib.is_scalar": [
                    546,
                    802,
                    1479,
                    583,
                    863
                ],
                "is_period": [
                    554,
                    555
                ],
                "is_period_dtype": [
                    1441,
                    1284,
                    554,
                    1515,
                    1100,
                    1389,
                    1616,
                    1458,
                    1244,
                    1204,
                    1524,
                    1462,
                    1015,
                    1404,
                    1498,
                    668
                ],
                "self.freq": [
                    1058,
                    1060,
                    1351,
                    1289,
                    556,
                    684,
                    748,
                    560,
                    561,
                    1362,
                    563,
                    1204,
                    1299,
                    1206,
                    567,
                    1365,
                    1366,
                    1371
                ],
                "key.step": [
                    560,
                    561
                ],
                "Ellipsis": [
                    564
                ],
                "Sequence": [
                    587,
                    572,
                    573
                ],
                "Any": [
                    573
                ],
                "value": [
                    769,
                    900,
                    1030,
                    775,
                    776,
                    903,
                    778,
                    779,
                    781,
                    782,
                    784,
                    787,
                    790,
                    791,
                    1047,
                    793,
                    794,
                    795,
                    1048,
                    797,
                    1049,
                    799,
                    1051,
                    802,
                    803,
                    805,
                    806,
                    807,
                    808,
                    809,
                    810,
                    811,
                    812,
                    813,
                    817,
                    821,
                    824,
                    825,
                    826,
                    829,
                    831,
                    580,
                    837,
                    588,
                    592,
                    598,
                    600,
                    992,
                    993,
                    995,
                    999,
                    1000,
                    1002,
                    1005,
                    767
                ],
                "is_slice": [
                    586,
                    581
                ],
                "cast": [
                    587
                ],
                "msg": [
                    1290,
                    589,
                    1293,
                    815,
                    594,
                    819,
                    637,
                    638
                ],
                "self._validate_setitem_value": [
                    598
                ],
                "self._maybe_clear_freq": [
                    601
                ],
                "pandas_dtype": [
                    613
                ],
                "reshape": [
                    616,
                    1333
                ],
                "self._box_values": [
                    616
                ],
                "self.asi8.ravel": [
                    616
                ],
                "self.shape": [
                    1251,
                    616,
                    1193,
                    1265,
                    1329,
                    1333
                ],
                "is_string_dtype": [
                    617
                ],
                "is_categorical_dtype": [
                    617,
                    854,
                    639
                ],
                "is_integer_dtype": [
                    1403,
                    619,
                    1461,
                    1502
                ],
                "is_unsigned_integer_dtype": [
                    624
                ],
                "values.view": [
                    626,
                    1636
                ],
                "copy": [
                    628
                ],
                "values.copy": [
                    1019,
                    629
                ],
                "is_datetime_or_timedelta_dtype": [
                    632
                ],
                "is_dtype_equal": [
                    856,
                    633
                ],
                "is_float_dtype": [
                    634
                ],
                "__name__": [
                    834,
                    1286,
                    1291,
                    1324,
                    1165,
                    817,
                    787,
                    1172,
                    1619,
                    1496,
                    1178,
                    1500,
                    637,
                    1246
                ],
                "TypeError": [
                    833,
                    1495,
                    771,
                    1285,
                    1669,
                    1165,
                    846,
                    785,
                    1618,
                    819,
                    1172,
                    791,
                    1178,
                    1500,
                    860,
                    1245,
                    638
                ],
                "arr_cls": [
                    640,
                    641
                ],
                "dtype.construct_array_type": [
                    640
                ],
                "dtypes": [
                    657,
                    658,
                    659
                ],
                "x.dtype": [
                    657
                ],
                "x": [
                    673,
                    675,
                    657,
                    1299,
                    664
                ],
                "to_concat": [
                    673,
                    675,
                    676,
                    657,
                    661,
                    664
                ],
                "obj": [
                    675,
                    677,
                    678,
                    661,
                    662,
                    669
                ],
                "obj.dtype": [
                    662
                ],
                "i8values": [
                    664,
                    665
                ],
                "x.asi8": [
                    664
                ],
                "np.concatenate": [
                    665
                ],
                "axis": [
                    1573,
                    670,
                    1551,
                    665,
                    702
                ],
                "new_freq": [
                    678,
                    680,
                    1203,
                    1206,
                    1208,
                    667,
                    669
                ],
                "obj.freq": [
                    675,
                    669,
                    678,
                    677
                ],
                "all": [
                    675,
                    677
                ],
                "x.freq": [
                    675
                ],
                "pairs": [
                    676,
                    677
                ],
                "zip": [
                    676
                ],
                "pair": [
                    677
                ],
                "cls._simple_new": [
                    680
                ],
                "self.asi8.copy": [
                    683
                ],
                "_simple_new": [
                    704,
                    684
                ],
                "iNaT": [
                    963,
                    1252,
                    1194,
                    813,
                    687,
                    1266,
                    1236,
                    728,
                    954
                ],
                "original.dtype": [
                    691
                ],
                "original": [
                    691
                ],
                "self.size": [
                    698
                ],
                "periods": [
                    1665,
                    1666,
                    1667,
                    1668,
                    1669,
                    1670,
                    1354,
                    1358,
                    1365,
                    1366,
                    698,
                    702
                ],
                "self.copy": [
                    1032,
                    1360,
                    699,
                    1029
                ],
                "fill_value": [
                    701,
                    702,
                    727,
                    728,
                    729,
                    730,
                    731,
                    732,
                    983,
                    984,
                    985,
                    736,
                    738,
                    742,
                    743,
                    744,
                    746,
                    748,
                    750,
                    755,
                    761,
                    763,
                    764
                ],
                "self._validate_shift_value": [
                    701
                ],
                "new_values": [
                    1025,
                    1026,
                    1029,
                    1030,
                    1032,
                    1033,
                    1295,
                    1299,
                    1302,
                    1303,
                    1193,
                    1194,
                    1195,
                    1198,
                    1201,
                    1208,
                    702,
                    704,
                    1231,
                    1236,
                    1238,
                    1021
                ],
                "shift": [
                    702
                ],
                "ExtensionArray.shift.__doc__": [
                    696
                ],
                "ExtensionArray.shift": [
                    696
                ],
                "ExtensionArray": [
                    696
                ],
                "is_valid_nat_for_dtype": [
                    742,
                    775,
                    840,
                    812,
                    727,
                    829
                ],
                "lib.is_integer": [
                    1668,
                    1502,
                    746,
                    1386,
                    1438
                ],
                "new_fill": [
                    761,
                    748,
                    750
                ],
                "Period._from_ordinal": [
                    748
                ],
                "warnings.warn": [
                    754,
                    1322
                ],
                "warnings": [
                    754,
                    1322
                ],
                "self._scalar_type.__name__": [
                    816,
                    757
                ],
                "FutureWarning": [
                    758
                ],
                "err": [
                    773
                ],
                "array": [
                    851,
                    1332,
                    941,
                    782
                ],
                "value.asi8": [
                    808,
                    795
                ],
                "com.maybe_box_datetimelike": [
                    803
                ],
                "extract_array": [
                    852,
                    1333
                ],
                "other.categories.dtype": [
                    856
                ],
                "other.categories": [
                    856
                ],
                "other._internal_get_values": [
                    857
                ],
                "other.view": [
                    866
                ],
                "self._validate_searchsorted_value": [
                    900
                ],
                "self.asi8.searchsorted": [
                    903
                ],
                "side": [
                    903
                ],
                "sorter": [
                    903
                ],
                "dropna": [
                    920,
                    927
                ],
                "self.isna": [
                    997,
                    1575,
                    1553,
                    1624,
                    921
                ],
                "value_counts": [
                    927
                ],
                "index": [
                    928,
                    931,
                    1104,
                    1105,
                    1110,
                    1112
                ],
                "Index": [
                    928,
                    941
                ],
                "result.index.view": [
                    929
                ],
                "result.index": [
                    929
                ],
                "result.index.name": [
                    929
                ],
                "Series": [
                    931
                ],
                "result._values": [
                    931
                ],
                "result.name": [
                    931
                ],
                "map": [
                    941
                ],
                "mapper": [
                    941
                ],
                "self._isnan.any": [
                    961
                ],
                "convert": [
                    981,
                    982
                ],
                "ABCSeries": [
                    992
                ],
                "value.array": [
                    993
                ],
                "method": [
                    1008,
                    1009,
                    995
                ],
                "validate_fillna_kwargs": [
                    995
                ],
                "mask": [
                    997,
                    1030,
                    1575,
                    1577,
                    1578,
                    1005,
                    1007,
                    1235,
                    1236,
                    1301,
                    1302,
                    1624,
                    1626,
                    1627,
                    1021
                ],
                "is_array_like": [
                    999
                ],
                "mask.any": [
                    1578,
                    1627,
                    1007
                ],
                "func": [
                    1010,
                    1012,
                    1021
                ],
                "missing.pad_1d": [
                    1010
                ],
                "missing": [
                    1010,
                    1012
                ],
                "missing.backfill_1d": [
                    1012
                ],
                "limit": [
                    1021
                ],
                "new_values.view": [
                    1025
                ],
                "self._validate_frequency": [
                    1049
                ],
                "freq.setter": [
                    1045
                ],
                "self.freq.freqstr": [
                    1060
                ],
                "self.ndim": [
                    1069
                ],
                "frequencies.infer_freq": [
                    1072
                ],
                "frequencies.Resolution.get_reso_from_freq": [
                    1078
                ],
                "frequencies.Resolution": [
                    1085,
                    1078
                ],
                "self.freqstr": [
                    1291,
                    1078
                ],
                "frequencies.Resolution.get_str": [
                    1085
                ],
                "self._resolution": [
                    1085
                ],
                "inferred": [
                    1104,
                    1105,
                    1125
                ],
                "index.inferred_freq": [
                    1104
                ],
                "index.size": [
                    1105
                ],
                "freq.freqstr": [
                    1105,
                    1732,
                    1126
                ],
                "on_freq": [
                    1112,
                    1109
                ],
                "cls._generate_range": [
                    1109
                ],
                "kwargs": [
                    1537,
                    1572,
                    1550,
                    1110,
                    1535
                ],
                "np.array_equal": [
                    1112
                ],
                "index.asi8": [
                    1112
                ],
                "on_freq.asi8": [
                    1112
                ],
                "e": [
                    1115,
                    1118,
                    1127
                ],
                "algos.is_monotonic": [
                    1138,
                    1134
                ],
                "algos": [
                    1138,
                    1134
                ],
                "unique1d": [
                    1142
                ],
                "_create_comparison_method": [
                    1146
                ],
                "_datetimelike_array_cmp": [
                    1146
                ],
                "__pow__": [
                    1150
                ],
                "make_invalid_op": [
                    1152,
                    1153,
                    1154,
                    1155,
                    1156,
                    1157,
                    1158,
                    1159,
                    1160,
                    1161,
                    1150,
                    1151
                ],
                "__rpow__": [
                    1151
                ],
                "__mul__": [
                    1152
                ],
                "__rmul__": [
                    1153
                ],
                "__truediv__": [
                    1154
                ],
                "__rtruediv__": [
                    1155
                ],
                "__floordiv__": [
                    1156
                ],
                "__rfloordiv__": [
                    1157
                ],
                "__mod__": [
                    1158
                ],
                "__rmod__": [
                    1159
                ],
                "__divmod__": [
                    1160
                ],
                "__rdivmod__": [
                    1161
                ],
                "_add_datetime_arraylike": [
                    1167
                ],
                "_add_datetimelike_scalar": [
                    1167
                ],
                "_sub_datetime_arraylike": [
                    1174
                ],
                "_sub_datetimelike_scalar": [
                    1174
                ],
                "np.empty": [
                    1193
                ],
                "inc": [
                    1197,
                    1198
                ],
                "delta_to_nanoseconds": [
                    1197
                ],
                "view": [
                    1198
                ],
                "checked_add_with_arr": [
                    1295,
                    1198,
                    1231
                ],
                "Tick": [
                    1379,
                    1204,
                    1431
                ],
                "TimedeltaArray._from_sequence": [
                    1227
                ],
                "TimedeltaArray": [
                    1472,
                    1418,
                    1227
                ],
                "self_i8": [
                    1232,
                    1229
                ],
                "other._isnan": [
                    1232,
                    1296,
                    1235,
                    1301
                ],
                "other._hasnans": [
                    1234,
                    1300
                ],
                "np.zeros": [
                    1265,
                    1251
                ],
                "np.int64": [
                    1265,
                    1251
                ],
                "result.fill": [
                    1266,
                    1252
                ],
                "result.view": [
                    1267
                ],
                "other.freq": [
                    1289
                ],
                "DIFFERENT_FREQ.format": [
                    1290
                ],
                "DIFFERENT_FREQ": [
                    1290
                ],
                "other.freqstr": [
                    1291
                ],
                "IncompatibleFrequency": [
                    1293
                ],
                "self.freq.base": [
                    1299
                ],
                "operator.add": [
                    1406,
                    1318,
                    1399
                ],
                "operator": [
                    1318,
                    1454,
                    1399,
                    1464,
                    1406
                ],
                "operator.sub": [
                    1464,
                    1454,
                    1318
                ],
                "PerformanceWarning": [
                    1325
                ],
                "other.shape": [
                    1329
                ],
                "res_values": [
                    1331,
                    1332
                ],
                "res_values.ravel": [
                    1332
                ],
                "offset": [
                    1354,
                    1355
                ],
                "NullFrequencyError": [
                    1363
                ],
                "start": [
                    1371,
                    1365
                ],
                "end": [
                    1371,
                    1366
                ],
                "self._generate_range": [
                    1371
                ],
                "self._add_nat": [
                    1378
                ],
                "timedelta": [
                    1379,
                    1431
                ],
                "np.timedelta64": [
                    1379,
                    1431
                ],
                "self._add_timedeltalike_scalar": [
                    1432,
                    1380
                ],
                "self._add_offset": [
                    1435,
                    1383
                ],
                "datetime": [
                    1384,
                    1436
                ],
                "np.datetime64": [
                    1384,
                    1436
                ],
                "self._add_datetimelike_scalar": [
                    1385
                ],
                "integer_op_not_supported": [
                    1442,
                    1405,
                    1390,
                    1463
                ],
                "self._time_shift": [
                    1443,
                    1391
                ],
                "is_timedelta64_dtype": [
                    1501,
                    1476,
                    1415,
                    1449,
                    1394,
                    1498,
                    1469
                ],
                "self._add_timedelta_arraylike": [
                    1451,
                    1396
                ],
                "self._addsub_object_array": [
                    1454,
                    1399
                ],
                "is_datetime64_dtype": [
                    1400,
                    1455
                ],
                "self._add_datetime_arraylike": [
                    1402
                ],
                "self._addsub_int_array": [
                    1464,
                    1406
                ],
                "NotImplemented": [
                    1467,
                    1413
                ],
                "self.__add__": [
                    1423
                ],
                "self._sub_nat": [
                    1430
                ],
                "self._sub_datetimelike_scalar": [
                    1437
                ],
                "self._sub_period": [
                    1446
                ],
                "self._sub_datetime_arraylike": [
                    1457
                ],
                "self._sub_period_array": [
                    1460
                ],
                "is_datetime64_any_dtype": [
                    1489,
                    1491,
                    1476
                ],
                "DatetimeLikeArrayMixin": [
                    1641,
                    1482
                ],
                "DatetimeArray": [
                    1486
                ],
                "hasattr": [
                    1490
                ],
                "result._freq": [
                    1517,
                    1526
                ],
                "name": [
                    1537,
                    1533
                ],
                "skipna": [
                    1537,
                    1636,
                    1576,
                    1553,
                    1587,
                    1625,
                    1535
                ],
                "_reduce": [
                    1537
                ],
                "super": [
                    1537
                ],
                "nv.validate_min": [
                    1550
                ],
                "nv": [
                    1572,
                    1573,
                    1550,
                    1551
                ],
                "args": [
                    1572,
                    1550
                ],
                "nv.validate_minmax_axis": [
                    1573,
                    1551
                ],
                "nanops.nanmin": [
                    1553
                ],
                "nanops": [
                    1553,
                    1587,
                    1636
                ],
                "nv.validate_max": [
                    1572
                ],
                "asi8": [
                    1577
                ],
                "nanops.nanmax": [
                    1587
                ],
                "nanops.nanmean": [
                    1636
                ],
                "DatetimeLikeArrayMixin._add_comparison_ops": [
                    1641
                ],
                "lib.is_float": [
                    1666
                ],
                "left_closed": [
                    1697,
                    1690,
                    1694,
                    1703
                ],
                "right_closed": [
                    1703,
                    1691,
                    1699,
                    1695
                ],
                "closed": [
                    1696,
                    1698,
                    1693
                ],
                "inferred_freq": [
                    1728,
                    1730,
                    1735,
                    1727
                ],
                "freq_infer": [
                    1764,
                    1766,
                    1736,
                    1738,
                    1758
                ]
            },
            "filtered_variables_in_file": {
                "opname": [
                    139,
                    108,
                    61,
                    62
                ],
                "op.__name__": [
                    61
                ],
                "op": [
                    1533,
                    131,
                    1318,
                    1320,
                    114,
                    1331,
                    122,
                    61,
                    1534,
                    1535
                ],
                "nat_result": [
                    62,
                    135
                ],
                "other": [
                    68,
                    71,
                    74,
                    76,
                    77,
                    78,
                    80,
                    81,
                    83,
                    87,
                    89,
                    91,
                    92,
                    94,
                    97,
                    98,
                    103,
                    104,
                    106,
                    112,
                    114,
                    116,
                    122,
                    125,
                    126,
                    129,
                    133,
                    1165,
                    1171,
                    1191,
                    1197,
                    1220,
                    1223,
                    1227,
                    1230,
                    1232,
                    1234,
                    1235,
                    1286,
                    1289,
                    1291,
                    1296,
                    1300,
                    1301,
                    1319,
                    1320,
                    1329,
                    1331,
                    840,
                    841,
                    842,
                    843,
                    844,
                    845,
                    846,
                    851,
                    852,
                    854,
                    856,
                    857,
                    859,
                    860,
                    861,
                    863,
                    864,
                    1377,
                    866,
                    1379,
                    868,
                    1380,
                    1381,
                    1383,
                    1384,
                    1385,
                    1386,
                    1391,
                    1394,
                    1396,
                    1397,
                    1399,
                    1400,
                    1402,
                    1403,
                    1406,
                    1423,
                    1429,
                    1431,
                    1432,
                    1433,
                    1435,
                    1436,
                    1437,
                    1438,
                    1443,
                    1445,
                    1446,
                    1449,
                    1451,
                    1452,
                    1454,
                    1455,
                    1457,
                    1458,
                    1460,
                    1461,
                    1464,
                    1476,
                    1479,
                    1481,
                    1482,
                    1486,
                    1487,
                    1490,
                    1491,
                    1496,
                    1498,
                    1500,
                    1502,
                    1505,
                    1507,
                    1509,
                    1512,
                    1521
                ],
                "self._scalar_from_string": [
                    769,
                    71
                ],
                "self": [
                    1026,
                    1527,
                    1029,
                    520,
                    521,
                    1032,
                    1553,
                    1043,
                    1557,
                    535,
                    1049,
                    1051,
                    542,
                    544,
                    545,
                    1058,
                    547,
                    548,
                    1060,
                    1575,
                    1577,
                    554,
                    556,
                    1069,
                    1581,
                    560,
                    561,
                    1072,
                    563,
                    1589,
                    1078,
                    567,
                    1085,
                    71,
                    76,
                    77,
                    78,
                    1616,
                    83,
                    1619,
                    598,
                    599,
                    600,
                    601,
                    1624,
                    91,
                    1626,
                    1630,
                    97,
                    1638,
                    103,
                    104,
                    616,
                    618,
                    622,
                    1134,
                    112,
                    114,
                    1138,
                    1142,
                    633,
                    122,
                    637,
                    125,
                    126,
                    641,
                    131,
                    643,
                    134,
                    135,
                    646,
                    647,
                    648,
                    1165,
                    1172,
                    1178,
                    1181,
                    158,
                    1193,
                    683,
                    684,
                    1195,
                    1198,
                    687,
                    1201,
                    180,
                    1204,
                    694,
                    1206,
                    1208,
                    698,
                    699,
                    701,
                    702,
                    704,
                    1220,
                    199,
                    1229,
                    1232,
                    1234,
                    1235,
                    1238,
                    727,
                    729,
                    730,
                    731,
                    732,
                    1244,
                    1246,
                    735,
                    224,
                    1251,
                    1253,
                    742,
                    744,
                    746,
                    748,
                    750,
                    1265,
                    757,
                    763,
                    769,
                    1284,
                    1286,
                    775,
                    1289,
                    778,
                    779,
                    1291,
                    781,
                    271,
                    784,
                    1296,
                    1299,
                    1300,
                    1301,
                    790,
                    793,
                    794,
                    797,
                    806,
                    807,
                    1320,
                    809,
                    810,
                    811,
                    812,
                    1324,
                    816,
                    1329,
                    1331,
                    1333,
                    824,
                    825,
                    826,
                    829,
                    834,
                    1351,
                    840,
                    842,
                    843,
                    844,
                    1355,
                    1360,
                    1362,
                    1365,
                    1366,
                    856,
                    859,
                    1371,
                    861,
                    864,
                    1378,
                    1380,
                    1383,
                    1385,
                    1389,
                    1390,
                    1391,
                    1396,
                    1399,
                    1402,
                    1404,
                    1405,
                    1406,
                    385,
                    387,
                    900,
                    390,
                    903,
                    394,
                    396,
                    397,
                    1423,
                    401,
                    405,
                    1430,
                    1432,
                    409,
                    921,
                    923,
                    1435,
                    925,
                    1437,
                    929,
                    1441,
                    1442,
                    1443,
                    1446,
                    427,
                    1451,
                    941,
                    1454,
                    1457,
                    434,
                    947,
                    436,
                    437,
                    1460,
                    1462,
                    1463,
                    1464,
                    954,
                    961,
                    1476,
                    1481,
                    460,
                    1487,
                    464,
                    1489,
                    980,
                    1496,
                    473,
                    985,
                    1498,
                    1500,
                    1501,
                    479,
                    1505,
                    482,
                    1507,
                    997,
                    1509,
                    1000,
                    1512,
                    1513,
                    1003,
                    1515,
                    1517,
                    1518,
                    495,
                    1521,
                    1522,
                    1524,
                    1014,
                    1015,
                    1526,
                    508,
                    1533,
                    1022
                ],
                "InvalidComparison": [
                    98,
                    74,
                    81,
                    113,
                    92
                ],
                "self._recognized_scalars": [
                    744,
                    778,
                    842,
                    76,
                    824,
                    729
                ],
                "NaT": [
                    1377,
                    1634,
                    743,
                    776,
                    841,
                    1579,
                    396,
                    76,
                    1585,
                    1171,
                    1556,
                    1429,
                    790,
                    1302,
                    1628,
                    125,
                    1246,
                    831
                ],
                "self._scalar_type": [
                    809,
                    746,
                    779,
                    843,
                    77,
                    750,
                    816,
                    757,
                    790,
                    825,
                    731,
                    125,
                    735
                ],
                "self._check_compatible_with": [
                    807,
                    104,
                    810,
                    844,
                    78,
                    730,
                    794,
                    826,
                    861
                ],
                "is_list_like": [
                    580,
                    805,
                    845,
                    781,
                    80
                ],
                "np.array": [
                    520,
                    89,
                    1299,
                    1331
                ],
                "np": [
                    643,
                    517,
                    134,
                    1415,
                    520,
                    143,
                    271,
                    146,
                    1299,
                    533,
                    1431,
                    536,
                    665,
                    1305,
                    1436,
                    1193,
                    1331,
                    1469,
                    1223,
                    458,
                    462,
                    1112,
                    984,
                    89,
                    91,
                    1251,
                    1379,
                    485,
                    1384,
                    1265,
                    121
                ],
                "np.ndarray": [
                    485,
                    517,
                    1223,
                    1415,
                    458,
                    462,
                    143,
                    146,
                    1305,
                    91,
                    1469
                ],
                "is_object_dtype": [
                    615,
                    519,
                    1452,
                    532,
                    117,
                    1397,
                    94
                ],
                "other.dtype": [
                    97,
                    1286,
                    1500,
                    1491,
                    854,
                    859,
                    860,
                    94
                ],
                "_is_recognized_dtype": [
                    784,
                    97,
                    859
                ],
                "_from_sequence": [
                    806,
                    103
                ],
                "_validate_comparison_value": [
                    112
                ],
                "invalid_comparison": [
                    114
                ],
                "dtype": [
                    640,
                    641,
                    643,
                    646,
                    519,
                    648,
                    662,
                    668,
                    680,
                    613,
                    615,
                    617,
                    619,
                    624,
                    116,
                    117,
                    632,
                    633,
                    634,
                    637,
                    639
                ],
                "np.errstate": [
                    121
                ],
                "result": [
                    131,
                    388,
                    389,
                    135,
                    1415,
                    137,
                    1418,
                    395,
                    396,
                    397,
                    1419,
                    271,
                    272,
                    1553,
                    1554,
                    1557,
                    1430,
                    1432,
                    1435,
                    1437,
                    927,
                    545,
                    546,
                    547,
                    548,
                    929,
                    931,
                    1443,
                    1446,
                    1451,
                    1454,
                    1457,
                    1587,
                    1332,
                    1333,
                    1334,
                    1460,
                    1464,
                    1589,
                    1469,
                    1472,
                    1473,
                    1355,
                    1356,
                    982,
                    985,
                    986,
                    1378,
                    1251,
                    1252,
                    1253,
                    1380,
                    1383,
                    1512,
                    1385,
                    1513,
                    1636,
                    1638,
                    1517,
                    1391,
                    1265,
                    1266,
                    1267,
                    1396,
                    1521,
                    1522,
                    1399,
                    1526,
                    122,
                    123,
                    1406
                ],
                "ops.comp_method_OBJECT_ARRAY": [
                    122
                ],
                "ops": [
                    122
                ],
                "self.astype": [
                    122,
                    1331
                ],
                "other_i8": [
                    129,
                    131,
                    1230,
                    1232,
                    126
                ],
                "self._unbox_scalar": [
                    864,
                    811,
                    763,
                    732,
                    797,
                    126
                ],
                "other.asi8": [
                    1296,
                    129,
                    1230
                ],
                "self.asi8": [
                    482,
                    131,
                    903,
                    616,
                    683,
                    460,
                    1229,
                    622,
                    687,
                    1134,
                    1198,
                    1138,
                    1296,
                    1553,
                    1581,
                    1142,
                    954
                ],
                "o_mask": [
                    133,
                    134,
                    135
                ],
                "isna": [
                    802,
                    1554,
                    133,
                    1191
                ],
                "self._hasnans": [
                    1234,
                    980,
                    1300,
                    134
                ],
                "np.any": [
                    134
                ],
                "self._isnan": [
                    961,
                    135,
                    1198,
                    1232,
                    1296,
                    947,
                    1235,
                    1301,
                    985
                ],
                "unpack_zerodim_and_defer": [
                    1425,
                    108,
                    1373
                ],
                "set_function_name": [
                    139
                ],
                "wrapper": [
                    139
                ],
                "cls": [
                    929,
                    680,
                    139,
                    1100,
                    147,
                    691,
                    1109,
                    925
                ],
                "_data": [
                    921,
                    143
                ],
                "AbstractMethodError": [
                    224,
                    199,
                    147,
                    180,
                    473,
                    508,
                    1181,
                    158
                ],
                "Type": [
                    150
                ],
                "DatetimeLikeScalar": [
                    150
                ],
                "Union": [
                    162,
                    202,
                    182,
                    572,
                    573
                ],
                "Period": [
                    162,
                    1445,
                    202,
                    746,
                    748,
                    182
                ],
                "Timestamp": [
                    202,
                    162,
                    1481,
                    182
                ],
                "Timedelta": [
                    202,
                    162,
                    182
                ],
                "NaTType": [
                    202,
                    162,
                    573,
                    182
                ],
                "self._format_native_types": [
                    618,
                    271
                ],
                "date_format": [
                    271
                ],
                "np.nan": [
                    984,
                    271
                ],
                "result.astype": [
                    272,
                    982
                ],
                "Substitution": [
                    232
                ],
                "_round_doc": [
                    280,
                    407,
                    403,
                    399
                ],
                "_round_example": [
                    341,
                    399
                ],
                "_floor_example": [
                    355,
                    403
                ],
                "_ceil_example": [
                    369,
                    407
                ],
                "is_datetime64tz_dtype": [
                    1400,
                    385,
                    1022,
                    1455
                ],
                "naive": [
                    387,
                    388
                ],
                "self.tz_localize": [
                    387
                ],
                "naive._round": [
                    388
                ],
                "freq": [
                    388,
                    395,
                    401,
                    405,
                    1045,
                    409,
                    544,
                    548,
                    424,
                    427,
                    556,
                    558,
                    433,
                    434,
                    561,
                    436,
                    563,
                    567,
                    568,
                    1728,
                    1732,
                    1734,
                    1351,
                    1352,
                    1353,
                    1354,
                    1735,
                    1738,
                    1105,
                    1110,
                    1759,
                    1761,
                    1762,
                    1765,
                    1126,
                    1766
                ],
                "mode": [
                    395,
                    388
                ],
                "ambiguous": [
                    388,
                    390,
                    401,
                    405,
                    409
                ],
                "nonexistent": [
                    388,
                    390,
                    401,
                    405,
                    409
                ],
                "aware": [
                    392,
                    389
                ],
                "result.tz_localize": [
                    389
                ],
                "self.tz": [
                    390
                ],
                "values": [
                    394,
                    395,
                    665,
                    921,
                    923,
                    927,
                    680,
                    1577,
                    683,
                    684,
                    1581,
                    1583,
                    691,
                    1587,
                    1626,
                    1630,
                    479,
                    1632,
                    1636,
                    622,
                    626,
                    629,
                    630,
                    1014,
                    1019,
                    1021
                ],
                "self.view": [
                    394
                ],
                "round_nsint64": [
                    395
                ],
                "self._maybe_mask_results": [
                    1201,
                    396
                ],
                "self._simple_new": [
                    548,
                    397
                ],
                "self.dtype": [
                    1026,
                    646,
                    647,
                    775,
                    397,
                    929,
                    548,
                    806,
                    554,
                    1195,
                    684,
                    812,
                    1204,
                    1208,
                    829,
                    704,
                    1476,
                    840,
                    464,
                    1489,
                    1238,
                    727,
                    856,
                    1498,
                    1501,
                    1253,
                    742,
                    633
                ],
                "self._round": [
                    401,
                    409,
                    405
                ],
                "RoundTo.NEAREST_HALF_EVEN": [
                    401
                ],
                "RoundTo": [
                    401,
                    409,
                    405
                ],
                "Appender": [
                    407,
                    403,
                    696,
                    399
                ],
                "RoundTo.MINUS_INFTY": [
                    405
                ],
                "RoundTo.PLUS_INFTY": [
                    409
                ],
                "DateOffset": [
                    1433,
                    427,
                    1381,
                    1759
                ],
                "frequencies.to_offset": [
                    1048,
                    1353,
                    434,
                    1762
                ],
                "frequencies": [
                    1762,
                    1353,
                    1072,
                    434,
                    1078,
                    1048,
                    1085
                ],
                "self.inferred_freq": [
                    434
                ],
                "self._freq": [
                    1517,
                    1043,
                    436,
                    1526,
                    1051
                ],
                "ExtensionOpsMixin": [
                    441
                ],
                "AttributesMixin": [
                    441
                ],
                "NDArrayBackedExtensionArray": [
                    441
                ],
                "_T": [
                    462
                ],
                "arr": [
                    464
                ],
                "lib.map_infer": [
                    479
                ],
                "lib": [
                    546,
                    802,
                    1666,
                    1502,
                    1668,
                    583,
                    1479,
                    746,
                    1386,
                    863,
                    536,
                    1438,
                    479
                ],
                "self._box_func": [
                    482,
                    547,
                    1638,
                    1589,
                    1557,
                    479
                ],
                "v": [
                    482
                ],
                "self._data.view": [
                    648,
                    495
                ],
                "self._data": [
                    545,
                    647,
                    648,
                    521,
                    495,
                    694,
                    1014,
                    600,
                    923,
                    702
                ],
                "com.is_bool_indexer": [
                    529,
                    588
                ],
                "com": [
                    529,
                    803,
                    588
                ],
                "key": [
                    529,
                    532,
                    533,
                    535,
                    536,
                    537,
                    542,
                    544,
                    545,
                    559,
                    560,
                    561,
                    564,
                    581,
                    583,
                    587,
                    588,
                    590,
                    595,
                    599,
                    600
                ],
                "np.asarray": [
                    643,
                    533
                ],
                "check_array_indexer": [
                    599,
                    542,
                    535
                ],
                "lib.maybe_booleans_to_slice": [
                    536
                ],
                "key.view": [
                    536
                ],
                "np.uint8": [
                    536
                ],
                "self._get_getitem_freq": [
                    544
                ],
                "lib.is_scalar": [
                    546,
                    802,
                    1479,
                    583,
                    863
                ],
                "is_period": [
                    554,
                    555
                ],
                "is_period_dtype": [
                    1441,
                    1284,
                    554,
                    1515,
                    1100,
                    1389,
                    1616,
                    1458,
                    1244,
                    1204,
                    1524,
                    1462,
                    1015,
                    1404,
                    1498,
                    668
                ],
                "self.freq": [
                    1058,
                    1060,
                    1351,
                    1289,
                    556,
                    684,
                    748,
                    560,
                    561,
                    1362,
                    563,
                    1204,
                    1299,
                    1206,
                    567,
                    1365,
                    1366,
                    1371
                ],
                "key.step": [
                    560,
                    561
                ],
                "Sequence": [
                    587,
                    572,
                    573
                ],
                "Any": [
                    573
                ],
                "value": [
                    769,
                    900,
                    1030,
                    775,
                    776,
                    903,
                    778,
                    779,
                    781,
                    782,
                    784,
                    787,
                    790,
                    791,
                    1047,
                    793,
                    794,
                    795,
                    1048,
                    797,
                    1049,
                    799,
                    1051,
                    802,
                    803,
                    805,
                    806,
                    807,
                    808,
                    809,
                    810,
                    811,
                    812,
                    813,
                    817,
                    821,
                    824,
                    825,
                    826,
                    829,
                    831,
                    580,
                    837,
                    588,
                    592,
                    598,
                    600,
                    992,
                    993,
                    995,
                    999,
                    1000,
                    1002,
                    1005,
                    767
                ],
                "is_slice": [
                    586,
                    581
                ],
                "cast": [
                    587
                ],
                "msg": [
                    1290,
                    589,
                    1293,
                    815,
                    594,
                    819,
                    637,
                    638
                ],
                "self._validate_setitem_value": [
                    598
                ],
                "self._maybe_clear_freq": [
                    601
                ],
                "pandas_dtype": [
                    613
                ],
                "reshape": [
                    616,
                    1333
                ],
                "self._box_values": [
                    616
                ],
                "self.asi8.ravel": [
                    616
                ],
                "self.shape": [
                    1251,
                    616,
                    1193,
                    1265,
                    1329,
                    1333
                ],
                "is_string_dtype": [
                    617
                ],
                "is_categorical_dtype": [
                    617,
                    854,
                    639
                ],
                "is_integer_dtype": [
                    1403,
                    619,
                    1461,
                    1502
                ],
                "is_unsigned_integer_dtype": [
                    624
                ],
                "values.view": [
                    626,
                    1636
                ],
                "copy": [
                    628
                ],
                "values.copy": [
                    1019,
                    629
                ],
                "is_datetime_or_timedelta_dtype": [
                    632
                ],
                "is_dtype_equal": [
                    856,
                    633
                ],
                "is_float_dtype": [
                    634
                ],
                "arr_cls": [
                    640,
                    641
                ],
                "dtype.construct_array_type": [
                    640
                ],
                "dtypes": [
                    657,
                    658,
                    659
                ],
                "x.dtype": [
                    657
                ],
                "x": [
                    673,
                    675,
                    657,
                    1299,
                    664
                ],
                "to_concat": [
                    673,
                    675,
                    676,
                    657,
                    661,
                    664
                ],
                "obj": [
                    675,
                    677,
                    678,
                    661,
                    662,
                    669
                ],
                "obj.dtype": [
                    662
                ],
                "i8values": [
                    664,
                    665
                ],
                "x.asi8": [
                    664
                ],
                "np.concatenate": [
                    665
                ],
                "axis": [
                    1573,
                    670,
                    1551,
                    665,
                    702
                ],
                "new_freq": [
                    678,
                    680,
                    1203,
                    1206,
                    1208,
                    667,
                    669
                ],
                "obj.freq": [
                    675,
                    669,
                    678,
                    677
                ],
                "x.freq": [
                    675
                ],
                "pairs": [
                    676,
                    677
                ],
                "pair": [
                    677
                ],
                "cls._simple_new": [
                    680
                ],
                "self.asi8.copy": [
                    683
                ],
                "_simple_new": [
                    704,
                    684
                ],
                "iNaT": [
                    963,
                    1252,
                    1194,
                    813,
                    687,
                    1266,
                    1236,
                    728,
                    954
                ],
                "original.dtype": [
                    691
                ],
                "original": [
                    691
                ],
                "self.size": [
                    698
                ],
                "periods": [
                    1665,
                    1666,
                    1667,
                    1668,
                    1669,
                    1670,
                    1354,
                    1358,
                    1365,
                    1366,
                    698,
                    702
                ],
                "self.copy": [
                    1032,
                    1360,
                    699,
                    1029
                ],
                "fill_value": [
                    701,
                    702,
                    727,
                    728,
                    729,
                    730,
                    731,
                    732,
                    983,
                    984,
                    985,
                    736,
                    738,
                    742,
                    743,
                    744,
                    746,
                    748,
                    750,
                    755,
                    761,
                    763,
                    764
                ],
                "self._validate_shift_value": [
                    701
                ],
                "new_values": [
                    1025,
                    1026,
                    1029,
                    1030,
                    1032,
                    1033,
                    1295,
                    1299,
                    1302,
                    1303,
                    1193,
                    1194,
                    1195,
                    1198,
                    1201,
                    1208,
                    702,
                    704,
                    1231,
                    1236,
                    1238,
                    1021
                ],
                "shift": [
                    702
                ],
                "ExtensionArray.shift.__doc__": [
                    696
                ],
                "ExtensionArray.shift": [
                    696
                ],
                "ExtensionArray": [
                    696
                ],
                "is_valid_nat_for_dtype": [
                    742,
                    775,
                    840,
                    812,
                    727,
                    829
                ],
                "lib.is_integer": [
                    1668,
                    1502,
                    746,
                    1386,
                    1438
                ],
                "new_fill": [
                    761,
                    748,
                    750
                ],
                "Period._from_ordinal": [
                    748
                ],
                "warnings.warn": [
                    754,
                    1322
                ],
                "warnings": [
                    754,
                    1322
                ],
                "self._scalar_type.__name__": [
                    816,
                    757
                ],
                "err": [
                    773
                ],
                "array": [
                    851,
                    1332,
                    941,
                    782
                ],
                "value.asi8": [
                    808,
                    795
                ],
                "com.maybe_box_datetimelike": [
                    803
                ],
                "extract_array": [
                    852,
                    1333
                ],
                "other.categories.dtype": [
                    856
                ],
                "other.categories": [
                    856
                ],
                "other._internal_get_values": [
                    857
                ],
                "other.view": [
                    866
                ],
                "self._validate_searchsorted_value": [
                    900
                ],
                "self.asi8.searchsorted": [
                    903
                ],
                "side": [
                    903
                ],
                "sorter": [
                    903
                ],
                "dropna": [
                    920,
                    927
                ],
                "self.isna": [
                    997,
                    1575,
                    1553,
                    1624,
                    921
                ],
                "value_counts": [
                    927
                ],
                "index": [
                    928,
                    931,
                    1104,
                    1105,
                    1110,
                    1112
                ],
                "Index": [
                    928,
                    941
                ],
                "result.index.view": [
                    929
                ],
                "result.index": [
                    929
                ],
                "result.index.name": [
                    929
                ],
                "Series": [
                    931
                ],
                "result._values": [
                    931
                ],
                "result.name": [
                    931
                ],
                "mapper": [
                    941
                ],
                "self._isnan.any": [
                    961
                ],
                "convert": [
                    981,
                    982
                ],
                "ABCSeries": [
                    992
                ],
                "value.array": [
                    993
                ],
                "method": [
                    1008,
                    1009,
                    995
                ],
                "validate_fillna_kwargs": [
                    995
                ],
                "mask": [
                    997,
                    1030,
                    1575,
                    1577,
                    1578,
                    1005,
                    1007,
                    1235,
                    1236,
                    1301,
                    1302,
                    1624,
                    1626,
                    1627,
                    1021
                ],
                "is_array_like": [
                    999
                ],
                "mask.any": [
                    1578,
                    1627,
                    1007
                ],
                "func": [
                    1010,
                    1012,
                    1021
                ],
                "missing.pad_1d": [
                    1010
                ],
                "missing": [
                    1010,
                    1012
                ],
                "missing.backfill_1d": [
                    1012
                ],
                "limit": [
                    1021
                ],
                "new_values.view": [
                    1025
                ],
                "self._validate_frequency": [
                    1049
                ],
                "freq.setter": [
                    1045
                ],
                "self.freq.freqstr": [
                    1060
                ],
                "self.ndim": [
                    1069
                ],
                "frequencies.infer_freq": [
                    1072
                ],
                "frequencies.Resolution.get_reso_from_freq": [
                    1078
                ],
                "frequencies.Resolution": [
                    1085,
                    1078
                ],
                "self.freqstr": [
                    1291,
                    1078
                ],
                "frequencies.Resolution.get_str": [
                    1085
                ],
                "self._resolution": [
                    1085
                ],
                "inferred": [
                    1104,
                    1105,
                    1125
                ],
                "index.inferred_freq": [
                    1104
                ],
                "index.size": [
                    1105
                ],
                "freq.freqstr": [
                    1105,
                    1732,
                    1126
                ],
                "on_freq": [
                    1112,
                    1109
                ],
                "cls._generate_range": [
                    1109
                ],
                "kwargs": [
                    1537,
                    1572,
                    1550,
                    1110,
                    1535
                ],
                "np.array_equal": [
                    1112
                ],
                "index.asi8": [
                    1112
                ],
                "on_freq.asi8": [
                    1112
                ],
                "e": [
                    1115,
                    1118,
                    1127
                ],
                "algos.is_monotonic": [
                    1138,
                    1134
                ],
                "algos": [
                    1138,
                    1134
                ],
                "unique1d": [
                    1142
                ],
                "_create_comparison_method": [
                    1146
                ],
                "_datetimelike_array_cmp": [
                    1146
                ],
                "__pow__": [
                    1150
                ],
                "make_invalid_op": [
                    1152,
                    1153,
                    1154,
                    1155,
                    1156,
                    1157,
                    1158,
                    1159,
                    1160,
                    1161,
                    1150,
                    1151
                ],
                "__rpow__": [
                    1151
                ],
                "__mul__": [
                    1152
                ],
                "__rmul__": [
                    1153
                ],
                "__truediv__": [
                    1154
                ],
                "__rtruediv__": [
                    1155
                ],
                "__floordiv__": [
                    1156
                ],
                "__rfloordiv__": [
                    1157
                ],
                "__mod__": [
                    1158
                ],
                "__rmod__": [
                    1159
                ],
                "__divmod__": [
                    1160
                ],
                "__rdivmod__": [
                    1161
                ],
                "_add_datetime_arraylike": [
                    1167
                ],
                "_add_datetimelike_scalar": [
                    1167
                ],
                "_sub_datetime_arraylike": [
                    1174
                ],
                "_sub_datetimelike_scalar": [
                    1174
                ],
                "np.empty": [
                    1193
                ],
                "inc": [
                    1197,
                    1198
                ],
                "delta_to_nanoseconds": [
                    1197
                ],
                "view": [
                    1198
                ],
                "checked_add_with_arr": [
                    1295,
                    1198,
                    1231
                ],
                "Tick": [
                    1379,
                    1204,
                    1431
                ],
                "TimedeltaArray._from_sequence": [
                    1227
                ],
                "TimedeltaArray": [
                    1472,
                    1418,
                    1227
                ],
                "self_i8": [
                    1232,
                    1229
                ],
                "other._isnan": [
                    1232,
                    1296,
                    1235,
                    1301
                ],
                "other._hasnans": [
                    1234,
                    1300
                ],
                "np.zeros": [
                    1265,
                    1251
                ],
                "np.int64": [
                    1265,
                    1251
                ],
                "result.fill": [
                    1266,
                    1252
                ],
                "result.view": [
                    1267
                ],
                "other.freq": [
                    1289
                ],
                "DIFFERENT_FREQ.format": [
                    1290
                ],
                "DIFFERENT_FREQ": [
                    1290
                ],
                "other.freqstr": [
                    1291
                ],
                "IncompatibleFrequency": [
                    1293
                ],
                "self.freq.base": [
                    1299
                ],
                "operator.add": [
                    1406,
                    1318,
                    1399
                ],
                "operator": [
                    1318,
                    1454,
                    1399,
                    1464,
                    1406
                ],
                "operator.sub": [
                    1464,
                    1454,
                    1318
                ],
                "PerformanceWarning": [
                    1325
                ],
                "other.shape": [
                    1329
                ],
                "res_values": [
                    1331,
                    1332
                ],
                "res_values.ravel": [
                    1332
                ],
                "offset": [
                    1354,
                    1355
                ],
                "NullFrequencyError": [
                    1363
                ],
                "start": [
                    1371,
                    1365
                ],
                "end": [
                    1371,
                    1366
                ],
                "self._generate_range": [
                    1371
                ],
                "self._add_nat": [
                    1378
                ],
                "timedelta": [
                    1379,
                    1431
                ],
                "np.timedelta64": [
                    1379,
                    1431
                ],
                "self._add_timedeltalike_scalar": [
                    1432,
                    1380
                ],
                "self._add_offset": [
                    1435,
                    1383
                ],
                "datetime": [
                    1384,
                    1436
                ],
                "np.datetime64": [
                    1384,
                    1436
                ],
                "self._add_datetimelike_scalar": [
                    1385
                ],
                "integer_op_not_supported": [
                    1442,
                    1405,
                    1390,
                    1463
                ],
                "self._time_shift": [
                    1443,
                    1391
                ],
                "is_timedelta64_dtype": [
                    1501,
                    1476,
                    1415,
                    1449,
                    1394,
                    1498,
                    1469
                ],
                "self._add_timedelta_arraylike": [
                    1451,
                    1396
                ],
                "self._addsub_object_array": [
                    1454,
                    1399
                ],
                "is_datetime64_dtype": [
                    1400,
                    1455
                ],
                "self._add_datetime_arraylike": [
                    1402
                ],
                "self._addsub_int_array": [
                    1464,
                    1406
                ],
                "self.__add__": [
                    1423
                ],
                "self._sub_nat": [
                    1430
                ],
                "self._sub_datetimelike_scalar": [
                    1437
                ],
                "self._sub_period": [
                    1446
                ],
                "self._sub_datetime_arraylike": [
                    1457
                ],
                "self._sub_period_array": [
                    1460
                ],
                "is_datetime64_any_dtype": [
                    1489,
                    1491,
                    1476
                ],
                "DatetimeLikeArrayMixin": [
                    1641,
                    1482
                ],
                "DatetimeArray": [
                    1486
                ],
                "result._freq": [
                    1517,
                    1526
                ],
                "name": [
                    1537,
                    1533
                ],
                "skipna": [
                    1537,
                    1636,
                    1576,
                    1553,
                    1587,
                    1625,
                    1535
                ],
                "_reduce": [
                    1537
                ],
                "nv.validate_min": [
                    1550
                ],
                "nv": [
                    1572,
                    1573,
                    1550,
                    1551
                ],
                "args": [
                    1572,
                    1550
                ],
                "nv.validate_minmax_axis": [
                    1573,
                    1551
                ],
                "nanops.nanmin": [
                    1553
                ],
                "nanops": [
                    1553,
                    1587,
                    1636
                ],
                "nv.validate_max": [
                    1572
                ],
                "asi8": [
                    1577
                ],
                "nanops.nanmax": [
                    1587
                ],
                "nanops.nanmean": [
                    1636
                ],
                "DatetimeLikeArrayMixin._add_comparison_ops": [
                    1641
                ],
                "lib.is_float": [
                    1666
                ],
                "left_closed": [
                    1697,
                    1690,
                    1694,
                    1703
                ],
                "right_closed": [
                    1703,
                    1691,
                    1699,
                    1695
                ],
                "closed": [
                    1696,
                    1698,
                    1693
                ],
                "inferred_freq": [
                    1728,
                    1730,
                    1735,
                    1727
                ],
                "freq_infer": [
                    1764,
                    1766,
                    1736,
                    1738,
                    1758
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_15/pandas/tests/indexes/datetimes/test_datetime.py",
                "test_function": "test_pickle_after_set_freq",
                "test_function_code": "    def test_pickle_after_set_freq(self):\n        dti = date_range(\"20130101\", periods=3, tz=\"US/Eastern\", name=\"foo\")\n        dti = dti._with_freq(None)\n\n        res = tm.round_trip_pickle(dti)\n        tm.assert_index_equal(res, dti)",
                "test_error": "AssertionError",
                "full_test_error": "self = <pandas.tests.indexes.datetimes.test_datetime.TestDatetimeIndex object at 0x1169040d0>\n\n    def test_pickle_after_set_freq(self):\n        dti = date_range(\"20130101\", periods=3, tz=\"US/Eastern\", name=\"foo\")\n        dti = dti._with_freq(None)\n    \n>       res = tm.round_trip_pickle(dti)\n\npandas/tests/indexes/datetimes/test_datetime.py:45: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/_testing.py:158: in round_trip_pickle\n    return pd.read_pickle(temp_path)\npandas/io/pickle.py:181: in read_pickle\n    return pickle.load(f)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ncls = <class 'pandas.core.indexes.datetimes.DatetimeIndex'>, d = {'name': 'foo'}\n\n    def _new_DatetimeIndex(cls, d):\n        \"\"\"\n        This is called upon unpickling, rather than the default which doesn't\n        have arguments and breaks __new__\n        \"\"\"\n        if \"data\" in d and not isinstance(d[\"data\"], DatetimeIndex):\n            # Avoid need to verify integrity by calling simple_new directly\n            data = d.pop(\"data\")\n            if not isinstance(data, DatetimeArray):\n                # For backward compat with older pickles, we may need to construct\n                #  a DatetimeArray to adapt to the newer _simple_new signature\n                tz = d.pop(\"tz\")\n                freq = d.pop(\"freq\")\n                dta = DatetimeArray._simple_new(data, dtype=tz_to_dtype(tz), freq=freq)\n            else:\n                dta = data\n                for key in [\"tz\", \"freq\"]:\n                    # These are already stored in our DatetimeArray; if they are\n                    #  also in the pickle and don't match, we have a problem.\n                    if key in d:\n>                       assert d.pop(key) == getattr(dta, key)\nE                       AssertionError\n\npandas/core/indexes/datetimes.py:55: AssertionError",
                "traceback": "pandas/_testing.py:158: in round_trip_pickle\n    return pd.read_pickle(temp_path)\npandas/io/pickle.py:181: in read_pickle\n    return pickle.load(f)",
                "test_error_location": "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ncls = <class 'pandas.core.indexes.datetimes.DatetimeIndex'>, d = {'name': 'foo'}\n\n    def _new_DatetimeIndex(cls, d):\n        \"\"\"\n        This is called upon unpickling, rather than the default which doesn't\n        have arguments and breaks __new__\n        \"\"\"\n        if \"data\" in d and not isinstance(d[\"data\"], DatetimeIndex):\n            # Avoid need to verify integrity by calling simple_new directly\n            data = d.pop(\"data\")\n            if not isinstance(data, DatetimeArray):\n                # For backward compat with older pickles, we may need to construct\n                #  a DatetimeArray to adapt to the newer _simple_new signature\n                tz = d.pop(\"tz\")\n                freq = d.pop(\"freq\")\n                dta = DatetimeArray._simple_new(data, dtype=tz_to_dtype(tz), freq=freq)\n            else:\n                dta = data\n                for key in [\"tz\", \"freq\"]:\n                    # These are already stored in our DatetimeArray; if they are\n                    #  also in the pickle and don't match, we have a problem.\n                    if key in d:\n>                       assert d.pop(key) == getattr(dta, key)\nE                       AssertionError\n\npandas/core/indexes/datetimes.py:55: AssertionError",
                "test_function_decorators": []
            }
        ]
    }
}