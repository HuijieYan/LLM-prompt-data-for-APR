# Error stack trace

```json
[
    [
        "self = <test_indexing.TestDataFrameIndexing object at 0x11c8f47f0>\ntz_aware_fixture = 'UTC'\n\n    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n    \n        expected = df.head(3)\n>       actual = df.reindex(idx[:3], method=\"nearest\")\n\npandas/tests/frame/indexing/test_indexing.py:1612: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/util/_decorators.py:227: in wrapper\n    return func(*args, **kwargs)\npandas/core/frame.py:3887: in reindex\n    return self._ensure_type(super().reindex(**kwargs))\npandas/core/generic.py:4372: in reindex\n    return self._reindex_axes(\npandas/core/frame.py:3735: in _reindex_axes\n    frame = frame._reindex_index(\npandas/core/frame.py:3751: in _reindex_index\n    new_index, indexer = self.index.reindex(\npandas/core/indexes/base.py:3382: in reindex\n    indexer = self.get_indexer(\npandas/core/indexes/base.py:2992: in get_indexer\n    indexer = self._get_nearest_indexer(target, limit, tolerance)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = DatetimeIndex(['2019-01-01 00:00:00+00:00', '2019-01-02 00:00:00+00:00',\n               '2019-01-03 00:00:00+00:00', '...1-04 00:00:00+00:00',\n               '2019-01-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='D')\ntarget = array([Timestamp('2019-01-01 00:00:00+0000', tz='UTC', freq='D'),\n       Timestamp('2019-01-02 00:00:00+0000', tz='UTC', freq='D'),\n       Timestamp('2019-01-03 00:00:00+0000', tz='UTC', freq='D')],\n      dtype=object)\nlimit = None, tolerance = None\n\n    def _get_nearest_indexer(self, target: \"Index\", limit, tolerance) -> np.ndarray:\n        \"\"\"\n        Get the indexer for the nearest index labels; requires an index with\n        values that can be subtracted from each other (e.g., not strings or\n        tuples).\n        \"\"\"\n        left_indexer = self.get_indexer(target, \"pad\", limit=limit)\n        right_indexer = self.get_indexer(target, \"backfill\", limit=limit)\n    \n        target = np.asarray(target)\n>       left_distances = abs(self.values[left_indexer] - target)",
        "\npandas/core/indexes/base.py:3077: UFuncTypeError"
    ],
    [
        "self = <test_indexing.TestDataFrameIndexing object at 0x11ce30250>\ntz_aware_fixture = 'US/Eastern'\n\n    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n    \n        expected = df.head(3)\n>       actual = df.reindex(idx[:3], method=\"nearest\")\n\npandas/tests/frame/indexing/test_indexing.py:1612: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/util/_decorators.py:227: in wrapper\n    return func(*args, **kwargs)\npandas/core/frame.py:3887: in reindex\n    return self._ensure_type(super().reindex(**kwargs))\npandas/core/generic.py:4372: in reindex\n    return self._reindex_axes(\npandas/core/frame.py:3735: in _reindex_axes\n    frame = frame._reindex_index(\npandas/core/frame.py:3751: in _reindex_index\n    new_index, indexer = self.index.reindex(\npandas/core/indexes/base.py:3382: in reindex\n    indexer = self.get_indexer(\npandas/core/indexes/base.py:2992: in get_indexer\n    indexer = self._get_nearest_indexer(target, limit, tolerance)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = DatetimeIndex(['2019-01-01 00:00:00-05:00', '2019-01-02 00:00:00-05:00',\n               '2019-01-03 00:00:00-05:00', '...:00:00-05:00',\n               '2019-01-05 00:00:00-05:00'],\n              dtype='datetime64[ns, US/Eastern]', freq='D')\ntarget = array([Timestamp('2019-01-01 00:00:00-0500', tz='US/Eastern', freq='D'),\n       Timestamp('2019-01-02 00:00:00-0500', tz='US/Eastern', freq='D'),\n       Timestamp('2019-01-03 00:00:00-0500', tz='US/Eastern', freq='D')],\n      dtype=object)\nlimit = None, tolerance = None\n\n    def _get_nearest_indexer(self, target: \"Index\", limit, tolerance) -> np.ndarray:\n        \"\"\"\n        Get the indexer for the nearest index labels; requires an index with\n        values that can be subtracted from each other (e.g., not strings or\n        tuples).\n        \"\"\"\n        left_indexer = self.get_indexer(target, \"pad\", limit=limit)\n        right_indexer = self.get_indexer(target, \"backfill\", limit=limit)\n    \n        target = np.asarray(target)\n>       left_distances = abs(self.values[left_indexer] - target)",
        "\npandas/core/indexes/base.py:3077: UFuncTypeError"
    ],
    [
        "self = <test_indexing.TestDataFrameIndexing object at 0x125657400>\ntz_aware_fixture = 'Asia/Tokyo'\n\n    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n    \n        expected = df.head(3)\n>       actual = df.reindex(idx[:3], method=\"nearest\")\n\npandas/tests/frame/indexing/test_indexing.py:1612: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/util/_decorators.py:227: in wrapper\n    return func(*args, **kwargs)\npandas/core/frame.py:3887: in reindex\n    return self._ensure_type(super().reindex(**kwargs))\npandas/core/generic.py:4372: in reindex\n    return self._reindex_axes(\npandas/core/frame.py:3735: in _reindex_axes\n    frame = frame._reindex_index(\npandas/core/frame.py:3751: in _reindex_index\n    new_index, indexer = self.index.reindex(\npandas/core/indexes/base.py:3382: in reindex\n    indexer = self.get_indexer(\npandas/core/indexes/base.py:2992: in get_indexer\n    indexer = self._get_nearest_indexer(target, limit, tolerance)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = DatetimeIndex(['2019-01-01 00:00:00+09:00', '2019-01-02 00:00:00+09:00',\n               '2019-01-03 00:00:00+09:00', '...:00:00+09:00',\n               '2019-01-05 00:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq='D')\ntarget = array([Timestamp('2019-01-01 00:00:00+0900', tz='Asia/Tokyo', freq='D'),\n       Timestamp('2019-01-02 00:00:00+0900', tz='Asia/Tokyo', freq='D'),\n       Timestamp('2019-01-03 00:00:00+0900', tz='Asia/Tokyo', freq='D')],\n      dtype=object)\nlimit = None, tolerance = None\n\n    def _get_nearest_indexer(self, target: \"Index\", limit, tolerance) -> np.ndarray:\n        \"\"\"\n        Get the indexer for the nearest index labels; requires an index with\n        values that can be subtracted from each other (e.g., not strings or\n        tuples).\n        \"\"\"\n        left_indexer = self.get_indexer(target, \"pad\", limit=limit)\n        right_indexer = self.get_indexer(target, \"backfill\", limit=limit)\n    \n        target = np.asarray(target)\n>       left_distances = abs(self.values[left_indexer] - target)",
        "\npandas/core/indexes/base.py:3077: UFuncTypeError"
    ],
    [
        "self = <test_indexing.TestDataFrameIndexing object at 0x12559cb80>\ntz_aware_fixture = 'dateutil/US/Pacific'\n\n    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n    \n        expected = df.head(3)\n>       actual = df.reindex(idx[:3], method=\"nearest\")\n\npandas/tests/frame/indexing/test_indexing.py:1612: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/util/_decorators.py:227: in wrapper\n    return func(*args, **kwargs)\npandas/core/frame.py:3887: in reindex\n    return self._ensure_type(super().reindex(**kwargs))\npandas/core/generic.py:4372: in reindex\n    return self._reindex_axes(\npandas/core/frame.py:3735: in _reindex_axes\n    frame = frame._reindex_index(\npandas/core/frame.py:3751: in _reindex_index\n    new_index, indexer = self.index.reindex(\npandas/core/indexes/base.py:3382: in reindex\n    indexer = self.get_indexer(\npandas/core/indexes/base.py:2992: in get_indexer\n    indexer = self._get_nearest_indexer(target, limit, tolerance)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = DatetimeIndex(['2019-01-01 00:00:00-08:00', '2019-01-02 00:00:00-08:00',\n               '2019-01-03 00:00:00-08:00', '...'2019-01-05 00:00:00-08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/US/Pacific')]', freq='D')\ntarget = array([Timestamp('2019-01-01 00:00:00-0800', tz='dateutil//usr/share/zoneinfo/US/Pacific', freq='D'),\n       Timestamp...    Timestamp('2019-01-03 00:00:00-0800', tz='dateutil//usr/share/zoneinfo/US/Pacific', freq='D')],\n      dtype=object)\nlimit = None, tolerance = None\n\n    def _get_nearest_indexer(self, target: \"Index\", limit, tolerance) -> np.ndarray:\n        \"\"\"\n        Get the indexer for the nearest index labels; requires an index with\n        values that can be subtracted from each other (e.g., not strings or\n        tuples).\n        \"\"\"\n        left_indexer = self.get_indexer(target, \"pad\", limit=limit)\n        right_indexer = self.get_indexer(target, \"backfill\", limit=limit)\n    \n        target = np.asarray(target)\n>       left_distances = abs(self.values[left_indexer] - target)",
        "\npandas/core/indexes/base.py:3077: UFuncTypeError"
    ],
    [
        "self = <test_indexing.TestDataFrameIndexing object at 0x11cc5c820>\ntz_aware_fixture = 'dateutil/Asia/Singapore'\n\n    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n    \n        expected = df.head(3)\n>       actual = df.reindex(idx[:3], method=\"nearest\")\n\npandas/tests/frame/indexing/test_indexing.py:1612: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/util/_decorators.py:227: in wrapper\n    return func(*args, **kwargs)\npandas/core/frame.py:3887: in reindex\n    return self._ensure_type(super().reindex(**kwargs))\npandas/core/generic.py:4372: in reindex\n    return self._reindex_axes(\npandas/core/frame.py:3735: in _reindex_axes\n    frame = frame._reindex_index(\npandas/core/frame.py:3751: in _reindex_index\n    new_index, indexer = self.index.reindex(\npandas/core/indexes/base.py:3382: in reindex\n    indexer = self.get_indexer(\npandas/core/indexes/base.py:2992: in get_indexer\n    indexer = self._get_nearest_indexer(target, limit, tolerance)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = DatetimeIndex(['2019-01-01 00:00:00+08:00', '2019-01-02 00:00:00+08:00',\n               '2019-01-03 00:00:00+08:00', '...9-01-05 00:00:00+08:00'],\n              dtype='datetime64[ns, tzfile('/usr/share/zoneinfo/Asia/Singapore')]', freq='D')\ntarget = array([Timestamp('2019-01-01 00:00:00+0800', tz='dateutil//usr/share/zoneinfo/Asia/Singapore', freq='D'),\n       Times...Timestamp('2019-01-03 00:00:00+0800', tz='dateutil//usr/share/zoneinfo/Asia/Singapore', freq='D')],\n      dtype=object)\nlimit = None, tolerance = None\n\n    def _get_nearest_indexer(self, target: \"Index\", limit, tolerance) -> np.ndarray:\n        \"\"\"\n        Get the indexer for the nearest index labels; requires an index with\n        values that can be subtracted from each other (e.g., not strings or\n        tuples).\n        \"\"\"\n        left_indexer = self.get_indexer(target, \"pad\", limit=limit)\n        right_indexer = self.get_indexer(target, \"backfill\", limit=limit)\n    \n        target = np.asarray(target)\n>       left_distances = abs(self.values[left_indexer] - target)",
        "\npandas/core/indexes/base.py:3077: UFuncTypeError"
    ],
    [
        "self = <test_indexing.TestDataFrameIndexing object at 0x1251c12b0>\ntz_aware_fixture = tzutc()\n\n    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n    \n        expected = df.head(3)\n>       actual = df.reindex(idx[:3], method=\"nearest\")\n\npandas/tests/frame/indexing/test_indexing.py:1612: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/util/_decorators.py:227: in wrapper\n    return func(*args, **kwargs)\npandas/core/frame.py:3887: in reindex\n    return self._ensure_type(super().reindex(**kwargs))\npandas/core/generic.py:4372: in reindex\n    return self._reindex_axes(\npandas/core/frame.py:3735: in _reindex_axes\n    frame = frame._reindex_index(\npandas/core/frame.py:3751: in _reindex_index\n    new_index, indexer = self.index.reindex(\npandas/core/indexes/base.py:3382: in reindex\n    indexer = self.get_indexer(\npandas/core/indexes/base.py:2992: in get_indexer\n    indexer = self._get_nearest_indexer(target, limit, tolerance)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = DatetimeIndex(['2019-01-01 00:00:00+00:00', '2019-01-02 00:00:00+00:00',\n               '2019-01-03 00:00:00+00:00', '... 00:00:00+00:00',\n               '2019-01-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzutc()]', freq='D')\ntarget = array([Timestamp('2019-01-01 00:00:00+0000', tz='tzutc()', freq='D'),\n       Timestamp('2019-01-02 00:00:00+0000', tz='tzutc()', freq='D'),\n       Timestamp('2019-01-03 00:00:00+0000', tz='tzutc()', freq='D')],\n      dtype=object)\nlimit = None, tolerance = None\n\n    def _get_nearest_indexer(self, target: \"Index\", limit, tolerance) -> np.ndarray:\n        \"\"\"\n        Get the indexer for the nearest index labels; requires an index with\n        values that can be subtracted from each other (e.g., not strings or\n        tuples).\n        \"\"\"\n        left_indexer = self.get_indexer(target, \"pad\", limit=limit)\n        right_indexer = self.get_indexer(target, \"backfill\", limit=limit)\n    \n        target = np.asarray(target)\n>       left_distances = abs(self.values[left_indexer] - target)",
        "\npandas/core/indexes/base.py:3077: UFuncTypeError"
    ],
    [
        "self = <test_indexing.TestDataFrameIndexing object at 0x1251473a0>\ntz_aware_fixture = tzlocal()\n\n    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n    \n        expected = df.head(3)\n>       actual = df.reindex(idx[:3], method=\"nearest\")\n\npandas/tests/frame/indexing/test_indexing.py:1612: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/util/_decorators.py:227: in wrapper\n    return func(*args, **kwargs)\npandas/core/frame.py:3887: in reindex\n    return self._ensure_type(super().reindex(**kwargs))\npandas/core/generic.py:4372: in reindex\n    return self._reindex_axes(\npandas/core/frame.py:3735: in _reindex_axes\n    frame = frame._reindex_index(\npandas/core/frame.py:3751: in _reindex_index\n    new_index, indexer = self.index.reindex(\npandas/core/indexes/base.py:3382: in reindex\n    indexer = self.get_indexer(\npandas/core/indexes/base.py:2992: in get_indexer\n    indexer = self._get_nearest_indexer(target, limit, tolerance)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = DatetimeIndex(['2019-01-01 00:00:00+00:00', '2019-01-02 00:00:00+00:00',\n               '2019-01-03 00:00:00+00:00', '...0:00:00+00:00',\n               '2019-01-05 00:00:00+00:00'],\n              dtype='datetime64[ns, tzlocal()]', freq='D')\ntarget = array([Timestamp('2019-01-01 00:00:00+0000', tz='tzlocal()', freq='D'),\n       Timestamp('2019-01-02 00:00:00+0000', tz='tzlocal()', freq='D'),\n       Timestamp('2019-01-03 00:00:00+0000', tz='tzlocal()', freq='D')],\n      dtype=object)\nlimit = None, tolerance = None\n\n    def _get_nearest_indexer(self, target: \"Index\", limit, tolerance) -> np.ndarray:\n        \"\"\"\n        Get the indexer for the nearest index labels; requires an index with\n        values that can be subtracted from each other (e.g., not strings or\n        tuples).\n        \"\"\"\n        left_indexer = self.get_indexer(target, \"pad\", limit=limit)\n        right_indexer = self.get_indexer(target, \"backfill\", limit=limit)\n    \n        target = np.asarray(target)\n>       left_distances = abs(self.values[left_indexer] - target)",
        "\npandas/core/indexes/base.py:3077: UFuncTypeError"
    ],
    [
        "self = <test_indexing.TestDataFrameIndexing object at 0x124f4fc70>\ntz_aware_fixture = pytz.FixedOffset(300)\n\n    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n    \n        expected = df.head(3)\n>       actual = df.reindex(idx[:3], method=\"nearest\")\n\npandas/tests/frame/indexing/test_indexing.py:1612: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/util/_decorators.py:227: in wrapper\n    return func(*args, **kwargs)\npandas/core/frame.py:3887: in reindex\n    return self._ensure_type(super().reindex(**kwargs))\npandas/core/generic.py:4372: in reindex\n    return self._reindex_axes(\npandas/core/frame.py:3735: in _reindex_axes\n    frame = frame._reindex_index(\npandas/core/frame.py:3751: in _reindex_index\n    new_index, indexer = self.index.reindex(\npandas/core/indexes/base.py:3382: in reindex\n    indexer = self.get_indexer(\npandas/core/indexes/base.py:2992: in get_indexer\n    indexer = self._get_nearest_indexer(target, limit, tolerance)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = DatetimeIndex(['2019-01-01 00:00:00+05:00', '2019-01-02 00:00:00+05:00',\n               '2019-01-03 00:00:00+05:00', '...0',\n               '2019-01-05 00:00:00+05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(300)]', freq='D')\ntarget = array([Timestamp('2019-01-01 00:00:00+0500', tz='pytz.FixedOffset(300)', freq='D'),\n       Timestamp('2019-01-02 00:00...)', freq='D'),\n       Timestamp('2019-01-03 00:00:00+0500', tz='pytz.FixedOffset(300)', freq='D')],\n      dtype=object)\nlimit = None, tolerance = None\n\n    def _get_nearest_indexer(self, target: \"Index\", limit, tolerance) -> np.ndarray:\n        \"\"\"\n        Get the indexer for the nearest index labels; requires an index with\n        values that can be subtracted from each other (e.g., not strings or\n        tuples).\n        \"\"\"\n        left_indexer = self.get_indexer(target, \"pad\", limit=limit)\n        right_indexer = self.get_indexer(target, \"backfill\", limit=limit)\n    \n        target = np.asarray(target)\n>       left_distances = abs(self.values[left_indexer] - target)",
        "\npandas/core/indexes/base.py:3077: UFuncTypeError"
    ],
    [
        "self = <test_indexing.TestDataFrameIndexing object at 0x125974760>\ntz_aware_fixture = <UTC>\n\n    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n    \n        expected = df.head(3)\n>       actual = df.reindex(idx[:3], method=\"nearest\")\n\npandas/tests/frame/indexing/test_indexing.py:1612: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/util/_decorators.py:227: in wrapper\n    return func(*args, **kwargs)\npandas/core/frame.py:3887: in reindex\n    return self._ensure_type(super().reindex(**kwargs))\npandas/core/generic.py:4372: in reindex\n    return self._reindex_axes(\npandas/core/frame.py:3735: in _reindex_axes\n    frame = frame._reindex_index(\npandas/core/frame.py:3751: in _reindex_index\n    new_index, indexer = self.index.reindex(\npandas/core/indexes/base.py:3382: in reindex\n    indexer = self.get_indexer(\npandas/core/indexes/base.py:2992: in get_indexer\n    indexer = self._get_nearest_indexer(target, limit, tolerance)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = DatetimeIndex(['2019-01-01 00:00:00+00:00', '2019-01-02 00:00:00+00:00',\n               '2019-01-03 00:00:00+00:00', '...1-04 00:00:00+00:00',\n               '2019-01-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='D')\ntarget = array([Timestamp('2019-01-01 00:00:00+0000', tz='UTC', freq='D'),\n       Timestamp('2019-01-02 00:00:00+0000', tz='UTC', freq='D'),\n       Timestamp('2019-01-03 00:00:00+0000', tz='UTC', freq='D')],\n      dtype=object)\nlimit = None, tolerance = None\n\n    def _get_nearest_indexer(self, target: \"Index\", limit, tolerance) -> np.ndarray:\n        \"\"\"\n        Get the indexer for the nearest index labels; requires an index with\n        values that can be subtracted from each other (e.g., not strings or\n        tuples).\n        \"\"\"\n        left_indexer = self.get_indexer(target, \"pad\", limit=limit)\n        right_indexer = self.get_indexer(target, \"backfill\", limit=limit)\n    \n        target = np.asarray(target)\n>       left_distances = abs(self.values[left_indexer] - target)",
        "\npandas/core/indexes/base.py:3077: UFuncTypeError"
    ],
    [
        "self = <test_indexing.TestDataFrameIndexing object at 0x125854520>\ntz_aware_fixture = pytz.FixedOffset(-300)\n\n    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n    \n        expected = df.head(3)\n>       actual = df.reindex(idx[:3], method=\"nearest\")\n\npandas/tests/frame/indexing/test_indexing.py:1612: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/util/_decorators.py:227: in wrapper\n    return func(*args, **kwargs)\npandas/core/frame.py:3887: in reindex\n    return self._ensure_type(super().reindex(**kwargs))\npandas/core/generic.py:4372: in reindex\n    return self._reindex_axes(\npandas/core/frame.py:3735: in _reindex_axes\n    frame = frame._reindex_index(\npandas/core/frame.py:3751: in _reindex_index\n    new_index, indexer = self.index.reindex(\npandas/core/indexes/base.py:3382: in reindex\n    indexer = self.get_indexer(\npandas/core/indexes/base.py:2992: in get_indexer\n    indexer = self._get_nearest_indexer(target, limit, tolerance)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = DatetimeIndex(['2019-01-01 00:00:00-05:00', '2019-01-02 00:00:00-05:00',\n               '2019-01-03 00:00:00-05:00', '...',\n               '2019-01-05 00:00:00-05:00'],\n              dtype='datetime64[ns, pytz.FixedOffset(-300)]', freq='D')\ntarget = array([Timestamp('2019-01-01 00:00:00-0500', tz='pytz.FixedOffset(-300)', freq='D'),\n       Timestamp('2019-01-02 00:0...', freq='D'),\n       Timestamp('2019-01-03 00:00:00-0500', tz='pytz.FixedOffset(-300)', freq='D')],\n      dtype=object)\nlimit = None, tolerance = None\n\n    def _get_nearest_indexer(self, target: \"Index\", limit, tolerance) -> np.ndarray:\n        \"\"\"\n        Get the indexer for the nearest index labels; requires an index with\n        values that can be subtracted from each other (e.g., not strings or\n        tuples).\n        \"\"\"\n        left_indexer = self.get_indexer(target, \"pad\", limit=limit)\n        right_indexer = self.get_indexer(target, \"backfill\", limit=limit)\n    \n        target = np.asarray(target)\n>       left_distances = abs(self.values[left_indexer] - target)",
        "\npandas/core/indexes/base.py:3077: UFuncTypeError"
    ],
    [
        "self = <test_indexing.TestDataFrameIndexing object at 0x125b7fd60>\ntz_aware_fixture = datetime.timezone.utc\n\n    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n    \n        expected = df.head(3)\n>       actual = df.reindex(idx[:3], method=\"nearest\")\n\npandas/tests/frame/indexing/test_indexing.py:1612: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/util/_decorators.py:227: in wrapper\n    return func(*args, **kwargs)\npandas/core/frame.py:3887: in reindex\n    return self._ensure_type(super().reindex(**kwargs))\npandas/core/generic.py:4372: in reindex\n    return self._reindex_axes(\npandas/core/frame.py:3735: in _reindex_axes\n    frame = frame._reindex_index(\npandas/core/frame.py:3751: in _reindex_index\n    new_index, indexer = self.index.reindex(\npandas/core/indexes/base.py:3382: in reindex\n    indexer = self.get_indexer(\npandas/core/indexes/base.py:2992: in get_indexer\n    indexer = self._get_nearest_indexer(target, limit, tolerance)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = DatetimeIndex(['2019-01-01 00:00:00+00:00', '2019-01-02 00:00:00+00:00',\n               '2019-01-03 00:00:00+00:00', '...1-04 00:00:00+00:00',\n               '2019-01-05 00:00:00+00:00'],\n              dtype='datetime64[ns, UTC]', freq='D')\ntarget = array([Timestamp('2019-01-01 00:00:00+0000', tz='UTC', freq='D'),\n       Timestamp('2019-01-02 00:00:00+0000', tz='UTC', freq='D'),\n       Timestamp('2019-01-03 00:00:00+0000', tz='UTC', freq='D')],\n      dtype=object)\nlimit = None, tolerance = None\n\n    def _get_nearest_indexer(self, target: \"Index\", limit, tolerance) -> np.ndarray:\n        \"\"\"\n        Get the indexer for the nearest index labels; requires an index with\n        values that can be subtracted from each other (e.g., not strings or\n        tuples).\n        \"\"\"\n        left_indexer = self.get_indexer(target, \"pad\", limit=limit)\n        right_indexer = self.get_indexer(target, \"backfill\", limit=limit)\n    \n        target = np.asarray(target)\n>       left_distances = abs(self.values[left_indexer] - target)",
        "\npandas/core/indexes/base.py:3077: UFuncTypeError"
    ],
    [
        "self = <test_indexing.TestDataFrameIndexing object at 0x11cd43850>\ntz_aware_fixture = datetime.timezone(datetime.timedelta(seconds=3600))\n\n    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n    \n        expected = df.head(3)\n>       actual = df.reindex(idx[:3], method=\"nearest\")\n\npandas/tests/frame/indexing/test_indexing.py:1612: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/util/_decorators.py:227: in wrapper\n    return func(*args, **kwargs)\npandas/core/frame.py:3887: in reindex\n    return self._ensure_type(super().reindex(**kwargs))\npandas/core/generic.py:4372: in reindex\n    return self._reindex_axes(\npandas/core/frame.py:3735: in _reindex_axes\n    frame = frame._reindex_index(\npandas/core/frame.py:3751: in _reindex_index\n    new_index, indexer = self.index.reindex(\npandas/core/indexes/base.py:3382: in reindex\n    indexer = self.get_indexer(\npandas/core/indexes/base.py:2992: in get_indexer\n    indexer = self._get_nearest_indexer(target, limit, tolerance)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = DatetimeIndex(['2019-01-01 00:00:00+01:00', '2019-01-02 00:00:00+01:00',\n               '2019-01-03 00:00:00+01:00', '...0:00:00+01:00',\n               '2019-01-05 00:00:00+01:00'],\n              dtype='datetime64[ns, UTC+01:00]', freq='D')\ntarget = array([Timestamp('2019-01-01 00:00:00+0100', tz='UTC+01:00', freq='D'),\n       Timestamp('2019-01-02 00:00:00+0100', tz='UTC+01:00', freq='D'),\n       Timestamp('2019-01-03 00:00:00+0100', tz='UTC+01:00', freq='D')],\n      dtype=object)\nlimit = None, tolerance = None\n\n    def _get_nearest_indexer(self, target: \"Index\", limit, tolerance) -> np.ndarray:\n        \"\"\"\n        Get the indexer for the nearest index labels; requires an index with\n        values that can be subtracted from each other (e.g., not strings or\n        tuples).\n        \"\"\"\n        left_indexer = self.get_indexer(target, \"pad\", limit=limit)\n        right_indexer = self.get_indexer(target, \"backfill\", limit=limit)\n    \n        target = np.asarray(target)\n>       left_distances = abs(self.values[left_indexer] - target)",
        "\npandas/core/indexes/base.py:3077: UFuncTypeError"
    ],
    [
        "self = <test_indexing.TestDataFrameIndexing object at 0x124e63700>\ntz_aware_fixture = datetime.timezone(datetime.timedelta(days=-1, seconds=82800), 'foo')\n\n    def test_reindex_nearest_tz(self, tz_aware_fixture):\n        # GH26683\n        tz = tz_aware_fixture\n        idx = pd.date_range(\"2019-01-01\", periods=5, tz=tz)\n        df = pd.DataFrame({\"x\": list(range(5))}, index=idx)\n    \n        expected = df.head(3)\n>       actual = df.reindex(idx[:3], method=\"nearest\")\n\npandas/tests/frame/indexing/test_indexing.py:1612: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/util/_decorators.py:227: in wrapper\n    return func(*args, **kwargs)\npandas/core/frame.py:3887: in reindex\n    return self._ensure_type(super().reindex(**kwargs))\npandas/core/generic.py:4372: in reindex\n    return self._reindex_axes(\npandas/core/frame.py:3735: in _reindex_axes\n    frame = frame._reindex_index(\npandas/core/frame.py:3751: in _reindex_index\n    new_index, indexer = self.index.reindex(\npandas/core/indexes/base.py:3382: in reindex\n    indexer = self.get_indexer(\npandas/core/indexes/base.py:2992: in get_indexer\n    indexer = self._get_nearest_indexer(target, limit, tolerance)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = DatetimeIndex(['2019-01-01 00:00:00-01:00', '2019-01-02 00:00:00-01:00',\n               '2019-01-03 00:00:00-01:00', '...1-04 00:00:00-01:00',\n               '2019-01-05 00:00:00-01:00'],\n              dtype='datetime64[ns, foo]', freq='D')\ntarget = array([Timestamp('2019-01-01 00:00:00-0100', tz='foo', freq='D'),\n       Timestamp('2019-01-02 00:00:00-0100', tz='foo', freq='D'),\n       Timestamp('2019-01-03 00:00:00-0100', tz='foo', freq='D')],\n      dtype=object)\nlimit = None, tolerance = None\n\n    def _get_nearest_indexer(self, target: \"Index\", limit, tolerance) -> np.ndarray:\n        \"\"\"\n        Get the indexer for the nearest index labels; requires an index with\n        values that can be subtracted from each other (e.g., not strings or\n        tuples).\n        \"\"\"\n        left_indexer = self.get_indexer(target, \"pad\", limit=limit)\n        right_indexer = self.get_indexer(target, \"backfill\", limit=limit)\n    \n        target = np.asarray(target)\n>       left_distances = abs(self.values[left_indexer] - target)",
        "\npandas/core/indexes/base.py:3077: UFuncTypeError"
    ]
]
```
