{
    "pandas:93": {
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_93/pandas/core/arrays/datetimelike.py": {
            "buggy_functions": [
                {
                    "function_name": "_datetimelike_array_cmp",
                    "function_code": "def _datetimelike_array_cmp(cls, op):\n    \"\"\"\n    Wrap comparison operations to convert Timestamp/Timedelta/Period-like to\n    boxed scalars/arrays.\n    \"\"\"\n    opname = f\"__{op.__name__}__\"\n    nat_result = opname == \"__ne__\"\n\n    @unpack_zerodim_and_defer(opname)\n    def wrapper(self, other):\n\n        if isinstance(other, str):\n            try:\n                # GH#18435 strings get a pass from tzawareness compat\n                other = self._scalar_from_string(other)\n            except ValueError:\n                # failed to parse as Timestamp/Timedelta/Period\n                return invalid_comparison(self, other, op)\n\n        if isinstance(other, self._recognized_scalars) or other is NaT:\n            other = self._scalar_type(other)\n            self._check_compatible_with(other)\n\n            other_i8 = self._unbox_scalar(other)\n\n            result = op(self.view(\"i8\"), other_i8)\n            if isna(other):\n                result.fill(nat_result)\n\n        elif not is_list_like(other):\n            return invalid_comparison(self, other, op)\n\n        elif len(other) != len(self):\n            raise ValueError(\"Lengths must match\")\n\n        else:\n            if isinstance(other, list):\n                # TODO: could use pd.Index to do inference?\n                other = np.array(other)\n\n            if not isinstance(other, (np.ndarray, type(self))):\n                return invalid_comparison(self, other, op)\n\n            if is_object_dtype(other):\n                # We have to use comp_method_OBJECT_ARRAY instead of numpy\n                #  comparison otherwise it would fail to raise when\n                #  comparing tz-aware and tz-naive\n                with np.errstate(all=\"ignore\"):\n                    result = ops.comp_method_OBJECT_ARRAY(\n                        op, self.astype(object), other\n                    )\n                o_mask = isna(other)\n\n            elif not type(self)._is_recognized_dtype(other.dtype):\n                return invalid_comparison(self, other, op)\n\n            else:\n                # For PeriodDType this casting is unnecessary\n                other = type(self)._from_sequence(other)\n                self._check_compatible_with(other)\n\n                result = op(self.view(\"i8\"), other.view(\"i8\"))\n                o_mask = other._isnan\n\n            if o_mask.any():\n                result[o_mask] = nat_result\n\n        if self._hasnans:\n            result[self._isnan] = nat_result\n\n        return result\n\n    return set_function_name(wrapper, opname, cls)\n",
                    "decorators": [],
                    "docstring": "Wrap comparison operations to convert Timestamp/Timedelta/Period-like to\nboxed scalars/arrays.",
                    "start_line": 54,
                    "variables": {
                        "opname": [
                            126,
                            59,
                            60,
                            62
                        ],
                        "op.__name__": [
                            59
                        ],
                        "op": [
                            71,
                            103,
                            108,
                            79,
                            115,
                            84,
                            59,
                            95
                        ],
                        "nat_result": [
                            81,
                            122,
                            60,
                            119
                        ],
                        "isinstance": [
                            73,
                            65,
                            90,
                            94
                        ],
                        "other": [
                            65,
                            68,
                            71,
                            73,
                            74,
                            75,
                            77,
                            80,
                            83,
                            84,
                            86,
                            90,
                            92,
                            94,
                            95,
                            97,
                            103,
                            105,
                            107,
                            108,
                            112,
                            113,
                            115,
                            116
                        ],
                        "str": [
                            65
                        ],
                        "self._scalar_from_string": [
                            68
                        ],
                        "self": [
                            68,
                            71,
                            73,
                            74,
                            75,
                            77,
                            79,
                            84,
                            86,
                            94,
                            95,
                            103,
                            107,
                            108,
                            112,
                            113,
                            115,
                            121,
                            122
                        ],
                        "ValueError": [
                            69,
                            87
                        ],
                        "invalid_comparison": [
                            108,
                            84,
                            95,
                            71
                        ],
                        "self._recognized_scalars": [
                            73
                        ],
                        "NaT": [
                            73
                        ],
                        "self._scalar_type": [
                            74
                        ],
                        "self._check_compatible_with": [
                            113,
                            75
                        ],
                        "other_i8": [
                            77,
                            79
                        ],
                        "self._unbox_scalar": [
                            77
                        ],
                        "result": [
                            102,
                            79,
                            81,
                            115,
                            119,
                            122,
                            124
                        ],
                        "self.view": [
                            115,
                            79
                        ],
                        "isna": [
                            80,
                            105
                        ],
                        "result.fill": [
                            81
                        ],
                        "is_list_like": [
                            83
                        ],
                        "len": [
                            86
                        ],
                        "list": [
                            90
                        ],
                        "np.array": [
                            92
                        ],
                        "np": [
                            92,
                            101,
                            94
                        ],
                        "np.ndarray": [
                            94
                        ],
                        "type": [
                            112,
                            107,
                            94
                        ],
                        "is_object_dtype": [
                            97
                        ],
                        "np.errstate": [
                            101
                        ],
                        "ops.comp_method_OBJECT_ARRAY": [
                            102
                        ],
                        "ops": [
                            102
                        ],
                        "self.astype": [
                            103
                        ],
                        "object": [
                            103
                        ],
                        "o_mask": [
                            105,
                            116,
                            118,
                            119
                        ],
                        "_is_recognized_dtype": [
                            107
                        ],
                        "other.dtype": [
                            107
                        ],
                        "_from_sequence": [
                            112
                        ],
                        "other.view": [
                            115
                        ],
                        "other._isnan": [
                            116
                        ],
                        "o_mask.any": [
                            118
                        ],
                        "self._hasnans": [
                            121
                        ],
                        "self._isnan": [
                            122
                        ],
                        "unpack_zerodim_and_defer": [
                            62
                        ],
                        "set_function_name": [
                            126
                        ],
                        "wrapper": [
                            126
                        ],
                        "cls": [
                            126
                        ]
                    },
                    "filtered_variables": {
                        "opname": [
                            126,
                            59,
                            60,
                            62
                        ],
                        "op.__name__": [
                            59
                        ],
                        "op": [
                            71,
                            103,
                            108,
                            79,
                            115,
                            84,
                            59,
                            95
                        ],
                        "nat_result": [
                            81,
                            122,
                            60,
                            119
                        ],
                        "other": [
                            65,
                            68,
                            71,
                            73,
                            74,
                            75,
                            77,
                            80,
                            83,
                            84,
                            86,
                            90,
                            92,
                            94,
                            95,
                            97,
                            103,
                            105,
                            107,
                            108,
                            112,
                            113,
                            115,
                            116
                        ],
                        "self._scalar_from_string": [
                            68
                        ],
                        "self": [
                            68,
                            71,
                            73,
                            74,
                            75,
                            77,
                            79,
                            84,
                            86,
                            94,
                            95,
                            103,
                            107,
                            108,
                            112,
                            113,
                            115,
                            121,
                            122
                        ],
                        "invalid_comparison": [
                            108,
                            84,
                            95,
                            71
                        ],
                        "self._recognized_scalars": [
                            73
                        ],
                        "NaT": [
                            73
                        ],
                        "self._scalar_type": [
                            74
                        ],
                        "self._check_compatible_with": [
                            113,
                            75
                        ],
                        "other_i8": [
                            77,
                            79
                        ],
                        "self._unbox_scalar": [
                            77
                        ],
                        "result": [
                            102,
                            79,
                            81,
                            115,
                            119,
                            122,
                            124
                        ],
                        "self.view": [
                            115,
                            79
                        ],
                        "isna": [
                            80,
                            105
                        ],
                        "result.fill": [
                            81
                        ],
                        "is_list_like": [
                            83
                        ],
                        "np.array": [
                            92
                        ],
                        "np": [
                            92,
                            101,
                            94
                        ],
                        "np.ndarray": [
                            94
                        ],
                        "is_object_dtype": [
                            97
                        ],
                        "np.errstate": [
                            101
                        ],
                        "ops.comp_method_OBJECT_ARRAY": [
                            102
                        ],
                        "ops": [
                            102
                        ],
                        "self.astype": [
                            103
                        ],
                        "o_mask": [
                            105,
                            116,
                            118,
                            119
                        ],
                        "_is_recognized_dtype": [
                            107
                        ],
                        "other.dtype": [
                            107
                        ],
                        "_from_sequence": [
                            112
                        ],
                        "other.view": [
                            115
                        ],
                        "other._isnan": [
                            116
                        ],
                        "o_mask.any": [
                            118
                        ],
                        "self._hasnans": [
                            121
                        ],
                        "self._isnan": [
                            122
                        ],
                        "unpack_zerodim_and_defer": [
                            62
                        ],
                        "set_function_name": [
                            126
                        ],
                        "wrapper": [
                            126
                        ],
                        "cls": [
                            126
                        ]
                    },
                    "diff_line_number": 54,
                    "class_data": null,
                    "variable_values": [
                        [
                            {
                                "opname": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "op.__name__": {
                                    "variable_value": "'eq'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function eq>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result.fill": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x107e470e0>"
                                }
                            },
                            {
                                "opname": {
                                    "variable_value": "'__eq__'",
                                    "variable_type": "str",
                                    "variable_shape": "6"
                                },
                                "op.__name__": {
                                    "variable_value": "'eq'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function eq>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result.fill": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>.wrapper at 0x107e69790>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x107e470e0>"
                                }
                            }
                        ],
                        [
                            {
                                "opname": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "op.__name__": {
                                    "variable_value": "'ne'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function ne>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result.fill": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x107e470e0>"
                                }
                            },
                            {
                                "opname": {
                                    "variable_value": "'__ne__'",
                                    "variable_type": "str",
                                    "variable_shape": "6"
                                },
                                "op.__name__": {
                                    "variable_value": "'ne'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function ne>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result.fill": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>.wrapper at 0x107e69d30>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x107e470e0>"
                                }
                            }
                        ],
                        [
                            {
                                "opname": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "op.__name__": {
                                    "variable_value": "'lt'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function lt>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result.fill": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x107e470e0>"
                                }
                            },
                            {
                                "opname": {
                                    "variable_value": "'__lt__'",
                                    "variable_type": "str",
                                    "variable_shape": "6"
                                },
                                "op.__name__": {
                                    "variable_value": "'lt'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function lt>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result.fill": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>.wrapper at 0x107e71310>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x107e470e0>"
                                }
                            }
                        ],
                        [
                            {
                                "opname": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "op.__name__": {
                                    "variable_value": "'gt'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function gt>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result.fill": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x107e470e0>"
                                }
                            },
                            {
                                "opname": {
                                    "variable_value": "'__gt__'",
                                    "variable_type": "str",
                                    "variable_shape": "6"
                                },
                                "op.__name__": {
                                    "variable_value": "'gt'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function gt>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result.fill": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>.wrapper at 0x107e718b0>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x107e470e0>"
                                }
                            }
                        ],
                        [
                            {
                                "opname": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "op.__name__": {
                                    "variable_value": "'le'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function le>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result.fill": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x107e470e0>"
                                }
                            },
                            {
                                "opname": {
                                    "variable_value": "'__le__'",
                                    "variable_type": "str",
                                    "variable_shape": "6"
                                },
                                "op.__name__": {
                                    "variable_value": "'le'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function le>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result.fill": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>.wrapper at 0x107e71e50>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x107e470e0>"
                                }
                            }
                        ],
                        [
                            {
                                "opname": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "op.__name__": {
                                    "variable_value": "'ge'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function ge>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result.fill": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x107e470e0>"
                                }
                            },
                            {
                                "opname": {
                                    "variable_value": "'__ge__'",
                                    "variable_type": "str",
                                    "variable_shape": "6"
                                },
                                "op.__name__": {
                                    "variable_value": "'ge'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function ge>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result.fill": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>.wrapper at 0x10866e430>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x107e470e0>"
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "opname": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "op.__name__": {
                                    "variable_value": "'eq'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function eq>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result.fill": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10c37df90>"
                                }
                            },
                            {
                                "opname": {
                                    "variable_value": "'__eq__'",
                                    "variable_type": "str",
                                    "variable_shape": "6"
                                },
                                "op.__name__": {
                                    "variable_value": "'eq'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function eq>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result.fill": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>.wrapper at 0x10bb67790>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10c37df90>"
                                }
                            }
                        ],
                        [
                            {
                                "opname": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "op.__name__": {
                                    "variable_value": "'ne'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function ne>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result.fill": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10c37df90>"
                                }
                            },
                            {
                                "opname": {
                                    "variable_value": "'__ne__'",
                                    "variable_type": "str",
                                    "variable_shape": "6"
                                },
                                "op.__name__": {
                                    "variable_value": "'ne'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function ne>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result.fill": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>.wrapper at 0x10bb67af0>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10c37df90>"
                                }
                            }
                        ],
                        [
                            {
                                "opname": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "op.__name__": {
                                    "variable_value": "'lt'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function lt>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result.fill": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10c37df90>"
                                }
                            },
                            {
                                "opname": {
                                    "variable_value": "'__lt__'",
                                    "variable_type": "str",
                                    "variable_shape": "6"
                                },
                                "op.__name__": {
                                    "variable_value": "'lt'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function lt>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result.fill": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>.wrapper at 0x10bb710d0>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10c37df90>"
                                }
                            }
                        ],
                        [
                            {
                                "opname": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "op.__name__": {
                                    "variable_value": "'gt'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function gt>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result.fill": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10c37df90>"
                                }
                            },
                            {
                                "opname": {
                                    "variable_value": "'__gt__'",
                                    "variable_type": "str",
                                    "variable_shape": "6"
                                },
                                "op.__name__": {
                                    "variable_value": "'gt'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function gt>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result.fill": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>.wrapper at 0x10bb71670>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10c37df90>"
                                }
                            }
                        ],
                        [
                            {
                                "opname": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "op.__name__": {
                                    "variable_value": "'le'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function le>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result.fill": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10c37df90>"
                                }
                            },
                            {
                                "opname": {
                                    "variable_value": "'__le__'",
                                    "variable_type": "str",
                                    "variable_shape": "6"
                                },
                                "op.__name__": {
                                    "variable_value": "'le'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function le>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result.fill": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>.wrapper at 0x10bb71c10>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10c37df90>"
                                }
                            }
                        ],
                        [
                            {
                                "opname": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "op.__name__": {
                                    "variable_value": "'ge'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function ge>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result.fill": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10c37df90>"
                                }
                            },
                            {
                                "opname": {
                                    "variable_value": "'__ge__'",
                                    "variable_type": "str",
                                    "variable_shape": "6"
                                },
                                "op.__name__": {
                                    "variable_value": "'ge'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "op": {
                                    "variable_value": "<built-in function ge>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "nat_result": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_from_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "invalid_comparison": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._recognized_scalars": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._scalar_type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._check_compatible_with": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other_i8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._unbox_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result.fill": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ndarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.errstate": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops.comp_method_OBJECT_ARRAY": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ops": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.astype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_is_recognized_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_from_sequence": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "o_mask.any": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._hasnans": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "unpack_zerodim_and_defer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "set_function_name": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "wrapper": {
                                    "variable_value": "<function _datetimelike_array_cmp.<locals>.wrapper at 0x10c3b91f0>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "cls": {
                                    "variable_value": "<class 'pandas.core.arrays.datetimelike.DatetimeLikeArrayMixin'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10c37df90>"
                                }
                            }
                        ]
                    ]
                },
                {
                    "function_name": "_simple_new",
                    "function_code": "@classmethod\ndef _simple_new(cls, values, **kwargs):\n    raise AbstractMethodError(cls)\n",
                    "decorators": [
                        "classmethod"
                    ],
                    "docstring": null,
                    "start_line": 132,
                    "variables": {
                        "AbstractMethodError": [
                            134
                        ],
                        "cls": [
                            134
                        ],
                        "classmethod": [
                            132
                        ]
                    },
                    "filtered_variables": {
                        "AbstractMethodError": [
                            134
                        ],
                        "cls": [
                            134
                        ]
                    },
                    "diff_line_number": 133,
                    "class_data": {
                        "signature": "class AttributesMixin()",
                        "docstring": null,
                        "constructor_docstring": null,
                        "functions": [
                            "@classmethod\ndef _simple_new(cls, values, **kwargs):\n    raise AbstractMethodError(cls)",
                            "@property\ndef _scalar_type(self) -> Type[DatetimeLikeScalar]:\n    \"\"\"The scalar associated with this datelike\n\n    * PeriodArray : Period\n    * DatetimeArray : Timestamp\n    * TimedeltaArray : Timedelta\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _scalar_from_string(self, value: str) -> Union[Period, Timestamp, Timedelta, NaTType]:\n    \"\"\"\n    Construct a scalar type from a string.\n\n    Parameters\n    ----------\n    value : str\n\n    Returns\n    -------\n    Period, Timestamp, or Timedelta, or NaT\n        Whatever the type of ``self._scalar_type`` is.\n\n    Notes\n    -----\n    This should call ``self._check_compatible_with`` before\n    unboxing the result.\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _unbox_scalar(self, value: Union[Period, Timestamp, Timedelta, NaTType]) -> int:\n    \"\"\"\n    Unbox the integer value of a scalar `value`.\n\n    Parameters\n    ----------\n    value : Union[Period, Timestamp, Timedelta]\n\n    Returns\n    -------\n    int\n\n    Examples\n    --------\n    >>> self._unbox_scalar(Timedelta('10s'))  # DOCTEST: +SKIP\n    10000000000\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _check_compatible_with(self, other: Union[Period, Timestamp, Timedelta, NaTType], setitem: bool=False) -> None:\n    \"\"\"\n    Verify that `self` and `other` are compatible.\n\n    * DatetimeArray verifies that the timezones (if any) match\n    * PeriodArray verifies that the freq matches\n    * Timedelta has no verification\n\n    In each case, NaT is considered compatible.\n\n    Parameters\n    ----------\n    other\n    setitem : bool, default False\n        For __setitem__ we may have stricter compatiblity resrictions than\n        for comparisons.\n\n    Raises\n    ------\n    Exception\n    \"\"\"\n    raise AbstractMethodError(self)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_data"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_simple_new(cls, values, **kwargs)",
                            "_scalar_type(self) -> Type[DatetimeLikeScalar]",
                            "_scalar_from_string(self, value: str) -> Union[Period, Timestamp, Timedelta, NaTType]",
                            "_unbox_scalar(self, value: Union[Period, Timestamp, Timedelta, NaTType]) -> int",
                            "_check_compatible_with(self, other: Union[Period, Timestamp, Timedelta, NaTType], setitem: bool=False) -> None"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_scalar_type",
                    "function_code": "@property\ndef _scalar_type(self) -> Type[DatetimeLikeScalar]:\n    \"\"\"The scalar associated with this datelike\n\n    * PeriodArray : Period\n    * DatetimeArray : Timestamp\n    * TimedeltaArray : Timedelta\n    \"\"\"\n    raise AbstractMethodError(self)\n",
                    "decorators": [
                        "property"
                    ],
                    "docstring": "The scalar associated with this datelike\n\n* PeriodArray : Period\n* DatetimeArray : Timestamp\n* TimedeltaArray : Timedelta",
                    "start_line": 136,
                    "variables": {
                        "AbstractMethodError": [
                            144
                        ],
                        "self": [
                            144
                        ],
                        "property": [
                            136
                        ],
                        "Type": [
                            137
                        ],
                        "DatetimeLikeScalar": [
                            137
                        ]
                    },
                    "filtered_variables": {
                        "AbstractMethodError": [
                            144
                        ],
                        "self": [
                            144
                        ],
                        "Type": [
                            137
                        ],
                        "DatetimeLikeScalar": [
                            137
                        ]
                    },
                    "diff_line_number": 137,
                    "class_data": {
                        "signature": "class AttributesMixin()",
                        "docstring": null,
                        "constructor_docstring": null,
                        "functions": [
                            "@classmethod\ndef _simple_new(cls, values, **kwargs):\n    raise AbstractMethodError(cls)",
                            "@property\ndef _scalar_type(self) -> Type[DatetimeLikeScalar]:\n    \"\"\"The scalar associated with this datelike\n\n    * PeriodArray : Period\n    * DatetimeArray : Timestamp\n    * TimedeltaArray : Timedelta\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _scalar_from_string(self, value: str) -> Union[Period, Timestamp, Timedelta, NaTType]:\n    \"\"\"\n    Construct a scalar type from a string.\n\n    Parameters\n    ----------\n    value : str\n\n    Returns\n    -------\n    Period, Timestamp, or Timedelta, or NaT\n        Whatever the type of ``self._scalar_type`` is.\n\n    Notes\n    -----\n    This should call ``self._check_compatible_with`` before\n    unboxing the result.\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _unbox_scalar(self, value: Union[Period, Timestamp, Timedelta, NaTType]) -> int:\n    \"\"\"\n    Unbox the integer value of a scalar `value`.\n\n    Parameters\n    ----------\n    value : Union[Period, Timestamp, Timedelta]\n\n    Returns\n    -------\n    int\n\n    Examples\n    --------\n    >>> self._unbox_scalar(Timedelta('10s'))  # DOCTEST: +SKIP\n    10000000000\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _check_compatible_with(self, other: Union[Period, Timestamp, Timedelta, NaTType], setitem: bool=False) -> None:\n    \"\"\"\n    Verify that `self` and `other` are compatible.\n\n    * DatetimeArray verifies that the timezones (if any) match\n    * PeriodArray verifies that the freq matches\n    * Timedelta has no verification\n\n    In each case, NaT is considered compatible.\n\n    Parameters\n    ----------\n    other\n    setitem : bool, default False\n        For __setitem__ we may have stricter compatiblity resrictions than\n        for comparisons.\n\n    Raises\n    ------\n    Exception\n    \"\"\"\n    raise AbstractMethodError(self)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_data"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_simple_new(cls, values, **kwargs)",
                            "_scalar_type(self) -> Type[DatetimeLikeScalar]",
                            "_scalar_from_string(self, value: str) -> Union[Period, Timestamp, Timedelta, NaTType]",
                            "_unbox_scalar(self, value: Union[Period, Timestamp, Timedelta, NaTType]) -> int",
                            "_check_compatible_with(self, other: Union[Period, Timestamp, Timedelta, NaTType], setitem: bool=False) -> None"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_scalar_from_string",
                    "function_code": "def _scalar_from_string(\n    self, value: str\n) -> Union[Period, Timestamp, Timedelta, NaTType]:\n    \"\"\"\n    Construct a scalar type from a string.\n\n    Parameters\n    ----------\n    value : str\n\n    Returns\n    -------\n    Period, Timestamp, or Timedelta, or NaT\n        Whatever the type of ``self._scalar_type`` is.\n\n    Notes\n    -----\n    This should call ``self._check_compatible_with`` before\n    unboxing the result.\n    \"\"\"\n    raise AbstractMethodError(self)\n",
                    "decorators": [],
                    "docstring": "Construct a scalar type from a string.\n\nParameters\n----------\nvalue : str\n\nReturns\n-------\nPeriod, Timestamp, or Timedelta, or NaT\n    Whatever the type of ``self._scalar_type`` is.\n\nNotes\n-----\nThis should call ``self._check_compatible_with`` before\nunboxing the result.",
                    "start_line": 146,
                    "variables": {
                        "str": [
                            147
                        ],
                        "AbstractMethodError": [
                            166
                        ],
                        "self": [
                            166
                        ],
                        "Union": [
                            148
                        ],
                        "Period": [
                            148
                        ],
                        "Timestamp": [
                            148
                        ],
                        "Timedelta": [
                            148
                        ],
                        "NaTType": [
                            148
                        ]
                    },
                    "filtered_variables": {
                        "AbstractMethodError": [
                            166
                        ],
                        "self": [
                            166
                        ],
                        "Union": [
                            148
                        ],
                        "Period": [
                            148
                        ],
                        "Timestamp": [
                            148
                        ],
                        "Timedelta": [
                            148
                        ],
                        "NaTType": [
                            148
                        ]
                    },
                    "diff_line_number": 146,
                    "class_data": {
                        "signature": "class AttributesMixin()",
                        "docstring": null,
                        "constructor_docstring": null,
                        "functions": [
                            "@classmethod\ndef _simple_new(cls, values, **kwargs):\n    raise AbstractMethodError(cls)",
                            "@property\ndef _scalar_type(self) -> Type[DatetimeLikeScalar]:\n    \"\"\"The scalar associated with this datelike\n\n    * PeriodArray : Period\n    * DatetimeArray : Timestamp\n    * TimedeltaArray : Timedelta\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _scalar_from_string(self, value: str) -> Union[Period, Timestamp, Timedelta, NaTType]:\n    \"\"\"\n    Construct a scalar type from a string.\n\n    Parameters\n    ----------\n    value : str\n\n    Returns\n    -------\n    Period, Timestamp, or Timedelta, or NaT\n        Whatever the type of ``self._scalar_type`` is.\n\n    Notes\n    -----\n    This should call ``self._check_compatible_with`` before\n    unboxing the result.\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _unbox_scalar(self, value: Union[Period, Timestamp, Timedelta, NaTType]) -> int:\n    \"\"\"\n    Unbox the integer value of a scalar `value`.\n\n    Parameters\n    ----------\n    value : Union[Period, Timestamp, Timedelta]\n\n    Returns\n    -------\n    int\n\n    Examples\n    --------\n    >>> self._unbox_scalar(Timedelta('10s'))  # DOCTEST: +SKIP\n    10000000000\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _check_compatible_with(self, other: Union[Period, Timestamp, Timedelta, NaTType], setitem: bool=False) -> None:\n    \"\"\"\n    Verify that `self` and `other` are compatible.\n\n    * DatetimeArray verifies that the timezones (if any) match\n    * PeriodArray verifies that the freq matches\n    * Timedelta has no verification\n\n    In each case, NaT is considered compatible.\n\n    Parameters\n    ----------\n    other\n    setitem : bool, default False\n        For __setitem__ we may have stricter compatiblity resrictions than\n        for comparisons.\n\n    Raises\n    ------\n    Exception\n    \"\"\"\n    raise AbstractMethodError(self)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_data"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_simple_new(cls, values, **kwargs)",
                            "_scalar_type(self) -> Type[DatetimeLikeScalar]",
                            "_scalar_from_string(self, value: str) -> Union[Period, Timestamp, Timedelta, NaTType]",
                            "_unbox_scalar(self, value: Union[Period, Timestamp, Timedelta, NaTType]) -> int",
                            "_check_compatible_with(self, other: Union[Period, Timestamp, Timedelta, NaTType], setitem: bool=False) -> None"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_unbox_scalar",
                    "function_code": "def _unbox_scalar(self, value: Union[Period, Timestamp, Timedelta, NaTType]) -> int:\n    \"\"\"\n    Unbox the integer value of a scalar `value`.\n\n    Parameters\n    ----------\n    value : Union[Period, Timestamp, Timedelta]\n\n    Returns\n    -------\n    int\n\n    Examples\n    --------\n    >>> self._unbox_scalar(Timedelta('10s'))  # DOCTEST: +SKIP\n    10000000000\n    \"\"\"\n    raise AbstractMethodError(self)\n",
                    "decorators": [],
                    "docstring": "Unbox the integer value of a scalar `value`.\n\nParameters\n----------\nvalue : Union[Period, Timestamp, Timedelta]\n\nReturns\n-------\nint\n\nExamples\n--------\n>>> self._unbox_scalar(Timedelta('10s'))  # DOCTEST: +SKIP\n10000000000",
                    "start_line": 168,
                    "variables": {
                        "Union": [
                            168
                        ],
                        "Period": [
                            168
                        ],
                        "Timestamp": [
                            168
                        ],
                        "Timedelta": [
                            168
                        ],
                        "NaTType": [
                            168
                        ],
                        "AbstractMethodError": [
                            185
                        ],
                        "self": [
                            185
                        ],
                        "int": [
                            168
                        ]
                    },
                    "filtered_variables": {
                        "Union": [
                            168
                        ],
                        "Period": [
                            168
                        ],
                        "Timestamp": [
                            168
                        ],
                        "Timedelta": [
                            168
                        ],
                        "NaTType": [
                            168
                        ],
                        "AbstractMethodError": [
                            185
                        ],
                        "self": [
                            185
                        ]
                    },
                    "diff_line_number": 168,
                    "class_data": {
                        "signature": "class AttributesMixin()",
                        "docstring": null,
                        "constructor_docstring": null,
                        "functions": [
                            "@classmethod\ndef _simple_new(cls, values, **kwargs):\n    raise AbstractMethodError(cls)",
                            "@property\ndef _scalar_type(self) -> Type[DatetimeLikeScalar]:\n    \"\"\"The scalar associated with this datelike\n\n    * PeriodArray : Period\n    * DatetimeArray : Timestamp\n    * TimedeltaArray : Timedelta\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _scalar_from_string(self, value: str) -> Union[Period, Timestamp, Timedelta, NaTType]:\n    \"\"\"\n    Construct a scalar type from a string.\n\n    Parameters\n    ----------\n    value : str\n\n    Returns\n    -------\n    Period, Timestamp, or Timedelta, or NaT\n        Whatever the type of ``self._scalar_type`` is.\n\n    Notes\n    -----\n    This should call ``self._check_compatible_with`` before\n    unboxing the result.\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _unbox_scalar(self, value: Union[Period, Timestamp, Timedelta, NaTType]) -> int:\n    \"\"\"\n    Unbox the integer value of a scalar `value`.\n\n    Parameters\n    ----------\n    value : Union[Period, Timestamp, Timedelta]\n\n    Returns\n    -------\n    int\n\n    Examples\n    --------\n    >>> self._unbox_scalar(Timedelta('10s'))  # DOCTEST: +SKIP\n    10000000000\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _check_compatible_with(self, other: Union[Period, Timestamp, Timedelta, NaTType], setitem: bool=False) -> None:\n    \"\"\"\n    Verify that `self` and `other` are compatible.\n\n    * DatetimeArray verifies that the timezones (if any) match\n    * PeriodArray verifies that the freq matches\n    * Timedelta has no verification\n\n    In each case, NaT is considered compatible.\n\n    Parameters\n    ----------\n    other\n    setitem : bool, default False\n        For __setitem__ we may have stricter compatiblity resrictions than\n        for comparisons.\n\n    Raises\n    ------\n    Exception\n    \"\"\"\n    raise AbstractMethodError(self)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_data"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_simple_new(cls, values, **kwargs)",
                            "_scalar_type(self) -> Type[DatetimeLikeScalar]",
                            "_scalar_from_string(self, value: str) -> Union[Period, Timestamp, Timedelta, NaTType]",
                            "_unbox_scalar(self, value: Union[Period, Timestamp, Timedelta, NaTType]) -> int",
                            "_check_compatible_with(self, other: Union[Period, Timestamp, Timedelta, NaTType], setitem: bool=False) -> None"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_check_compatible_with",
                    "function_code": "def _check_compatible_with(\n    self, other: Union[Period, Timestamp, Timedelta, NaTType], setitem: bool = False\n) -> None:\n    \"\"\"\n    Verify that `self` and `other` are compatible.\n\n    * DatetimeArray verifies that the timezones (if any) match\n    * PeriodArray verifies that the freq matches\n    * Timedelta has no verification\n\n    In each case, NaT is considered compatible.\n\n    Parameters\n    ----------\n    other\n    setitem : bool, default False\n        For __setitem__ we may have stricter compatiblity resrictions than\n        for comparisons.\n\n    Raises\n    ------\n    Exception\n    \"\"\"\n    raise AbstractMethodError(self)\n",
                    "decorators": [],
                    "docstring": "Verify that `self` and `other` are compatible.\n\n* DatetimeArray verifies that the timezones (if any) match\n* PeriodArray verifies that the freq matches\n* Timedelta has no verification\n\nIn each case, NaT is considered compatible.\n\nParameters\n----------\nother\nsetitem : bool, default False\n    For __setitem__ we may have stricter compatiblity resrictions than\n    for comparisons.\n\nRaises\n------\nException",
                    "start_line": 187,
                    "variables": {
                        "Union": [
                            188
                        ],
                        "Period": [
                            188
                        ],
                        "Timestamp": [
                            188
                        ],
                        "Timedelta": [
                            188
                        ],
                        "NaTType": [
                            188
                        ],
                        "bool": [
                            188
                        ],
                        "AbstractMethodError": [
                            210
                        ],
                        "self": [
                            210
                        ]
                    },
                    "filtered_variables": {
                        "Union": [
                            188
                        ],
                        "Period": [
                            188
                        ],
                        "Timestamp": [
                            188
                        ],
                        "Timedelta": [
                            188
                        ],
                        "NaTType": [
                            188
                        ],
                        "AbstractMethodError": [
                            210
                        ],
                        "self": [
                            210
                        ]
                    },
                    "diff_line_number": 187,
                    "class_data": {
                        "signature": "class AttributesMixin()",
                        "docstring": null,
                        "constructor_docstring": null,
                        "functions": [
                            "@classmethod\ndef _simple_new(cls, values, **kwargs):\n    raise AbstractMethodError(cls)",
                            "@property\ndef _scalar_type(self) -> Type[DatetimeLikeScalar]:\n    \"\"\"The scalar associated with this datelike\n\n    * PeriodArray : Period\n    * DatetimeArray : Timestamp\n    * TimedeltaArray : Timedelta\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _scalar_from_string(self, value: str) -> Union[Period, Timestamp, Timedelta, NaTType]:\n    \"\"\"\n    Construct a scalar type from a string.\n\n    Parameters\n    ----------\n    value : str\n\n    Returns\n    -------\n    Period, Timestamp, or Timedelta, or NaT\n        Whatever the type of ``self._scalar_type`` is.\n\n    Notes\n    -----\n    This should call ``self._check_compatible_with`` before\n    unboxing the result.\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _unbox_scalar(self, value: Union[Period, Timestamp, Timedelta, NaTType]) -> int:\n    \"\"\"\n    Unbox the integer value of a scalar `value`.\n\n    Parameters\n    ----------\n    value : Union[Period, Timestamp, Timedelta]\n\n    Returns\n    -------\n    int\n\n    Examples\n    --------\n    >>> self._unbox_scalar(Timedelta('10s'))  # DOCTEST: +SKIP\n    10000000000\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _check_compatible_with(self, other: Union[Period, Timestamp, Timedelta, NaTType], setitem: bool=False) -> None:\n    \"\"\"\n    Verify that `self` and `other` are compatible.\n\n    * DatetimeArray verifies that the timezones (if any) match\n    * PeriodArray verifies that the freq matches\n    * Timedelta has no verification\n\n    In each case, NaT is considered compatible.\n\n    Parameters\n    ----------\n    other\n    setitem : bool, default False\n        For __setitem__ we may have stricter compatiblity resrictions than\n        for comparisons.\n\n    Raises\n    ------\n    Exception\n    \"\"\"\n    raise AbstractMethodError(self)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_data"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_simple_new(cls, values, **kwargs)",
                            "_scalar_type(self) -> Type[DatetimeLikeScalar]",
                            "_scalar_from_string(self, value: str) -> Union[Period, Timestamp, Timedelta, NaTType]",
                            "_unbox_scalar(self, value: Union[Period, Timestamp, Timedelta, NaTType]) -> int",
                            "_check_compatible_with(self, other: Union[Period, Timestamp, Timedelta, NaTType], setitem: bool=False) -> None"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "strftime",
                    "function_code": "@Substitution(\n    URL=\"https://docs.python.org/3/library/datetime.html\"\n    \"#strftime-and-strptime-behavior\"\n)\ndef strftime(self, date_format):\n    \"\"\"\n    Convert to Index using specified date_format.\n\n    Return an Index of formatted strings specified by date_format, which\n    supports the same string format as the python standard library. Details\n    of the string format can be found in `python string format\n    doc <%(URL)s>`__.\n\n    Parameters\n    ----------\n    date_format : str\n        Date format string (e.g. \"%%Y-%%m-%%d\").\n\n    Returns\n    -------\n    ndarray\n        NumPy ndarray of formatted strings.\n\n    See Also\n    --------\n    to_datetime : Convert the given argument to datetime.\n    DatetimeIndex.normalize : Return DatetimeIndex with times to midnight.\n    DatetimeIndex.round : Round the DatetimeIndex to the specified freq.\n    DatetimeIndex.floor : Floor the DatetimeIndex to the specified freq.\n\n    Examples\n    --------\n    >>> rng = pd.date_range(pd.Timestamp(\"2018-03-10 09:00\"),\n    ...                     periods=3, freq='s')\n    >>> rng.strftime('%%B %%d, %%Y, %%r')\n    Index(['March 10, 2018, 09:00:00 AM', 'March 10, 2018, 09:00:01 AM',\n           'March 10, 2018, 09:00:02 AM'],\n          dtype='object')\n    \"\"\"\n    result = self._format_native_types(date_format=date_format, na_rep=np.nan)\n    return result.astype(object)\n",
                    "decorators": [
                        "Substitution(URL='https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior')"
                    ],
                    "docstring": "Convert to Index using specified date_format.\n\nReturn an Index of formatted strings specified by date_format, which\nsupports the same string format as the python standard library. Details\nof the string format can be found in `python string format\ndoc <%(URL)s>`__.\n\nParameters\n----------\ndate_format : str\n    Date format string (e.g. \"%%Y-%%m-%%d\").\n\nReturns\n-------\nndarray\n    NumPy ndarray of formatted strings.\n\nSee Also\n--------\nto_datetime : Convert the given argument to datetime.\nDatetimeIndex.normalize : Return DatetimeIndex with times to midnight.\nDatetimeIndex.round : Round the DatetimeIndex to the specified freq.\nDatetimeIndex.floor : Floor the DatetimeIndex to the specified freq.\n\nExamples\n--------\n>>> rng = pd.date_range(pd.Timestamp(\"2018-03-10 09:00\"),\n...                     periods=3, freq='s')\n>>> rng.strftime('%%B %%d, %%Y, %%r')\nIndex(['March 10, 2018, 09:00:00 AM', 'March 10, 2018, 09:00:01 AM',\n       'March 10, 2018, 09:00:02 AM'],\n      dtype='object')",
                    "start_line": 218,
                    "variables": {
                        "result": [
                            257,
                            258
                        ],
                        "self._format_native_types": [
                            257
                        ],
                        "self": [
                            257
                        ],
                        "date_format": [
                            257
                        ],
                        "np.nan": [
                            257
                        ],
                        "np": [
                            257
                        ],
                        "result.astype": [
                            258
                        ],
                        "object": [
                            258
                        ],
                        "Substitution": [
                            218
                        ]
                    },
                    "filtered_variables": {
                        "result": [
                            257,
                            258
                        ],
                        "self._format_native_types": [
                            257
                        ],
                        "self": [
                            257
                        ],
                        "date_format": [
                            257
                        ],
                        "np.nan": [
                            257
                        ],
                        "np": [
                            257
                        ],
                        "result.astype": [
                            258
                        ],
                        "Substitution": [
                            218
                        ]
                    },
                    "diff_line_number": 222,
                    "class_data": {
                        "signature": "class DatelikeOps()",
                        "docstring": "Common ops for DatetimeIndex/PeriodIndex, but not TimedeltaIndex.",
                        "constructor_docstring": null,
                        "functions": [
                            "@Substitution(URL='https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior')\ndef strftime(self, date_format):\n    \"\"\"\n    Convert to Index using specified date_format.\n\n    Return an Index of formatted strings specified by date_format, which\n    supports the same string format as the python standard library. Details\n    of the string format can be found in `python string format\n    doc <%(URL)s>`__.\n\n    Parameters\n    ----------\n    date_format : str\n        Date format string (e.g. \"%%Y-%%m-%%d\").\n\n    Returns\n    -------\n    ndarray\n        NumPy ndarray of formatted strings.\n\n    See Also\n    --------\n    to_datetime : Convert the given argument to datetime.\n    DatetimeIndex.normalize : Return DatetimeIndex with times to midnight.\n    DatetimeIndex.round : Round the DatetimeIndex to the specified freq.\n    DatetimeIndex.floor : Floor the DatetimeIndex to the specified freq.\n\n    Examples\n    --------\n    >>> rng = pd.date_range(pd.Timestamp(\"2018-03-10 09:00\"),\n    ...                     periods=3, freq='s')\n    >>> rng.strftime('%%B %%d, %%Y, %%r')\n    Index(['March 10, 2018, 09:00:00 AM', 'March 10, 2018, 09:00:01 AM',\n           'March 10, 2018, 09:00:02 AM'],\n          dtype='object')\n    \"\"\"\n    result = self._format_native_types(date_format=date_format, na_rep=np.nan)\n    return result.astype(object)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [],
                        "class_decorators": [],
                        "function_signatures": [
                            "strftime(self, date_format)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_round",
                    "function_code": "def _round(self, freq, mode, ambiguous, nonexistent):\n    # round the local times\n    values = _ensure_datetimelike_to_i8(self)\n    result = round_nsint64(values, mode, freq)\n    result = self._maybe_mask_results(result, fill_value=NaT)\n\n    dtype = self.dtype\n    if is_datetime64tz_dtype(self):\n        dtype = None\n    return self._ensure_localized(\n        self._simple_new(result, dtype=dtype), ambiguous, nonexistent\n    )\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 369,
                    "variables": {
                        "values": [
                            371,
                            372
                        ],
                        "_ensure_datetimelike_to_i8": [
                            371
                        ],
                        "self": [
                            371,
                            373,
                            375,
                            376,
                            378,
                            379
                        ],
                        "result": [
                            379,
                            372,
                            373
                        ],
                        "round_nsint64": [
                            372
                        ],
                        "mode": [
                            372
                        ],
                        "freq": [
                            372
                        ],
                        "self._maybe_mask_results": [
                            373
                        ],
                        "NaT": [
                            373
                        ],
                        "dtype": [
                            377,
                            379,
                            375
                        ],
                        "self.dtype": [
                            375
                        ],
                        "is_datetime64tz_dtype": [
                            376
                        ],
                        "self._ensure_localized": [
                            378
                        ],
                        "self._simple_new": [
                            379
                        ],
                        "ambiguous": [
                            379
                        ],
                        "nonexistent": [
                            379
                        ]
                    },
                    "filtered_variables": {
                        "values": [
                            371,
                            372
                        ],
                        "_ensure_datetimelike_to_i8": [
                            371
                        ],
                        "self": [
                            371,
                            373,
                            375,
                            376,
                            378,
                            379
                        ],
                        "result": [
                            379,
                            372,
                            373
                        ],
                        "round_nsint64": [
                            372
                        ],
                        "mode": [
                            372
                        ],
                        "freq": [
                            372
                        ],
                        "self._maybe_mask_results": [
                            373
                        ],
                        "NaT": [
                            373
                        ],
                        "dtype": [
                            377,
                            379,
                            375
                        ],
                        "self.dtype": [
                            375
                        ],
                        "is_datetime64tz_dtype": [
                            376
                        ],
                        "self._ensure_localized": [
                            378
                        ],
                        "self._simple_new": [
                            379
                        ],
                        "ambiguous": [
                            379
                        ],
                        "nonexistent": [
                            379
                        ]
                    },
                    "diff_line_number": 369,
                    "class_data": {
                        "signature": "class TimelikeOps()",
                        "docstring": "Common ops for TimedeltaIndex/DatetimeIndex, but not PeriodIndex.",
                        "constructor_docstring": null,
                        "functions": [
                            "def _round(self, freq, mode, ambiguous, nonexistent):\n    values = _ensure_datetimelike_to_i8(self)\n    result = round_nsint64(values, mode, freq)\n    result = self._maybe_mask_results(result, fill_value=NaT)\n    dtype = self.dtype\n    if is_datetime64tz_dtype(self):\n        dtype = None\n    return self._ensure_localized(self._simple_new(result, dtype=dtype), ambiguous, nonexistent)",
                            "@Appender((_round_doc + _round_example).format(op='round'))\ndef round(self, freq, ambiguous='raise', nonexistent='raise'):\n    return self._round(freq, RoundTo.NEAREST_HALF_EVEN, ambiguous, nonexistent)",
                            "@Appender((_round_doc + _floor_example).format(op='floor'))\ndef floor(self, freq, ambiguous='raise', nonexistent='raise'):\n    return self._round(freq, RoundTo.MINUS_INFTY, ambiguous, nonexistent)",
                            "@Appender((_round_doc + _ceil_example).format(op='ceil'))\ndef ceil(self, freq, ambiguous='raise', nonexistent='raise'):\n    return self._round(freq, RoundTo.PLUS_INFTY, ambiguous, nonexistent)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_round_doc",
                            "_round_example",
                            "_floor_example",
                            "_ceil_example"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_round(self, freq, mode, ambiguous, nonexistent)",
                            "round(self, freq, ambiguous='raise', nonexistent='raise')",
                            "floor(self, freq, ambiguous='raise', nonexistent='raise')",
                            "ceil(self, freq, ambiguous='raise', nonexistent='raise')"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "round",
                    "function_code": "@Appender((_round_doc + _round_example).format(op=\"round\"))\ndef round(self, freq, ambiguous=\"raise\", nonexistent=\"raise\"):\n    return self._round(freq, RoundTo.NEAREST_HALF_EVEN, ambiguous, nonexistent)\n",
                    "decorators": [
                        "Appender((_round_doc + _round_example).format(op='round'))"
                    ],
                    "docstring": null,
                    "start_line": 382,
                    "variables": {
                        "self._round": [
                            384
                        ],
                        "self": [
                            384
                        ],
                        "freq": [
                            384
                        ],
                        "RoundTo.NEAREST_HALF_EVEN": [
                            384
                        ],
                        "RoundTo": [
                            384
                        ],
                        "ambiguous": [
                            384
                        ],
                        "nonexistent": [
                            384
                        ],
                        "Appender": [
                            382
                        ],
                        "format": [
                            382
                        ],
                        "_round_doc": [
                            382
                        ],
                        "_round_example": [
                            382
                        ]
                    },
                    "filtered_variables": {
                        "self._round": [
                            384
                        ],
                        "self": [
                            384
                        ],
                        "freq": [
                            384
                        ],
                        "RoundTo.NEAREST_HALF_EVEN": [
                            384
                        ],
                        "RoundTo": [
                            384
                        ],
                        "ambiguous": [
                            384
                        ],
                        "nonexistent": [
                            384
                        ],
                        "Appender": [
                            382
                        ],
                        "_round_doc": [
                            382
                        ],
                        "_round_example": [
                            382
                        ]
                    },
                    "diff_line_number": 383,
                    "class_data": {
                        "signature": "class TimelikeOps()",
                        "docstring": "Common ops for TimedeltaIndex/DatetimeIndex, but not PeriodIndex.",
                        "constructor_docstring": null,
                        "functions": [
                            "def _round(self, freq, mode, ambiguous, nonexistent):\n    values = _ensure_datetimelike_to_i8(self)\n    result = round_nsint64(values, mode, freq)\n    result = self._maybe_mask_results(result, fill_value=NaT)\n    dtype = self.dtype\n    if is_datetime64tz_dtype(self):\n        dtype = None\n    return self._ensure_localized(self._simple_new(result, dtype=dtype), ambiguous, nonexistent)",
                            "@Appender((_round_doc + _round_example).format(op='round'))\ndef round(self, freq, ambiguous='raise', nonexistent='raise'):\n    return self._round(freq, RoundTo.NEAREST_HALF_EVEN, ambiguous, nonexistent)",
                            "@Appender((_round_doc + _floor_example).format(op='floor'))\ndef floor(self, freq, ambiguous='raise', nonexistent='raise'):\n    return self._round(freq, RoundTo.MINUS_INFTY, ambiguous, nonexistent)",
                            "@Appender((_round_doc + _ceil_example).format(op='ceil'))\ndef ceil(self, freq, ambiguous='raise', nonexistent='raise'):\n    return self._round(freq, RoundTo.PLUS_INFTY, ambiguous, nonexistent)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_round_doc",
                            "_round_example",
                            "_floor_example",
                            "_ceil_example"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_round(self, freq, mode, ambiguous, nonexistent)",
                            "round(self, freq, ambiguous='raise', nonexistent='raise')",
                            "floor(self, freq, ambiguous='raise', nonexistent='raise')",
                            "ceil(self, freq, ambiguous='raise', nonexistent='raise')"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "floor",
                    "function_code": "@Appender((_round_doc + _floor_example).format(op=\"floor\"))\ndef floor(self, freq, ambiguous=\"raise\", nonexistent=\"raise\"):\n    return self._round(freq, RoundTo.MINUS_INFTY, ambiguous, nonexistent)\n",
                    "decorators": [
                        "Appender((_round_doc + _floor_example).format(op='floor'))"
                    ],
                    "docstring": null,
                    "start_line": 386,
                    "variables": {
                        "self._round": [
                            388
                        ],
                        "self": [
                            388
                        ],
                        "freq": [
                            388
                        ],
                        "RoundTo.MINUS_INFTY": [
                            388
                        ],
                        "RoundTo": [
                            388
                        ],
                        "ambiguous": [
                            388
                        ],
                        "nonexistent": [
                            388
                        ],
                        "Appender": [
                            386
                        ],
                        "format": [
                            386
                        ],
                        "_round_doc": [
                            386
                        ],
                        "_floor_example": [
                            386
                        ]
                    },
                    "filtered_variables": {
                        "self._round": [
                            388
                        ],
                        "self": [
                            388
                        ],
                        "freq": [
                            388
                        ],
                        "RoundTo.MINUS_INFTY": [
                            388
                        ],
                        "RoundTo": [
                            388
                        ],
                        "ambiguous": [
                            388
                        ],
                        "nonexistent": [
                            388
                        ],
                        "Appender": [
                            386
                        ],
                        "_round_doc": [
                            386
                        ],
                        "_floor_example": [
                            386
                        ]
                    },
                    "diff_line_number": 387,
                    "class_data": {
                        "signature": "class TimelikeOps()",
                        "docstring": "Common ops for TimedeltaIndex/DatetimeIndex, but not PeriodIndex.",
                        "constructor_docstring": null,
                        "functions": [
                            "def _round(self, freq, mode, ambiguous, nonexistent):\n    values = _ensure_datetimelike_to_i8(self)\n    result = round_nsint64(values, mode, freq)\n    result = self._maybe_mask_results(result, fill_value=NaT)\n    dtype = self.dtype\n    if is_datetime64tz_dtype(self):\n        dtype = None\n    return self._ensure_localized(self._simple_new(result, dtype=dtype), ambiguous, nonexistent)",
                            "@Appender((_round_doc + _round_example).format(op='round'))\ndef round(self, freq, ambiguous='raise', nonexistent='raise'):\n    return self._round(freq, RoundTo.NEAREST_HALF_EVEN, ambiguous, nonexistent)",
                            "@Appender((_round_doc + _floor_example).format(op='floor'))\ndef floor(self, freq, ambiguous='raise', nonexistent='raise'):\n    return self._round(freq, RoundTo.MINUS_INFTY, ambiguous, nonexistent)",
                            "@Appender((_round_doc + _ceil_example).format(op='ceil'))\ndef ceil(self, freq, ambiguous='raise', nonexistent='raise'):\n    return self._round(freq, RoundTo.PLUS_INFTY, ambiguous, nonexistent)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_round_doc",
                            "_round_example",
                            "_floor_example",
                            "_ceil_example"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_round(self, freq, mode, ambiguous, nonexistent)",
                            "round(self, freq, ambiguous='raise', nonexistent='raise')",
                            "floor(self, freq, ambiguous='raise', nonexistent='raise')",
                            "ceil(self, freq, ambiguous='raise', nonexistent='raise')"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "ceil",
                    "function_code": "@Appender((_round_doc + _ceil_example).format(op=\"ceil\"))\ndef ceil(self, freq, ambiguous=\"raise\", nonexistent=\"raise\"):\n    return self._round(freq, RoundTo.PLUS_INFTY, ambiguous, nonexistent)\n",
                    "decorators": [
                        "Appender((_round_doc + _ceil_example).format(op='ceil'))"
                    ],
                    "docstring": null,
                    "start_line": 390,
                    "variables": {
                        "self._round": [
                            392
                        ],
                        "self": [
                            392
                        ],
                        "freq": [
                            392
                        ],
                        "RoundTo.PLUS_INFTY": [
                            392
                        ],
                        "RoundTo": [
                            392
                        ],
                        "ambiguous": [
                            392
                        ],
                        "nonexistent": [
                            392
                        ],
                        "Appender": [
                            390
                        ],
                        "format": [
                            390
                        ],
                        "_round_doc": [
                            390
                        ],
                        "_ceil_example": [
                            390
                        ]
                    },
                    "filtered_variables": {
                        "self._round": [
                            392
                        ],
                        "self": [
                            392
                        ],
                        "freq": [
                            392
                        ],
                        "RoundTo.PLUS_INFTY": [
                            392
                        ],
                        "RoundTo": [
                            392
                        ],
                        "ambiguous": [
                            392
                        ],
                        "nonexistent": [
                            392
                        ],
                        "Appender": [
                            390
                        ],
                        "_round_doc": [
                            390
                        ],
                        "_ceil_example": [
                            390
                        ]
                    },
                    "diff_line_number": 391,
                    "class_data": {
                        "signature": "class TimelikeOps()",
                        "docstring": "Common ops for TimedeltaIndex/DatetimeIndex, but not PeriodIndex.",
                        "constructor_docstring": null,
                        "functions": [
                            "def _round(self, freq, mode, ambiguous, nonexistent):\n    values = _ensure_datetimelike_to_i8(self)\n    result = round_nsint64(values, mode, freq)\n    result = self._maybe_mask_results(result, fill_value=NaT)\n    dtype = self.dtype\n    if is_datetime64tz_dtype(self):\n        dtype = None\n    return self._ensure_localized(self._simple_new(result, dtype=dtype), ambiguous, nonexistent)",
                            "@Appender((_round_doc + _round_example).format(op='round'))\ndef round(self, freq, ambiguous='raise', nonexistent='raise'):\n    return self._round(freq, RoundTo.NEAREST_HALF_EVEN, ambiguous, nonexistent)",
                            "@Appender((_round_doc + _floor_example).format(op='floor'))\ndef floor(self, freq, ambiguous='raise', nonexistent='raise'):\n    return self._round(freq, RoundTo.MINUS_INFTY, ambiguous, nonexistent)",
                            "@Appender((_round_doc + _ceil_example).format(op='ceil'))\ndef ceil(self, freq, ambiguous='raise', nonexistent='raise'):\n    return self._round(freq, RoundTo.PLUS_INFTY, ambiguous, nonexistent)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_round_doc",
                            "_round_example",
                            "_floor_example",
                            "_ceil_example"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_round(self, freq, mode, ambiguous, nonexistent)",
                            "round(self, freq, ambiguous='raise', nonexistent='raise')",
                            "floor(self, freq, ambiguous='raise', nonexistent='raise')",
                            "ceil(self, freq, ambiguous='raise', nonexistent='raise')"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "ndim",
                    "function_code": "@property\ndef ndim(self) -> int:\n    return self._data.ndim\n",
                    "decorators": [
                        "property"
                    ],
                    "docstring": null,
                    "start_line": 407,
                    "variables": {
                        "self._data.ndim": [
                            409
                        ],
                        "self._data": [
                            409
                        ],
                        "self": [
                            409
                        ],
                        "property": [
                            407
                        ],
                        "int": [
                            408
                        ]
                    },
                    "filtered_variables": {
                        "self._data.ndim": [
                            409
                        ],
                        "self._data": [
                            409
                        ],
                        "self": [
                            409
                        ]
                    },
                    "diff_line_number": 408,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "self._data.ndim": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._data": {
                                    "variable_value": "array([                          'NaT',                           'NaT',\n       '2013-01-03T00:00:00.000000000', '2013-01-04T00:00:00.000000000',\n       '2013-01-05T00:00:00.000000000'], dtype='datetime64[ns]')",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n[                'NaT',                 'NaT', '2013-01-03 00:00:00',\n '2013-01-04 00:00:00', '2013-01-05 00:00:00']\nLength: 5, dtype: datetime64[ns]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "5"
                                }
                            },
                            {
                                "self._data.ndim": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._data": {
                                    "variable_value": "array([                          'NaT',                           'NaT',\n       '2013-01-03T00:00:00.000000000', '2013-01-04T00:00:00.000000000',\n       '2013-01-05T00:00:00.000000000'], dtype='datetime64[ns]')",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n[                'NaT',                 'NaT', '2013-01-03 00:00:00',\n '2013-01-04 00:00:00', '2013-01-05 00:00:00']\nLength: 5, dtype: datetime64[ns]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "5"
                                }
                            }
                        ]
                    ]
                },
                {
                    "function_name": "shape",
                    "function_code": "@property\ndef shape(self):\n    return self._data.shape\n",
                    "decorators": [
                        "property"
                    ],
                    "docstring": null,
                    "start_line": 411,
                    "variables": {
                        "self._data.shape": [
                            413
                        ],
                        "self._data": [
                            413
                        ],
                        "self": [
                            413
                        ],
                        "property": [
                            411
                        ]
                    },
                    "filtered_variables": {
                        "self._data.shape": [
                            413
                        ],
                        "self._data": [
                            413
                        ],
                        "self": [
                            413
                        ]
                    },
                    "diff_line_number": 412,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "reshape",
                    "function_code": "def reshape(self, *args, **kwargs):\n    # Note: we drop any freq\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 415,
                    "variables": {
                        "data": [
                            417,
                            418
                        ],
                        "self._data.reshape": [
                            417
                        ],
                        "self._data": [
                            417
                        ],
                        "self": [
                            417,
                            418
                        ],
                        "args": [
                            417
                        ],
                        "kwargs": [
                            417
                        ],
                        "type": [
                            418
                        ],
                        "self.dtype": [
                            418
                        ]
                    },
                    "filtered_variables": {
                        "data": [
                            417,
                            418
                        ],
                        "self._data.reshape": [
                            417
                        ],
                        "self._data": [
                            417
                        ],
                        "self": [
                            417,
                            418
                        ],
                        "args": [
                            417
                        ],
                        "kwargs": [
                            417
                        ],
                        "self.dtype": [
                            418
                        ]
                    },
                    "diff_line_number": 415,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "ravel",
                    "function_code": "def ravel(self, *args, **kwargs):\n    # Note: we drop any freq\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 420,
                    "variables": {
                        "data": [
                            422,
                            423
                        ],
                        "self._data.ravel": [
                            422
                        ],
                        "self._data": [
                            422
                        ],
                        "self": [
                            422,
                            423
                        ],
                        "args": [
                            422
                        ],
                        "kwargs": [
                            422
                        ],
                        "type": [
                            423
                        ],
                        "self.dtype": [
                            423
                        ]
                    },
                    "filtered_variables": {
                        "data": [
                            422,
                            423
                        ],
                        "self._data.ravel": [
                            422
                        ],
                        "self._data": [
                            422
                        ],
                        "self": [
                            422,
                            423
                        ],
                        "args": [
                            422
                        ],
                        "kwargs": [
                            422
                        ],
                        "self.dtype": [
                            423
                        ]
                    },
                    "diff_line_number": 420,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_box_func",
                    "function_code": "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)\n",
                    "decorators": [
                        "property"
                    ],
                    "docstring": "box function to get object from internal representation",
                    "start_line": 425,
                    "variables": {
                        "AbstractMethodError": [
                            430
                        ],
                        "self": [
                            430
                        ],
                        "property": [
                            425
                        ]
                    },
                    "filtered_variables": {
                        "AbstractMethodError": [
                            430
                        ],
                        "self": [
                            430
                        ]
                    },
                    "diff_line_number": 426,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_box_values",
                    "function_code": "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)\n",
                    "decorators": [],
                    "docstring": "apply box func to passed values",
                    "start_line": 432,
                    "variables": {
                        "lib.map_infer": [
                            436
                        ],
                        "lib": [
                            436
                        ],
                        "values": [
                            436
                        ],
                        "self._box_func": [
                            436
                        ],
                        "self": [
                            436
                        ]
                    },
                    "filtered_variables": {
                        "lib.map_infer": [
                            436
                        ],
                        "lib": [
                            436
                        ],
                        "values": [
                            436
                        ],
                        "self._box_func": [
                            436
                        ],
                        "self": [
                            436
                        ]
                    },
                    "diff_line_number": 432,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {
                                "lib.map_infer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": "array([15708, 15709, 15710])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self._box_func": {
                                    "variable_value": "<function PeriodArray._box_func.<locals>.<lambda> at 0x11e9e54c0>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['2013-01-03', '2013-01-04', '2013-01-05']\nLength: 3, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "3"
                                }
                            },
                            {
                                "lib.map_infer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": "array([15708, 15709, 15710])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self._box_func": {
                                    "variable_value": "<function PeriodArray._box_func.<locals>.<lambda> at 0x11e9b03a0>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['2013-01-03', '2013-01-04', '2013-01-05']\nLength: 3, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "3"
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "lib.map_infer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": "array([15708, 15709, 15710])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self._box_func": {
                                    "variable_value": "<function PeriodArray._box_func.<locals>.<lambda> at 0x116b84f70>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['2013-01-03', '2013-01-04', '2013-01-05']\nLength: 3, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "3"
                                }
                            },
                            {
                                "lib.map_infer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": "array([15708, 15709, 15710])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "self._box_func": {
                                    "variable_value": "<function PeriodArray._box_func.<locals>.<lambda> at 0x116ab2550>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['2013-01-03', '2013-01-04', '2013-01-05']\nLength: 3, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "3"
                                }
                            }
                        ]
                    ]
                },
                {
                    "function_name": "__iter__",
                    "function_code": "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 438,
                    "variables": {
                        "self._box_func": [
                            439
                        ],
                        "self": [
                            439
                        ],
                        "v": [
                            439
                        ],
                        "self.asi8": [
                            439
                        ]
                    },
                    "filtered_variables": {
                        "self._box_func": [
                            439
                        ],
                        "self": [
                            439
                        ],
                        "v": [
                            439
                        ],
                        "self.asi8": [
                            439
                        ]
                    },
                    "diff_line_number": 438,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "asi8",
                    "function_code": "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    # do not cache or you'll create a memory leak\n    return self._data.view(\"i8\")\n",
                    "decorators": [
                        "property"
                    ],
                    "docstring": "Integer representation of the values.\n\nReturns\n-------\nndarray\n    An ndarray with int64 dtype.",
                    "start_line": 441,
                    "variables": {
                        "self._data.view": [
                            452
                        ],
                        "self._data": [
                            452
                        ],
                        "self": [
                            452
                        ],
                        "property": [
                            441
                        ],
                        "np.ndarray": [
                            442
                        ],
                        "np": [
                            442
                        ]
                    },
                    "filtered_variables": {
                        "self._data.view": [
                            452
                        ],
                        "self._data": [
                            452
                        ],
                        "self": [
                            452
                        ],
                        "np.ndarray": [
                            442
                        ],
                        "np": [
                            442
                        ]
                    },
                    "diff_line_number": 442,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_ndarray_values",
                    "function_code": "@property\ndef _ndarray_values(self):\n    return self._data\n",
                    "decorators": [
                        "property"
                    ],
                    "docstring": null,
                    "start_line": 454,
                    "variables": {
                        "self._data": [
                            456
                        ],
                        "self": [
                            456
                        ],
                        "property": [
                            454
                        ]
                    },
                    "filtered_variables": {
                        "self._data": [
                            456
                        ],
                        "self": [
                            456
                        ]
                    },
                    "diff_line_number": 455,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "self._data": {
                                    "variable_value": "array([                          'NaT',                           'NaT',\n       '2013-01-03T00:00:00.000000000', '2013-01-04T00:00:00.000000000',\n       '2013-01-05T00:00:00.000000000'], dtype='datetime64[ns]')",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n[                'NaT',                 'NaT', '2013-01-03 00:00:00',\n '2013-01-04 00:00:00', '2013-01-05 00:00:00']\nLength: 5, dtype: datetime64[ns]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "5"
                                }
                            },
                            {
                                "self._data": {
                                    "variable_value": "array([                          'NaT',                           'NaT',\n       '2013-01-03T00:00:00.000000000', '2013-01-04T00:00:00.000000000',\n       '2013-01-05T00:00:00.000000000'], dtype='datetime64[ns]')",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n[                'NaT',                 'NaT', '2013-01-03 00:00:00',\n '2013-01-04 00:00:00', '2013-01-05 00:00:00']\nLength: 5, dtype: datetime64[ns]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "5"
                                }
                            }
                        ]
                    ]
                },
                {
                    "function_name": "_format_native_types",
                    "function_code": "def _format_native_types(self, na_rep=\"NaT\", date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)\n",
                    "decorators": [],
                    "docstring": "Helper method for astype when converting to strings.\n\nReturns\n-------\nndarray[str]",
                    "start_line": 461,
                    "variables": {
                        "AbstractMethodError": [
                            469
                        ],
                        "self": [
                            469
                        ]
                    },
                    "filtered_variables": {
                        "AbstractMethodError": [
                            469
                        ],
                        "self": [
                            469
                        ]
                    },
                    "diff_line_number": 461,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_formatter",
                    "function_code": "def _formatter(self, boxed=False):\n    # TODO: Remove Datetime & DatetimeTZ formatters.\n    return \"'{}'\".format\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 471,
                    "variables": {
                        "format": [
                            473
                        ]
                    },
                    "filtered_variables": {},
                    "diff_line_number": 471,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "nbytes",
                    "function_code": "@property\ndef nbytes(self):\n    return self._data.nbytes\n",
                    "decorators": [
                        "property"
                    ],
                    "docstring": null,
                    "start_line": 478,
                    "variables": {
                        "self._data.nbytes": [
                            480
                        ],
                        "self._data": [
                            480
                        ],
                        "self": [
                            480
                        ],
                        "property": [
                            478
                        ]
                    },
                    "filtered_variables": {
                        "self._data.nbytes": [
                            480
                        ],
                        "self._data": [
                            480
                        ],
                        "self": [
                            480
                        ]
                    },
                    "diff_line_number": 479,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "__array__",
                    "function_code": "def __array__(self, dtype=None):\n    # used for Timedelta/DatetimeArray, overwritten by PeriodArray\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 482,
                    "variables": {
                        "is_object_dtype": [
                            484
                        ],
                        "dtype": [
                            484
                        ],
                        "np.array": [
                            485
                        ],
                        "np": [
                            485
                        ],
                        "list": [
                            485
                        ],
                        "self": [
                            485,
                            486
                        ],
                        "object": [
                            485
                        ],
                        "self._data": [
                            486
                        ]
                    },
                    "filtered_variables": {
                        "is_object_dtype": [
                            484
                        ],
                        "dtype": [
                            484
                        ],
                        "np.array": [
                            485
                        ],
                        "np": [
                            485
                        ],
                        "self": [
                            485,
                            486
                        ],
                        "self._data": [
                            486
                        ]
                    },
                    "diff_line_number": 482,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "size",
                    "function_code": "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)\n",
                    "decorators": [
                        "property"
                    ],
                    "docstring": "The number of elements in this array.",
                    "start_line": 488,
                    "variables": {
                        "np.prod": [
                            491
                        ],
                        "np": [
                            491
                        ],
                        "self.shape": [
                            491
                        ],
                        "self": [
                            491
                        ],
                        "property": [
                            488
                        ],
                        "int": [
                            489
                        ]
                    },
                    "filtered_variables": {
                        "np.prod": [
                            491
                        ],
                        "np": [
                            491
                        ],
                        "self.shape": [
                            491
                        ],
                        "self": [
                            491
                        ]
                    },
                    "diff_line_number": 489,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "__len__",
                    "function_code": "def __len__(self) -> int:\n    return len(self._data)\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 493,
                    "variables": {
                        "len": [
                            494
                        ],
                        "self._data": [
                            494
                        ],
                        "self": [
                            494
                        ],
                        "int": [
                            493
                        ]
                    },
                    "filtered_variables": {
                        "self._data": [
                            494
                        ],
                        "self": [
                            494
                        ]
                    },
                    "diff_line_number": 493,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "__getitem__",
                    "function_code": "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and not is_int:\n        raise IndexError(\n            \"only integers, slices (`:`), ellipsis (`...`), \"\n            \"numpy.newaxis (`None`) and integer or boolean \"\n            \"arrays are valid indices\"\n        )\n\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            # i.e. self.ndim == 1\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            # GH#21282 indexing with Ellipsis is similar to a full slice,\n            #  should preserve `freq` attribute\n            freq = self.freq\n\n    result = getitem(key)\n    if result.ndim > 1:\n        # To support MPL which performs slicing with 2 dim\n        # even though it only has 1 dim by definition\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n\n    return self._simple_new(result, dtype=self.dtype, freq=freq)\n",
                    "decorators": [],
                    "docstring": "This getitem defers to the underlying array, which by-definition can\nonly handle list-likes, slices, and integer scalars",
                    "start_line": 496,
                    "variables": {
                        "is_int": [
                            511,
                            502,
                            503
                        ],
                        "lib.is_integer": [
                            502
                        ],
                        "lib": [
                            513,
                            523,
                            502,
                            503
                        ],
                        "key": [
                            512,
                            535,
                            518,
                            519,
                            520,
                            521,
                            523,
                            530,
                            531,
                            532,
                            502,
                            503,
                            540
                        ],
                        "lib.is_scalar": [
                            513,
                            503
                        ],
                        "IndexError": [
                            504
                        ],
                        "getitem": [
                            512,
                            540,
                            510
                        ],
                        "self._data.__getitem__": [
                            510
                        ],
                        "self._data": [
                            510
                        ],
                        "self": [
                            545,
                            515,
                            516,
                            548,
                            519,
                            525,
                            527,
                            531,
                            532,
                            534,
                            538,
                            510
                        ],
                        "val": [
                            512,
                            513,
                            515,
                            516
                        ],
                        "self._box_func": [
                            515
                        ],
                        "type": [
                            516
                        ],
                        "self.dtype": [
                            545,
                            516,
                            548
                        ],
                        "com.is_bool_indexer": [
                            518
                        ],
                        "com": [
                            518
                        ],
                        "check_bool_array_indexer": [
                            519
                        ],
                        "key.all": [
                            520
                        ],
                        "slice": [
                            521,
                            530
                        ],
                        "lib.maybe_booleans_to_slice": [
                            523
                        ],
                        "key.view": [
                            523
                        ],
                        "np.uint8": [
                            523
                        ],
                        "np": [
                            523
                        ],
                        "is_period": [
                            544,
                            525,
                            526
                        ],
                        "is_period_dtype": [
                            525
                        ],
                        "freq": [
                            545,
                            548,
                            527,
                            529,
                            532,
                            534,
                            538
                        ],
                        "self.freq": [
                            527,
                            531,
                            532,
                            534,
                            538
                        ],
                        "isinstance": [
                            530
                        ],
                        "key.step": [
                            531,
                            532
                        ],
                        "Ellipsis": [
                            535
                        ],
                        "result": [
                            545,
                            546,
                            548,
                            540,
                            541
                        ],
                        "result.ndim": [
                            541
                        ],
                        "self._simple_new": [
                            545,
                            548
                        ]
                    },
                    "filtered_variables": {
                        "is_int": [
                            511,
                            502,
                            503
                        ],
                        "lib.is_integer": [
                            502
                        ],
                        "lib": [
                            513,
                            523,
                            502,
                            503
                        ],
                        "key": [
                            512,
                            535,
                            518,
                            519,
                            520,
                            521,
                            523,
                            530,
                            531,
                            532,
                            502,
                            503,
                            540
                        ],
                        "lib.is_scalar": [
                            513,
                            503
                        ],
                        "getitem": [
                            512,
                            540,
                            510
                        ],
                        "self._data.__getitem__": [
                            510
                        ],
                        "self._data": [
                            510
                        ],
                        "self": [
                            545,
                            515,
                            516,
                            548,
                            519,
                            525,
                            527,
                            531,
                            532,
                            534,
                            538,
                            510
                        ],
                        "val": [
                            512,
                            513,
                            515,
                            516
                        ],
                        "self._box_func": [
                            515
                        ],
                        "self.dtype": [
                            545,
                            516,
                            548
                        ],
                        "com.is_bool_indexer": [
                            518
                        ],
                        "com": [
                            518
                        ],
                        "check_bool_array_indexer": [
                            519
                        ],
                        "key.all": [
                            520
                        ],
                        "lib.maybe_booleans_to_slice": [
                            523
                        ],
                        "key.view": [
                            523
                        ],
                        "np.uint8": [
                            523
                        ],
                        "np": [
                            523
                        ],
                        "is_period": [
                            544,
                            525,
                            526
                        ],
                        "is_period_dtype": [
                            525
                        ],
                        "freq": [
                            545,
                            548,
                            527,
                            529,
                            532,
                            534,
                            538
                        ],
                        "self.freq": [
                            527,
                            531,
                            532,
                            534,
                            538
                        ],
                        "key.step": [
                            531,
                            532
                        ],
                        "result": [
                            545,
                            546,
                            548,
                            540,
                            541
                        ],
                        "result.ndim": [
                            541
                        ],
                        "self._simple_new": [
                            545,
                            548
                        ]
                    },
                    "diff_line_number": 496,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {
                                "is_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "slice(2, None, None)",
                                    "variable_type": "slice",
                                    "variable_shape": null
                                },
                                "lib.is_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "getitem": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._data.__getitem__": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._data": {
                                    "variable_value": "array([15706, 15707, 15708, 15709, 15710])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04', '2013-01-05']\nLength: 5, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "5"
                                },
                                "val": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._box_func": {
                                    "variable_value": "<function PeriodArray._box_func.<locals>.<lambda> at 0x11c9a84c0>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "period[D]",
                                    "variable_type": "PeriodDtype",
                                    "variable_shape": "()"
                                },
                                "com.is_bool_indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "com": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "check_bool_array_indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key.all": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.maybe_booleans_to_slice": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key.view": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.uint8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_period": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_period_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.freq": {
                                    "variable_value": "<Day>",
                                    "variable_type": "Day",
                                    "variable_shape": null
                                },
                                "key.step": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result.ndim": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._simple_new": {
                                    "variable_value": "<bound method PeriodArray._simple_new of <class 'pandas.core.arrays.period.PeriodArray'>>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            },
                            {
                                "is_int": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "slice(2, None, None)",
                                    "variable_type": "slice",
                                    "variable_shape": null
                                },
                                "lib.is_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "getitem": {
                                    "variable_value": "<method-wrapper '__getitem__' of numpy.ndarray object at 0x11c9cce40>",
                                    "variable_type": "method-wrapper",
                                    "variable_shape": null
                                },
                                "self._data.__getitem__": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._data": {
                                    "variable_value": "array([15706, 15707, 15708, 15709, 15710])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04', '2013-01-05']\nLength: 5, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "5"
                                },
                                "val": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._box_func": {
                                    "variable_value": "<function PeriodArray._box_func.<locals>.<lambda> at 0x11c975d30>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "period[D]",
                                    "variable_type": "PeriodDtype",
                                    "variable_shape": "()"
                                },
                                "com.is_bool_indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "com": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "check_bool_array_indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key.all": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.maybe_booleans_to_slice": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key.view": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.uint8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_period": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "is_period_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "<Day>",
                                    "variable_type": "Day",
                                    "variable_shape": null
                                },
                                "self.freq": {
                                    "variable_value": "<Day>",
                                    "variable_type": "Day",
                                    "variable_shape": null
                                },
                                "key.step": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": "array([15708, 15709, 15710])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "result.ndim": {
                                    "variable_value": "1",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self._simple_new": {
                                    "variable_value": "<bound method PeriodArray._simple_new of <class 'pandas.core.arrays.period.PeriodArray'>>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "is_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "slice(2, None, None)",
                                    "variable_type": "slice",
                                    "variable_shape": null
                                },
                                "lib.is_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "getitem": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._data.__getitem__": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._data": {
                                    "variable_value": "array([15706, 15707, 15708, 15709, 15710])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04', '2013-01-05']\nLength: 5, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "5"
                                },
                                "val": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._box_func": {
                                    "variable_value": "<function PeriodArray._box_func.<locals>.<lambda> at 0x1210173a0>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "period[D]",
                                    "variable_type": "PeriodDtype",
                                    "variable_shape": "()"
                                },
                                "com.is_bool_indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "com": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "check_bool_array_indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key.all": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.maybe_booleans_to_slice": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key.view": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.uint8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_period": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_period_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.freq": {
                                    "variable_value": "<Day>",
                                    "variable_type": "Day",
                                    "variable_shape": null
                                },
                                "key.step": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "result.ndim": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._simple_new": {
                                    "variable_value": "<bound method PeriodArray._simple_new of <class 'pandas.core.arrays.period.PeriodArray'>>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            },
                            {
                                "is_int": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "slice(2, None, None)",
                                    "variable_type": "slice",
                                    "variable_shape": null
                                },
                                "lib.is_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "getitem": {
                                    "variable_value": "<method-wrapper '__getitem__' of numpy.ndarray object at 0x12103ad50>",
                                    "variable_type": "method-wrapper",
                                    "variable_shape": null
                                },
                                "self._data.__getitem__": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._data": {
                                    "variable_value": "array([15706, 15707, 15708, 15709, 15710])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04', '2013-01-05']\nLength: 5, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "5"
                                },
                                "val": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._box_func": {
                                    "variable_value": "<function PeriodArray._box_func.<locals>.<lambda> at 0x120fe4b80>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "period[D]",
                                    "variable_type": "PeriodDtype",
                                    "variable_shape": "()"
                                },
                                "com.is_bool_indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "com": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "check_bool_array_indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key.all": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "lib.maybe_booleans_to_slice": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key.view": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.uint8": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_period": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "is_period_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "<Day>",
                                    "variable_type": "Day",
                                    "variable_shape": null
                                },
                                "self.freq": {
                                    "variable_value": "<Day>",
                                    "variable_type": "Day",
                                    "variable_shape": null
                                },
                                "key.step": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "result": {
                                    "variable_value": "array([15708, 15709, 15710])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "result.ndim": {
                                    "variable_value": "1",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self._simple_new": {
                                    "variable_value": "<bound method PeriodArray._simple_new of <class 'pandas.core.arrays.period.PeriodArray'>>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                },
                {
                    "function_name": "__setitem__",
                    "function_code": "def __setitem__(\n    self,\n    key: Union[int, Sequence[int], Sequence[bool], slice],\n    value: Union[NaTType, Any, Sequence[Any]],\n) -> None:\n    # I'm fudging the types a bit here. \"Any\" above really depends\n    # on type(self). For PeriodArray, it's Period (or stuff coercible\n    # to a period in from_sequence). For DatetimeArray, it's Timestamp...\n    # I don't know if mypy can do that, possibly with Generics.\n    # https://mypy.readthedocs.io/en/latest/generics.html\n    if lib.is_scalar(value) and not isna(value):\n        value = com.maybe_box_datetimelike(value)\n\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n\n        if lib.is_scalar(key):\n            raise ValueError(\"setting an array element with a sequence.\")\n\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and not com.is_bool_indexer(key):\n                msg = (\n                    f\"shape mismatch: value array of length '{len(key)}' \"\n                    \"does not match indexing result of length \"\n                    f\"'{len(value)}'.\"\n                )\n                raise ValueError(msg)\n            elif not len(key):\n                return\n\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = (\n            f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', \"\n            f\"or array of those. Got '{type(value).__name__}' instead.\"\n        )\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 550,
                    "variables": {
                        "Union": [
                            552,
                            553
                        ],
                        "int": [
                            552
                        ],
                        "Sequence": [
                            552,
                            553,
                            570
                        ],
                        "bool": [
                            552
                        ],
                        "slice": [
                            552,
                            564
                        ],
                        "NaTType": [
                            553
                        ],
                        "Any": [
                            553
                        ],
                        "lib.is_scalar": [
                            560,
                            566
                        ],
                        "lib": [
                            560,
                            566
                        ],
                        "value": [
                            581,
                            582,
                            583,
                            584,
                            585,
                            586,
                            587,
                            588,
                            560,
                            561,
                            592,
                            563,
                            595,
                            571,
                            575
                        ],
                        "isna": [
                            560
                        ],
                        "com.maybe_box_datetimelike": [
                            561
                        ],
                        "com": [
                            561,
                            571
                        ],
                        "is_list_like": [
                            563
                        ],
                        "is_slice": [
                            569,
                            564
                        ],
                        "isinstance": [
                            584,
                            564
                        ],
                        "key": [
                            578,
                            595,
                            564,
                            566,
                            570,
                            571,
                            573
                        ],
                        "ValueError": [
                            577,
                            567
                        ],
                        "cast": [
                            570
                        ],
                        "len": [
                            578,
                            571,
                            573,
                            575
                        ],
                        "com.is_bool_indexer": [
                            571
                        ],
                        "msg": [
                            577,
                            594,
                            572,
                            590
                        ],
                        "_from_sequence": [
                            581
                        ],
                        "type": [
                            592,
                            581
                        ],
                        "self": [
                            581,
                            582,
                            584,
                            585,
                            586,
                            587,
                            591,
                            595,
                            596
                        ],
                        "self.dtype": [
                            587,
                            581
                        ],
                        "self._check_compatible_with": [
                            585,
                            582
                        ],
                        "value.asi8": [
                            583
                        ],
                        "self._scalar_type": [
                            584,
                            591
                        ],
                        "self._unbox_scalar": [
                            586
                        ],
                        "is_valid_nat_for_dtype": [
                            587
                        ],
                        "iNaT": [
                            588
                        ],
                        "self._scalar_type.__name__": [
                            591
                        ],
                        "__name__": [
                            592
                        ],
                        "TypeError": [
                            594
                        ],
                        "self._data": [
                            595
                        ],
                        "self._maybe_clear_freq": [
                            596
                        ]
                    },
                    "filtered_variables": {
                        "Union": [
                            552,
                            553
                        ],
                        "Sequence": [
                            552,
                            553,
                            570
                        ],
                        "NaTType": [
                            553
                        ],
                        "Any": [
                            553
                        ],
                        "lib.is_scalar": [
                            560,
                            566
                        ],
                        "lib": [
                            560,
                            566
                        ],
                        "value": [
                            581,
                            582,
                            583,
                            584,
                            585,
                            586,
                            587,
                            588,
                            560,
                            561,
                            592,
                            563,
                            595,
                            571,
                            575
                        ],
                        "isna": [
                            560
                        ],
                        "com.maybe_box_datetimelike": [
                            561
                        ],
                        "com": [
                            561,
                            571
                        ],
                        "is_list_like": [
                            563
                        ],
                        "is_slice": [
                            569,
                            564
                        ],
                        "key": [
                            578,
                            595,
                            564,
                            566,
                            570,
                            571,
                            573
                        ],
                        "cast": [
                            570
                        ],
                        "com.is_bool_indexer": [
                            571
                        ],
                        "msg": [
                            577,
                            594,
                            572,
                            590
                        ],
                        "_from_sequence": [
                            581
                        ],
                        "self": [
                            581,
                            582,
                            584,
                            585,
                            586,
                            587,
                            591,
                            595,
                            596
                        ],
                        "self.dtype": [
                            587,
                            581
                        ],
                        "self._check_compatible_with": [
                            585,
                            582
                        ],
                        "value.asi8": [
                            583
                        ],
                        "self._scalar_type": [
                            584,
                            591
                        ],
                        "self._unbox_scalar": [
                            586
                        ],
                        "is_valid_nat_for_dtype": [
                            587
                        ],
                        "iNaT": [
                            588
                        ],
                        "self._scalar_type.__name__": [
                            591
                        ],
                        "self._data": [
                            595
                        ],
                        "self._maybe_clear_freq": [
                            596
                        ]
                    },
                    "diff_line_number": 550,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_maybe_clear_freq",
                    "function_code": "def _maybe_clear_freq(self):\n    # inplace operations like __setitem__ may invalidate the freq of\n    # DatetimeArray and TimedeltaArray\n    pass\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 598,
                    "variables": {},
                    "filtered_variables": {},
                    "diff_line_number": 598,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "astype",
                    "function_code": "def astype(self, dtype, copy=True):\n    # Some notes on cases we don't have to handle here in the base class:\n    #   1. PeriodArray.astype handles period -> period\n    #   2. DatetimeArray.astype handles conversion between tz.\n    #   3. DatetimeArray.astype handles datetime -> period\n    from pandas import Categorical\n\n    dtype = pandas_dtype(dtype)\n\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and not is_categorical_dtype(dtype):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        # we deliberately ignore int32 vs. int64 here.\n        # See https://github.com/pandas-dev/pandas/issues/24381 for more.\n        values = self.asi8\n\n        if is_unsigned_integer_dtype(dtype):\n            # Again, we ignore int32 vs. int64\n            values = values.view(\"uint64\")\n\n        if copy:\n            values = values.copy()\n        return values\n    elif (\n        is_datetime_or_timedelta_dtype(dtype)\n        and not is_dtype_equal(self.dtype, dtype)\n    ) or is_float_dtype(dtype):\n        # disallow conversion between datetime/timedelta,\n        # and conversions for any datetimelike to float\n        msg = f\"Cannot cast {type(self).__name__} to dtype {dtype}\"\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 603,
                    "variables": {
                        "dtype": [
                            610,
                            612,
                            614,
                            616,
                            621,
                            629,
                            630,
                            631,
                            634,
                            636,
                            637,
                            639
                        ],
                        "pandas_dtype": [
                            610
                        ],
                        "is_object_dtype": [
                            612
                        ],
                        "self._box_values": [
                            613
                        ],
                        "self": [
                            613,
                            615,
                            619,
                            630,
                            634,
                            637,
                            639
                        ],
                        "self.asi8": [
                            619,
                            613
                        ],
                        "is_string_dtype": [
                            614
                        ],
                        "is_categorical_dtype": [
                            636,
                            614
                        ],
                        "self._format_native_types": [
                            615
                        ],
                        "is_integer_dtype": [
                            616
                        ],
                        "values": [
                            627,
                            626,
                            619,
                            623
                        ],
                        "is_unsigned_integer_dtype": [
                            621
                        ],
                        "values.view": [
                            623
                        ],
                        "copy": [
                            625
                        ],
                        "values.copy": [
                            626
                        ],
                        "is_datetime_or_timedelta_dtype": [
                            629
                        ],
                        "is_dtype_equal": [
                            630
                        ],
                        "self.dtype": [
                            630
                        ],
                        "is_float_dtype": [
                            631
                        ],
                        "msg": [
                            634,
                            635
                        ],
                        "__name__": [
                            634
                        ],
                        "type": [
                            634
                        ],
                        "TypeError": [
                            635
                        ],
                        "Categorical": [
                            637
                        ],
                        "np.asarray": [
                            639
                        ],
                        "np": [
                            639
                        ]
                    },
                    "filtered_variables": {
                        "dtype": [
                            610,
                            612,
                            614,
                            616,
                            621,
                            629,
                            630,
                            631,
                            634,
                            636,
                            637,
                            639
                        ],
                        "pandas_dtype": [
                            610
                        ],
                        "is_object_dtype": [
                            612
                        ],
                        "self._box_values": [
                            613
                        ],
                        "self": [
                            613,
                            615,
                            619,
                            630,
                            634,
                            637,
                            639
                        ],
                        "self.asi8": [
                            619,
                            613
                        ],
                        "is_string_dtype": [
                            614
                        ],
                        "is_categorical_dtype": [
                            636,
                            614
                        ],
                        "self._format_native_types": [
                            615
                        ],
                        "is_integer_dtype": [
                            616
                        ],
                        "values": [
                            627,
                            626,
                            619,
                            623
                        ],
                        "is_unsigned_integer_dtype": [
                            621
                        ],
                        "values.view": [
                            623
                        ],
                        "copy": [
                            625
                        ],
                        "values.copy": [
                            626
                        ],
                        "is_datetime_or_timedelta_dtype": [
                            629
                        ],
                        "is_dtype_equal": [
                            630
                        ],
                        "self.dtype": [
                            630
                        ],
                        "is_float_dtype": [
                            631
                        ],
                        "msg": [
                            634,
                            635
                        ],
                        "Categorical": [
                            637
                        ],
                        "np.asarray": [
                            639
                        ],
                        "np": [
                            639
                        ]
                    },
                    "diff_line_number": 603,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {
                                "dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "pandas_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._box_values": {
                                    "variable_value": "<bound method DatetimeLikeArrayMixin._box_values of <PeriodArray>\n['2013-01-03', '2013-01-04', '2013-01-05']\nLength: 3, dtype: period[D]>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['2013-01-03', '2013-01-04', '2013-01-05']\nLength: 3, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "3"
                                },
                                "self.asi8": {
                                    "variable_value": "array([15708, 15709, 15710])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_categorical_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._format_native_types": {
                                    "variable_value": "<bound method PeriodArray._format_native_types of <PeriodArray>\n['2013-01-03', '2013-01-04', '2013-01-05']\nLength: 3, dtype: period[D]>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "is_integer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_unsigned_integer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "copy": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "values.copy": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetime_or_timedelta_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "period[D]",
                                    "variable_type": "PeriodDtype",
                                    "variable_shape": "()"
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "msg": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "pandas_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._box_values": {
                                    "variable_value": "<bound method DatetimeLikeArrayMixin._box_values of <PeriodArray>\n['2013-01-03', '2013-01-04', '2013-01-05']\nLength: 3, dtype: period[D]>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['2013-01-03', '2013-01-04', '2013-01-05']\nLength: 3, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "3"
                                },
                                "self.asi8": {
                                    "variable_value": "array([15708, 15709, 15710])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_categorical_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._format_native_types": {
                                    "variable_value": "<bound method PeriodArray._format_native_types of <PeriodArray>\n['2013-01-03', '2013-01-04', '2013-01-05']\nLength: 3, dtype: period[D]>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "is_integer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_unsigned_integer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "copy": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "values.copy": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetime_or_timedelta_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "period[D]",
                                    "variable_type": "PeriodDtype",
                                    "variable_shape": "()"
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "msg": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Categorical": {
                                    "variable_value": "<class 'pandas.core.arrays.categorical.Categorical'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10eaab090>"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "pandas_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._box_values": {
                                    "variable_value": "<bound method DatetimeLikeArrayMixin._box_values of <PeriodArray>\n['2013-01-03', '2013-01-04', '2013-01-05']\nLength: 3, dtype: period[D]>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['2013-01-03', '2013-01-04', '2013-01-05']\nLength: 3, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "3"
                                },
                                "self.asi8": {
                                    "variable_value": "array([15708, 15709, 15710])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_categorical_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._format_native_types": {
                                    "variable_value": "<bound method PeriodArray._format_native_types of <PeriodArray>\n['2013-01-03', '2013-01-04', '2013-01-05']\nLength: 3, dtype: period[D]>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "is_integer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_unsigned_integer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "copy": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "values.copy": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetime_or_timedelta_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "period[D]",
                                    "variable_type": "PeriodDtype",
                                    "variable_shape": "()"
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "msg": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "pandas_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_object_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._box_values": {
                                    "variable_value": "<bound method DatetimeLikeArrayMixin._box_values of <PeriodArray>\n['2013-01-03', '2013-01-04', '2013-01-05']\nLength: 3, dtype: period[D]>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['2013-01-03', '2013-01-04', '2013-01-05']\nLength: 3, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "3"
                                },
                                "self.asi8": {
                                    "variable_value": "array([15708, 15709, 15710])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "3"
                                },
                                "is_string_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_categorical_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._format_native_types": {
                                    "variable_value": "<bound method PeriodArray._format_native_types of <PeriodArray>\n['2013-01-03', '2013-01-04', '2013-01-05']\nLength: 3, dtype: period[D]>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "is_integer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_unsigned_integer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values.view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "copy": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "values.copy": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_datetime_or_timedelta_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_dtype_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "period[D]",
                                    "variable_type": "PeriodDtype",
                                    "variable_shape": "()"
                                },
                                "is_float_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "msg": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Categorical": {
                                    "variable_value": "<class 'pandas.core.arrays.categorical.Categorical'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x1085fe090>"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                },
                {
                    "function_name": "view",
                    "function_code": "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 641,
                    "variables": {
                        "dtype": [
                            642,
                            644
                        ],
                        "self.dtype": [
                            642,
                            643
                        ],
                        "self": [
                            642,
                            643,
                            644
                        ],
                        "type": [
                            643
                        ],
                        "self._data": [
                            643,
                            644
                        ],
                        "self._data.view": [
                            644
                        ]
                    },
                    "filtered_variables": {
                        "dtype": [
                            642,
                            644
                        ],
                        "self.dtype": [
                            642,
                            643
                        ],
                        "self": [
                            642,
                            643,
                            644
                        ],
                        "self._data": [
                            643,
                            644
                        ],
                        "self._data.view": [
                            644
                        ]
                    },
                    "diff_line_number": 641,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "dtype": {
                                    "variable_value": "'i8'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "self.dtype": {
                                    "variable_value": "period[D]",
                                    "variable_type": "PeriodDtype",
                                    "variable_shape": "()"
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04', '2013-01-05']\nLength: 5, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "5"
                                },
                                "self._data": {
                                    "variable_value": "array([15706, 15707, 15708, 15709, 15710])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self._data.view": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            },
                            {
                                "dtype": {
                                    "variable_value": "'i8'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "self.dtype": {
                                    "variable_value": "period[D]",
                                    "variable_type": "PeriodDtype",
                                    "variable_shape": "()"
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04', '2013-01-05']\nLength: 5, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "5"
                                },
                                "self._data": {
                                    "variable_value": "array([15706, 15707, 15708, 15709, 15710])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self._data.view": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "dtype": {
                                    "variable_value": "'i8'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "self.dtype": {
                                    "variable_value": "period[D]",
                                    "variable_type": "PeriodDtype",
                                    "variable_shape": "()"
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04', '2013-01-05']\nLength: 5, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "5"
                                },
                                "self._data": {
                                    "variable_value": "array([15706, 15707, 15708, 15709, 15710])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self._data.view": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            },
                            {
                                "dtype": {
                                    "variable_value": "'i8'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "self.dtype": {
                                    "variable_value": "period[D]",
                                    "variable_type": "PeriodDtype",
                                    "variable_shape": "()"
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04', '2013-01-05']\nLength: 5, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "5"
                                },
                                "self._data": {
                                    "variable_value": "array([15706, 15707, 15708, 15709, 15710])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self._data.view": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "dtype": {
                                    "variable_value": "'i8'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "self.dtype": {
                                    "variable_value": "period[D]",
                                    "variable_type": "PeriodDtype",
                                    "variable_shape": "()"
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04', '2013-01-05']\nLength: 5, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "5"
                                },
                                "self._data": {
                                    "variable_value": "array([15706, 15707, 15708, 15709, 15710])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self._data.view": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            },
                            {
                                "dtype": {
                                    "variable_value": "'i8'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "self.dtype": {
                                    "variable_value": "period[D]",
                                    "variable_type": "PeriodDtype",
                                    "variable_shape": "()"
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04', '2013-01-05']\nLength: 5, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "5"
                                },
                                "self._data": {
                                    "variable_value": "array([15706, 15707, 15708, 15709, 15710])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self._data.view": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                },
                {
                    "function_name": "unique",
                    "function_code": "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 649,
                    "variables": {
                        "result": [
                            650,
                            651
                        ],
                        "unique1d": [
                            650
                        ],
                        "self.asi8": [
                            650
                        ],
                        "self": [
                            650,
                            651
                        ],
                        "type": [
                            651
                        ],
                        "self.dtype": [
                            651
                        ]
                    },
                    "filtered_variables": {
                        "result": [
                            650,
                            651
                        ],
                        "unique1d": [
                            650
                        ],
                        "self.asi8": [
                            650
                        ],
                        "self": [
                            650,
                            651
                        ],
                        "self.dtype": [
                            651
                        ]
                    },
                    "diff_line_number": 649,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_validate_fill_value",
                    "function_code": "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(\n            f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\"\n        )\n    return fill_value\n",
                    "decorators": [],
                    "docstring": "If a fill_value is passed to `take` convert it to an i8 representation,\nraising ValueError if this is not possible.\n\nParameters\n----------\nfill_value : object\n\nReturns\n-------\nfill_value : np.int64\n\nRaises\n------\nValueError",
                    "start_line": 653,
                    "variables": {
                        "isna": [
                            670
                        ],
                        "fill_value": [
                            672,
                            673,
                            674,
                            675,
                            678,
                            680,
                            670,
                            671
                        ],
                        "iNaT": [
                            671
                        ],
                        "isinstance": [
                            672
                        ],
                        "self._recognized_scalars": [
                            672
                        ],
                        "self": [
                            672,
                            673,
                            674,
                            675,
                            678
                        ],
                        "self._check_compatible_with": [
                            673
                        ],
                        "self._scalar_type": [
                            674,
                            678
                        ],
                        "self._unbox_scalar": [
                            675
                        ],
                        "ValueError": [
                            677
                        ]
                    },
                    "filtered_variables": {
                        "isna": [
                            670
                        ],
                        "fill_value": [
                            672,
                            673,
                            674,
                            675,
                            678,
                            680,
                            670,
                            671
                        ],
                        "iNaT": [
                            671
                        ],
                        "self._recognized_scalars": [
                            672
                        ],
                        "self": [
                            672,
                            673,
                            674,
                            675,
                            678
                        ],
                        "self._check_compatible_with": [
                            673
                        ],
                        "self._scalar_type": [
                            674,
                            678
                        ],
                        "self._unbox_scalar": [
                            675
                        ]
                    },
                    "diff_line_number": 653,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "take",
                    "function_code": "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n\n    new_values = take(\n        self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value\n    )\n\n    return type(self)(new_values, dtype=self.dtype)\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 682,
                    "variables": {
                        "allow_fill": [
                            683,
                            687
                        ],
                        "fill_value": [
                            684,
                            687
                        ],
                        "self._validate_fill_value": [
                            684
                        ],
                        "self": [
                            690,
                            684,
                            687
                        ],
                        "new_values": [
                            690,
                            686
                        ],
                        "take": [
                            686
                        ],
                        "self.asi8": [
                            687
                        ],
                        "indices": [
                            687
                        ],
                        "type": [
                            690
                        ],
                        "self.dtype": [
                            690
                        ]
                    },
                    "filtered_variables": {
                        "allow_fill": [
                            683,
                            687
                        ],
                        "fill_value": [
                            684,
                            687
                        ],
                        "self._validate_fill_value": [
                            684
                        ],
                        "self": [
                            690,
                            684,
                            687
                        ],
                        "new_values": [
                            690,
                            686
                        ],
                        "take": [
                            686
                        ],
                        "self.asi8": [
                            687
                        ],
                        "indices": [
                            687
                        ],
                        "self.dtype": [
                            690
                        ]
                    },
                    "diff_line_number": 682,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_concat_same_type",
                    "function_code": "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)\n",
                    "decorators": [
                        "classmethod"
                    ],
                    "docstring": null,
                    "start_line": 692,
                    "variables": {
                        "dtypes": [
                            696,
                            694,
                            695
                        ],
                        "x.dtype": [
                            694
                        ],
                        "x": [
                            698,
                            694
                        ],
                        "to_concat": [
                            698,
                            694
                        ],
                        "len": [
                            695
                        ],
                        "dtype": [
                            696,
                            699
                        ],
                        "list": [
                            696
                        ],
                        "values": [
                            698,
                            699
                        ],
                        "np.concatenate": [
                            698
                        ],
                        "np": [
                            698
                        ],
                        "x.asi8": [
                            698
                        ],
                        "cls": [
                            699
                        ],
                        "classmethod": [
                            692
                        ]
                    },
                    "filtered_variables": {
                        "dtypes": [
                            696,
                            694,
                            695
                        ],
                        "x.dtype": [
                            694
                        ],
                        "x": [
                            698,
                            694
                        ],
                        "to_concat": [
                            698,
                            694
                        ],
                        "dtype": [
                            696,
                            699
                        ],
                        "values": [
                            698,
                            699
                        ],
                        "np.concatenate": [
                            698
                        ],
                        "np": [
                            698
                        ],
                        "x.asi8": [
                            698
                        ],
                        "cls": [
                            699
                        ]
                    },
                    "diff_line_number": 693,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "copy",
                    "function_code": "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 701,
                    "variables": {
                        "values": [
                            702,
                            703
                        ],
                        "self.asi8.copy": [
                            702
                        ],
                        "self.asi8": [
                            702
                        ],
                        "self": [
                            702,
                            703
                        ],
                        "_simple_new": [
                            703
                        ],
                        "type": [
                            703
                        ],
                        "self.dtype": [
                            703
                        ],
                        "self.freq": [
                            703
                        ]
                    },
                    "filtered_variables": {
                        "values": [
                            702,
                            703
                        ],
                        "self.asi8.copy": [
                            702
                        ],
                        "self.asi8": [
                            702
                        ],
                        "self": [
                            702,
                            703
                        ],
                        "_simple_new": [
                            703
                        ],
                        "self.dtype": [
                            703
                        ],
                        "self.freq": [
                            703
                        ]
                    },
                    "diff_line_number": 701,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_values_for_factorize",
                    "function_code": "def _values_for_factorize(self):\n    return self.asi8, iNaT\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 705,
                    "variables": {
                        "self.asi8": [
                            706
                        ],
                        "self": [
                            706
                        ],
                        "iNaT": [
                            706
                        ]
                    },
                    "filtered_variables": {
                        "self.asi8": [
                            706
                        ],
                        "self": [
                            706
                        ],
                        "iNaT": [
                            706
                        ]
                    },
                    "diff_line_number": 705,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_from_factorized",
                    "function_code": "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)\n",
                    "decorators": [
                        "classmethod"
                    ],
                    "docstring": null,
                    "start_line": 708,
                    "variables": {
                        "cls": [
                            710
                        ],
                        "values": [
                            710
                        ],
                        "original.dtype": [
                            710
                        ],
                        "original": [
                            710
                        ],
                        "classmethod": [
                            708
                        ]
                    },
                    "filtered_variables": {
                        "cls": [
                            710
                        ],
                        "values": [
                            710
                        ],
                        "original.dtype": [
                            710
                        ],
                        "original": [
                            710
                        ]
                    },
                    "diff_line_number": 709,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_values_for_argsort",
                    "function_code": "def _values_for_argsort(self):\n    return self._data\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 712,
                    "variables": {
                        "self._data": [
                            713
                        ],
                        "self": [
                            713
                        ]
                    },
                    "filtered_variables": {
                        "self._data": [
                            713
                        ],
                        "self": [
                            713
                        ]
                    },
                    "diff_line_number": 712,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "searchsorted",
                    "function_code": "def searchsorted(self, value, side=\"left\", sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)\n",
                    "decorators": [],
                    "docstring": "Find indices where elements should be inserted to maintain order.\n\nFind the indices into a sorted array `self` such that, if the\ncorresponding elements in `value` were inserted before the indices,\nthe order of `self` would be preserved.\n\nParameters\n----------\nvalue : array_like\n    Values to insert into `self`.\nside : {'left', 'right'}, optional\n    If 'left', the index of the first suitable location found is given.\n    If 'right', return the last such index.  If there is no suitable\n    index, return either 0 or N (where N is the length of `self`).\nsorter : 1-D array_like, optional\n    Optional array of integer indices that sort `self` into ascending\n    order. They are typically the result of ``np.argsort``.\n\nReturns\n-------\nindices : array of ints\n    Array of insertion points with the same shape as `value`.",
                    "start_line": 720,
                    "variables": {
                        "isinstance": [
                            752,
                            745,
                            748
                        ],
                        "value": [
                            745,
                            746,
                            748,
                            749,
                            751,
                            752,
                            753,
                            755,
                            757
                        ],
                        "str": [
                            745
                        ],
                        "self._scalar_from_string": [
                            746
                        ],
                        "self": [
                            746,
                            748,
                            751,
                            752,
                            755,
                            757
                        ],
                        "self._scalar_type": [
                            748
                        ],
                        "type": [
                            752,
                            748,
                            749
                        ],
                        "isna": [
                            748
                        ],
                        "ValueError": [
                            749
                        ],
                        "self._check_compatible_with": [
                            751
                        ],
                        "value.asi8": [
                            753
                        ],
                        "self._unbox_scalar": [
                            755
                        ],
                        "self.asi8.searchsorted": [
                            757
                        ],
                        "self.asi8": [
                            757
                        ],
                        "side": [
                            757
                        ],
                        "sorter": [
                            757
                        ]
                    },
                    "filtered_variables": {
                        "value": [
                            745,
                            746,
                            748,
                            749,
                            751,
                            752,
                            753,
                            755,
                            757
                        ],
                        "self._scalar_from_string": [
                            746
                        ],
                        "self": [
                            746,
                            748,
                            751,
                            752,
                            755,
                            757
                        ],
                        "self._scalar_type": [
                            748
                        ],
                        "isna": [
                            748
                        ],
                        "self._check_compatible_with": [
                            751
                        ],
                        "value.asi8": [
                            753
                        ],
                        "self._unbox_scalar": [
                            755
                        ],
                        "self.asi8.searchsorted": [
                            757
                        ],
                        "self.asi8": [
                            757
                        ],
                        "side": [
                            757
                        ],
                        "sorter": [
                            757
                        ]
                    },
                    "diff_line_number": 720,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "repeat",
                    "function_code": "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view(\"i8\"), dtype=self.dtype)\n",
                    "decorators": [],
                    "docstring": "Repeat elements of an array.\n\nSee Also\n--------\nnumpy.ndarray.repeat",
                    "start_line": 759,
                    "variables": {
                        "nv.validate_repeat": [
                            767
                        ],
                        "nv": [
                            767
                        ],
                        "args": [
                            767
                        ],
                        "kwargs": [
                            767
                        ],
                        "values": [
                            768,
                            769
                        ],
                        "self._data.repeat": [
                            768
                        ],
                        "self._data": [
                            768
                        ],
                        "self": [
                            768,
                            769
                        ],
                        "repeats": [
                            768
                        ],
                        "type": [
                            769
                        ],
                        "values.view": [
                            769
                        ],
                        "self.dtype": [
                            769
                        ]
                    },
                    "filtered_variables": {
                        "nv.validate_repeat": [
                            767
                        ],
                        "nv": [
                            767
                        ],
                        "args": [
                            767
                        ],
                        "kwargs": [
                            767
                        ],
                        "values": [
                            768,
                            769
                        ],
                        "self._data.repeat": [
                            768
                        ],
                        "self._data": [
                            768
                        ],
                        "self": [
                            768,
                            769
                        ],
                        "repeats": [
                            768
                        ],
                        "values.view": [
                            769
                        ],
                        "self.dtype": [
                            769
                        ]
                    },
                    "diff_line_number": 759,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "value_counts",
                    "function_code": "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n\n    cls = type(self)\n\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(\n        cls(result.index.view(\"i8\"), dtype=self.dtype), name=result.index.name\n    )\n    return Series(result.values, index=index, name=result.name)\n",
                    "decorators": [],
                    "docstring": "Return a Series containing counts of unique values.\n\nParameters\n----------\ndropna : bool, default True\n    Don't include counts of NaT values.\n\nReturns\n-------\nSeries",
                    "start_line": 771,
                    "variables": {
                        "dropna": [
                            793,
                            786
                        ],
                        "values": [
                            793,
                            787,
                            789
                        ],
                        "_data": [
                            787
                        ],
                        "self": [
                            795,
                            787,
                            789,
                            791
                        ],
                        "self.isna": [
                            787
                        ],
                        "self._data": [
                            789
                        ],
                        "cls": [
                            795,
                            791
                        ],
                        "type": [
                            791
                        ],
                        "result": [
                            793,
                            795,
                            797
                        ],
                        "value_counts": [
                            793
                        ],
                        "index": [
                            794,
                            797
                        ],
                        "Index": [
                            794
                        ],
                        "result.index.view": [
                            795
                        ],
                        "result.index": [
                            795
                        ],
                        "self.dtype": [
                            795
                        ],
                        "result.index.name": [
                            795
                        ],
                        "Series": [
                            797
                        ],
                        "result.values": [
                            797
                        ],
                        "result.name": [
                            797
                        ]
                    },
                    "filtered_variables": {
                        "dropna": [
                            793,
                            786
                        ],
                        "values": [
                            793,
                            787,
                            789
                        ],
                        "_data": [
                            787
                        ],
                        "self": [
                            795,
                            787,
                            789,
                            791
                        ],
                        "self.isna": [
                            787
                        ],
                        "self._data": [
                            789
                        ],
                        "cls": [
                            795,
                            791
                        ],
                        "result": [
                            793,
                            795,
                            797
                        ],
                        "value_counts": [
                            793
                        ],
                        "index": [
                            794,
                            797
                        ],
                        "Index": [
                            794
                        ],
                        "result.index.view": [
                            795
                        ],
                        "result.index": [
                            795
                        ],
                        "self.dtype": [
                            795
                        ],
                        "result.index.name": [
                            795
                        ],
                        "Series": [
                            797
                        ],
                        "result.values": [
                            797
                        ],
                        "result.name": [
                            797
                        ]
                    },
                    "diff_line_number": 771,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "map",
                    "function_code": "def map(self, mapper):\n    # TODO(GH-23179): Add ExtensionArray.map\n    # Need to figure out if we want ExtensionArray.map first.\n    # If so, then we can refactor IndexOpsMixin._map_values to\n    # a standalone function and call from here..\n    # Else, just rewrite _map_infer_values to do the right thing.\n    from pandas import Index\n\n    return Index(self).map(mapper).array\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 799,
                    "variables": {
                        "array": [
                            807
                        ],
                        "map": [
                            807
                        ],
                        "Index": [
                            807
                        ],
                        "self": [
                            807
                        ],
                        "mapper": [
                            807
                        ]
                    },
                    "filtered_variables": {
                        "array": [
                            807
                        ],
                        "Index": [
                            807
                        ],
                        "self": [
                            807
                        ],
                        "mapper": [
                            807
                        ]
                    },
                    "diff_line_number": 799,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "isna",
                    "function_code": "def isna(self):\n    return self._isnan\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 812,
                    "variables": {
                        "self._isnan": [
                            813
                        ],
                        "self": [
                            813
                        ]
                    },
                    "filtered_variables": {
                        "self._isnan": [
                            813
                        ],
                        "self": [
                            813
                        ]
                    },
                    "diff_line_number": 812,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {
                                "self._isnan": {
                                    "variable_value": "array([ True,  True, False, False, False])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['NaT', 'NaT', '2013-01-03', '2013-01-04', '2013-01-05']\nLength: 5, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "5"
                                }
                            },
                            {
                                "self._isnan": {
                                    "variable_value": "array([ True,  True, False, False, False])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['NaT', 'NaT', '2013-01-03', '2013-01-04', '2013-01-05']\nLength: 5, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "5"
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "self._isnan": {
                                    "variable_value": "array([ True,  True, False, False, False])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['NaT', 'NaT', '2013-01-03', '2013-01-04', '2013-01-05']\nLength: 5, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "5"
                                }
                            },
                            {
                                "self._isnan": {
                                    "variable_value": "array([ True,  True, False, False, False])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['NaT', 'NaT', '2013-01-03', '2013-01-04', '2013-01-05']\nLength: 5, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "5"
                                }
                            }
                        ],
                        [
                            {
                                "self._isnan": {
                                    "variable_value": "array([ True,  True, False, False, False])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['NaT', 'NaT', '2013-01-03', '2013-01-04', '2013-01-05']\nLength: 5, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "5"
                                }
                            },
                            {
                                "self._isnan": {
                                    "variable_value": "array([ True,  True, False, False, False])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['NaT', 'NaT', '2013-01-03', '2013-01-04', '2013-01-05']\nLength: 5, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "5"
                                }
                            }
                        ],
                        [
                            {
                                "self._isnan": {
                                    "variable_value": "array([ True,  True, False, False, False])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['NaT', 'NaT', '2013-01-03', '2013-01-04', '2013-01-05']\nLength: 5, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "5"
                                }
                            },
                            {
                                "self._isnan": {
                                    "variable_value": "array([ True,  True, False, False, False])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['NaT', 'NaT', '2013-01-03', '2013-01-04', '2013-01-05']\nLength: 5, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "5"
                                }
                            }
                        ]
                    ]
                },
                {
                    "function_name": "_isnan",
                    "function_code": "@property  # NB: override with cache_readonly in immutable subclasses\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT\n",
                    "decorators": [
                        "property"
                    ],
                    "docstring": "return if each value is nan",
                    "start_line": 815,
                    "variables": {
                        "self.asi8": [
                            820
                        ],
                        "self": [
                            820
                        ],
                        "iNaT": [
                            820
                        ],
                        "property": [
                            815
                        ]
                    },
                    "filtered_variables": {
                        "self.asi8": [
                            820
                        ],
                        "self": [
                            820
                        ],
                        "iNaT": [
                            820
                        ]
                    },
                    "diff_line_number": 816,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {
                                "self.asi8": {
                                    "variable_value": "array([-9223372036854775808, -9223372036854775808,                15708,\n                      15709,                15710])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['NaT', 'NaT', '2013-01-03', '2013-01-04', '2013-01-05']\nLength: 5, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "5"
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "self.asi8": {
                                    "variable_value": "array([-9223372036854775808, -9223372036854775808,                15708,\n                      15709,                15710])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['NaT', 'NaT', '2013-01-03', '2013-01-04', '2013-01-05']\nLength: 5, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "5"
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "self.asi8": {
                                    "variable_value": "array([-9223372036854775808, -9223372036854775808,                15708,\n                      15709,                15710])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['NaT', 'NaT', '2013-01-03', '2013-01-04', '2013-01-05']\nLength: 5, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "5"
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "self.asi8": {
                                    "variable_value": "array([-9223372036854775808, -9223372036854775808,                15708,\n                      15709,                15710])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['NaT', 'NaT', '2013-01-03', '2013-01-04', '2013-01-05']\nLength: 5, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "5"
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "self.asi8": {
                                    "variable_value": "array([-9223372036854775808, -9223372036854775808,                15708,\n                      15709,                15710])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['NaT', 'NaT', '2013-01-03', '2013-01-04', '2013-01-05']\nLength: 5, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "5"
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "self.asi8": {
                                    "variable_value": "array([-9223372036854775808, -9223372036854775808,                15708,\n                      15709,                15710])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['NaT', 'NaT', '2013-01-03', '2013-01-04', '2013-01-05']\nLength: 5, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "5"
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "self.asi8": {
                                    "variable_value": "array([-9223372036854775808, -9223372036854775808,                15708,\n                      15709,                15710])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['NaT', 'NaT', '2013-01-03', '2013-01-04', '2013-01-05']\nLength: 5, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "5"
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "self.asi8": {
                                    "variable_value": "array([-9223372036854775808, -9223372036854775808,                15708,\n                      15709,                15710])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['NaT', 'NaT', '2013-01-03', '2013-01-04', '2013-01-05']\nLength: 5, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "5"
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "self.asi8": {
                                    "variable_value": "array([-9223372036854775808, -9223372036854775808,                15708,\n                      15709,                15710])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['NaT', 'NaT', '2013-01-03', '2013-01-04', '2013-01-05']\nLength: 5, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "5"
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "self.asi8": {
                                    "variable_value": "array([-9223372036854775808, -9223372036854775808,                15708,\n                      15709,                15710])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['NaT', 'NaT', '2013-01-03', '2013-01-04', '2013-01-05']\nLength: 5, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "5"
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "self.asi8": {
                                    "variable_value": "array([-9223372036854775808, -9223372036854775808,                15708,\n                      15709,                15710])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['NaT', 'NaT', '2013-01-03', '2013-01-04', '2013-01-05']\nLength: 5, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "5"
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "self.asi8": {
                                    "variable_value": "array([-9223372036854775808, -9223372036854775808,                15708,\n                      15709,                15710])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['NaT', 'NaT', '2013-01-03', '2013-01-04', '2013-01-05']\nLength: 5, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "5"
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                },
                {
                    "function_name": "_hasnans",
                    "function_code": "@property  # NB: override with cache_readonly in immutable subclasses\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())\n",
                    "decorators": [
                        "property"
                    ],
                    "docstring": "return if I have any nans; enables various perf speedups",
                    "start_line": 822,
                    "variables": {
                        "bool": [
                            827
                        ],
                        "self._isnan.any": [
                            827
                        ],
                        "self._isnan": [
                            827
                        ],
                        "self": [
                            827
                        ],
                        "property": [
                            822
                        ]
                    },
                    "filtered_variables": {
                        "self._isnan.any": [
                            827
                        ],
                        "self._isnan": [
                            827
                        ],
                        "self": [
                            827
                        ]
                    },
                    "diff_line_number": 823,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "self._isnan.any": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": "array([ True,  True, False, False, False])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['NaT', 'NaT', '2013-01-03', '2013-01-04', '2013-01-05']\nLength: 5, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "5"
                                }
                            },
                            {
                                "self._isnan.any": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._isnan": {
                                    "variable_value": "array([ True,  True, False, False, False])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                },
                                "self": {
                                    "variable_value": "<PeriodArray>\n['NaT', 'NaT', '2013-01-03', '2013-01-04', '2013-01-05']\nLength: 5, dtype: period[D]",
                                    "variable_type": "PeriodArray",
                                    "variable_shape": "5"
                                }
                            }
                        ]
                    ]
                },
                {
                    "function_name": "_maybe_mask_results",
                    "function_code": "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result\n",
                    "decorators": [],
                    "docstring": "Parameters\n----------\nresult : a ndarray\nfill_value : object, default iNaT\nconvert : str, dtype or None\n\nReturns\n-------\nresult : ndarray with values replace by the fill_value\n\nmask the result if needed, convert to the provided dtype if its not\nNone\n\nThis is an internal routine.",
                    "start_line": 829,
                    "variables": {
                        "iNaT": [
                            829
                        ],
                        "self._hasnans": [
                            847
                        ],
                        "self": [
                            852,
                            847
                        ],
                        "convert": [
                            848,
                            849
                        ],
                        "result": [
                            849,
                            852,
                            853
                        ],
                        "result.astype": [
                            849
                        ],
                        "fill_value": [
                            850,
                            851,
                            852
                        ],
                        "np.nan": [
                            851
                        ],
                        "np": [
                            851
                        ],
                        "self._isnan": [
                            852
                        ]
                    },
                    "filtered_variables": {
                        "iNaT": [
                            829
                        ],
                        "self._hasnans": [
                            847
                        ],
                        "self": [
                            852,
                            847
                        ],
                        "convert": [
                            848,
                            849
                        ],
                        "result": [
                            849,
                            852,
                            853
                        ],
                        "result.astype": [
                            849
                        ],
                        "fill_value": [
                            850,
                            851,
                            852
                        ],
                        "np.nan": [
                            851
                        ],
                        "np": [
                            851
                        ],
                        "self._isnan": [
                            852
                        ]
                    },
                    "diff_line_number": 829,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "fillna",
                    "function_code": "def fillna(self, value=None, method=None, limit=None):\n    # TODO(GH-20300): remove this\n    # Just overriding to ensure that we avoid an astype(object).\n    # Either 20300 or a `_values_for_fillna` would avoid this duplication.\n    if isinstance(value, ABCSeries):\n        value = value.array\n\n    value, method = validate_fillna_kwargs(value, method)\n\n    mask = self.isna()\n\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(\n                f\"Length of 'value' does not match. Got ({len(value)}) \"\n                f\" expected {len(self)}\"\n            )\n        value = value[mask]\n\n    if mask.any():\n        if method is not None:\n            if method == \"pad\":\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n\n            values = self._data\n            if not is_period_dtype(self):\n                # For PeriodArray self._data is i8, which gets copied\n                #  by `func`.  Otherwise we need to make a copy manually\n                # to avoid modifying `self` in-place.\n                values = values.copy()\n\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                # we need to pass int64 values to the constructor to avoid\n                #  re-localizing incorrectly\n                new_values = new_values.view(\"i8\")\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            # fill with value\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 855,
                    "variables": {
                        "isinstance": [
                            859
                        ],
                        "value": [
                            897,
                            866,
                            867,
                            869,
                            872,
                            859,
                            860,
                            862
                        ],
                        "ABCSeries": [
                            859
                        ],
                        "value.array": [
                            860
                        ],
                        "method": [
                            875,
                            876,
                            862
                        ],
                        "validate_fillna_kwargs": [
                            862
                        ],
                        "mask": [
                            864,
                            897,
                            872,
                            874,
                            888
                        ],
                        "self.isna": [
                            864
                        ],
                        "self": [
                            864,
                            896,
                            867,
                            899,
                            870,
                            881,
                            882,
                            889,
                            893
                        ],
                        "is_array_like": [
                            866
                        ],
                        "len": [
                            867,
                            869,
                            870
                        ],
                        "ValueError": [
                            868
                        ],
                        "mask.any": [
                            874
                        ],
                        "func": [
                            888,
                            877,
                            879
                        ],
                        "missing.pad_1d": [
                            877
                        ],
                        "missing": [
                            877,
                            879
                        ],
                        "missing.backfill_1d": [
                            879
                        ],
                        "values": [
                            888,
                            881,
                            886
                        ],
                        "self._data": [
                            881
                        ],
                        "is_period_dtype": [
                            882
                        ],
                        "values.copy": [
                            886
                        ],
                        "new_values": [
                            896,
                            897,
                            899,
                            900,
                            888,
                            892,
                            893
                        ],
                        "limit": [
                            888
                        ],
                        "is_datetime64tz_dtype": [
                            889
                        ],
                        "new_values.view": [
                            892
                        ],
                        "type": [
                            893
                        ],
                        "self.dtype": [
                            893
                        ],
                        "self.copy": [
                            896,
                            899
                        ]
                    },
                    "filtered_variables": {
                        "value": [
                            897,
                            866,
                            867,
                            869,
                            872,
                            859,
                            860,
                            862
                        ],
                        "ABCSeries": [
                            859
                        ],
                        "value.array": [
                            860
                        ],
                        "method": [
                            875,
                            876,
                            862
                        ],
                        "validate_fillna_kwargs": [
                            862
                        ],
                        "mask": [
                            864,
                            897,
                            872,
                            874,
                            888
                        ],
                        "self.isna": [
                            864
                        ],
                        "self": [
                            864,
                            896,
                            867,
                            899,
                            870,
                            881,
                            882,
                            889,
                            893
                        ],
                        "is_array_like": [
                            866
                        ],
                        "mask.any": [
                            874
                        ],
                        "func": [
                            888,
                            877,
                            879
                        ],
                        "missing.pad_1d": [
                            877
                        ],
                        "missing": [
                            877,
                            879
                        ],
                        "missing.backfill_1d": [
                            879
                        ],
                        "values": [
                            888,
                            881,
                            886
                        ],
                        "self._data": [
                            881
                        ],
                        "is_period_dtype": [
                            882
                        ],
                        "values.copy": [
                            886
                        ],
                        "new_values": [
                            896,
                            897,
                            899,
                            900,
                            888,
                            892,
                            893
                        ],
                        "limit": [
                            888
                        ],
                        "is_datetime64tz_dtype": [
                            889
                        ],
                        "new_values.view": [
                            892
                        ],
                        "self.dtype": [
                            893
                        ],
                        "self.copy": [
                            896,
                            899
                        ]
                    },
                    "diff_line_number": 855,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "freq",
                    "function_code": "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq\n",
                    "decorators": [
                        "property"
                    ],
                    "docstring": "Return the frequency object if it is set, otherwise None.",
                    "start_line": 905,
                    "variables": {
                        "self._freq": [
                            910
                        ],
                        "self": [
                            910
                        ],
                        "property": [
                            905
                        ]
                    },
                    "filtered_variables": {
                        "self._freq": [
                            910
                        ],
                        "self": [
                            910
                        ]
                    },
                    "diff_line_number": 906,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ],
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "freq",
                    "function_code": "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n\n    self._freq = value\n",
                    "decorators": [
                        "freq.setter"
                    ],
                    "docstring": null,
                    "start_line": 912,
                    "variables": {
                        "value": [
                            914,
                            915,
                            916,
                            918
                        ],
                        "frequencies.to_offset": [
                            915
                        ],
                        "frequencies": [
                            915
                        ],
                        "self._validate_frequency": [
                            916
                        ],
                        "self": [
                            916,
                            918
                        ],
                        "self._freq": [
                            918
                        ],
                        "freq.setter": [
                            912
                        ],
                        "freq": [
                            912
                        ]
                    },
                    "filtered_variables": {
                        "value": [
                            914,
                            915,
                            916,
                            918
                        ],
                        "frequencies.to_offset": [
                            915
                        ],
                        "frequencies": [
                            915
                        ],
                        "self._validate_frequency": [
                            916
                        ],
                        "self": [
                            916,
                            918
                        ],
                        "self._freq": [
                            918
                        ],
                        "freq.setter": [
                            912
                        ],
                        "freq": [
                            912
                        ]
                    },
                    "diff_line_number": 913,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "freqstr",
                    "function_code": "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr\n",
                    "decorators": [
                        "property"
                    ],
                    "docstring": "Return the frequency object as a string if its set, otherwise None",
                    "start_line": 920,
                    "variables": {
                        "self.freq": [
                            925,
                            927
                        ],
                        "self": [
                            925,
                            927
                        ],
                        "self.freq.freqstr": [
                            927
                        ],
                        "property": [
                            920
                        ]
                    },
                    "filtered_variables": {
                        "self.freq": [
                            925,
                            927
                        ],
                        "self": [
                            925,
                            927
                        ],
                        "self.freq.freqstr": [
                            927
                        ]
                    },
                    "diff_line_number": 921,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "inferred_freq",
                    "function_code": "@property  # NB: override with cache_readonly in immutable subclasses\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None\n",
                    "decorators": [
                        "property"
                    ],
                    "docstring": "Tryies to return a string representing a frequency guess,\ngenerated by infer_freq.  Returns None if it can't autodetect the\nfrequency.",
                    "start_line": 929,
                    "variables": {
                        "self.ndim": [
                            936
                        ],
                        "self": [
                            936,
                            939
                        ],
                        "frequencies.infer_freq": [
                            939
                        ],
                        "frequencies": [
                            939
                        ],
                        "ValueError": [
                            940
                        ],
                        "property": [
                            929
                        ]
                    },
                    "filtered_variables": {
                        "self.ndim": [
                            936
                        ],
                        "self": [
                            936,
                            939
                        ],
                        "frequencies.infer_freq": [
                            939
                        ],
                        "frequencies": [
                            939
                        ]
                    },
                    "diff_line_number": 930,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "self.ndim": {
                                    "variable_value": "1",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n[                'NaT',                 'NaT', '2013-01-03 00:00:00',\n '2013-01-04 00:00:00', '2013-01-05 00:00:00']\nLength: 5, dtype: datetime64[ns]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "5"
                                },
                                "frequencies.infer_freq": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "self.ndim": {
                                    "variable_value": "1",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<DatetimeArray>\n[                'NaT',                 'NaT', '2013-01-03 00:00:00',\n '2013-01-04 00:00:00', '2013-01-05 00:00:00']\nLength: 5, dtype: datetime64[ns]",
                                    "variable_type": "DatetimeArray",
                                    "variable_shape": "5"
                                },
                                "frequencies.infer_freq": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                },
                {
                    "function_name": "_resolution",
                    "function_code": "@property  # NB: override with cache_readonly in immutable subclasses\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)\n",
                    "decorators": [
                        "property"
                    ],
                    "docstring": null,
                    "start_line": 943,
                    "variables": {
                        "frequencies.Resolution.get_reso_from_freq": [
                            945
                        ],
                        "frequencies.Resolution": [
                            945
                        ],
                        "frequencies": [
                            945
                        ],
                        "self.freqstr": [
                            945
                        ],
                        "self": [
                            945
                        ],
                        "property": [
                            943
                        ]
                    },
                    "filtered_variables": {
                        "frequencies.Resolution.get_reso_from_freq": [
                            945
                        ],
                        "frequencies.Resolution": [
                            945
                        ],
                        "frequencies": [
                            945
                        ],
                        "self.freqstr": [
                            945
                        ],
                        "self": [
                            945
                        ]
                    },
                    "diff_line_number": 944,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "resolution",
                    "function_code": "@property  # NB: override with cache_readonly in immutable subclasses\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)\n",
                    "decorators": [
                        "property"
                    ],
                    "docstring": "Returns day, hour, minute, second, millisecond or microsecond",
                    "start_line": 947,
                    "variables": {
                        "frequencies.Resolution.get_str": [
                            952
                        ],
                        "frequencies.Resolution": [
                            952
                        ],
                        "frequencies": [
                            952
                        ],
                        "self._resolution": [
                            952
                        ],
                        "self": [
                            952
                        ],
                        "property": [
                            947
                        ]
                    },
                    "filtered_variables": {
                        "frequencies.Resolution.get_str": [
                            952
                        ],
                        "frequencies.Resolution": [
                            952
                        ],
                        "frequencies": [
                            952
                        ],
                        "self._resolution": [
                            952
                        ],
                        "self": [
                            952
                        ]
                    },
                    "diff_line_number": 948,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_validate_frequency",
                    "function_code": "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        # Frequency validation is not meaningful for Period Array/Index\n        return None\n\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n\n    try:\n        on_freq = cls._generate_range(\n            start=index[0], end=None, periods=len(index), freq=freq, **kwargs\n        )\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if \"non-fixed\" in str(e):\n            # non-fixed frequencies are not meaningful for timedelta64;\n            #  we retain that error message\n            raise e\n        # GH#11587 the main way this is reached is if the `np.array_equal`\n        #  check above is False.  This can also be reached if index[0]\n        #  is `NaT`, in which case the call to `cls._generate_range` will\n        #  raise a ValueError, which we re-raise with a more targeted\n        #  message.\n        raise ValueError(\n            f\"Inferred frequency {inferred} from passed values \"\n            f\"does not conform to passed frequency {freq.freqstr}\"\n        )\n",
                    "decorators": [
                        "classmethod"
                    ],
                    "docstring": "Validate that a frequency is compatible with the values of a given\nDatetime Array/Index or Timedelta Array/Index\n\nParameters\n----------\nindex : DatetimeIndex or TimedeltaIndex\n    The index on which to determine if the given frequency is valid\nfreq : DateOffset\n    The frequency to validate",
                    "start_line": 954,
                    "variables": {
                        "is_period_dtype": [
                            967
                        ],
                        "cls": [
                            976,
                            967
                        ],
                        "inferred": [
                            992,
                            971,
                            972
                        ],
                        "index.inferred_freq": [
                            971
                        ],
                        "index": [
                            977,
                            971,
                            972,
                            979
                        ],
                        "index.size": [
                            972
                        ],
                        "freq.freqstr": [
                            993,
                            972
                        ],
                        "freq": [
                            977,
                            972,
                            993
                        ],
                        "on_freq": [
                            976,
                            979
                        ],
                        "cls._generate_range": [
                            976
                        ],
                        "len": [
                            977
                        ],
                        "kwargs": [
                            977
                        ],
                        "np.array_equal": [
                            979
                        ],
                        "np": [
                            979
                        ],
                        "index.asi8": [
                            979
                        ],
                        "on_freq.asi8": [
                            979
                        ],
                        "ValueError": [
                            980,
                            981,
                            991
                        ],
                        "str": [
                            982
                        ],
                        "e": [
                            985,
                            982
                        ],
                        "classmethod": [
                            954
                        ]
                    },
                    "filtered_variables": {
                        "is_period_dtype": [
                            967
                        ],
                        "cls": [
                            976,
                            967
                        ],
                        "inferred": [
                            992,
                            971,
                            972
                        ],
                        "index.inferred_freq": [
                            971
                        ],
                        "index": [
                            977,
                            971,
                            972,
                            979
                        ],
                        "index.size": [
                            972
                        ],
                        "freq.freqstr": [
                            993,
                            972
                        ],
                        "freq": [
                            977,
                            972,
                            993
                        ],
                        "on_freq": [
                            976,
                            979
                        ],
                        "cls._generate_range": [
                            976
                        ],
                        "kwargs": [
                            977
                        ],
                        "np.array_equal": [
                            979
                        ],
                        "np": [
                            979
                        ],
                        "index.asi8": [
                            979
                        ],
                        "on_freq.asi8": [
                            979
                        ],
                        "e": [
                            985,
                            982
                        ]
                    },
                    "diff_line_number": 955,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_is_monotonic_increasing",
                    "function_code": "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]\n",
                    "decorators": [
                        "property"
                    ],
                    "docstring": null,
                    "start_line": 999,
                    "variables": {
                        "algos.is_monotonic": [
                            1001
                        ],
                        "algos": [
                            1001
                        ],
                        "self.asi8": [
                            1001
                        ],
                        "self": [
                            1001
                        ],
                        "property": [
                            999
                        ]
                    },
                    "filtered_variables": {
                        "algos.is_monotonic": [
                            1001
                        ],
                        "algos": [
                            1001
                        ],
                        "self.asi8": [
                            1001
                        ],
                        "self": [
                            1001
                        ]
                    },
                    "diff_line_number": 1000,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_is_monotonic_decreasing",
                    "function_code": "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]\n",
                    "decorators": [
                        "property"
                    ],
                    "docstring": null,
                    "start_line": 1003,
                    "variables": {
                        "algos.is_monotonic": [
                            1005
                        ],
                        "algos": [
                            1005
                        ],
                        "self.asi8": [
                            1005
                        ],
                        "self": [
                            1005
                        ],
                        "property": [
                            1003
                        ]
                    },
                    "filtered_variables": {
                        "algos.is_monotonic": [
                            1005
                        ],
                        "algos": [
                            1005
                        ],
                        "self.asi8": [
                            1005
                        ],
                        "self": [
                            1005
                        ]
                    },
                    "diff_line_number": 1004,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_is_unique",
                    "function_code": "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)\n",
                    "decorators": [
                        "property"
                    ],
                    "docstring": null,
                    "start_line": 1007,
                    "variables": {
                        "len": [
                            1009
                        ],
                        "unique1d": [
                            1009
                        ],
                        "self.asi8": [
                            1009
                        ],
                        "self": [
                            1009
                        ],
                        "property": [
                            1007
                        ]
                    },
                    "filtered_variables": {
                        "unique1d": [
                            1009
                        ],
                        "self.asi8": [
                            1009
                        ],
                        "self": [
                            1009
                        ]
                    },
                    "diff_line_number": 1008,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_add_datetimelike_scalar",
                    "function_code": "def _add_datetimelike_scalar(self, other):\n    # Overridden by TimedeltaArray\n    raise TypeError(f\"cannot add {type(self).__name__} and {type(other).__name__}\")\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 1030,
                    "variables": {
                        "TypeError": [
                            1032
                        ],
                        "__name__": [
                            1032
                        ],
                        "type": [
                            1032
                        ],
                        "self": [
                            1032
                        ],
                        "other": [
                            1032
                        ]
                    },
                    "filtered_variables": {
                        "self": [
                            1032
                        ],
                        "other": [
                            1032
                        ]
                    },
                    "diff_line_number": 1030,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_sub_datetimelike_scalar",
                    "function_code": "def _sub_datetimelike_scalar(self, other):\n    # Overridden by DatetimeArray\n    assert other is not NaT\n    raise TypeError(f\"cannot subtract a datelike from a {type(self).__name__}\")\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 1036,
                    "variables": {
                        "other": [
                            1038
                        ],
                        "NaT": [
                            1038
                        ],
                        "TypeError": [
                            1039
                        ],
                        "__name__": [
                            1039
                        ],
                        "type": [
                            1039
                        ],
                        "self": [
                            1039
                        ]
                    },
                    "filtered_variables": {
                        "other": [
                            1038
                        ],
                        "NaT": [
                            1038
                        ],
                        "self": [
                            1039
                        ]
                    },
                    "diff_line_number": 1036,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_sub_period",
                    "function_code": "def _sub_period(self, other):\n    # Overridden by PeriodArray\n    raise TypeError(f\"cannot subtract Period from a {type(self).__name__}\")\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 1043,
                    "variables": {
                        "TypeError": [
                            1045
                        ],
                        "__name__": [
                            1045
                        ],
                        "type": [
                            1045
                        ],
                        "self": [
                            1045
                        ]
                    },
                    "filtered_variables": {
                        "self": [
                            1045
                        ]
                    },
                    "diff_line_number": 1043,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_add_offset",
                    "function_code": "def _add_offset(self, offset):\n    raise AbstractMethodError(self)\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 1047,
                    "variables": {
                        "AbstractMethodError": [
                            1048
                        ],
                        "self": [
                            1048
                        ]
                    },
                    "filtered_variables": {
                        "AbstractMethodError": [
                            1048
                        ],
                        "self": [
                            1048
                        ]
                    },
                    "diff_line_number": 1047,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_add_delta",
                    "function_code": "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        # ndarray[timedelta64] or TimedeltaArray/index\n        new_values = self._add_delta_tdi(other)\n\n    return new_values\n",
                    "decorators": [],
                    "docstring": "Add a timedelta-like, Tick or TimedeltaIndex-like object\nto self, yielding an int64 numpy array\n\nParameters\n----------\ndelta : {timedelta, np.timedelta64, Tick,\n         TimedeltaIndex, ndarray[timedelta64]}\n\nReturns\n-------\nresult : ndarray[int64]\n\nNotes\n-----\nThe result's name is set outside of _add_delta by the calling\nmethod (__add__ or __sub__), if necessary (i.e. for Indexes).",
                    "start_line": 1050,
                    "variables": {
                        "isinstance": [
                            1069
                        ],
                        "other": [
                            1073,
                            1069,
                            1070,
                            1071
                        ],
                        "Tick": [
                            1069
                        ],
                        "timedelta": [
                            1069
                        ],
                        "np.timedelta64": [
                            1069
                        ],
                        "np": [
                            1069
                        ],
                        "new_values": [
                            1073,
                            1075,
                            1070
                        ],
                        "self._add_timedeltalike_scalar": [
                            1070
                        ],
                        "self": [
                            1073,
                            1070
                        ],
                        "is_timedelta64_dtype": [
                            1071
                        ],
                        "self._add_delta_tdi": [
                            1073
                        ]
                    },
                    "filtered_variables": {
                        "other": [
                            1073,
                            1069,
                            1070,
                            1071
                        ],
                        "Tick": [
                            1069
                        ],
                        "timedelta": [
                            1069
                        ],
                        "np.timedelta64": [
                            1069
                        ],
                        "np": [
                            1069
                        ],
                        "new_values": [
                            1073,
                            1075,
                            1070
                        ],
                        "self._add_timedeltalike_scalar": [
                            1070
                        ],
                        "self": [
                            1073,
                            1070
                        ],
                        "is_timedelta64_dtype": [
                            1071
                        ],
                        "self._add_delta_tdi": [
                            1073
                        ]
                    },
                    "diff_line_number": 1050,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_add_timedeltalike_scalar",
                    "function_code": "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        # i.e np.timedelta64(\"NaT\"), not recognized by delta_to_nanoseconds\n        new_values = np.empty(self.shape, dtype=\"i8\")\n        new_values[:] = iNaT\n        return new_values\n\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view(\n        \"i8\"\n    )\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view(\"i8\")\n",
                    "decorators": [],
                    "docstring": "Add a delta of a timedeltalike\nreturn the i8 result view",
                    "start_line": 1077,
                    "variables": {
                        "isna": [
                            1082
                        ],
                        "other": [
                            1088,
                            1082
                        ],
                        "new_values": [
                            1089,
                            1092,
                            1093,
                            1084,
                            1085,
                            1086
                        ],
                        "np.empty": [
                            1084
                        ],
                        "np": [
                            1084
                        ],
                        "self.shape": [
                            1084
                        ],
                        "self": [
                            1089,
                            1084,
                            1092
                        ],
                        "iNaT": [
                            1085
                        ],
                        "inc": [
                            1088,
                            1089
                        ],
                        "delta_to_nanoseconds": [
                            1088
                        ],
                        "view": [
                            1089
                        ],
                        "checked_add_with_arr": [
                            1089
                        ],
                        "self.asi8": [
                            1089
                        ],
                        "self._isnan": [
                            1089
                        ],
                        "self._maybe_mask_results": [
                            1092
                        ],
                        "new_values.view": [
                            1093
                        ]
                    },
                    "filtered_variables": {
                        "isna": [
                            1082
                        ],
                        "other": [
                            1088,
                            1082
                        ],
                        "new_values": [
                            1089,
                            1092,
                            1093,
                            1084,
                            1085,
                            1086
                        ],
                        "np.empty": [
                            1084
                        ],
                        "np": [
                            1084
                        ],
                        "self.shape": [
                            1084
                        ],
                        "self": [
                            1089,
                            1084,
                            1092
                        ],
                        "iNaT": [
                            1085
                        ],
                        "inc": [
                            1088,
                            1089
                        ],
                        "delta_to_nanoseconds": [
                            1088
                        ],
                        "view": [
                            1089
                        ],
                        "checked_add_with_arr": [
                            1089
                        ],
                        "self.asi8": [
                            1089
                        ],
                        "self._isnan": [
                            1089
                        ],
                        "self._maybe_mask_results": [
                            1092
                        ],
                        "new_values.view": [
                            1093
                        ]
                    },
                    "diff_line_number": 1077,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_add_delta_tdi",
                    "function_code": "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError(\"cannot add indices of unequal length\")\n\n    if isinstance(other, np.ndarray):\n        # ndarray[timedelta64]; wrap in TimedeltaIndex for op\n        from pandas.core.arrays import TimedeltaArray\n\n        other = TimedeltaArray._from_sequence(other)\n\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(\n        self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan\n    )\n    if self._hasnans or other._hasnans:\n        mask = (self._isnan) | (other._isnan)\n        new_values[mask] = iNaT\n    return new_values.view(\"i8\")\n",
                    "decorators": [],
                    "docstring": "Add a delta of a TimedeltaIndex\nreturn the i8 result view",
                    "start_line": 1095,
                    "variables": {
                        "len": [
                            1100
                        ],
                        "self": [
                            1100,
                            1109,
                            1112,
                            1114,
                            1115
                        ],
                        "other": [
                            1100,
                            1103,
                            1107,
                            1110,
                            1112,
                            1114,
                            1115
                        ],
                        "ValueError": [
                            1101
                        ],
                        "isinstance": [
                            1103
                        ],
                        "np.ndarray": [
                            1103
                        ],
                        "np": [
                            1103
                        ],
                        "TimedeltaArray._from_sequence": [
                            1107
                        ],
                        "TimedeltaArray": [
                            1107
                        ],
                        "self_i8": [
                            1112,
                            1109
                        ],
                        "self.asi8": [
                            1109
                        ],
                        "other_i8": [
                            1112,
                            1110
                        ],
                        "other.asi8": [
                            1110
                        ],
                        "new_values": [
                            1116,
                            1117,
                            1111
                        ],
                        "checked_add_with_arr": [
                            1111
                        ],
                        "self._isnan": [
                            1112,
                            1115
                        ],
                        "other._isnan": [
                            1112,
                            1115
                        ],
                        "self._hasnans": [
                            1114
                        ],
                        "other._hasnans": [
                            1114
                        ],
                        "mask": [
                            1115,
                            1116
                        ],
                        "iNaT": [
                            1116
                        ],
                        "new_values.view": [
                            1117
                        ]
                    },
                    "filtered_variables": {
                        "self": [
                            1100,
                            1109,
                            1112,
                            1114,
                            1115
                        ],
                        "other": [
                            1100,
                            1103,
                            1107,
                            1110,
                            1112,
                            1114,
                            1115
                        ],
                        "np.ndarray": [
                            1103
                        ],
                        "np": [
                            1103
                        ],
                        "TimedeltaArray._from_sequence": [
                            1107
                        ],
                        "TimedeltaArray": [
                            1107
                        ],
                        "self_i8": [
                            1112,
                            1109
                        ],
                        "self.asi8": [
                            1109
                        ],
                        "other_i8": [
                            1112,
                            1110
                        ],
                        "other.asi8": [
                            1110
                        ],
                        "new_values": [
                            1116,
                            1117,
                            1111
                        ],
                        "checked_add_with_arr": [
                            1111
                        ],
                        "self._isnan": [
                            1112,
                            1115
                        ],
                        "other._isnan": [
                            1112,
                            1115
                        ],
                        "self._hasnans": [
                            1114
                        ],
                        "other._hasnans": [
                            1114
                        ],
                        "mask": [
                            1115,
                            1116
                        ],
                        "iNaT": [
                            1116
                        ],
                        "new_values.view": [
                            1117
                        ]
                    },
                    "diff_line_number": 1095,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_add_nat",
                    "function_code": "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(\n            f\"Cannot add {type(self).__name__} and {type(NaT).__name__}\"\n        )\n\n    # GH#19124 pd.NaT is treated like a timedelta for both timedelta\n    # and datetime dtypes\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)\n",
                    "decorators": [],
                    "docstring": "Add pd.NaT to self",
                    "start_line": 1119,
                    "variables": {
                        "is_period_dtype": [
                            1123
                        ],
                        "self": [
                            1130,
                            1123,
                            1132,
                            1125
                        ],
                        "TypeError": [
                            1124
                        ],
                        "__name__": [
                            1125
                        ],
                        "type": [
                            1132,
                            1125
                        ],
                        "NaT": [
                            1125
                        ],
                        "result": [
                            1130,
                            1131,
                            1132
                        ],
                        "np.zeros": [
                            1130
                        ],
                        "np": [
                            1130
                        ],
                        "self.shape": [
                            1130
                        ],
                        "np.int64": [
                            1130
                        ],
                        "result.fill": [
                            1131
                        ],
                        "iNaT": [
                            1131
                        ],
                        "self.dtype": [
                            1132
                        ]
                    },
                    "filtered_variables": {
                        "is_period_dtype": [
                            1123
                        ],
                        "self": [
                            1130,
                            1123,
                            1132,
                            1125
                        ],
                        "NaT": [
                            1125
                        ],
                        "result": [
                            1130,
                            1131,
                            1132
                        ],
                        "np.zeros": [
                            1130
                        ],
                        "np": [
                            1130
                        ],
                        "self.shape": [
                            1130
                        ],
                        "np.int64": [
                            1130
                        ],
                        "result.fill": [
                            1131
                        ],
                        "iNaT": [
                            1131
                        ],
                        "self.dtype": [
                            1132
                        ]
                    },
                    "diff_line_number": 1119,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_sub_nat",
                    "function_code": "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    # GH#19124 Timedelta - datetime is not in general well-defined.\n    # We make an exception for pd.NaT, which in this case quacks\n    # like a timedelta.\n    # For datetime64 dtypes by convention we treat NaT as a datetime, so\n    # this subtraction returns a timedelta64 dtype.\n    # For period dtype, timedelta64 is a close-enough return dtype.\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view(\"timedelta64[ns]\")\n",
                    "decorators": [],
                    "docstring": "Subtract pd.NaT from self",
                    "start_line": 1134,
                    "variables": {
                        "result": [
                            1144,
                            1145,
                            1146
                        ],
                        "np.zeros": [
                            1144
                        ],
                        "np": [
                            1144
                        ],
                        "self.shape": [
                            1144
                        ],
                        "self": [
                            1144
                        ],
                        "np.int64": [
                            1144
                        ],
                        "result.fill": [
                            1145
                        ],
                        "iNaT": [
                            1145
                        ],
                        "result.view": [
                            1146
                        ]
                    },
                    "filtered_variables": {
                        "result": [
                            1144,
                            1145,
                            1146
                        ],
                        "np.zeros": [
                            1144
                        ],
                        "np": [
                            1144
                        ],
                        "self.shape": [
                            1144
                        ],
                        "self": [
                            1144
                        ],
                        "np.int64": [
                            1144
                        ],
                        "result.fill": [
                            1145
                        ],
                        "iNaT": [
                            1145
                        ],
                        "result.view": [
                            1146
                        ]
                    },
                    "diff_line_number": 1134,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_sub_period_array",
                    "function_code": "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(\n            f\"cannot subtract {other.dtype}-dtype from {type(self).__name__}\"\n        )\n\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(\n            cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr\n        )\n        raise IncompatibleFrequency(msg)\n\n    new_values = checked_add_with_arr(\n        self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan\n    )\n\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = (self._isnan) | (other._isnan)\n        new_values[mask] = NaT\n    return new_values\n",
                    "decorators": [],
                    "docstring": "Subtract a Period Array/Index from self.  This is only valid if self\nis itself a Period Array/Index, raises otherwise.  Both objects must\nhave the same frequency.\n\nParameters\n----------\nother : PeriodIndex or PeriodArray\n\nReturns\n-------\nresult : np.ndarray[object]\n    Array of DateOffset objects; nulls represented by NaT.",
                    "start_line": 1148,
                    "variables": {
                        "is_period_dtype": [
                            1163
                        ],
                        "self": [
                            1163,
                            1165,
                            1168,
                            1170,
                            1175,
                            1178,
                            1179,
                            1180
                        ],
                        "TypeError": [
                            1164
                        ],
                        "other.dtype": [
                            1165
                        ],
                        "other": [
                            1165,
                            1168,
                            1170,
                            1175,
                            1179,
                            1180
                        ],
                        "__name__": [
                            1170,
                            1165
                        ],
                        "type": [
                            1170,
                            1165
                        ],
                        "self.freq": [
                            1168,
                            1178
                        ],
                        "other.freq": [
                            1168
                        ],
                        "msg": [
                            1169,
                            1172
                        ],
                        "DIFFERENT_FREQ.format": [
                            1169
                        ],
                        "DIFFERENT_FREQ": [
                            1169
                        ],
                        "self.freqstr": [
                            1170
                        ],
                        "other.freqstr": [
                            1170
                        ],
                        "IncompatibleFrequency": [
                            1172
                        ],
                        "new_values": [
                            1178,
                            1182,
                            1181,
                            1174
                        ],
                        "checked_add_with_arr": [
                            1174
                        ],
                        "self.asi8": [
                            1175
                        ],
                        "other.asi8": [
                            1175
                        ],
                        "self._isnan": [
                            1180,
                            1175
                        ],
                        "other._isnan": [
                            1180,
                            1175
                        ],
                        "np.array": [
                            1178
                        ],
                        "np": [
                            1178
                        ],
                        "self.freq.base": [
                            1178
                        ],
                        "x": [
                            1178
                        ],
                        "self._hasnans": [
                            1179
                        ],
                        "other._hasnans": [
                            1179
                        ],
                        "mask": [
                            1180,
                            1181
                        ],
                        "NaT": [
                            1181
                        ]
                    },
                    "filtered_variables": {
                        "is_period_dtype": [
                            1163
                        ],
                        "self": [
                            1163,
                            1165,
                            1168,
                            1170,
                            1175,
                            1178,
                            1179,
                            1180
                        ],
                        "other.dtype": [
                            1165
                        ],
                        "other": [
                            1165,
                            1168,
                            1170,
                            1175,
                            1179,
                            1180
                        ],
                        "self.freq": [
                            1168,
                            1178
                        ],
                        "other.freq": [
                            1168
                        ],
                        "msg": [
                            1169,
                            1172
                        ],
                        "DIFFERENT_FREQ.format": [
                            1169
                        ],
                        "DIFFERENT_FREQ": [
                            1169
                        ],
                        "self.freqstr": [
                            1170
                        ],
                        "other.freqstr": [
                            1170
                        ],
                        "IncompatibleFrequency": [
                            1172
                        ],
                        "new_values": [
                            1178,
                            1182,
                            1181,
                            1174
                        ],
                        "checked_add_with_arr": [
                            1174
                        ],
                        "self.asi8": [
                            1175
                        ],
                        "other.asi8": [
                            1175
                        ],
                        "self._isnan": [
                            1180,
                            1175
                        ],
                        "other._isnan": [
                            1180,
                            1175
                        ],
                        "np.array": [
                            1178
                        ],
                        "np": [
                            1178
                        ],
                        "self.freq.base": [
                            1178
                        ],
                        "x": [
                            1178
                        ],
                        "self._hasnans": [
                            1179
                        ],
                        "other._hasnans": [
                            1179
                        ],
                        "mask": [
                            1180,
                            1181
                        ],
                        "NaT": [
                            1181
                        ]
                    },
                    "diff_line_number": 1148,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_addsub_object_array",
                    "function_code": "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n\n    warnings.warn(\n        \"Adding/subtracting array of DateOffsets to \"\n        f\"{type(self).__name__} not vectorized\",\n        PerformanceWarning,\n    )\n\n    # For EA self.astype('O') returns a numpy array, not an Index\n    left = self.astype(\"O\")\n\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs[\"freq\"] = \"infer\"\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        # e.g. we've passed a Timestamp to TimedeltaArray\n        res = res_values\n    return res\n",
                    "decorators": [],
                    "docstring": "Add or subtract array-like of DateOffset objects\n\nParameters\n----------\nother : np.ndarray[object]\nop : {operator.add, operator.sub}\n\nReturns\n-------\nresult : same class as self",
                    "start_line": 1184,
                    "variables": {
                        "np.ndarray": [
                            1184
                        ],
                        "np": [
                            1184,
                            1210
                        ],
                        "op": [
                            1210,
                            1197,
                            1199
                        ],
                        "operator.add": [
                            1197
                        ],
                        "operator": [
                            1197
                        ],
                        "operator.sub": [
                            1197
                        ],
                        "len": [
                            1198
                        ],
                        "other": [
                            1210,
                            1198,
                            1199
                        ],
                        "self": [
                            1199,
                            1203,
                            1208,
                            1212,
                            1215
                        ],
                        "warnings.warn": [
                            1201
                        ],
                        "warnings": [
                            1201
                        ],
                        "__name__": [
                            1203
                        ],
                        "type": [
                            1203,
                            1215
                        ],
                        "PerformanceWarning": [
                            1204
                        ],
                        "left": [
                            1208,
                            1210
                        ],
                        "self.astype": [
                            1208
                        ],
                        "res_values": [
                            1218,
                            1210,
                            1215
                        ],
                        "np.array": [
                            1210
                        ],
                        "kwargs": [
                            1211,
                            1213,
                            1215
                        ],
                        "is_period_dtype": [
                            1212
                        ],
                        "res": [
                            1218,
                            1219,
                            1215
                        ],
                        "_from_sequence": [
                            1215
                        ],
                        "ValueError": [
                            1216
                        ]
                    },
                    "filtered_variables": {
                        "np.ndarray": [
                            1184
                        ],
                        "np": [
                            1184,
                            1210
                        ],
                        "op": [
                            1210,
                            1197,
                            1199
                        ],
                        "operator.add": [
                            1197
                        ],
                        "operator": [
                            1197
                        ],
                        "operator.sub": [
                            1197
                        ],
                        "other": [
                            1210,
                            1198,
                            1199
                        ],
                        "self": [
                            1199,
                            1203,
                            1208,
                            1212,
                            1215
                        ],
                        "warnings.warn": [
                            1201
                        ],
                        "warnings": [
                            1201
                        ],
                        "PerformanceWarning": [
                            1204
                        ],
                        "left": [
                            1208,
                            1210
                        ],
                        "self.astype": [
                            1208
                        ],
                        "res_values": [
                            1218,
                            1210,
                            1215
                        ],
                        "np.array": [
                            1210
                        ],
                        "kwargs": [
                            1211,
                            1213,
                            1215
                        ],
                        "is_period_dtype": [
                            1212
                        ],
                        "res": [
                            1218,
                            1219,
                            1215
                        ],
                        "_from_sequence": [
                            1215
                        ]
                    },
                    "diff_line_number": 1184,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_time_shift",
                    "function_code": "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n\n    if periods == 0:\n        # immutable so OK\n        return self.copy()\n\n    if self.freq is None:\n        raise NullFrequencyError(\"Cannot shift with no freq\")\n\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n\n    # Note: in the DatetimeTZ case, _generate_range will infer the\n    #  appropriate timezone from `start` and `end`, so tz does not need\n    #  to be passed explicitly.\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)\n",
                    "decorators": [],
                    "docstring": "Shift each value by `periods`.\n\nNote this is different from ExtensionArray.shift, which\nshifts the *position* of each element, padding the end with\nmissing values.\n\nParameters\n----------\nperiods : int\n    Number of periods to shift by.\nfreq : pandas.DateOffset, pandas.Timedelta, or str\n    Frequency increment to shift by.",
                    "start_line": 1221,
                    "variables": {
                        "freq": [
                            1236,
                            1237,
                            1238,
                            1239
                        ],
                        "self.freq": [
                            1250,
                            1251,
                            1256,
                            1236,
                            1247
                        ],
                        "self": [
                            1250,
                            1251,
                            1256,
                            1236,
                            1240,
                            1245,
                            1247
                        ],
                        "isinstance": [
                            1237
                        ],
                        "str": [
                            1237
                        ],
                        "frequencies.to_offset": [
                            1238
                        ],
                        "frequencies": [
                            1238
                        ],
                        "offset": [
                            1240,
                            1239
                        ],
                        "periods": [
                            1250,
                            1243,
                            1251,
                            1239
                        ],
                        "result": [
                            1240,
                            1241
                        ],
                        "self.copy": [
                            1245
                        ],
                        "NullFrequencyError": [
                            1248
                        ],
                        "start": [
                            1256,
                            1250
                        ],
                        "end": [
                            1256,
                            1251
                        ],
                        "self._generate_range": [
                            1256
                        ]
                    },
                    "filtered_variables": {
                        "freq": [
                            1236,
                            1237,
                            1238,
                            1239
                        ],
                        "self.freq": [
                            1250,
                            1251,
                            1256,
                            1236,
                            1247
                        ],
                        "self": [
                            1250,
                            1251,
                            1256,
                            1236,
                            1240,
                            1245,
                            1247
                        ],
                        "frequencies.to_offset": [
                            1238
                        ],
                        "frequencies": [
                            1238
                        ],
                        "offset": [
                            1240,
                            1239
                        ],
                        "periods": [
                            1250,
                            1243,
                            1251,
                            1239
                        ],
                        "result": [
                            1240,
                            1241
                        ],
                        "self.copy": [
                            1245
                        ],
                        "NullFrequencyError": [
                            1248
                        ],
                        "start": [
                            1256,
                            1250
                        ],
                        "end": [
                            1256,
                            1251
                        ],
                        "self._generate_range": [
                            1256
                        ]
                    },
                    "diff_line_number": 1221,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "__add__",
                    "function_code": "@unpack_zerodim_and_defer(\"__add__\")\ndef __add__(self, other):\n\n    # scalar others\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        # specifically _not_ a Tick\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        # This check must come after the check for np.timedelta64\n        # as is_integer returns True for these\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n\n    # array-like others\n    elif is_timedelta64_dtype(other):\n        # TimedeltaIndex, ndarray[timedelta64]\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        # e.g. Array/Index of DateOffset objects\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        # DatetimeIndex, ndarray[datetime64]\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        # Includes Categorical, other ExtensionArrays\n        # For PeriodDtype, if self is a TimedeltaArray and other is a\n        #  PeriodArray with  a timedelta-like (i.e. Tick) freq, this\n        #  operation is valid.  Defer to the PeriodArray implementation.\n        #  In remaining cases, this will end up raising TypeError.\n        return NotImplemented\n\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n\n        return TimedeltaArray(result)\n    return result\n",
                    "decorators": [
                        "unpack_zerodim_and_defer('__add__')"
                    ],
                    "docstring": null,
                    "start_line": 1258,
                    "variables": {
                        "other": [
                            1281,
                            1282,
                            1284,
                            1285,
                            1287,
                            1288,
                            1291,
                            1262,
                            1264,
                            1265,
                            1266,
                            1268,
                            1269,
                            1270,
                            1271,
                            1276,
                            1279
                        ],
                        "NaT": [
                            1262
                        ],
                        "result": [
                            1281,
                            1284,
                            1291,
                            1263,
                            1265,
                            1268,
                            1300,
                            1270,
                            1303,
                            1304,
                            1276
                        ],
                        "self._add_nat": [
                            1263
                        ],
                        "self": [
                            1281,
                            1284,
                            1287,
                            1289,
                            1290,
                            1291,
                            1263,
                            1265,
                            1268,
                            1270,
                            1274,
                            1275,
                            1276
                        ],
                        "isinstance": [
                            1264,
                            1266,
                            1300,
                            1269
                        ],
                        "Tick": [
                            1264
                        ],
                        "timedelta": [
                            1264
                        ],
                        "np.timedelta64": [
                            1264
                        ],
                        "np": [
                            1264,
                            1300,
                            1269
                        ],
                        "self._add_delta": [
                            1265,
                            1281
                        ],
                        "DateOffset": [
                            1266
                        ],
                        "self._add_offset": [
                            1268
                        ],
                        "datetime": [
                            1269
                        ],
                        "np.datetime64": [
                            1269
                        ],
                        "self._add_datetimelike_scalar": [
                            1270
                        ],
                        "lib.is_integer": [
                            1271
                        ],
                        "lib": [
                            1271
                        ],
                        "is_period_dtype": [
                            1289,
                            1274
                        ],
                        "integer_op_not_supported": [
                            1290,
                            1275
                        ],
                        "self._time_shift": [
                            1276
                        ],
                        "is_timedelta64_dtype": [
                            1300,
                            1279
                        ],
                        "is_object_dtype": [
                            1282
                        ],
                        "self._addsub_object_array": [
                            1284
                        ],
                        "operator.add": [
                            1291,
                            1284
                        ],
                        "operator": [
                            1291,
                            1284
                        ],
                        "is_datetime64_dtype": [
                            1285
                        ],
                        "is_datetime64tz_dtype": [
                            1285
                        ],
                        "self._add_datetime_arraylike": [
                            1287
                        ],
                        "is_integer_dtype": [
                            1288
                        ],
                        "self._addsub_int_array": [
                            1291
                        ],
                        "NotImplemented": [
                            1298
                        ],
                        "np.ndarray": [
                            1300
                        ],
                        "TimedeltaArray": [
                            1303
                        ],
                        "unpack_zerodim_and_defer": [
                            1258
                        ]
                    },
                    "filtered_variables": {
                        "other": [
                            1281,
                            1282,
                            1284,
                            1285,
                            1287,
                            1288,
                            1291,
                            1262,
                            1264,
                            1265,
                            1266,
                            1268,
                            1269,
                            1270,
                            1271,
                            1276,
                            1279
                        ],
                        "NaT": [
                            1262
                        ],
                        "result": [
                            1281,
                            1284,
                            1291,
                            1263,
                            1265,
                            1268,
                            1300,
                            1270,
                            1303,
                            1304,
                            1276
                        ],
                        "self._add_nat": [
                            1263
                        ],
                        "self": [
                            1281,
                            1284,
                            1287,
                            1289,
                            1290,
                            1291,
                            1263,
                            1265,
                            1268,
                            1270,
                            1274,
                            1275,
                            1276
                        ],
                        "Tick": [
                            1264
                        ],
                        "timedelta": [
                            1264
                        ],
                        "np.timedelta64": [
                            1264
                        ],
                        "np": [
                            1264,
                            1300,
                            1269
                        ],
                        "self._add_delta": [
                            1265,
                            1281
                        ],
                        "DateOffset": [
                            1266
                        ],
                        "self._add_offset": [
                            1268
                        ],
                        "datetime": [
                            1269
                        ],
                        "np.datetime64": [
                            1269
                        ],
                        "self._add_datetimelike_scalar": [
                            1270
                        ],
                        "lib.is_integer": [
                            1271
                        ],
                        "lib": [
                            1271
                        ],
                        "is_period_dtype": [
                            1289,
                            1274
                        ],
                        "integer_op_not_supported": [
                            1290,
                            1275
                        ],
                        "self._time_shift": [
                            1276
                        ],
                        "is_timedelta64_dtype": [
                            1300,
                            1279
                        ],
                        "is_object_dtype": [
                            1282
                        ],
                        "self._addsub_object_array": [
                            1284
                        ],
                        "operator.add": [
                            1291,
                            1284
                        ],
                        "operator": [
                            1291,
                            1284
                        ],
                        "is_datetime64_dtype": [
                            1285
                        ],
                        "is_datetime64tz_dtype": [
                            1285
                        ],
                        "self._add_datetime_arraylike": [
                            1287
                        ],
                        "is_integer_dtype": [
                            1288
                        ],
                        "self._addsub_int_array": [
                            1291
                        ],
                        "np.ndarray": [
                            1300
                        ],
                        "TimedeltaArray": [
                            1303
                        ],
                        "unpack_zerodim_and_defer": [
                            1258
                        ]
                    },
                    "diff_line_number": 1259,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "__radd__",
                    "function_code": "def __radd__(self, other):\n    # alias for __add__\n    return self.__add__(other)\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 1306,
                    "variables": {
                        "self.__add__": [
                            1308
                        ],
                        "self": [
                            1308
                        ],
                        "other": [
                            1308
                        ]
                    },
                    "filtered_variables": {
                        "self.__add__": [
                            1308
                        ],
                        "self": [
                            1308
                        ],
                        "other": [
                            1308
                        ]
                    },
                    "diff_line_number": 1306,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "__sub__",
                    "function_code": "@unpack_zerodim_and_defer(\"__sub__\")\ndef __sub__(self, other):\n\n    # scalar others\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        # specifically _not_ a Tick\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        # This check must come after the check for np.timedelta64\n        # as is_integer returns True for these\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n\n    # array-like others\n    elif is_timedelta64_dtype(other):\n        # TimedeltaIndex, ndarray[timedelta64]\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        # e.g. Array/Index of DateOffset objects\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        # DatetimeIndex, ndarray[datetime64]\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        # PeriodIndex\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        # Includes ExtensionArrays, float_dtype\n        return NotImplemented\n\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n\n        return TimedeltaArray(result)\n    return result\n",
                    "decorators": [
                        "unpack_zerodim_and_defer('__sub__')"
                    ],
                    "docstring": null,
                    "start_line": 1310,
                    "variables": {
                        "other": [
                            1314,
                            1316,
                            1317,
                            1318,
                            1320,
                            1321,
                            1322,
                            1323,
                            1328,
                            1330,
                            1331,
                            1334,
                            1336,
                            1337,
                            1339,
                            1340,
                            1342,
                            1343,
                            1345,
                            1346,
                            1349
                        ],
                        "NaT": [
                            1314
                        ],
                        "result": [
                            1345,
                            1315,
                            1317,
                            1349,
                            1320,
                            1322,
                            1354,
                            1357,
                            1358,
                            1328,
                            1331,
                            1336,
                            1339,
                            1342
                        ],
                        "self._sub_nat": [
                            1315
                        ],
                        "self": [
                            1345,
                            1315,
                            1347,
                            1317,
                            1348,
                            1349,
                            1320,
                            1322,
                            1326,
                            1327,
                            1328,
                            1331,
                            1336,
                            1339,
                            1342
                        ],
                        "isinstance": [
                            1316,
                            1318,
                            1321,
                            1354,
                            1330
                        ],
                        "Tick": [
                            1316
                        ],
                        "timedelta": [
                            1316
                        ],
                        "np.timedelta64": [
                            1316
                        ],
                        "np": [
                            1321,
                            1354,
                            1316
                        ],
                        "self._add_delta": [
                            1336,
                            1317
                        ],
                        "DateOffset": [
                            1318
                        ],
                        "self._add_offset": [
                            1320
                        ],
                        "datetime": [
                            1321
                        ],
                        "np.datetime64": [
                            1321
                        ],
                        "self._sub_datetimelike_scalar": [
                            1322
                        ],
                        "lib.is_integer": [
                            1323
                        ],
                        "lib": [
                            1323
                        ],
                        "is_period_dtype": [
                            1347,
                            1326,
                            1343
                        ],
                        "integer_op_not_supported": [
                            1348,
                            1327
                        ],
                        "self._time_shift": [
                            1328
                        ],
                        "Period": [
                            1330
                        ],
                        "self._sub_period": [
                            1331
                        ],
                        "is_timedelta64_dtype": [
                            1354,
                            1334
                        ],
                        "is_object_dtype": [
                            1337
                        ],
                        "self._addsub_object_array": [
                            1339
                        ],
                        "operator.sub": [
                            1339,
                            1349
                        ],
                        "operator": [
                            1339,
                            1349
                        ],
                        "is_datetime64_dtype": [
                            1340
                        ],
                        "is_datetime64tz_dtype": [
                            1340
                        ],
                        "self._sub_datetime_arraylike": [
                            1342
                        ],
                        "self._sub_period_array": [
                            1345
                        ],
                        "is_integer_dtype": [
                            1346
                        ],
                        "self._addsub_int_array": [
                            1349
                        ],
                        "NotImplemented": [
                            1352
                        ],
                        "np.ndarray": [
                            1354
                        ],
                        "TimedeltaArray": [
                            1357
                        ],
                        "unpack_zerodim_and_defer": [
                            1310
                        ]
                    },
                    "filtered_variables": {
                        "other": [
                            1314,
                            1316,
                            1317,
                            1318,
                            1320,
                            1321,
                            1322,
                            1323,
                            1328,
                            1330,
                            1331,
                            1334,
                            1336,
                            1337,
                            1339,
                            1340,
                            1342,
                            1343,
                            1345,
                            1346,
                            1349
                        ],
                        "NaT": [
                            1314
                        ],
                        "result": [
                            1345,
                            1315,
                            1317,
                            1349,
                            1320,
                            1322,
                            1354,
                            1357,
                            1358,
                            1328,
                            1331,
                            1336,
                            1339,
                            1342
                        ],
                        "self._sub_nat": [
                            1315
                        ],
                        "self": [
                            1345,
                            1315,
                            1347,
                            1317,
                            1348,
                            1349,
                            1320,
                            1322,
                            1326,
                            1327,
                            1328,
                            1331,
                            1336,
                            1339,
                            1342
                        ],
                        "Tick": [
                            1316
                        ],
                        "timedelta": [
                            1316
                        ],
                        "np.timedelta64": [
                            1316
                        ],
                        "np": [
                            1321,
                            1354,
                            1316
                        ],
                        "self._add_delta": [
                            1336,
                            1317
                        ],
                        "DateOffset": [
                            1318
                        ],
                        "self._add_offset": [
                            1320
                        ],
                        "datetime": [
                            1321
                        ],
                        "np.datetime64": [
                            1321
                        ],
                        "self._sub_datetimelike_scalar": [
                            1322
                        ],
                        "lib.is_integer": [
                            1323
                        ],
                        "lib": [
                            1323
                        ],
                        "is_period_dtype": [
                            1347,
                            1326,
                            1343
                        ],
                        "integer_op_not_supported": [
                            1348,
                            1327
                        ],
                        "self._time_shift": [
                            1328
                        ],
                        "Period": [
                            1330
                        ],
                        "self._sub_period": [
                            1331
                        ],
                        "is_timedelta64_dtype": [
                            1354,
                            1334
                        ],
                        "is_object_dtype": [
                            1337
                        ],
                        "self._addsub_object_array": [
                            1339
                        ],
                        "operator.sub": [
                            1339,
                            1349
                        ],
                        "operator": [
                            1339,
                            1349
                        ],
                        "is_datetime64_dtype": [
                            1340
                        ],
                        "is_datetime64tz_dtype": [
                            1340
                        ],
                        "self._sub_datetime_arraylike": [
                            1342
                        ],
                        "self._sub_period_array": [
                            1345
                        ],
                        "is_integer_dtype": [
                            1346
                        ],
                        "self._addsub_int_array": [
                            1349
                        ],
                        "np.ndarray": [
                            1354
                        ],
                        "TimedeltaArray": [
                            1357
                        ],
                        "unpack_zerodim_and_defer": [
                            1310
                        ]
                    },
                    "diff_line_number": 1311,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "__rsub__",
                    "function_code": "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        # ndarray[datetime64] cannot be subtracted from self, so\n        # we need to wrap in DatetimeArray/Index and flip the operation\n        if lib.is_scalar(other):\n            # i.e. np.datetime64 object\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            # Avoid down-casting DatetimeIndex\n            from pandas.core.arrays import DatetimeArray\n\n            other = DatetimeArray(other)\n        return other - self\n    elif (\n        is_datetime64_any_dtype(self.dtype)\n        and hasattr(other, \"dtype\")\n        and not is_datetime64_any_dtype(other.dtype)\n    ):\n        # GH#19959 datetime - datetime is well-defined as timedelta,\n        # but any other type - datetime is not well-defined.\n        raise TypeError(\n            f\"cannot subtract {type(self).__name__} from {type(other).__name__}\"\n        )\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        # TODO: Can we simplify/generalize these cases at all?\n        raise TypeError(f\"cannot subtract {type(self).__name__} from {other.dtype}\")\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            # need to subtract before negating, since that flips freq\n            # -self flips self.freq, messing up results\n            return -(self - other)\n\n        return (-self) + other\n\n    return -(self - other)\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 1360,
                    "variables": {
                        "is_datetime64_any_dtype": [
                            1376,
                            1361,
                            1374
                        ],
                        "other": [
                            1376,
                            1381,
                            1383,
                            1385,
                            1387,
                            1390,
                            1392,
                            1361,
                            1394,
                            1364,
                            1366,
                            1367,
                            1371,
                            1372,
                            1375
                        ],
                        "is_timedelta64_dtype": [
                            1361,
                            1386,
                            1383
                        ],
                        "self.dtype": [
                            1361,
                            1386,
                            1374,
                            1383
                        ],
                        "self": [
                            1381,
                            1383,
                            1385,
                            1386,
                            1390,
                            1392,
                            1361,
                            1394,
                            1366,
                            1372,
                            1374
                        ],
                        "lib.is_scalar": [
                            1364
                        ],
                        "lib": [
                            1387,
                            1364
                        ],
                        "Timestamp": [
                            1366
                        ],
                        "isinstance": [
                            1367
                        ],
                        "DatetimeLikeArrayMixin": [
                            1367
                        ],
                        "DatetimeArray": [
                            1371
                        ],
                        "hasattr": [
                            1375
                        ],
                        "other.dtype": [
                            1376,
                            1385
                        ],
                        "TypeError": [
                            1385,
                            1380
                        ],
                        "__name__": [
                            1385,
                            1381
                        ],
                        "type": [
                            1385,
                            1381
                        ],
                        "is_period_dtype": [
                            1383
                        ],
                        "lib.is_integer": [
                            1387
                        ],
                        "is_integer_dtype": [
                            1387
                        ]
                    },
                    "filtered_variables": {
                        "is_datetime64_any_dtype": [
                            1376,
                            1361,
                            1374
                        ],
                        "other": [
                            1376,
                            1381,
                            1383,
                            1385,
                            1387,
                            1390,
                            1392,
                            1361,
                            1394,
                            1364,
                            1366,
                            1367,
                            1371,
                            1372,
                            1375
                        ],
                        "is_timedelta64_dtype": [
                            1361,
                            1386,
                            1383
                        ],
                        "self.dtype": [
                            1361,
                            1386,
                            1374,
                            1383
                        ],
                        "self": [
                            1381,
                            1383,
                            1385,
                            1386,
                            1390,
                            1392,
                            1361,
                            1394,
                            1366,
                            1372,
                            1374
                        ],
                        "lib.is_scalar": [
                            1364
                        ],
                        "lib": [
                            1387,
                            1364
                        ],
                        "Timestamp": [
                            1366
                        ],
                        "DatetimeLikeArrayMixin": [
                            1367
                        ],
                        "DatetimeArray": [
                            1371
                        ],
                        "other.dtype": [
                            1376,
                            1385
                        ],
                        "is_period_dtype": [
                            1383
                        ],
                        "lib.is_integer": [
                            1387
                        ],
                        "is_integer_dtype": [
                            1387
                        ]
                    },
                    "diff_line_number": 1360,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "__iadd__",
                    "function_code": "def __iadd__(self, other):  # type: ignore\n    result = self + other\n    self[:] = result[:]\n\n    if not is_period_dtype(self):\n        # restore freq, which is invalidated by setitem\n        self._freq = result._freq\n    return self\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 1396,
                    "variables": {
                        "result": [
                            1402,
                            1397,
                            1398
                        ],
                        "self": [
                            1397,
                            1398,
                            1400,
                            1402,
                            1403
                        ],
                        "other": [
                            1397
                        ],
                        "is_period_dtype": [
                            1400
                        ],
                        "self._freq": [
                            1402
                        ],
                        "result._freq": [
                            1402
                        ]
                    },
                    "filtered_variables": {
                        "result": [
                            1402,
                            1397,
                            1398
                        ],
                        "self": [
                            1397,
                            1398,
                            1400,
                            1402,
                            1403
                        ],
                        "other": [
                            1397
                        ],
                        "is_period_dtype": [
                            1400
                        ],
                        "self._freq": [
                            1402
                        ],
                        "result._freq": [
                            1402
                        ]
                    },
                    "diff_line_number": 1396,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "__isub__",
                    "function_code": "def __isub__(self, other):  # type: ignore\n    result = self - other\n    self[:] = result[:]\n\n    if not is_period_dtype(self):\n        # restore freq, which is invalidated by setitem\n        self._freq = result._freq\n    return self\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 1405,
                    "variables": {
                        "result": [
                            1411,
                            1406,
                            1407
                        ],
                        "self": [
                            1409,
                            1411,
                            1412,
                            1406,
                            1407
                        ],
                        "other": [
                            1406
                        ],
                        "is_period_dtype": [
                            1409
                        ],
                        "self._freq": [
                            1411
                        ],
                        "result._freq": [
                            1411
                        ]
                    },
                    "filtered_variables": {
                        "result": [
                            1411,
                            1406,
                            1407
                        ],
                        "self": [
                            1409,
                            1411,
                            1412,
                            1406,
                            1407
                        ],
                        "other": [
                            1406
                        ],
                        "is_period_dtype": [
                            1409
                        ],
                        "self._freq": [
                            1411
                        ],
                        "result._freq": [
                            1411
                        ]
                    },
                    "diff_line_number": 1405,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_ensure_localized",
                    "function_code": "def _ensure_localized(\n    self, arg, ambiguous=\"raise\", nonexistent=\"raise\", from_utc=False\n):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n\n    # reconvert to local tz\n    tz = getattr(self, \"tz\", None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize(\"UTC\").tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(\n                self.tz, ambiguous=ambiguous, nonexistent=nonexistent\n            )\n    return arg\n",
                    "decorators": [],
                    "docstring": "Ensure that we are re-localized.\n\nThis is for compat as we can then call this on all datetimelike\narrays generally (ignored for Period/Timedelta)\n\nParameters\n----------\narg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\nambiguous : str, bool, or bool-ndarray, default 'raise'\nnonexistent : str, default 'raise'\nfrom_utc : bool, default False\n    If True, localize the i8 ndarray to UTC first before converting to\n    the appropriate tz. If False, localize directly to the tz.\n\nReturns\n-------\nlocalized array",
                    "start_line": 1417,
                    "variables": {
                        "tz": [
                            1441,
                            1442
                        ],
                        "getattr": [
                            1441
                        ],
                        "self": [
                            1441,
                            1443,
                            1444,
                            1446,
                            1449
                        ],
                        "isinstance": [
                            1443
                        ],
                        "arg": [
                            1443,
                            1444,
                            1446,
                            1448,
                            1451
                        ],
                        "type": [
                            1443
                        ],
                        "self._simple_new": [
                            1444
                        ],
                        "from_utc": [
                            1445
                        ],
                        "tz_convert": [
                            1446
                        ],
                        "arg.tz_localize": [
                            1448,
                            1446
                        ],
                        "self.tz": [
                            1449,
                            1446
                        ],
                        "ambiguous": [
                            1449
                        ],
                        "nonexistent": [
                            1449
                        ]
                    },
                    "filtered_variables": {
                        "tz": [
                            1441,
                            1442
                        ],
                        "self": [
                            1441,
                            1443,
                            1444,
                            1446,
                            1449
                        ],
                        "arg": [
                            1443,
                            1444,
                            1446,
                            1448,
                            1451
                        ],
                        "self._simple_new": [
                            1444
                        ],
                        "from_utc": [
                            1445
                        ],
                        "tz_convert": [
                            1446
                        ],
                        "arg.tz_localize": [
                            1448,
                            1446
                        ],
                        "self.tz": [
                            1449,
                            1446
                        ],
                        "ambiguous": [
                            1449
                        ],
                        "nonexistent": [
                            1449
                        ]
                    },
                    "diff_line_number": 1417,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "_reduce",
                    "function_code": "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 1456,
                    "variables": {
                        "op": [
                            1457,
                            1458,
                            1459
                        ],
                        "getattr": [
                            1457
                        ],
                        "self": [
                            1457
                        ],
                        "name": [
                            1457,
                            1461
                        ],
                        "skipna": [
                            1459,
                            1461
                        ],
                        "kwargs": [
                            1459,
                            1461
                        ],
                        "_reduce": [
                            1461
                        ],
                        "super": [
                            1461
                        ]
                    },
                    "filtered_variables": {
                        "op": [
                            1457,
                            1458,
                            1459
                        ],
                        "self": [
                            1457
                        ],
                        "name": [
                            1457,
                            1461
                        ],
                        "skipna": [
                            1459,
                            1461
                        ],
                        "kwargs": [
                            1459,
                            1461
                        ],
                        "_reduce": [
                            1461
                        ]
                    },
                    "diff_line_number": 1456,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "min",
                    "function_code": "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        # Period._from_ordinal does not handle np.nan gracefully\n        return NaT\n    return self._box_func(result)\n",
                    "decorators": [],
                    "docstring": "Return the minimum value of the Array or minimum along\nan axis.\n\nSee Also\n--------\nnumpy.ndarray.min\nIndex.min : Return the minimum value in an Index.\nSeries.min : Return the minimum value in a Series.",
                    "start_line": 1463,
                    "variables": {
                        "nv.validate_min": [
                            1474
                        ],
                        "nv": [
                            1474,
                            1475
                        ],
                        "args": [
                            1474
                        ],
                        "kwargs": [
                            1474
                        ],
                        "nv.validate_minmax_axis": [
                            1475
                        ],
                        "axis": [
                            1475
                        ],
                        "result": [
                            1481,
                            1477,
                            1478
                        ],
                        "nanops.nanmin": [
                            1477
                        ],
                        "nanops": [
                            1477
                        ],
                        "self.asi8": [
                            1477
                        ],
                        "self": [
                            1481,
                            1477
                        ],
                        "skipna": [
                            1477
                        ],
                        "self.isna": [
                            1477
                        ],
                        "isna": [
                            1478
                        ],
                        "NaT": [
                            1480
                        ],
                        "self._box_func": [
                            1481
                        ]
                    },
                    "filtered_variables": {
                        "nv.validate_min": [
                            1474
                        ],
                        "nv": [
                            1474,
                            1475
                        ],
                        "args": [
                            1474
                        ],
                        "kwargs": [
                            1474
                        ],
                        "nv.validate_minmax_axis": [
                            1475
                        ],
                        "axis": [
                            1475
                        ],
                        "result": [
                            1481,
                            1477,
                            1478
                        ],
                        "nanops.nanmin": [
                            1477
                        ],
                        "nanops": [
                            1477
                        ],
                        "self.asi8": [
                            1477
                        ],
                        "self": [
                            1481,
                            1477
                        ],
                        "skipna": [
                            1477
                        ],
                        "self.isna": [
                            1477
                        ],
                        "isna": [
                            1478
                        ],
                        "NaT": [
                            1480
                        ],
                        "self._box_func": [
                            1481
                        ]
                    },
                    "diff_line_number": 1463,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "max",
                    "function_code": "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    # TODO: skipna is broken with max.\n    # See https://github.com/pandas-dev/pandas/issues/24265\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n\n    if not len(values):\n        # short-circuit for empty max / min\n        return NaT\n\n    result = nanops.nanmax(values, skipna=skipna)\n    # Don't have to worry about NA `result`, since no NA went in.\n    return self._box_func(result)\n",
                    "decorators": [],
                    "docstring": "Return the maximum value of the Array or maximum along\nan axis.\n\nSee Also\n--------\nnumpy.ndarray.max\nIndex.max : Return the maximum value in an Index.\nSeries.max : Return the maximum value in a Series.",
                    "start_line": 1483,
                    "variables": {
                        "nv.validate_max": [
                            1496
                        ],
                        "nv": [
                            1496,
                            1497
                        ],
                        "args": [
                            1496
                        ],
                        "kwargs": [
                            1496
                        ],
                        "nv.validate_minmax_axis": [
                            1497
                        ],
                        "axis": [
                            1497
                        ],
                        "mask": [
                            1499,
                            1501,
                            1502
                        ],
                        "self.isna": [
                            1499
                        ],
                        "self": [
                            1513,
                            1505,
                            1499,
                            1501
                        ],
                        "skipna": [
                            1500,
                            1511
                        ],
                        "values": [
                            1505,
                            1507,
                            1501,
                            1511
                        ],
                        "asi8": [
                            1501
                        ],
                        "mask.any": [
                            1502
                        ],
                        "NaT": [
                            1509,
                            1503
                        ],
                        "self.asi8": [
                            1505
                        ],
                        "len": [
                            1507
                        ],
                        "result": [
                            1513,
                            1511
                        ],
                        "nanops.nanmax": [
                            1511
                        ],
                        "nanops": [
                            1511
                        ],
                        "self._box_func": [
                            1513
                        ]
                    },
                    "filtered_variables": {
                        "nv.validate_max": [
                            1496
                        ],
                        "nv": [
                            1496,
                            1497
                        ],
                        "args": [
                            1496
                        ],
                        "kwargs": [
                            1496
                        ],
                        "nv.validate_minmax_axis": [
                            1497
                        ],
                        "axis": [
                            1497
                        ],
                        "mask": [
                            1499,
                            1501,
                            1502
                        ],
                        "self.isna": [
                            1499
                        ],
                        "self": [
                            1513,
                            1505,
                            1499,
                            1501
                        ],
                        "skipna": [
                            1500,
                            1511
                        ],
                        "values": [
                            1505,
                            1507,
                            1501,
                            1511
                        ],
                        "asi8": [
                            1501
                        ],
                        "mask.any": [
                            1502
                        ],
                        "NaT": [
                            1509,
                            1503
                        ],
                        "self.asi8": [
                            1505
                        ],
                        "result": [
                            1513,
                            1511
                        ],
                        "nanops.nanmax": [
                            1511
                        ],
                        "nanops": [
                            1511
                        ],
                        "self._box_func": [
                            1513
                        ]
                    },
                    "diff_line_number": 1483,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "mean",
                    "function_code": "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        # See discussion in GH#24757\n        raise TypeError(\n            f\"mean is not implemented for {type(self).__name__} since the \"\n            \"meaning is ambiguous.  An alternative is \"\n            \"obj.to_timestamp(how='start').mean()\"\n        )\n\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n\n    if not len(values):\n        # short-circuit for empty max / min\n        return NaT\n\n    result = nanops.nanmean(values.view(\"i8\"), skipna=skipna)\n    # Don't have to worry about NA `result`, since no NA went in.\n    return self._box_func(result)\n",
                    "decorators": [],
                    "docstring": "Return the mean value of the Array.\n\n.. versionadded:: 0.25.0\n\nParameters\n----------\nskipna : bool, default True\n    Whether to ignore any NaT elements.\n\nReturns\n-------\nscalar\n    Timestamp or Timedelta.\n\nSee Also\n--------\nnumpy.ndarray.mean : Returns the average of array elements along a given axis.\nSeries.mean : Return the mean value in a Series.\n\nNotes\n-----\nmean is only defined for Datetime and Timedelta dtypes, not for Period.",
                    "start_line": 1515,
                    "variables": {
                        "is_period_dtype": [
                            1540
                        ],
                        "self": [
                            1540,
                            1543,
                            1548,
                            1550,
                            1554,
                            1562
                        ],
                        "TypeError": [
                            1542
                        ],
                        "__name__": [
                            1543
                        ],
                        "type": [
                            1543
                        ],
                        "mask": [
                            1548,
                            1550,
                            1551
                        ],
                        "self.isna": [
                            1548
                        ],
                        "skipna": [
                            1560,
                            1549
                        ],
                        "values": [
                            1560,
                            1554,
                            1556,
                            1550
                        ],
                        "mask.any": [
                            1551
                        ],
                        "NaT": [
                            1552,
                            1558
                        ],
                        "len": [
                            1556
                        ],
                        "result": [
                            1560,
                            1562
                        ],
                        "nanops.nanmean": [
                            1560
                        ],
                        "nanops": [
                            1560
                        ],
                        "values.view": [
                            1560
                        ],
                        "self._box_func": [
                            1562
                        ]
                    },
                    "filtered_variables": {
                        "is_period_dtype": [
                            1540
                        ],
                        "self": [
                            1540,
                            1543,
                            1548,
                            1550,
                            1554,
                            1562
                        ],
                        "mask": [
                            1548,
                            1550,
                            1551
                        ],
                        "self.isna": [
                            1548
                        ],
                        "skipna": [
                            1560,
                            1549
                        ],
                        "values": [
                            1560,
                            1554,
                            1556,
                            1550
                        ],
                        "mask.any": [
                            1551
                        ],
                        "NaT": [
                            1552,
                            1558
                        ],
                        "result": [
                            1560,
                            1562
                        ],
                        "nanops.nanmean": [
                            1560
                        ],
                        "nanops": [
                            1560
                        ],
                        "values.view": [
                            1560
                        ],
                        "self._box_func": [
                            1562
                        ]
                    },
                    "diff_line_number": 1515,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                            "@property\ndef shape(self):\n    return self._data.shape",
                            "def reshape(self, *args, **kwargs):\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "def ravel(self, *args, **kwargs):\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = f\"shape mismatch: value array of length '{len(key)}' does not match indexing result of length '{len(value)}'.\"\n                raise ValueError(msg)\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', or array of those. Got '{type(value).__name__}' instead.\"\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = f'Cannot cast {type(self).__name__} to dtype {dtype}'\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\")\n    return fill_value",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(f\"Length of 'value' does not match. Got ({len(value)})  expected {len(self)}\")\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError(f'Inferred frequency {inferred} from passed values does not conform to passed frequency {freq.freqstr}')",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError(f'cannot add {type(self).__name__} and {type(other).__name__}')",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError(f'cannot subtract a datelike from a {type(self).__name__}')",
                            "def _sub_period(self, other):\n    raise TypeError(f'cannot subtract Period from a {type(self).__name__}')",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(self.shape, dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f'Cannot add {type(self).__name__} and {type(NaT).__name__}')\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(f'cannot subtract {other.dtype}-dtype from {type(self).__name__}')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn(f'Adding/subtracting array of DateOffsets to {type(self).__name__} not vectorized', PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        res = res_values\n    return res",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "@unpack_zerodim_and_defer('__add__')\ndef __add__(self, other):\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "@unpack_zerodim_and_defer('__sub__')\ndef __sub__(self, other):\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if lib.is_scalar(other):\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {type(other).__name__}')\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError(f'cannot subtract {type(self).__name__} from {other.dtype}')\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    result = self + other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def __isub__(self, other):\n    result = self - other\n    self[:] = result[:]\n    if not is_period_dtype(self):\n        self._freq = result._freq\n    return self",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(f\"mean is not implemented for {type(self).__name__} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\")\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_create_comparison_method",
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "ndim(self) -> int",
                            "shape(self)",
                            "reshape(self, *args, **kwargs)",
                            "ravel(self, *args, **kwargs)",
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_object_array(self, other: np.ndarray, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "validate_periods",
                    "function_code": "def validate_periods(periods):\n    \"\"\"\n    If a `periods` argument is passed to the Datetime/Timedelta Array/Index\n    constructor, cast it to an integer.\n\n    Parameters\n    ----------\n    periods : None, float, int\n\n    Returns\n    -------\n    periods : None or int\n\n    Raises\n    ------\n    TypeError\n        if periods is None, float, or int\n    \"\"\"\n    if periods is not None:\n        if lib.is_float(periods):\n            periods = int(periods)\n        elif not lib.is_integer(periods):\n            raise TypeError(f\"periods must be a number, got {periods}\")\n    return periods\n",
                    "decorators": [],
                    "docstring": "If a `periods` argument is passed to the Datetime/Timedelta Array/Index\nconstructor, cast it to an integer.\n\nParameters\n----------\nperiods : None, float, int\n\nReturns\n-------\nperiods : None or int\n\nRaises\n------\nTypeError\n    if periods is None, float, or int",
                    "start_line": 1571,
                    "variables": {
                        "periods": [
                            1589,
                            1590,
                            1591,
                            1592,
                            1593,
                            1594
                        ],
                        "lib.is_float": [
                            1590
                        ],
                        "lib": [
                            1592,
                            1590
                        ],
                        "int": [
                            1591
                        ],
                        "lib.is_integer": [
                            1592
                        ],
                        "TypeError": [
                            1593
                        ]
                    },
                    "filtered_variables": {
                        "periods": [
                            1589,
                            1590,
                            1591,
                            1592,
                            1593,
                            1594
                        ],
                        "lib.is_float": [
                            1590
                        ],
                        "lib": [
                            1592,
                            1590
                        ],
                        "lib.is_integer": [
                            1592
                        ]
                    },
                    "diff_line_number": 1571,
                    "class_data": null,
                    "variable_values": [
                        [
                            {
                                "periods": {
                                    "variable_value": "100",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "periods": {
                                    "variable_value": "100",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "periods": {
                                    "variable_value": "100",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "periods": {
                                    "variable_value": "100",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "periods": {
                                    "variable_value": "100",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "periods": {
                                    "variable_value": "100",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "periods": {
                                    "variable_value": "5",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "periods": {
                                    "variable_value": "5",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "periods": {
                                    "variable_value": "100",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "periods": {
                                    "variable_value": "100",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "periods": {
                                    "variable_value": "100",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "periods": {
                                    "variable_value": "100",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "periods": {
                                    "variable_value": "100",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "periods": {
                                    "variable_value": "100",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "periods": {
                                    "variable_value": "5",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "periods": {
                                    "variable_value": "5",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "lib.is_float": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                },
                {
                    "function_name": "validate_endpoints",
                    "function_code": "def validate_endpoints(closed):\n    \"\"\"\n    Check that the `closed` argument is among [None, \"left\", \"right\"]\n\n    Parameters\n    ----------\n    closed : {None, \"left\", \"right\"}\n\n    Returns\n    -------\n    left_closed : bool\n    right_closed : bool\n\n    Raises\n    ------\n    ValueError : if argument is not among valid values\n    \"\"\"\n    left_closed = False\n    right_closed = False\n\n    if closed is None:\n        left_closed = True\n        right_closed = True\n    elif closed == \"left\":\n        left_closed = True\n    elif closed == \"right\":\n        right_closed = True\n    else:\n        raise ValueError(\"Closed has to be either 'left', 'right' or None\")\n\n    return left_closed, right_closed\n",
                    "decorators": [],
                    "docstring": "Check that the `closed` argument is among [None, \"left\", \"right\"]\n\nParameters\n----------\nclosed : {None, \"left\", \"right\"}\n\nReturns\n-------\nleft_closed : bool\nright_closed : bool\n\nRaises\n------\nValueError : if argument is not among valid values",
                    "start_line": 1597,
                    "variables": {
                        "left_closed": [
                            1618,
                            1627,
                            1621,
                            1614
                        ],
                        "right_closed": [
                            1627,
                            1619,
                            1623,
                            1615
                        ],
                        "closed": [
                            1617,
                            1620,
                            1622
                        ],
                        "ValueError": [
                            1625
                        ]
                    },
                    "filtered_variables": {
                        "left_closed": [
                            1618,
                            1627,
                            1621,
                            1614
                        ],
                        "right_closed": [
                            1627,
                            1619,
                            1623,
                            1615
                        ],
                        "closed": [
                            1617,
                            1620,
                            1622
                        ]
                    },
                    "diff_line_number": 1597,
                    "class_data": null,
                    "variable_values": [
                        [
                            {
                                "left_closed": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_closed": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "closed": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            },
                            {
                                "left_closed": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "right_closed": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "closed": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "left_closed": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_closed": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "closed": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            },
                            {
                                "left_closed": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "right_closed": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "closed": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "left_closed": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_closed": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "closed": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            },
                            {
                                "left_closed": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "right_closed": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "closed": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "left_closed": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "right_closed": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "closed": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            },
                            {
                                "left_closed": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "right_closed": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "closed": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                },
                {
                    "function_name": "validate_inferred_freq",
                    "function_code": "def validate_inferred_freq(freq, inferred_freq, freq_infer):\n    \"\"\"\n    If the user passes a freq and another freq is inferred from passed data,\n    require that they match.\n\n    Parameters\n    ----------\n    freq : DateOffset or None\n    inferred_freq : DateOffset or None\n    freq_infer : bool\n\n    Returns\n    -------\n    freq : DateOffset or None\n    freq_infer : bool\n\n    Notes\n    -----\n    We assume at this point that `maybe_infer_freq` has been called, so\n    `freq` is either a DateOffset object or None.\n    \"\"\"\n    if inferred_freq is not None:\n        if freq is not None and freq != inferred_freq:\n            raise ValueError(\n                f\"Inferred frequency {inferred_freq} from passed \"\n                \"values does not conform to passed frequency \"\n                f\"{freq.freqstr}\"\n            )\n        elif freq is None:\n            freq = inferred_freq\n        freq_infer = False\n\n    return freq, freq_infer\n",
                    "decorators": [],
                    "docstring": "If the user passes a freq and another freq is inferred from passed data,\nrequire that they match.\n\nParameters\n----------\nfreq : DateOffset or None\ninferred_freq : DateOffset or None\nfreq_infer : bool\n\nReturns\n-------\nfreq : DateOffset or None\nfreq_infer : bool\n\nNotes\n-----\nWe assume at this point that `maybe_infer_freq` has been called, so\n`freq` is either a DateOffset object or None.",
                    "start_line": 1630,
                    "variables": {
                        "inferred_freq": [
                            1659,
                            1651,
                            1652,
                            1654
                        ],
                        "freq": [
                            1652,
                            1656,
                            1658,
                            1659,
                            1662
                        ],
                        "ValueError": [
                            1653
                        ],
                        "freq.freqstr": [
                            1656
                        ],
                        "freq_infer": [
                            1660,
                            1662
                        ]
                    },
                    "filtered_variables": {
                        "inferred_freq": [
                            1659,
                            1651,
                            1652,
                            1654
                        ],
                        "freq": [
                            1652,
                            1656,
                            1658,
                            1659,
                            1662
                        ],
                        "freq.freqstr": [
                            1656
                        ],
                        "freq_infer": [
                            1660,
                            1662
                        ]
                    },
                    "diff_line_number": 1630,
                    "class_data": null,
                    "variable_values": [
                        [
                            {
                                "inferred_freq": {
                                    "variable_value": "<BusinessDay>",
                                    "variable_type": "BusinessDay",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            },
                            {
                                "inferred_freq": {
                                    "variable_value": "<BusinessDay>",
                                    "variable_type": "BusinessDay",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "<BusinessDay>",
                                    "variable_type": "BusinessDay",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "'B'",
                                    "variable_type": "str",
                                    "variable_shape": "1"
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "inferred_freq": {
                                    "variable_value": "<BusinessDay>",
                                    "variable_type": "BusinessDay",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            },
                            {
                                "inferred_freq": {
                                    "variable_value": "<BusinessDay>",
                                    "variable_type": "BusinessDay",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "<BusinessDay>",
                                    "variable_type": "BusinessDay",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "'B'",
                                    "variable_type": "str",
                                    "variable_shape": "1"
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "inferred_freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            },
                            {
                                "inferred_freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "inferred_freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            },
                            {
                                "inferred_freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "inferred_freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            },
                            {
                                "inferred_freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "inferred_freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            },
                            {
                                "inferred_freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "inferred_freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            },
                            {
                                "inferred_freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq.freqstr": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                },
                {
                    "function_name": "maybe_infer_freq",
                    "function_code": "def maybe_infer_freq(freq):\n    \"\"\"\n    Comparing a DateOffset to the string \"infer\" raises, so we need to\n    be careful about comparisons.  Make a dummy variable `freq_infer` to\n    signify the case where the given freq is \"infer\" and set freq to None\n    to avoid comparison trouble later on.\n\n    Parameters\n    ----------\n    freq : {DateOffset, None, str}\n\n    Returns\n    -------\n    freq : {DateOffset, None}\n    freq_infer : bool\n    \"\"\"\n    freq_infer = False\n    if not isinstance(freq, DateOffset):\n        # if a passed freq is None, don't infer automatically\n        if freq != \"infer\":\n            freq = frequencies.to_offset(freq)\n        else:\n            freq_infer = True\n            freq = None\n    return freq, freq_infer\n",
                    "decorators": [],
                    "docstring": "Comparing a DateOffset to the string \"infer\" raises, so we need to\nbe careful about comparisons.  Make a dummy variable `freq_infer` to\nsignify the case where the given freq is \"infer\" and set freq to None\nto avoid comparison trouble later on.\n\nParameters\n----------\nfreq : {DateOffset, None, str}\n\nReturns\n-------\nfreq : {DateOffset, None}\nfreq_infer : bool",
                    "start_line": 1665,
                    "variables": {
                        "freq_infer": [
                            1681,
                            1689,
                            1687
                        ],
                        "isinstance": [
                            1682
                        ],
                        "freq": [
                            1682,
                            1684,
                            1685,
                            1688,
                            1689
                        ],
                        "DateOffset": [
                            1682
                        ],
                        "frequencies.to_offset": [
                            1685
                        ],
                        "frequencies": [
                            1685
                        ]
                    },
                    "filtered_variables": {
                        "freq_infer": [
                            1681,
                            1689,
                            1687
                        ],
                        "freq": [
                            1682,
                            1684,
                            1685,
                            1688,
                            1689
                        ],
                        "DateOffset": [
                            1682
                        ],
                        "frequencies.to_offset": [
                            1685
                        ],
                        "frequencies": [
                            1685
                        ]
                    },
                    "diff_line_number": 1665,
                    "class_data": null,
                    "variable_values": [
                        [
                            {
                                "freq_infer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "freq_infer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "'D'",
                                    "variable_type": "str",
                                    "variable_shape": "1"
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "<Day>",
                                    "variable_type": "Day",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "freq_infer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "freq_infer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "'D'",
                                    "variable_type": "str",
                                    "variable_shape": "1"
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "<Day>",
                                    "variable_type": "Day",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "freq_infer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "freq_infer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "'infer'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "freq_infer": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "freq_infer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "freq_infer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "freq_infer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "freq_infer": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "DateOffset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies.to_offset": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "frequencies": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                },
                {
                    "function_name": "_ensure_datetimelike_to_i8",
                    "function_code": "def _ensure_datetimelike_to_i8(other, to_utc=False):\n    \"\"\"\n    Helper for coercing an input scalar or array to i8.\n\n    Parameters\n    ----------\n    other : 1d array\n    to_utc : bool, default False\n        If True, convert the values to UTC before extracting the i8 values\n        If False, extract the i8 values directly.\n\n    Returns\n    -------\n    i8 1d array\n    \"\"\"\n    from pandas import Index\n\n    if lib.is_scalar(other) and isna(other):\n        return iNaT\n    elif isinstance(other, (ABCPeriodArray, ABCIndexClass, DatetimeLikeArrayMixin)):\n        # convert tz if needed\n        if getattr(other, \"tz\", None) is not None:\n            if to_utc:\n                other = other.tz_convert(\"UTC\")\n            else:\n                other = other.tz_localize(None)\n    else:\n        try:\n            return np.array(other, copy=False).view(\"i8\")\n        except TypeError:\n            # period array cannot be coerced to int\n            other = Index(other)\n    return other.asi8\n",
                    "decorators": [],
                    "docstring": "Helper for coercing an input scalar or array to i8.\n\nParameters\n----------\nother : 1d array\nto_utc : bool, default False\n    If True, convert the values to UTC before extracting the i8 values\n    If False, extract the i8 values directly.\n\nReturns\n-------\ni8 1d array",
                    "start_line": 1692,
                    "variables": {
                        "lib.is_scalar": [
                            1709
                        ],
                        "lib": [
                            1709
                        ],
                        "other": [
                            1709,
                            1711,
                            1713,
                            1715,
                            1717,
                            1720,
                            1723,
                            1724
                        ],
                        "isna": [
                            1709
                        ],
                        "iNaT": [
                            1710
                        ],
                        "isinstance": [
                            1711
                        ],
                        "ABCPeriodArray": [
                            1711
                        ],
                        "ABCIndexClass": [
                            1711
                        ],
                        "DatetimeLikeArrayMixin": [
                            1711
                        ],
                        "getattr": [
                            1713
                        ],
                        "to_utc": [
                            1714
                        ],
                        "other.tz_convert": [
                            1715
                        ],
                        "other.tz_localize": [
                            1717
                        ],
                        "view": [
                            1720
                        ],
                        "np.array": [
                            1720
                        ],
                        "np": [
                            1720
                        ],
                        "TypeError": [
                            1721
                        ],
                        "Index": [
                            1723
                        ],
                        "other.asi8": [
                            1724
                        ]
                    },
                    "filtered_variables": {
                        "lib.is_scalar": [
                            1709
                        ],
                        "lib": [
                            1709
                        ],
                        "other": [
                            1709,
                            1711,
                            1713,
                            1715,
                            1717,
                            1720,
                            1723,
                            1724
                        ],
                        "isna": [
                            1709
                        ],
                        "iNaT": [
                            1710
                        ],
                        "ABCPeriodArray": [
                            1711
                        ],
                        "ABCIndexClass": [
                            1711
                        ],
                        "DatetimeLikeArrayMixin": [
                            1711
                        ],
                        "to_utc": [
                            1714
                        ],
                        "other.tz_convert": [
                            1715
                        ],
                        "other.tz_localize": [
                            1717
                        ],
                        "view": [
                            1720
                        ],
                        "np.array": [
                            1720
                        ],
                        "np": [
                            1720
                        ],
                        "Index": [
                            1723
                        ],
                        "other.asi8": [
                            1724
                        ]
                    },
                    "diff_line_number": 1692,
                    "class_data": null,
                    "variable_values": [
                        [
                            {
                                "lib.is_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": "PeriodIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04',\n             '2013-01-05'],\n            dtype='period[D]', freq='D')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "5"
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ABCPeriodArray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ABCIndexClass": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "DatetimeLikeArrayMixin": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "to_utc": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "other.tz_convert": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "other.tz_localize": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.asi8": {
                                    "variable_value": "array([15706, 15707, 15708, 15709, 15710])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                }
                            },
                            {
                                "lib.is_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": "PeriodIndex(['2013-01-01', '2013-01-02', '2013-01-03', '2013-01-04',\n             '2013-01-05'],\n            dtype='period[D]', freq='D')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "5"
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ABCPeriodArray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ABCIndexClass": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "DatetimeLikeArrayMixin": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "to_utc": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "other.tz_convert": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "other.tz_localize": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "view": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": "<class 'pandas.core.indexes.base.Index'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x112ca5b80>"
                                },
                                "other.asi8": {
                                    "variable_value": "array([15706, 15707, 15708, 15709, 15710])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "5"
                                }
                            }
                        ]
                    ]
                }
            ],
            "snippets": [
                {
                    "snippet_code": "from datetime import datetime, timedelta\nimport operator\nfrom typing import Any, Sequence, Type, Union, cast\nimport warnings\n\nimport numpy as np\n\nfrom pandas._libs import NaT, NaTType, Timestamp, algos, iNaT, lib\nfrom pandas._libs.tslibs.c_timestamp import integer_op_not_supported\nfrom pandas._libs.tslibs.period import DIFFERENT_FREQ, IncompatibleFrequency, Period\nfrom pandas._libs.tslibs.timedeltas import Timedelta, delta_to_nanoseconds\nfrom pandas._libs.tslibs.timestamps import RoundTo, round_nsint64\nfrom pandas._typing import DatetimeLikeScalar\nfrom pandas.compat import set_function_name\nfrom pandas.compat.numpy import function as nv\nfrom pandas.errors import AbstractMethodError, NullFrequencyError, PerformanceWarning\nfrom pandas.util._decorators import Appender, Substitution\nfrom pandas.util._validators import validate_fillna_kwargs\n\nfrom pandas.core.dtypes.common import (\n    is_categorical_dtype,\n    is_datetime64_any_dtype,\n    is_datetime64_dtype,\n    is_datetime64tz_dtype,\n    is_datetime_or_timedelta_dtype,\n    is_dtype_equal,\n    is_float_dtype,\n    is_integer_dtype,\n    is_list_like,\n    is_object_dtype,\n    is_period_dtype,\n    is_string_dtype,\n    is_timedelta64_dtype,\n    is_unsigned_integer_dtype,\n    pandas_dtype,\n)\nfrom pandas.core.dtypes.generic import ABCIndexClass, ABCPeriodArray, ABCSeries\nfrom pandas.core.dtypes.inference import is_array_like\nfrom pandas.core.dtypes.missing import is_valid_nat_for_dtype, isna\n\nfrom pandas.core import missing, nanops, ops\nfrom pandas.core.algorithms import checked_add_with_arr, take, unique1d, value_counts\nimport pandas.core.common as com\nfrom pandas.core.indexers import check_bool_array_indexer\nfrom pandas.core.ops.common import unpack_zerodim_and_defer\nfrom pandas.core.ops.invalid import invalid_comparison, make_invalid_op\n\nfrom pandas.tseries import frequencies\nfrom pandas.tseries.offsets import DateOffset, Tick\n\nfrom .base import ExtensionArray, ExtensionOpsMixin",
                    "start_line": 1,
                    "end_line": 52
                },
                {
                    "snippet_code": "class AttributesMixin:\n    _data: np.ndarray\n\n    @classmethod",
                    "start_line": 127,
                    "end_line": 132
                },
                {
                    "snippet_code": "class DatelikeOps:\n    \"\"\"\n    Common ops for DatetimeIndex/PeriodIndex, but not TimedeltaIndex.\n    \"\"\"\n\n    @Substitution(\n        URL=\"https://docs.python.org/3/library/datetime.html\"\n        \"#strftime-and-strptime-behavior\"\n    )",
                    "start_line": 211,
                    "end_line": 221
                },
                {
                    "snippet_code": "class TimelikeOps:\n    \"\"\"\n    Common ops for TimedeltaIndex/DatetimeIndex, but not PeriodIndex.\n    \"\"\"\n\n    _round_doc = \"\"\"\n        Perform {op} operation on the data to the specified `freq`.\n\n        Parameters\n        ----------\n        freq : str or Offset\n            The frequency level to {op} the index to. Must be a fixed\n            frequency like 'S' (second) not 'ME' (month end). See\n            :ref:`frequency aliases <timeseries.offset_aliases>` for\n            a list of possible `freq` values.\n        ambiguous : 'infer', bool-ndarray, 'NaT', default 'raise'\n            Only relevant for DatetimeIndex:\n\n            - 'infer' will attempt to infer fall dst-transition hours based on\n              order\n            - bool-ndarray where True signifies a DST time, False designates\n              a non-DST time (note that this flag is only applicable for\n              ambiguous times)\n            - 'NaT' will return NaT where there are ambiguous times\n            - 'raise' will raise an AmbiguousTimeError if there are ambiguous\n              times.\n\n            .. versionadded:: 0.24.0\n\n        nonexistent : 'shift_forward', 'shift_backward', 'NaT', timedelta, \\\ndefault 'raise'\n            A nonexistent time does not exist in a particular timezone\n            where clocks moved forward due to DST.\n\n            - 'shift_forward' will shift the nonexistent time forward to the\n              closest existing time\n            - 'shift_backward' will shift the nonexistent time backward to the\n              closest existing time\n            - 'NaT' will return NaT where there are nonexistent times\n            - timedelta objects will shift nonexistent times by the timedelta\n            - 'raise' will raise an NonExistentTimeError if there are\n              nonexistent times.\n\n            .. versionadded:: 0.24.0\n\n        Returns\n        -------\n        DatetimeIndex, TimedeltaIndex, or Series\n            Index of the same type for a DatetimeIndex or TimedeltaIndex,\n            or a Series with the same index for a Series.\n\n        Raises\n        ------\n        ValueError if the `freq` cannot be converted.\n\n        Examples\n        --------\n        **DatetimeIndex**\n\n        >>> rng = pd.date_range('1/1/2018 11:59:00', periods=3, freq='min')\n        >>> rng\n        DatetimeIndex(['2018-01-01 11:59:00', '2018-01-01 12:00:00',\n                       '2018-01-01 12:01:00'],\n                      dtype='datetime64[ns]', freq='T')\n        \"\"\"\n\n    _round_example = \"\"\">>> rng.round('H')\n        DatetimeIndex(['2018-01-01 12:00:00', '2018-01-01 12:00:00',\n                       '2018-01-01 12:00:00'],\n                      dtype='datetime64[ns]', freq=None)\n\n        **Series**\n\n        >>> pd.Series(rng).dt.round(\"H\")\n        0   2018-01-01 12:00:00\n        1   2018-01-01 12:00:00\n        2   2018-01-01 12:00:00\n        dtype: datetime64[ns]\n        \"\"\"\n\n    _floor_example = \"\"\">>> rng.floor('H')\n        DatetimeIndex(['2018-01-01 11:00:00', '2018-01-01 12:00:00',\n                       '2018-01-01 12:00:00'],\n                      dtype='datetime64[ns]', freq=None)\n\n        **Series**\n\n        >>> pd.Series(rng).dt.floor(\"H\")\n        0   2018-01-01 11:00:00\n        1   2018-01-01 12:00:00\n        2   2018-01-01 12:00:00\n        dtype: datetime64[ns]\n        \"\"\"\n\n    _ceil_example = \"\"\">>> rng.ceil('H')\n        DatetimeIndex(['2018-01-01 12:00:00', '2018-01-01 12:00:00',\n                       '2018-01-01 13:00:00'],\n                      dtype='datetime64[ns]', freq=None)\n\n        **Series**\n\n        >>> pd.Series(rng).dt.ceil(\"H\")\n        0   2018-01-01 12:00:00\n        1   2018-01-01 12:00:00\n        2   2018-01-01 13:00:00\n        dtype: datetime64[ns]\n        \"\"\"",
                    "start_line": 259,
                    "end_line": 368
                },
                {
                    "snippet_code": "@Appender((_round_doc + _round_example).format(op=\"round\"))",
                    "start_line": 381,
                    "end_line": 382
                },
                {
                    "snippet_code": "@Appender((_round_doc + _floor_example).format(op=\"floor\"))",
                    "start_line": 385,
                    "end_line": 386
                },
                {
                    "snippet_code": "@Appender((_round_doc + _ceil_example).format(op=\"ceil\"))",
                    "start_line": 389,
                    "end_line": 390
                },
                {
                    "snippet_code": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray):\n    \"\"\"\n    Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\n    Assumes that __new__/__init__ defines:\n        _data\n        _freq\n\n    and that the inheriting class has methods:\n        _generate_range\n    \"\"\"\n\n    @property",
                    "start_line": 393,
                    "end_line": 407
                },
                {
                    "snippet_code": "@property",
                    "start_line": 410,
                    "end_line": 411
                },
                {
                    "snippet_code": "@property",
                    "start_line": 440,
                    "end_line": 441
                },
                {
                    "snippet_code": "@property",
                    "start_line": 453,
                    "end_line": 454
                },
                {
                    "snippet_code": "# ----------------------------------------------------------------\n    # Rendering Methods",
                    "start_line": 457,
                    "end_line": 460
                },
                {
                    "snippet_code": "# ----------------------------------------------------------------\n    # Array-Like / EA-Interface Methods\n\n    @property",
                    "start_line": 474,
                    "end_line": 478
                },
                {
                    "snippet_code": "@property",
                    "start_line": 487,
                    "end_line": 488
                },
                {
                    "snippet_code": "# ------------------------------------------------------------------\n    # ExtensionArray Interface",
                    "start_line": 645,
                    "end_line": 648
                },
                {
                    "snippet_code": "@classmethod",
                    "start_line": 691,
                    "end_line": 692
                },
                {
                    "snippet_code": "@classmethod",
                    "start_line": 707,
                    "end_line": 708
                },
                {
                    "snippet_code": "# ------------------------------------------------------------------\n    # Additional array methods\n    #  These are not part of the EA API, but we implement them because\n    #  pandas assumes they're there.",
                    "start_line": 714,
                    "end_line": 719
                },
                {
                    "snippet_code": "# ------------------------------------------------------------------\n    # Null Handling",
                    "start_line": 809,
                    "end_line": 811
                },
                {
                    "snippet_code": "@property  # NB: override with cache_readonly in immutable subclasses",
                    "start_line": 814,
                    "end_line": 815
                },
                {
                    "snippet_code": "@property  # NB: override with cache_readonly in immutable subclasses",
                    "start_line": 821,
                    "end_line": 822
                },
                {
                    "snippet_code": "# ------------------------------------------------------------------\n    # Frequency Properties/Methods\n\n    @property",
                    "start_line": 901,
                    "end_line": 905
                },
                {
                    "snippet_code": "@freq.setter",
                    "start_line": 911,
                    "end_line": 912
                },
                {
                    "snippet_code": "@property",
                    "start_line": 919,
                    "end_line": 920
                },
                {
                    "snippet_code": "@property  # NB: override with cache_readonly in immutable subclasses",
                    "start_line": 928,
                    "end_line": 929
                },
                {
                    "snippet_code": "@property  # NB: override with cache_readonly in immutable subclasses",
                    "start_line": 942,
                    "end_line": 943
                },
                {
                    "snippet_code": "@property  # NB: override with cache_readonly in immutable subclasses",
                    "start_line": 946,
                    "end_line": 947
                },
                {
                    "snippet_code": "@classmethod",
                    "start_line": 953,
                    "end_line": 954
                },
                {
                    "snippet_code": "# monotonicity/uniqueness properties are called via frequencies.infer_freq,\n    #  see GH#23789\n\n    @property",
                    "start_line": 995,
                    "end_line": 999
                },
                {
                    "snippet_code": "@property",
                    "start_line": 1002,
                    "end_line": 1003
                },
                {
                    "snippet_code": "@property",
                    "start_line": 1006,
                    "end_line": 1007
                },
                {
                    "snippet_code": "# ------------------------------------------------------------------\n    # Arithmetic Methods\n    _create_comparison_method = classmethod(_datetimelike_array_cmp)\n\n    # pow is invalid for all three subclasses; TimedeltaArray will override\n    #  the multiplication and division ops\n    __pow__ = make_invalid_op(\"__pow__\")\n    __rpow__ = make_invalid_op(\"__rpow__\")\n    __mul__ = make_invalid_op(\"__mul__\")\n    __rmul__ = make_invalid_op(\"__rmul__\")\n    __truediv__ = make_invalid_op(\"__truediv__\")\n    __rtruediv__ = make_invalid_op(\"__rtruediv__\")\n    __floordiv__ = make_invalid_op(\"__floordiv__\")\n    __rfloordiv__ = make_invalid_op(\"__rfloordiv__\")\n    __mod__ = make_invalid_op(\"__mod__\")\n    __rmod__ = make_invalid_op(\"__rmod__\")\n    __divmod__ = make_invalid_op(\"__divmod__\")\n    __rdivmod__ = make_invalid_op(\"__rdivmod__\")",
                    "start_line": 1010,
                    "end_line": 1029
                },
                {
                    "snippet_code": "_add_datetime_arraylike = _add_datetimelike_scalar",
                    "start_line": 1033,
                    "end_line": 1035
                },
                {
                    "snippet_code": "_sub_datetime_arraylike = _sub_datetimelike_scalar",
                    "start_line": 1040,
                    "end_line": 1042
                },
                {
                    "snippet_code": "@unpack_zerodim_and_defer(\"__add__\")",
                    "start_line": 1257,
                    "end_line": 1258
                },
                {
                    "snippet_code": "@unpack_zerodim_and_defer(\"__sub__\")",
                    "start_line": 1309,
                    "end_line": 1310
                },
                {
                    "snippet_code": "# --------------------------------------------------------------\n    # Comparison Methods",
                    "start_line": 1413,
                    "end_line": 1416
                },
                {
                    "snippet_code": "# --------------------------------------------------------------\n    # Reductions",
                    "start_line": 1452,
                    "end_line": 1455
                },
                {
                    "snippet_code": "DatetimeLikeArrayMixin._add_comparison_ops()\n\n# -------------------------------------------------------------------\n# Shared Constructor Helpers",
                    "start_line": 1563,
                    "end_line": 1570
                }
            ],
            "inscope_functions": [
                "def _datetimelike_array_cmp(cls, op):\n    \"\"\"\n    Wrap comparison operations to convert Timestamp/Timedelta/Period-like to\n    boxed scalars/arrays.\n    \"\"\"\n    opname = f\"__{op.__name__}__\"\n    nat_result = opname == \"__ne__\"\n\n    @unpack_zerodim_and_defer(opname)\n    def wrapper(self, other):\n\n        if isinstance(other, str):\n            try:\n                # GH#18435 strings get a pass from tzawareness compat\n                other = self._scalar_from_string(other)\n            except ValueError:\n                # failed to parse as Timestamp/Timedelta/Period\n                return invalid_comparison(self, other, op)\n\n        if isinstance(other, self._recognized_scalars) or other is NaT:\n            other = self._scalar_type(other)\n            self._check_compatible_with(other)\n\n            other_i8 = self._unbox_scalar(other)\n\n            result = op(self.view(\"i8\"), other_i8)\n            if isna(other):\n                result.fill(nat_result)\n\n        elif not is_list_like(other):\n            return invalid_comparison(self, other, op)\n\n        elif len(other) != len(self):\n            raise ValueError(\"Lengths must match\")\n\n        else:\n            if isinstance(other, list):\n                # TODO: could use pd.Index to do inference?\n                other = np.array(other)\n\n            if not isinstance(other, (np.ndarray, type(self))):\n                return invalid_comparison(self, other, op)\n\n            if is_object_dtype(other):\n                # We have to use comp_method_OBJECT_ARRAY instead of numpy\n                #  comparison otherwise it would fail to raise when\n                #  comparing tz-aware and tz-naive\n                with np.errstate(all=\"ignore\"):\n                    result = ops.comp_method_OBJECT_ARRAY(\n                        op, self.astype(object), other\n                    )\n                o_mask = isna(other)\n\n            elif not type(self)._is_recognized_dtype(other.dtype):\n                return invalid_comparison(self, other, op)\n\n            else:\n                # For PeriodDType this casting is unnecessary\n                other = type(self)._from_sequence(other)\n                self._check_compatible_with(other)\n\n                result = op(self.view(\"i8\"), other.view(\"i8\"))\n                o_mask = other._isnan\n\n            if o_mask.any():\n                result[o_mask] = nat_result\n\n        if self._hasnans:\n            result[self._isnan] = nat_result\n\n        return result\n\n    return set_function_name(wrapper, opname, cls)",
                "def validate_periods(periods):\n    \"\"\"\n    If a `periods` argument is passed to the Datetime/Timedelta Array/Index\n    constructor, cast it to an integer.\n\n    Parameters\n    ----------\n    periods : None, float, int\n\n    Returns\n    -------\n    periods : None or int\n\n    Raises\n    ------\n    TypeError\n        if periods is None, float, or int\n    \"\"\"\n    if periods is not None:\n        if lib.is_float(periods):\n            periods = int(periods)\n        elif not lib.is_integer(periods):\n            raise TypeError(f\"periods must be a number, got {periods}\")\n    return periods",
                "def validate_endpoints(closed):\n    \"\"\"\n    Check that the `closed` argument is among [None, \"left\", \"right\"]\n\n    Parameters\n    ----------\n    closed : {None, \"left\", \"right\"}\n\n    Returns\n    -------\n    left_closed : bool\n    right_closed : bool\n\n    Raises\n    ------\n    ValueError : if argument is not among valid values\n    \"\"\"\n    left_closed = False\n    right_closed = False\n\n    if closed is None:\n        left_closed = True\n        right_closed = True\n    elif closed == \"left\":\n        left_closed = True\n    elif closed == \"right\":\n        right_closed = True\n    else:\n        raise ValueError(\"Closed has to be either 'left', 'right' or None\")\n\n    return left_closed, right_closed",
                "def validate_inferred_freq(freq, inferred_freq, freq_infer):\n    \"\"\"\n    If the user passes a freq and another freq is inferred from passed data,\n    require that they match.\n\n    Parameters\n    ----------\n    freq : DateOffset or None\n    inferred_freq : DateOffset or None\n    freq_infer : bool\n\n    Returns\n    -------\n    freq : DateOffset or None\n    freq_infer : bool\n\n    Notes\n    -----\n    We assume at this point that `maybe_infer_freq` has been called, so\n    `freq` is either a DateOffset object or None.\n    \"\"\"\n    if inferred_freq is not None:\n        if freq is not None and freq != inferred_freq:\n            raise ValueError(\n                f\"Inferred frequency {inferred_freq} from passed \"\n                \"values does not conform to passed frequency \"\n                f\"{freq.freqstr}\"\n            )\n        elif freq is None:\n            freq = inferred_freq\n        freq_infer = False\n\n    return freq, freq_infer",
                "def maybe_infer_freq(freq):\n    \"\"\"\n    Comparing a DateOffset to the string \"infer\" raises, so we need to\n    be careful about comparisons.  Make a dummy variable `freq_infer` to\n    signify the case where the given freq is \"infer\" and set freq to None\n    to avoid comparison trouble later on.\n\n    Parameters\n    ----------\n    freq : {DateOffset, None, str}\n\n    Returns\n    -------\n    freq : {DateOffset, None}\n    freq_infer : bool\n    \"\"\"\n    freq_infer = False\n    if not isinstance(freq, DateOffset):\n        # if a passed freq is None, don't infer automatically\n        if freq != \"infer\":\n            freq = frequencies.to_offset(freq)\n        else:\n            freq_infer = True\n            freq = None\n    return freq, freq_infer",
                "def _ensure_datetimelike_to_i8(other, to_utc=False):\n    \"\"\"\n    Helper for coercing an input scalar or array to i8.\n\n    Parameters\n    ----------\n    other : 1d array\n    to_utc : bool, default False\n        If True, convert the values to UTC before extracting the i8 values\n        If False, extract the i8 values directly.\n\n    Returns\n    -------\n    i8 1d array\n    \"\"\"\n    from pandas import Index\n\n    if lib.is_scalar(other) and isna(other):\n        return iNaT\n    elif isinstance(other, (ABCPeriodArray, ABCIndexClass, DatetimeLikeArrayMixin)):\n        # convert tz if needed\n        if getattr(other, \"tz\", None) is not None:\n            if to_utc:\n                other = other.tz_convert(\"UTC\")\n            else:\n                other = other.tz_localize(None)\n    else:\n        try:\n            return np.array(other, copy=False).view(\"i8\")\n        except TypeError:\n            # period array cannot be coerced to int\n            other = Index(other)\n    return other.asi8",
                "@unpack_zerodim_and_defer(opname)\ndef wrapper(self, other):\n\n    if isinstance(other, str):\n        try:\n            # GH#18435 strings get a pass from tzawareness compat\n            other = self._scalar_from_string(other)\n        except ValueError:\n            # failed to parse as Timestamp/Timedelta/Period\n            return invalid_comparison(self, other, op)\n\n    if isinstance(other, self._recognized_scalars) or other is NaT:\n        other = self._scalar_type(other)\n        self._check_compatible_with(other)\n\n        other_i8 = self._unbox_scalar(other)\n\n        result = op(self.view(\"i8\"), other_i8)\n        if isna(other):\n            result.fill(nat_result)\n\n    elif not is_list_like(other):\n        return invalid_comparison(self, other, op)\n\n    elif len(other) != len(self):\n        raise ValueError(\"Lengths must match\")\n\n    else:\n        if isinstance(other, list):\n            # TODO: could use pd.Index to do inference?\n            other = np.array(other)\n\n        if not isinstance(other, (np.ndarray, type(self))):\n            return invalid_comparison(self, other, op)\n\n        if is_object_dtype(other):\n            # We have to use comp_method_OBJECT_ARRAY instead of numpy\n            #  comparison otherwise it would fail to raise when\n            #  comparing tz-aware and tz-naive\n            with np.errstate(all=\"ignore\"):\n                result = ops.comp_method_OBJECT_ARRAY(\n                    op, self.astype(object), other\n                )\n            o_mask = isna(other)\n\n        elif not type(self)._is_recognized_dtype(other.dtype):\n            return invalid_comparison(self, other, op)\n\n        else:\n            # For PeriodDType this casting is unnecessary\n            other = type(self)._from_sequence(other)\n            self._check_compatible_with(other)\n\n            result = op(self.view(\"i8\"), other.view(\"i8\"))\n            o_mask = other._isnan\n\n        if o_mask.any():\n            result[o_mask] = nat_result\n\n    if self._hasnans:\n        result[self._isnan] = nat_result\n\n    return result",
                "@classmethod\ndef _simple_new(cls, values, **kwargs):\n    raise AbstractMethodError(cls)",
                "@property\ndef _scalar_type(self) -> Type[DatetimeLikeScalar]:\n    \"\"\"The scalar associated with this datelike\n\n    * PeriodArray : Period\n    * DatetimeArray : Timestamp\n    * TimedeltaArray : Timedelta\n    \"\"\"\n    raise AbstractMethodError(self)",
                "def _scalar_from_string(\n    self, value: str\n) -> Union[Period, Timestamp, Timedelta, NaTType]:\n    \"\"\"\n    Construct a scalar type from a string.\n\n    Parameters\n    ----------\n    value : str\n\n    Returns\n    -------\n    Period, Timestamp, or Timedelta, or NaT\n        Whatever the type of ``self._scalar_type`` is.\n\n    Notes\n    -----\n    This should call ``self._check_compatible_with`` before\n    unboxing the result.\n    \"\"\"\n    raise AbstractMethodError(self)",
                "def _unbox_scalar(self, value: Union[Period, Timestamp, Timedelta, NaTType]) -> int:\n    \"\"\"\n    Unbox the integer value of a scalar `value`.\n\n    Parameters\n    ----------\n    value : Union[Period, Timestamp, Timedelta]\n\n    Returns\n    -------\n    int\n\n    Examples\n    --------\n    >>> self._unbox_scalar(Timedelta('10s'))  # DOCTEST: +SKIP\n    10000000000\n    \"\"\"\n    raise AbstractMethodError(self)",
                "def _check_compatible_with(\n    self, other: Union[Period, Timestamp, Timedelta, NaTType], setitem: bool = False\n) -> None:\n    \"\"\"\n    Verify that `self` and `other` are compatible.\n\n    * DatetimeArray verifies that the timezones (if any) match\n    * PeriodArray verifies that the freq matches\n    * Timedelta has no verification\n\n    In each case, NaT is considered compatible.\n\n    Parameters\n    ----------\n    other\n    setitem : bool, default False\n        For __setitem__ we may have stricter compatiblity resrictions than\n        for comparisons.\n\n    Raises\n    ------\n    Exception\n    \"\"\"\n    raise AbstractMethodError(self)",
                "@Substitution(\n    URL=\"https://docs.python.org/3/library/datetime.html\"\n    \"#strftime-and-strptime-behavior\"\n)\ndef strftime(self, date_format):\n    \"\"\"\n    Convert to Index using specified date_format.\n\n    Return an Index of formatted strings specified by date_format, which\n    supports the same string format as the python standard library. Details\n    of the string format can be found in `python string format\n    doc <%(URL)s>`__.\n\n    Parameters\n    ----------\n    date_format : str\n        Date format string (e.g. \"%%Y-%%m-%%d\").\n\n    Returns\n    -------\n    ndarray\n        NumPy ndarray of formatted strings.\n\n    See Also\n    --------\n    to_datetime : Convert the given argument to datetime.\n    DatetimeIndex.normalize : Return DatetimeIndex with times to midnight.\n    DatetimeIndex.round : Round the DatetimeIndex to the specified freq.\n    DatetimeIndex.floor : Floor the DatetimeIndex to the specified freq.\n\n    Examples\n    --------\n    >>> rng = pd.date_range(pd.Timestamp(\"2018-03-10 09:00\"),\n    ...                     periods=3, freq='s')\n    >>> rng.strftime('%%B %%d, %%Y, %%r')\n    Index(['March 10, 2018, 09:00:00 AM', 'March 10, 2018, 09:00:01 AM',\n           'March 10, 2018, 09:00:02 AM'],\n          dtype='object')\n    \"\"\"\n    result = self._format_native_types(date_format=date_format, na_rep=np.nan)\n    return result.astype(object)",
                "def _round(self, freq, mode, ambiguous, nonexistent):\n    # round the local times\n    values = _ensure_datetimelike_to_i8(self)\n    result = round_nsint64(values, mode, freq)\n    result = self._maybe_mask_results(result, fill_value=NaT)\n\n    dtype = self.dtype\n    if is_datetime64tz_dtype(self):\n        dtype = None\n    return self._ensure_localized(\n        self._simple_new(result, dtype=dtype), ambiguous, nonexistent\n    )",
                "@Appender((_round_doc + _round_example).format(op=\"round\"))\ndef round(self, freq, ambiguous=\"raise\", nonexistent=\"raise\"):\n    return self._round(freq, RoundTo.NEAREST_HALF_EVEN, ambiguous, nonexistent)",
                "@Appender((_round_doc + _floor_example).format(op=\"floor\"))\ndef floor(self, freq, ambiguous=\"raise\", nonexistent=\"raise\"):\n    return self._round(freq, RoundTo.MINUS_INFTY, ambiguous, nonexistent)",
                "@Appender((_round_doc + _ceil_example).format(op=\"ceil\"))\ndef ceil(self, freq, ambiguous=\"raise\", nonexistent=\"raise\"):\n    return self._round(freq, RoundTo.PLUS_INFTY, ambiguous, nonexistent)",
                "@property\ndef ndim(self) -> int:\n    return self._data.ndim",
                "@property\ndef shape(self):\n    return self._data.shape",
                "def reshape(self, *args, **kwargs):\n    # Note: we drop any freq\n    data = self._data.reshape(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                "def ravel(self, *args, **kwargs):\n    # Note: we drop any freq\n    data = self._data.ravel(*args, **kwargs)\n    return type(self)(data, dtype=self.dtype)",
                "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    # do not cache or you'll create a memory leak\n    return self._data.view(\"i8\")",
                "@property\ndef _ndarray_values(self):\n    return self._data",
                "def _format_native_types(self, na_rep=\"NaT\", date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                "def _formatter(self, boxed=False):\n    # TODO: Remove Datetime & DatetimeTZ formatters.\n    return \"'{}'\".format",
                "@property\ndef nbytes(self):\n    return self._data.nbytes",
                "def __array__(self, dtype=None):\n    # used for Timedelta/DatetimeArray, overwritten by PeriodArray\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                "def __len__(self) -> int:\n    return len(self._data)",
                "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and not is_int:\n        raise IndexError(\n            \"only integers, slices (`:`), ellipsis (`...`), \"\n            \"numpy.newaxis (`None`) and integer or boolean \"\n            \"arrays are valid indices\"\n        )\n\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        if lib.is_scalar(val):\n            # i.e. self.ndim == 1\n            return self._box_func(val)\n        return type(self)(val, dtype=self.dtype)\n\n    if com.is_bool_indexer(key):\n        key = check_bool_array_indexer(self, key)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            # GH#21282 indexing with Ellipsis is similar to a full slice,\n            #  should preserve `freq` attribute\n            freq = self.freq\n\n    result = getitem(key)\n    if result.ndim > 1:\n        # To support MPL which performs slicing with 2 dim\n        # even though it only has 1 dim by definition\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                "def __setitem__(\n    self,\n    key: Union[int, Sequence[int], Sequence[bool], slice],\n    value: Union[NaTType, Any, Sequence[Any]],\n) -> None:\n    # I'm fudging the types a bit here. \"Any\" above really depends\n    # on type(self). For PeriodArray, it's Period (or stuff coercible\n    # to a period in from_sequence). For DatetimeArray, it's Timestamp...\n    # I don't know if mypy can do that, possibly with Generics.\n    # https://mypy.readthedocs.io/en/latest/generics.html\n    if lib.is_scalar(value) and not isna(value):\n        value = com.maybe_box_datetimelike(value)\n\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n\n        if lib.is_scalar(key):\n            raise ValueError(\"setting an array element with a sequence.\")\n\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and not com.is_bool_indexer(key):\n                msg = (\n                    f\"shape mismatch: value array of length '{len(key)}' \"\n                    \"does not match indexing result of length \"\n                    f\"'{len(value)}'.\"\n                )\n                raise ValueError(msg)\n            elif not len(key):\n                return\n\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value, setitem=True)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value, setitem=True)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = (\n            f\"'value' should be a '{self._scalar_type.__name__}', 'NaT', \"\n            f\"or array of those. Got '{type(value).__name__}' instead.\"\n        )\n        raise TypeError(msg)\n    self._data[key] = value\n    self._maybe_clear_freq()",
                "def _maybe_clear_freq(self):\n    # inplace operations like __setitem__ may invalidate the freq of\n    # DatetimeArray and TimedeltaArray\n    pass",
                "def astype(self, dtype, copy=True):\n    # Some notes on cases we don't have to handle here in the base class:\n    #   1. PeriodArray.astype handles period -> period\n    #   2. DatetimeArray.astype handles conversion between tz.\n    #   3. DatetimeArray.astype handles datetime -> period\n    from pandas import Categorical\n\n    dtype = pandas_dtype(dtype)\n\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and not is_categorical_dtype(dtype):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        # we deliberately ignore int32 vs. int64 here.\n        # See https://github.com/pandas-dev/pandas/issues/24381 for more.\n        values = self.asi8\n\n        if is_unsigned_integer_dtype(dtype):\n            # Again, we ignore int32 vs. int64\n            values = values.view(\"uint64\")\n\n        if copy:\n            values = values.copy()\n        return values\n    elif (\n        is_datetime_or_timedelta_dtype(dtype)\n        and not is_dtype_equal(self.dtype, dtype)\n    ) or is_float_dtype(dtype):\n        # disallow conversion between datetime/timedelta,\n        # and conversions for any datetimelike to float\n        msg = f\"Cannot cast {type(self).__name__} to dtype {dtype}\"\n        raise TypeError(msg)\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    if isna(fill_value):\n        fill_value = iNaT\n    elif isinstance(fill_value, self._recognized_scalars):\n        self._check_compatible_with(fill_value)\n        fill_value = self._scalar_type(fill_value)\n        fill_value = self._unbox_scalar(fill_value)\n    else:\n        raise ValueError(\n            f\"'fill_value' should be a {self._scalar_type}. Got '{fill_value}'.\"\n        )\n    return fill_value",
                "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n\n    new_values = take(\n        self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value\n    )\n\n    return type(self)(new_values, dtype=self.dtype)",
                "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                "def _values_for_factorize(self):\n    return self.asi8, iNaT",
                "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                "def _values_for_argsort(self):\n    return self._data",
                "def searchsorted(self, value, side=\"left\", sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(f\"Unexpected type for 'value': {type(value)}\")\n\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view(\"i8\"), dtype=self.dtype)",
                "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n\n    cls = type(self)\n\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(\n        cls(result.index.view(\"i8\"), dtype=self.dtype), name=result.index.name\n    )\n    return Series(result.values, index=index, name=result.name)",
                "def map(self, mapper):\n    # TODO(GH-23179): Add ExtensionArray.map\n    # Need to figure out if we want ExtensionArray.map first.\n    # If so, then we can refactor IndexOpsMixin._map_values to\n    # a standalone function and call from here..\n    # Else, just rewrite _map_infer_values to do the right thing.\n    from pandas import Index\n\n    return Index(self).map(mapper).array",
                "def isna(self):\n    return self._isnan",
                "@property  # NB: override with cache_readonly in immutable subclasses\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                "@property  # NB: override with cache_readonly in immutable subclasses\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                "def fillna(self, value=None, method=None, limit=None):\n    # TODO(GH-20300): remove this\n    # Just overriding to ensure that we avoid an astype(object).\n    # Either 20300 or a `_values_for_fillna` would avoid this duplication.\n    if isinstance(value, ABCSeries):\n        value = value.array\n\n    value, method = validate_fillna_kwargs(value, method)\n\n    mask = self.isna()\n\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(\n                f\"Length of 'value' does not match. Got ({len(value)}) \"\n                f\" expected {len(self)}\"\n            )\n        value = value[mask]\n\n    if mask.any():\n        if method is not None:\n            if method == \"pad\":\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n\n            values = self._data\n            if not is_period_dtype(self):\n                # For PeriodArray self._data is i8, which gets copied\n                #  by `func`.  Otherwise we need to make a copy manually\n                # to avoid modifying `self` in-place.\n                values = values.copy()\n\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                # we need to pass int64 values to the constructor to avoid\n                #  re-localizing incorrectly\n                new_values = new_values.view(\"i8\")\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            # fill with value\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n\n    self._freq = value",
                "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                "@property  # NB: override with cache_readonly in immutable subclasses\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    if self.ndim != 1:\n        return None\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                "@property  # NB: override with cache_readonly in immutable subclasses\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                "@property  # NB: override with cache_readonly in immutable subclasses\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        # Frequency validation is not meaningful for Period Array/Index\n        return None\n\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n\n    try:\n        on_freq = cls._generate_range(\n            start=index[0], end=None, periods=len(index), freq=freq, **kwargs\n        )\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if \"non-fixed\" in str(e):\n            # non-fixed frequencies are not meaningful for timedelta64;\n            #  we retain that error message\n            raise e\n        # GH#11587 the main way this is reached is if the `np.array_equal`\n        #  check above is False.  This can also be reached if index[0]\n        #  is `NaT`, in which case the call to `cls._generate_range` will\n        #  raise a ValueError, which we re-raise with a more targeted\n        #  message.\n        raise ValueError(\n            f\"Inferred frequency {inferred} from passed values \"\n            f\"does not conform to passed frequency {freq.freqstr}\"\n        )",
                "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                "def _add_datetimelike_scalar(self, other):\n    # Overridden by TimedeltaArray\n    raise TypeError(f\"cannot add {type(self).__name__} and {type(other).__name__}\")",
                "def _sub_datetimelike_scalar(self, other):\n    # Overridden by DatetimeArray\n    assert other is not NaT\n    raise TypeError(f\"cannot subtract a datelike from a {type(self).__name__}\")",
                "def _sub_period(self, other):\n    # Overridden by PeriodArray\n    raise TypeError(f\"cannot subtract Period from a {type(self).__name__}\")",
                "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        # ndarray[timedelta64] or TimedeltaArray/index\n        new_values = self._add_delta_tdi(other)\n\n    return new_values",
                "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        # i.e np.timedelta64(\"NaT\"), not recognized by delta_to_nanoseconds\n        new_values = np.empty(self.shape, dtype=\"i8\")\n        new_values[:] = iNaT\n        return new_values\n\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view(\n        \"i8\"\n    )\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view(\"i8\")",
                "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError(\"cannot add indices of unequal length\")\n\n    if isinstance(other, np.ndarray):\n        # ndarray[timedelta64]; wrap in TimedeltaIndex for op\n        from pandas.core.arrays import TimedeltaArray\n\n        other = TimedeltaArray._from_sequence(other)\n\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(\n        self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan\n    )\n    if self._hasnans or other._hasnans:\n        mask = (self._isnan) | (other._isnan)\n        new_values[mask] = iNaT\n    return new_values.view(\"i8\")",
                "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(\n            f\"Cannot add {type(self).__name__} and {type(NaT).__name__}\"\n        )\n\n    # GH#19124 pd.NaT is treated like a timedelta for both timedelta\n    # and datetime dtypes\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    # GH#19124 Timedelta - datetime is not in general well-defined.\n    # We make an exception for pd.NaT, which in this case quacks\n    # like a timedelta.\n    # For datetime64 dtypes by convention we treat NaT as a datetime, so\n    # this subtraction returns a timedelta64 dtype.\n    # For period dtype, timedelta64 is a close-enough return dtype.\n    result = np.zeros(self.shape, dtype=np.int64)\n    result.fill(iNaT)\n    return result.view(\"timedelta64[ns]\")",
                "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(\n            f\"cannot subtract {other.dtype}-dtype from {type(self).__name__}\"\n        )\n\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(\n            cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr\n        )\n        raise IncompatibleFrequency(msg)\n\n    new_values = checked_add_with_arr(\n        self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan\n    )\n\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = (self._isnan) | (other._isnan)\n        new_values[mask] = NaT\n    return new_values",
                "def _addsub_object_array(self, other: np.ndarray, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : np.ndarray[object]\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n\n    warnings.warn(\n        \"Adding/subtracting array of DateOffsets to \"\n        f\"{type(self).__name__} not vectorized\",\n        PerformanceWarning,\n    )\n\n    # For EA self.astype('O') returns a numpy array, not an Index\n    left = self.astype(\"O\")\n\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs[\"freq\"] = \"infer\"\n    try:\n        res = type(self)._from_sequence(res_values, **kwargs)\n    except ValueError:\n        # e.g. we've passed a Timestamp to TimedeltaArray\n        res = res_values\n    return res",
                "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n\n    if periods == 0:\n        # immutable so OK\n        return self.copy()\n\n    if self.freq is None:\n        raise NullFrequencyError(\"Cannot shift with no freq\")\n\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n\n    # Note: in the DatetimeTZ case, _generate_range will infer the\n    #  appropriate timezone from `start` and `end`, so tz does not need\n    #  to be passed explicitly.\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                "@unpack_zerodim_and_defer(\"__add__\")\ndef __add__(self, other):\n\n    # scalar others\n    if other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        # specifically _not_ a Tick\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        # This check must come after the check for np.timedelta64\n        # as is_integer returns True for these\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(other)\n\n    # array-like others\n    elif is_timedelta64_dtype(other):\n        # TimedeltaIndex, ndarray[timedelta64]\n        result = self._add_delta(other)\n    elif is_object_dtype(other):\n        # e.g. Array/Index of DateOffset objects\n        result = self._addsub_object_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        # DatetimeIndex, ndarray[datetime64]\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        # Includes Categorical, other ExtensionArrays\n        # For PeriodDtype, if self is a TimedeltaArray and other is a\n        #  PeriodArray with  a timedelta-like (i.e. Tick) freq, this\n        #  operation is valid.  Defer to the PeriodArray implementation.\n        #  In remaining cases, this will end up raising TypeError.\n        return NotImplemented\n\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n\n        return TimedeltaArray(result)\n    return result",
                "def __radd__(self, other):\n    # alias for __add__\n    return self.__add__(other)",
                "@unpack_zerodim_and_defer(\"__sub__\")\ndef __sub__(self, other):\n\n    # scalar others\n    if other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        # specifically _not_ a Tick\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        # This check must come after the check for np.timedelta64\n        # as is_integer returns True for these\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._time_shift(-other)\n\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n\n    # array-like others\n    elif is_timedelta64_dtype(other):\n        # TimedeltaIndex, ndarray[timedelta64]\n        result = self._add_delta(-other)\n    elif is_object_dtype(other):\n        # e.g. Array/Index of DateOffset objects\n        result = self._addsub_object_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        # DatetimeIndex, ndarray[datetime64]\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        # PeriodIndex\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            raise integer_op_not_supported(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        # Includes ExtensionArrays, float_dtype\n        return NotImplemented\n\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n\n        return TimedeltaArray(result)\n    return result",
                "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        # ndarray[datetime64] cannot be subtracted from self, so\n        # we need to wrap in DatetimeArray/Index and flip the operation\n        if lib.is_scalar(other):\n            # i.e. np.datetime64 object\n            return Timestamp(other) - self\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            # Avoid down-casting DatetimeIndex\n            from pandas.core.arrays import DatetimeArray\n\n            other = DatetimeArray(other)\n        return other - self\n    elif (\n        is_datetime64_any_dtype(self.dtype)\n        and hasattr(other, \"dtype\")\n        and not is_datetime64_any_dtype(other.dtype)\n    ):\n        # GH#19959 datetime - datetime is well-defined as timedelta,\n        # but any other type - datetime is not well-defined.\n        raise TypeError(\n            f\"cannot subtract {type(self).__name__} from {type(other).__name__}\"\n        )\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        # TODO: Can we simplify/generalize these cases at all?\n        raise TypeError(f\"cannot subtract {type(self).__name__} from {other.dtype}\")\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            # need to subtract before negating, since that flips freq\n            # -self flips self.freq, messing up results\n            return -(self - other)\n\n        return (-self) + other\n\n    return -(self - other)",
                "def __iadd__(self, other):  # type: ignore\n    result = self + other\n    self[:] = result[:]\n\n    if not is_period_dtype(self):\n        # restore freq, which is invalidated by setitem\n        self._freq = result._freq\n    return self",
                "def __isub__(self, other):  # type: ignore\n    result = self - other\n    self[:] = result[:]\n\n    if not is_period_dtype(self):\n        # restore freq, which is invalidated by setitem\n        self._freq = result._freq\n    return self",
                "def _ensure_localized(\n    self, arg, ambiguous=\"raise\", nonexistent=\"raise\", from_utc=False\n):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n\n    # reconvert to local tz\n    tz = getattr(self, \"tz\", None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize(\"UTC\").tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(\n                self.tz, ambiguous=ambiguous, nonexistent=nonexistent\n            )\n    return arg",
                "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        # Period._from_ordinal does not handle np.nan gracefully\n        return NaT\n    return self._box_func(result)",
                "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    # TODO: skipna is broken with max.\n    # See https://github.com/pandas-dev/pandas/issues/24265\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n\n    if not len(values):\n        # short-circuit for empty max / min\n        return NaT\n\n    result = nanops.nanmax(values, skipna=skipna)\n    # Don't have to worry about NA `result`, since no NA went in.\n    return self._box_func(result)",
                "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        # See discussion in GH#24757\n        raise TypeError(\n            f\"mean is not implemented for {type(self).__name__} since the \"\n            \"meaning is ambiguous.  An alternative is \"\n            \"obj.to_timestamp(how='start').mean()\"\n        )\n\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n\n    if not len(values):\n        # short-circuit for empty max / min\n        return NaT\n\n    result = nanops.nanmean(values.view(\"i8\"), skipna=skipna)\n    # Don't have to worry about NA `result`, since no NA went in.\n    return self._box_func(result)"
            ],
            "inscope_function_signatures": [
                "_datetimelike_array_cmp(cls, op)",
                "validate_periods(periods)",
                "validate_endpoints(closed)",
                "validate_inferred_freq(freq, inferred_freq, freq_infer)",
                "maybe_infer_freq(freq)",
                "_ensure_datetimelike_to_i8(other, to_utc=False)",
                "wrapper(self, other)",
                "_simple_new(cls, values, **kwargs)",
                "_scalar_type(self) -> Type[DatetimeLikeScalar]",
                "_scalar_from_string(self, value: str) -> Union[Period, Timestamp, Timedelta, NaTType]",
                "_unbox_scalar(self, value: Union[Period, Timestamp, Timedelta, NaTType]) -> int",
                "_check_compatible_with(self, other: Union[Period, Timestamp, Timedelta, NaTType], setitem: bool=False) -> None",
                "strftime(self, date_format)",
                "_round(self, freq, mode, ambiguous, nonexistent)",
                "round(self, freq, ambiguous='raise', nonexistent='raise')",
                "floor(self, freq, ambiguous='raise', nonexistent='raise')",
                "ceil(self, freq, ambiguous='raise', nonexistent='raise')",
                "ndim(self) -> int",
                "shape(self)",
                "reshape(self, *args, **kwargs)",
                "ravel(self, *args, **kwargs)",
                "_box_func(self)",
                "_box_values(self, values)",
                "__iter__(self)",
                "asi8(self) -> np.ndarray",
                "_ndarray_values(self)",
                "_format_native_types(self, na_rep='NaT', date_format=None)",
                "_formatter(self, boxed=False)",
                "nbytes(self)",
                "__array__(self, dtype=None)",
                "size(self) -> int",
                "__len__(self) -> int",
                "__getitem__(self, key)",
                "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                "_maybe_clear_freq(self)",
                "astype(self, dtype, copy=True)",
                "view(self, dtype=None)",
                "unique(self)",
                "_validate_fill_value(self, fill_value)",
                "take(self, indices, allow_fill=False, fill_value=None)",
                "_concat_same_type(cls, to_concat)",
                "copy(self)",
                "_values_for_factorize(self)",
                "_from_factorized(cls, values, original)",
                "_values_for_argsort(self)",
                "searchsorted(self, value, side='left', sorter=None)",
                "repeat(self, repeats, *args, **kwargs)",
                "value_counts(self, dropna=False)",
                "map(self, mapper)",
                "isna(self)",
                "_isnan(self)",
                "_hasnans(self)",
                "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                "fillna(self, value=None, method=None, limit=None)",
                "freq(self)",
                "freq(self, value)",
                "freqstr(self)",
                "inferred_freq(self)",
                "_resolution(self)",
                "resolution(self)",
                "_validate_frequency(cls, index, freq, **kwargs)",
                "_is_monotonic_increasing(self)",
                "_is_monotonic_decreasing(self)",
                "_is_unique(self)",
                "_add_datetimelike_scalar(self, other)",
                "_sub_datetimelike_scalar(self, other)",
                "_sub_period(self, other)",
                "_add_offset(self, offset)",
                "_add_delta(self, other)",
                "_add_timedeltalike_scalar(self, other)",
                "_add_delta_tdi(self, other)",
                "_add_nat(self)",
                "_sub_nat(self)",
                "_sub_period_array(self, other)",
                "_addsub_object_array(self, other: np.ndarray, op)",
                "_time_shift(self, periods, freq=None)",
                "__add__(self, other)",
                "__radd__(self, other)",
                "__sub__(self, other)",
                "__rsub__(self, other)",
                "__iadd__(self, other)",
                "__isub__(self, other)",
                "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                "min(self, axis=None, skipna=True, *args, **kwargs)",
                "max(self, axis=None, skipna=True, *args, **kwargs)",
                "mean(self, skipna=True)"
            ],
            "variables_in_file": {
                "opname": [
                    126,
                    59,
                    60,
                    62
                ],
                "op.__name__": [
                    59
                ],
                "op": [
                    71,
                    103,
                    108,
                    1197,
                    79,
                    1199,
                    1457,
                    1458,
                    115,
                    84,
                    1459,
                    1210,
                    59,
                    95
                ],
                "nat_result": [
                    81,
                    122,
                    60,
                    119
                ],
                "isinstance": [
                    530,
                    1682,
                    1300,
                    672,
                    1443,
                    1316,
                    1318,
                    1321,
                    1069,
                    1711,
                    1330,
                    564,
                    65,
                    584,
                    73,
                    1354,
                    1103,
                    1237,
                    1367,
                    90,
                    859,
                    94,
                    745,
                    748,
                    752,
                    1264,
                    1266,
                    1269
                ],
                "other": [
                    1032,
                    1038,
                    1069,
                    1070,
                    1071,
                    1073,
                    1082,
                    1088,
                    65,
                    68,
                    71,
                    73,
                    74,
                    75,
                    1100,
                    77,
                    1103,
                    80,
                    83,
                    84,
                    1107,
                    86,
                    1110,
                    1112,
                    90,
                    1114,
                    92,
                    1115,
                    94,
                    95,
                    97,
                    103,
                    105,
                    107,
                    108,
                    112,
                    113,
                    115,
                    116,
                    1165,
                    1168,
                    1170,
                    1175,
                    1179,
                    1180,
                    1709,
                    1198,
                    1199,
                    1711,
                    1713,
                    1715,
                    1717,
                    1720,
                    1210,
                    1723,
                    1724,
                    1262,
                    1264,
                    1265,
                    1266,
                    1268,
                    1269,
                    1270,
                    1271,
                    1276,
                    1279,
                    1281,
                    1282,
                    1284,
                    1285,
                    1287,
                    1288,
                    1291,
                    1308,
                    1314,
                    1316,
                    1317,
                    1318,
                    1320,
                    1321,
                    1322,
                    1323,
                    1328,
                    1330,
                    1331,
                    1334,
                    1336,
                    1337,
                    1339,
                    1340,
                    1342,
                    1343,
                    1345,
                    1346,
                    1349,
                    1361,
                    1364,
                    1366,
                    1367,
                    1371,
                    1372,
                    1375,
                    1376,
                    1381,
                    1383,
                    1385,
                    1387,
                    1390,
                    1392,
                    1394,
                    1397,
                    1406
                ],
                "str": [
                    65,
                    745,
                    147,
                    1237,
                    982
                ],
                "self._scalar_from_string": [
                    746,
                    68
                ],
                "self": [
                    515,
                    516,
                    1540,
                    519,
                    1032,
                    1543,
                    1548,
                    525,
                    1550,
                    527,
                    1039,
                    1554,
                    531,
                    532,
                    1045,
                    534,
                    1048,
                    538,
                    1562,
                    545,
                    548,
                    1070,
                    1073,
                    1084,
                    1089,
                    68,
                    581,
                    582,
                    71,
                    584,
                    73,
                    74,
                    75,
                    585,
                    77,
                    586,
                    79,
                    587,
                    591,
                    1100,
                    595,
                    84,
                    596,
                    86,
                    1109,
                    1112,
                    1114,
                    1115,
                    94,
                    95,
                    1123,
                    613,
                    1125,
                    103,
                    615,
                    1130,
                    107,
                    108,
                    619,
                    1132,
                    112,
                    113,
                    115,
                    630,
                    1144,
                    121,
                    122,
                    634,
                    637,
                    639,
                    642,
                    643,
                    644,
                    650,
                    651,
                    1163,
                    1165,
                    144,
                    1168,
                    1170,
                    1175,
                    1178,
                    1179,
                    1180,
                    672,
                    673,
                    674,
                    675,
                    166,
                    678,
                    684,
                    687,
                    1199,
                    690,
                    1203,
                    1208,
                    185,
                    1212,
                    702,
                    703,
                    1215,
                    706,
                    713,
                    210,
                    1236,
                    1240,
                    1245,
                    1247,
                    1250,
                    1251,
                    1256,
                    746,
                    748,
                    751,
                    752,
                    1263,
                    1265,
                    755,
                    1268,
                    757,
                    1270,
                    1274,
                    1275,
                    1276,
                    768,
                    257,
                    769,
                    1281,
                    1284,
                    1287,
                    1289,
                    1290,
                    1291,
                    787,
                    789,
                    791,
                    795,
                    1308,
                    1315,
                    1317,
                    807,
                    1320,
                    1322,
                    813,
                    1326,
                    1327,
                    1328,
                    1331,
                    820,
                    1336,
                    827,
                    1339,
                    1342,
                    1345,
                    1347,
                    1348,
                    1349,
                    847,
                    1361,
                    852,
                    1366,
                    1372,
                    1374,
                    864,
                    867,
                    1381,
                    870,
                    1383,
                    1385,
                    1386,
                    1390,
                    1392,
                    881,
                    882,
                    371,
                    1394,
                    373,
                    1397,
                    375,
                    376,
                    889,
                    378,
                    379,
                    1092,
                    893,
                    1398,
                    1400,
                    384,
                    896,
                    1402,
                    899,
                    388,
                    1406,
                    1407,
                    1409,
                    392,
                    1411,
                    1412,
                    910,
                    1403,
                    916,
                    918,
                    409,
                    413,
                    925,
                    927,
                    417,
                    418,
                    1441,
                    1443,
                    1444,
                    422,
                    423,
                    936,
                    1446,
                    1449,
                    939,
                    430,
                    945,
                    1457,
                    436,
                    439,
                    952,
                    452,
                    1477,
                    456,
                    1481,
                    469,
                    1499,
                    1501,
                    480,
                    1505,
                    485,
                    486,
                    1001,
                    1513,
                    491,
                    1005,
                    494,
                    1009,
                    510
                ],
                "ValueError": [
                    1216,
                    577,
                    868,
                    677,
                    69,
                    940,
                    749,
                    1101,
                    980,
                    981,
                    87,
                    567,
                    1653,
                    1625,
                    991
                ],
                "invalid_comparison": [
                    108,
                    84,
                    95,
                    71
                ],
                "self._recognized_scalars": [
                    672,
                    73
                ],
                "NaT": [
                    1314,
                    1125,
                    1509,
                    1480,
                    73,
                    1038,
                    1262,
                    1552,
                    373,
                    1558,
                    1181,
                    1503
                ],
                "self._scalar_type": [
                    674,
                    678,
                    584,
                    74,
                    748,
                    591
                ],
                "self._check_compatible_with": [
                    673,
                    582,
                    585,
                    75,
                    751,
                    113
                ],
                "other_i8": [
                    1112,
                    77,
                    1110,
                    79
                ],
                "self._unbox_scalar": [
                    586,
                    675,
                    77,
                    755
                ],
                "result": [
                    257,
                    258,
                    1281,
                    1284,
                    1411,
                    1146,
                    650,
                    651,
                    1291,
                    1402,
                    1276,
                    1300,
                    1303,
                    1304,
                    793,
                    1560,
                    795,
                    540,
                    541,
                    797,
                    1562,
                    545,
                    546,
                    1315,
                    548,
                    1317,
                    1406,
                    1407,
                    1320,
                    1322,
                    1328,
                    1331,
                    1336,
                    1339,
                    1342,
                    1345,
                    1349,
                    1477,
                    1478,
                    1481,
                    1354,
                    1357,
                    1358,
                    79,
                    81,
                    849,
                    852,
                    853,
                    1240,
                    1241,
                    102,
                    1511,
                    1513,
                    1130,
                    1131,
                    1132,
                    1263,
                    1265,
                    115,
                    372,
                    373,
                    1268,
                    119,
                    1144,
                    1145,
                    122,
                    379,
                    124,
                    1270,
                    1397,
                    1398
                ],
                "self.view": [
                    115,
                    79
                ],
                "isna": [
                    1478,
                    105,
                    748,
                    1709,
                    80,
                    560,
                    1082,
                    670
                ],
                "result.fill": [
                    81,
                    1131,
                    1145
                ],
                "is_list_like": [
                    563,
                    83
                ],
                "len": [
                    578,
                    867,
                    1507,
                    869,
                    870,
                    1100,
                    494,
                    1198,
                    977,
                    1009,
                    1556,
                    86,
                    695,
                    571,
                    573,
                    575
                ],
                "list": [
                    696,
                    90,
                    485
                ],
                "np.array": [
                    485,
                    1178,
                    1720,
                    1210,
                    92
                ],
                "np": [
                    257,
                    130,
                    523,
                    1300,
                    1178,
                    1184,
                    1316,
                    1321,
                    1069,
                    1720,
                    698,
                    442,
                    1084,
                    1210,
                    1354,
                    1103,
                    851,
                    979,
                    92,
                    94,
                    101,
                    485,
                    1130,
                    491,
                    1264,
                    1269,
                    1144,
                    639
                ],
                "np.ndarray": [
                    1184,
                    130,
                    1354,
                    1103,
                    1300,
                    442,
                    94
                ],
                "type": [
                    769,
                    643,
                    516,
                    1543,
                    1032,
                    651,
                    1165,
                    1039,
                    1170,
                    1045,
                    791,
                    418,
                    1443,
                    423,
                    690,
                    1203,
                    703,
                    1215,
                    581,
                    592,
                    94,
                    1125,
                    1381,
                    1385,
                    107,
                    748,
                    749,
                    1132,
                    112,
                    752,
                    634,
                    893
                ],
                "is_object_dtype": [
                    97,
                    1282,
                    612,
                    484,
                    1337
                ],
                "np.errstate": [
                    101
                ],
                "ops.comp_method_OBJECT_ARRAY": [
                    102
                ],
                "ops": [
                    102
                ],
                "self.astype": [
                    1208,
                    103
                ],
                "object": [
                    258,
                    485,
                    103
                ],
                "o_mask": [
                    105,
                    116,
                    118,
                    119
                ],
                "_is_recognized_dtype": [
                    107
                ],
                "other.dtype": [
                    1376,
                    1385,
                    107,
                    1165
                ],
                "_from_sequence": [
                    112,
                    581,
                    1215
                ],
                "other.view": [
                    115
                ],
                "other._isnan": [
                    116,
                    1175,
                    1112,
                    1115,
                    1180
                ],
                "o_mask.any": [
                    118
                ],
                "self._hasnans": [
                    121,
                    1114,
                    1179,
                    847
                ],
                "self._isnan": [
                    1089,
                    1115,
                    813,
                    852,
                    1175,
                    1112,
                    122,
                    827,
                    1180
                ],
                "unpack_zerodim_and_defer": [
                    1258,
                    62,
                    1310
                ],
                "set_function_name": [
                    126
                ],
                "wrapper": [
                    126
                ],
                "cls": [
                    795,
                    710,
                    134,
                    967,
                    976,
                    791,
                    699,
                    126
                ],
                "_data": [
                    130,
                    787
                ],
                "AbstractMethodError": [
                    166,
                    134,
                    430,
                    144,
                    210,
                    469,
                    1048,
                    185
                ],
                "classmethod": [
                    708,
                    132,
                    692,
                    1013,
                    954
                ],
                "property": [
                    929,
                    454,
                    999,
                    136,
                    425,
                    488,
                    905,
                    1003,
                    815,
                    943,
                    1007,
                    947,
                    822,
                    407,
                    920,
                    441,
                    411,
                    478
                ],
                "Type": [
                    137
                ],
                "DatetimeLikeScalar": [
                    137
                ],
                "Union": [
                    168,
                    553,
                    552,
                    148,
                    188
                ],
                "Period": [
                    168,
                    188,
                    148,
                    1330
                ],
                "Timestamp": [
                    168,
                    188,
                    148,
                    1366
                ],
                "Timedelta": [
                    168,
                    188,
                    148
                ],
                "NaTType": [
                    168,
                    553,
                    188,
                    148
                ],
                "int": [
                    168,
                    489,
                    552,
                    493,
                    1591,
                    408
                ],
                "bool": [
                    552,
                    827,
                    188
                ],
                "self._format_native_types": [
                    257,
                    615
                ],
                "date_format": [
                    257
                ],
                "np.nan": [
                    257,
                    851
                ],
                "result.astype": [
                    849,
                    258
                ],
                "Substitution": [
                    218
                ],
                "_round_doc": [
                    266,
                    390,
                    382,
                    386
                ],
                "_round_example": [
                    382,
                    327
                ],
                "_floor_example": [
                    386,
                    341
                ],
                "_ceil_example": [
                    355,
                    390
                ],
                "values": [
                    768,
                    769,
                    1550,
                    1554,
                    787,
                    1556,
                    789,
                    1560,
                    793,
                    436,
                    698,
                    699,
                    702,
                    703,
                    710,
                    1501,
                    1505,
                    1507,
                    1511,
                    619,
                    623,
                    881,
                    626,
                    371,
                    372,
                    627,
                    886,
                    888
                ],
                "_ensure_datetimelike_to_i8": [
                    371
                ],
                "round_nsint64": [
                    372
                ],
                "mode": [
                    372
                ],
                "freq": [
                    384,
                    388,
                    392,
                    527,
                    912,
                    529,
                    1682,
                    532,
                    1684,
                    534,
                    1685,
                    1688,
                    1689,
                    538,
                    545,
                    548,
                    972,
                    977,
                    1236,
                    1237,
                    1238,
                    1239,
                    993,
                    372,
                    1652,
                    1656,
                    1658,
                    1659,
                    1662
                ],
                "self._maybe_mask_results": [
                    1092,
                    373
                ],
                "dtype": [
                    642,
                    644,
                    696,
                    699,
                    375,
                    610,
                    484,
                    612,
                    614,
                    616,
                    621,
                    629,
                    630,
                    631,
                    377,
                    634,
                    379,
                    636,
                    637,
                    639
                ],
                "self.dtype": [
                    769,
                    642,
                    643,
                    516,
                    651,
                    795,
                    545,
                    418,
                    548,
                    423,
                    690,
                    703,
                    581,
                    587,
                    1361,
                    1374,
                    1383,
                    1386,
                    1132,
                    630,
                    375,
                    893
                ],
                "is_datetime64tz_dtype": [
                    376,
                    889,
                    1340,
                    1285
                ],
                "self._ensure_localized": [
                    378
                ],
                "self._simple_new": [
                    545,
                    1444,
                    379,
                    548
                ],
                "ambiguous": [
                    384,
                    388,
                    392,
                    1449,
                    379
                ],
                "nonexistent": [
                    384,
                    388,
                    392,
                    1449,
                    379
                ],
                "self._round": [
                    384,
                    388,
                    392
                ],
                "RoundTo.NEAREST_HALF_EVEN": [
                    384
                ],
                "RoundTo": [
                    384,
                    388,
                    392
                ],
                "Appender": [
                    386,
                    390,
                    382
                ],
                "format": [
                    473,
                    386,
                    390,
                    382
                ],
                "RoundTo.MINUS_INFTY": [
                    388
                ],
                "RoundTo.PLUS_INFTY": [
                    392
                ],
                "ExtensionOpsMixin": [
                    395
                ],
                "AttributesMixin": [
                    395
                ],
                "ExtensionArray": [
                    395
                ],
                "self._data.ndim": [
                    409
                ],
                "self._data": [
                    480,
                    417,
                    768,
                    643,
                    452,
                    644,
                    422,
                    486,
                    456,
                    713,
                    494,
                    881,
                    595,
                    789,
                    409,
                    413,
                    510
                ],
                "self._data.shape": [
                    413
                ],
                "data": [
                    417,
                    418,
                    422,
                    423
                ],
                "self._data.reshape": [
                    417
                ],
                "args": [
                    417,
                    1474,
                    422,
                    1496,
                    767
                ],
                "kwargs": [
                    417,
                    1215,
                    1474,
                    422,
                    977,
                    1459,
                    1461,
                    1496,
                    1211,
                    1213,
                    767
                ],
                "self._data.ravel": [
                    422
                ],
                "lib.map_infer": [
                    436
                ],
                "lib": [
                    513,
                    1592,
                    523,
                    1323,
                    1387,
                    1709,
                    560,
                    436,
                    1364,
                    502,
                    503,
                    566,
                    1590,
                    1271
                ],
                "self._box_func": [
                    515,
                    1481,
                    1513,
                    436,
                    439,
                    1562
                ],
                "v": [
                    439
                ],
                "self.asi8": [
                    1089,
                    706,
                    1505,
                    613,
                    1477,
                    1001,
                    650,
                    619,
                    1005,
                    687,
                    1009,
                    820,
                    757,
                    1109,
                    439,
                    1175,
                    702
                ],
                "self._data.view": [
                    644,
                    452
                ],
                "self._data.nbytes": [
                    480
                ],
                "np.prod": [
                    491
                ],
                "self.shape": [
                    1144,
                    1130,
                    491,
                    1084
                ],
                "is_int": [
                    511,
                    502,
                    503
                ],
                "lib.is_integer": [
                    1387,
                    1323,
                    502,
                    1271,
                    1592
                ],
                "key": [
                    512,
                    518,
                    519,
                    520,
                    521,
                    523,
                    530,
                    531,
                    532,
                    535,
                    540,
                    564,
                    566,
                    570,
                    571,
                    573,
                    578,
                    595,
                    502,
                    503
                ],
                "lib.is_scalar": [
                    513,
                    1709,
                    560,
                    1364,
                    566,
                    503
                ],
                "IndexError": [
                    504
                ],
                "getitem": [
                    512,
                    540,
                    510
                ],
                "self._data.__getitem__": [
                    510
                ],
                "val": [
                    512,
                    513,
                    515,
                    516
                ],
                "com.is_bool_indexer": [
                    571,
                    518
                ],
                "com": [
                    561,
                    571,
                    518
                ],
                "check_bool_array_indexer": [
                    519
                ],
                "key.all": [
                    520
                ],
                "slice": [
                    552,
                    521,
                    530,
                    564
                ],
                "lib.maybe_booleans_to_slice": [
                    523
                ],
                "key.view": [
                    523
                ],
                "np.uint8": [
                    523
                ],
                "is_period": [
                    544,
                    525,
                    526
                ],
                "is_period_dtype": [
                    1409,
                    1123,
                    1347,
                    1540,
                    967,
                    1383,
                    1289,
                    1163,
                    525,
                    1326,
                    882,
                    1400,
                    1274,
                    1212,
                    1343
                ],
                "self.freq": [
                    1247,
                    1250,
                    1251,
                    1178,
                    1256,
                    527,
                    1168,
                    531,
                    532,
                    1236,
                    534,
                    927,
                    538,
                    925,
                    703
                ],
                "key.step": [
                    531,
                    532
                ],
                "Ellipsis": [
                    535
                ],
                "result.ndim": [
                    541
                ],
                "Sequence": [
                    552,
                    553,
                    570
                ],
                "Any": [
                    553
                ],
                "value": [
                    897,
                    914,
                    915,
                    916,
                    918,
                    560,
                    561,
                    563,
                    571,
                    575,
                    581,
                    582,
                    583,
                    584,
                    585,
                    586,
                    587,
                    588,
                    592,
                    595,
                    859,
                    860,
                    862,
                    866,
                    867,
                    869,
                    872,
                    745,
                    746,
                    748,
                    749,
                    751,
                    752,
                    753,
                    755,
                    757
                ],
                "com.maybe_box_datetimelike": [
                    561
                ],
                "is_slice": [
                    569,
                    564
                ],
                "cast": [
                    570
                ],
                "msg": [
                    577,
                    590,
                    1169,
                    594,
                    1172,
                    634,
                    635,
                    572
                ],
                "value.asi8": [
                    753,
                    583
                ],
                "is_valid_nat_for_dtype": [
                    587
                ],
                "iNaT": [
                    706,
                    1131,
                    588,
                    1710,
                    1085,
                    820,
                    1145,
                    1116,
                    829,
                    671
                ],
                "self._scalar_type.__name__": [
                    591
                ],
                "__name__": [
                    1125,
                    1381,
                    1543,
                    1032,
                    1385,
                    1165,
                    1039,
                    592,
                    1170,
                    1203,
                    1045,
                    634
                ],
                "TypeError": [
                    1124,
                    1380,
                    1542,
                    1032,
                    1385,
                    1164,
                    1039,
                    594,
                    1721,
                    1045,
                    1593,
                    635
                ],
                "self._maybe_clear_freq": [
                    596
                ],
                "pandas_dtype": [
                    610
                ],
                "self._box_values": [
                    613
                ],
                "is_string_dtype": [
                    614
                ],
                "is_categorical_dtype": [
                    636,
                    614
                ],
                "is_integer_dtype": [
                    616,
                    1288,
                    1346,
                    1387
                ],
                "is_unsigned_integer_dtype": [
                    621
                ],
                "values.view": [
                    1560,
                    769,
                    623
                ],
                "copy": [
                    625
                ],
                "values.copy": [
                    626,
                    886
                ],
                "is_datetime_or_timedelta_dtype": [
                    629
                ],
                "is_dtype_equal": [
                    630
                ],
                "is_float_dtype": [
                    631
                ],
                "Categorical": [
                    637
                ],
                "np.asarray": [
                    639
                ],
                "unique1d": [
                    1009,
                    650
                ],
                "fill_value": [
                    672,
                    673,
                    674,
                    675,
                    678,
                    680,
                    684,
                    687,
                    850,
                    851,
                    852,
                    670,
                    671
                ],
                "allow_fill": [
                    683,
                    687
                ],
                "self._validate_fill_value": [
                    684
                ],
                "new_values": [
                    896,
                    897,
                    899,
                    900,
                    1174,
                    1178,
                    1181,
                    1182,
                    686,
                    1070,
                    1073,
                    690,
                    1075,
                    1084,
                    1085,
                    1086,
                    1089,
                    1092,
                    1093,
                    1111,
                    1116,
                    1117,
                    888,
                    892,
                    893
                ],
                "take": [
                    686
                ],
                "indices": [
                    687
                ],
                "dtypes": [
                    696,
                    694,
                    695
                ],
                "x.dtype": [
                    694
                ],
                "x": [
                    698,
                    694,
                    1178
                ],
                "to_concat": [
                    698,
                    694
                ],
                "np.concatenate": [
                    698
                ],
                "x.asi8": [
                    698
                ],
                "self.asi8.copy": [
                    702
                ],
                "_simple_new": [
                    703
                ],
                "original.dtype": [
                    710
                ],
                "original": [
                    710
                ],
                "self.asi8.searchsorted": [
                    757
                ],
                "side": [
                    757
                ],
                "sorter": [
                    757
                ],
                "nv.validate_repeat": [
                    767
                ],
                "nv": [
                    1474,
                    1475,
                    1496,
                    1497,
                    767
                ],
                "self._data.repeat": [
                    768
                ],
                "repeats": [
                    768
                ],
                "dropna": [
                    793,
                    786
                ],
                "self.isna": [
                    864,
                    1477,
                    1548,
                    787,
                    1499
                ],
                "value_counts": [
                    793
                ],
                "index": [
                    971,
                    972,
                    977,
                    979,
                    794,
                    797
                ],
                "Index": [
                    794,
                    1723,
                    807
                ],
                "result.index.view": [
                    795
                ],
                "result.index": [
                    795
                ],
                "result.index.name": [
                    795
                ],
                "Series": [
                    797
                ],
                "result.values": [
                    797
                ],
                "result.name": [
                    797
                ],
                "array": [
                    807
                ],
                "map": [
                    807
                ],
                "mapper": [
                    807
                ],
                "self._isnan.any": [
                    827
                ],
                "convert": [
                    848,
                    849
                ],
                "ABCSeries": [
                    859
                ],
                "value.array": [
                    860
                ],
                "method": [
                    875,
                    876,
                    862
                ],
                "validate_fillna_kwargs": [
                    862
                ],
                "mask": [
                    864,
                    897,
                    1501,
                    872,
                    874,
                    1548,
                    1550,
                    1551,
                    1180,
                    1499,
                    888,
                    1115,
                    1116,
                    1181,
                    1502
                ],
                "is_array_like": [
                    866
                ],
                "mask.any": [
                    874,
                    1502,
                    1551
                ],
                "func": [
                    888,
                    877,
                    879
                ],
                "missing.pad_1d": [
                    877
                ],
                "missing": [
                    877,
                    879
                ],
                "missing.backfill_1d": [
                    879
                ],
                "limit": [
                    888
                ],
                "new_values.view": [
                    892,
                    1093,
                    1117
                ],
                "self.copy": [
                    896,
                    899,
                    1245
                ],
                "self._freq": [
                    1402,
                    918,
                    1411,
                    910
                ],
                "frequencies.to_offset": [
                    915,
                    1685,
                    1238
                ],
                "frequencies": [
                    939,
                    945,
                    915,
                    1685,
                    1238,
                    952
                ],
                "self._validate_frequency": [
                    916
                ],
                "freq.setter": [
                    912
                ],
                "self.freq.freqstr": [
                    927
                ],
                "self.ndim": [
                    936
                ],
                "frequencies.infer_freq": [
                    939
                ],
                "frequencies.Resolution.get_reso_from_freq": [
                    945
                ],
                "frequencies.Resolution": [
                    952,
                    945
                ],
                "self.freqstr": [
                    945,
                    1170
                ],
                "frequencies.Resolution.get_str": [
                    952
                ],
                "self._resolution": [
                    952
                ],
                "inferred": [
                    992,
                    971,
                    972
                ],
                "index.inferred_freq": [
                    971
                ],
                "index.size": [
                    972
                ],
                "freq.freqstr": [
                    1656,
                    993,
                    972
                ],
                "on_freq": [
                    976,
                    979
                ],
                "cls._generate_range": [
                    976
                ],
                "np.array_equal": [
                    979
                ],
                "index.asi8": [
                    979
                ],
                "on_freq.asi8": [
                    979
                ],
                "e": [
                    985,
                    982
                ],
                "algos.is_monotonic": [
                    1001,
                    1005
                ],
                "algos": [
                    1001,
                    1005
                ],
                "_create_comparison_method": [
                    1013
                ],
                "_datetimelike_array_cmp": [
                    1013
                ],
                "__pow__": [
                    1017
                ],
                "make_invalid_op": [
                    1024,
                    1025,
                    1026,
                    1027,
                    1028,
                    1017,
                    1018,
                    1019,
                    1020,
                    1021,
                    1022,
                    1023
                ],
                "__rpow__": [
                    1018
                ],
                "__mul__": [
                    1019
                ],
                "__rmul__": [
                    1020
                ],
                "__truediv__": [
                    1021
                ],
                "__rtruediv__": [
                    1022
                ],
                "__floordiv__": [
                    1023
                ],
                "__rfloordiv__": [
                    1024
                ],
                "__mod__": [
                    1025
                ],
                "__rmod__": [
                    1026
                ],
                "__divmod__": [
                    1027
                ],
                "__rdivmod__": [
                    1028
                ],
                "_add_datetime_arraylike": [
                    1034
                ],
                "_add_datetimelike_scalar": [
                    1034
                ],
                "_sub_datetime_arraylike": [
                    1041
                ],
                "_sub_datetimelike_scalar": [
                    1041
                ],
                "Tick": [
                    1264,
                    1316,
                    1069
                ],
                "timedelta": [
                    1264,
                    1316,
                    1069
                ],
                "np.timedelta64": [
                    1264,
                    1316,
                    1069
                ],
                "self._add_timedeltalike_scalar": [
                    1070
                ],
                "is_timedelta64_dtype": [
                    1383,
                    1354,
                    1386,
                    1071,
                    1361,
                    1300,
                    1334,
                    1279
                ],
                "self._add_delta_tdi": [
                    1073
                ],
                "np.empty": [
                    1084
                ],
                "inc": [
                    1088,
                    1089
                ],
                "delta_to_nanoseconds": [
                    1088
                ],
                "view": [
                    1720,
                    1089
                ],
                "checked_add_with_arr": [
                    1089,
                    1174,
                    1111
                ],
                "TimedeltaArray._from_sequence": [
                    1107
                ],
                "TimedeltaArray": [
                    1107,
                    1357,
                    1303
                ],
                "self_i8": [
                    1112,
                    1109
                ],
                "other.asi8": [
                    1724,
                    1110,
                    1175
                ],
                "other._hasnans": [
                    1114,
                    1179
                ],
                "np.zeros": [
                    1144,
                    1130
                ],
                "np.int64": [
                    1144,
                    1130
                ],
                "result.view": [
                    1146
                ],
                "other.freq": [
                    1168
                ],
                "DIFFERENT_FREQ.format": [
                    1169
                ],
                "DIFFERENT_FREQ": [
                    1169
                ],
                "other.freqstr": [
                    1170
                ],
                "IncompatibleFrequency": [
                    1172
                ],
                "self.freq.base": [
                    1178
                ],
                "operator.add": [
                    1291,
                    1284,
                    1197
                ],
                "operator": [
                    1284,
                    1349,
                    1291,
                    1197,
                    1339
                ],
                "operator.sub": [
                    1339,
                    1349,
                    1197
                ],
                "warnings.warn": [
                    1201
                ],
                "warnings": [
                    1201
                ],
                "PerformanceWarning": [
                    1204
                ],
                "left": [
                    1208,
                    1210
                ],
                "res_values": [
                    1218,
                    1210,
                    1215
                ],
                "res": [
                    1218,
                    1219,
                    1215
                ],
                "offset": [
                    1240,
                    1239
                ],
                "periods": [
                    1250,
                    1251,
                    1591,
                    1589,
                    1590,
                    1239,
                    1592,
                    1593,
                    1594,
                    1243
                ],
                "NullFrequencyError": [
                    1248
                ],
                "start": [
                    1256,
                    1250
                ],
                "end": [
                    1256,
                    1251
                ],
                "self._generate_range": [
                    1256
                ],
                "self._add_nat": [
                    1263
                ],
                "self._add_delta": [
                    1336,
                    1265,
                    1317,
                    1281
                ],
                "DateOffset": [
                    1266,
                    1318,
                    1682
                ],
                "self._add_offset": [
                    1320,
                    1268
                ],
                "datetime": [
                    1321,
                    1269
                ],
                "np.datetime64": [
                    1321,
                    1269
                ],
                "self._add_datetimelike_scalar": [
                    1270
                ],
                "integer_op_not_supported": [
                    1290,
                    1275,
                    1348,
                    1327
                ],
                "self._time_shift": [
                    1328,
                    1276
                ],
                "self._addsub_object_array": [
                    1339,
                    1284
                ],
                "is_datetime64_dtype": [
                    1340,
                    1285
                ],
                "self._add_datetime_arraylike": [
                    1287
                ],
                "self._addsub_int_array": [
                    1291,
                    1349
                ],
                "NotImplemented": [
                    1352,
                    1298
                ],
                "self.__add__": [
                    1308
                ],
                "self._sub_nat": [
                    1315
                ],
                "self._sub_datetimelike_scalar": [
                    1322
                ],
                "self._sub_period": [
                    1331
                ],
                "self._sub_datetime_arraylike": [
                    1342
                ],
                "self._sub_period_array": [
                    1345
                ],
                "is_datetime64_any_dtype": [
                    1376,
                    1361,
                    1374
                ],
                "DatetimeLikeArrayMixin": [
                    1711,
                    1565,
                    1367
                ],
                "DatetimeArray": [
                    1371
                ],
                "hasattr": [
                    1375
                ],
                "result._freq": [
                    1402,
                    1411
                ],
                "tz": [
                    1441,
                    1442
                ],
                "getattr": [
                    1441,
                    1457,
                    1713
                ],
                "arg": [
                    1443,
                    1444,
                    1446,
                    1448,
                    1451
                ],
                "from_utc": [
                    1445
                ],
                "tz_convert": [
                    1446
                ],
                "arg.tz_localize": [
                    1448,
                    1446
                ],
                "self.tz": [
                    1449,
                    1446
                ],
                "name": [
                    1457,
                    1461
                ],
                "skipna": [
                    1477,
                    1511,
                    1549,
                    1459,
                    1461,
                    1560,
                    1500
                ],
                "_reduce": [
                    1461
                ],
                "super": [
                    1461
                ],
                "nv.validate_min": [
                    1474
                ],
                "nv.validate_minmax_axis": [
                    1497,
                    1475
                ],
                "axis": [
                    1497,
                    1475
                ],
                "nanops.nanmin": [
                    1477
                ],
                "nanops": [
                    1560,
                    1477,
                    1511
                ],
                "nv.validate_max": [
                    1496
                ],
                "asi8": [
                    1501
                ],
                "nanops.nanmax": [
                    1511
                ],
                "nanops.nanmean": [
                    1560
                ],
                "DatetimeLikeArrayMixin._add_comparison_ops": [
                    1565
                ],
                "lib.is_float": [
                    1590
                ],
                "left_closed": [
                    1618,
                    1627,
                    1621,
                    1614
                ],
                "right_closed": [
                    1627,
                    1619,
                    1623,
                    1615
                ],
                "closed": [
                    1617,
                    1620,
                    1622
                ],
                "inferred_freq": [
                    1659,
                    1651,
                    1652,
                    1654
                ],
                "freq_infer": [
                    1681,
                    1687,
                    1689,
                    1660,
                    1662
                ],
                "ABCPeriodArray": [
                    1711
                ],
                "ABCIndexClass": [
                    1711
                ],
                "to_utc": [
                    1714
                ],
                "other.tz_convert": [
                    1715
                ],
                "other.tz_localize": [
                    1717
                ]
            },
            "filtered_variables_in_file": {
                "opname": [
                    126,
                    59,
                    60,
                    62
                ],
                "op.__name__": [
                    59
                ],
                "op": [
                    71,
                    103,
                    108,
                    1197,
                    79,
                    1199,
                    1457,
                    1458,
                    115,
                    84,
                    1459,
                    1210,
                    59,
                    95
                ],
                "nat_result": [
                    81,
                    122,
                    60,
                    119
                ],
                "other": [
                    1032,
                    1038,
                    1069,
                    1070,
                    1071,
                    1073,
                    1082,
                    1088,
                    65,
                    68,
                    71,
                    73,
                    74,
                    75,
                    1100,
                    77,
                    1103,
                    80,
                    83,
                    84,
                    1107,
                    86,
                    1110,
                    1112,
                    90,
                    1114,
                    92,
                    1115,
                    94,
                    95,
                    97,
                    103,
                    105,
                    107,
                    108,
                    112,
                    113,
                    115,
                    116,
                    1165,
                    1168,
                    1170,
                    1175,
                    1179,
                    1180,
                    1709,
                    1198,
                    1199,
                    1711,
                    1713,
                    1715,
                    1717,
                    1720,
                    1210,
                    1723,
                    1724,
                    1262,
                    1264,
                    1265,
                    1266,
                    1268,
                    1269,
                    1270,
                    1271,
                    1276,
                    1279,
                    1281,
                    1282,
                    1284,
                    1285,
                    1287,
                    1288,
                    1291,
                    1308,
                    1314,
                    1316,
                    1317,
                    1318,
                    1320,
                    1321,
                    1322,
                    1323,
                    1328,
                    1330,
                    1331,
                    1334,
                    1336,
                    1337,
                    1339,
                    1340,
                    1342,
                    1343,
                    1345,
                    1346,
                    1349,
                    1361,
                    1364,
                    1366,
                    1367,
                    1371,
                    1372,
                    1375,
                    1376,
                    1381,
                    1383,
                    1385,
                    1387,
                    1390,
                    1392,
                    1394,
                    1397,
                    1406
                ],
                "self._scalar_from_string": [
                    746,
                    68
                ],
                "self": [
                    515,
                    516,
                    1540,
                    519,
                    1032,
                    1543,
                    1548,
                    525,
                    1550,
                    527,
                    1039,
                    1554,
                    531,
                    532,
                    1045,
                    534,
                    1048,
                    538,
                    1562,
                    545,
                    548,
                    1070,
                    1073,
                    1084,
                    1089,
                    68,
                    581,
                    582,
                    71,
                    584,
                    73,
                    74,
                    75,
                    585,
                    77,
                    586,
                    79,
                    587,
                    591,
                    1100,
                    595,
                    84,
                    596,
                    86,
                    1109,
                    1112,
                    1114,
                    1115,
                    94,
                    95,
                    1123,
                    613,
                    1125,
                    103,
                    615,
                    1130,
                    107,
                    108,
                    619,
                    1132,
                    112,
                    113,
                    115,
                    630,
                    1144,
                    121,
                    122,
                    634,
                    637,
                    639,
                    642,
                    643,
                    644,
                    650,
                    651,
                    1163,
                    1165,
                    144,
                    1168,
                    1170,
                    1175,
                    1178,
                    1179,
                    1180,
                    672,
                    673,
                    674,
                    675,
                    166,
                    678,
                    684,
                    687,
                    1199,
                    690,
                    1203,
                    1208,
                    185,
                    1212,
                    702,
                    703,
                    1215,
                    706,
                    713,
                    210,
                    1236,
                    1240,
                    1245,
                    1247,
                    1250,
                    1251,
                    1256,
                    746,
                    748,
                    751,
                    752,
                    1263,
                    1265,
                    755,
                    1268,
                    757,
                    1270,
                    1274,
                    1275,
                    1276,
                    768,
                    257,
                    769,
                    1281,
                    1284,
                    1287,
                    1289,
                    1290,
                    1291,
                    787,
                    789,
                    791,
                    795,
                    1308,
                    1315,
                    1317,
                    807,
                    1320,
                    1322,
                    813,
                    1326,
                    1327,
                    1328,
                    1331,
                    820,
                    1336,
                    827,
                    1339,
                    1342,
                    1345,
                    1347,
                    1348,
                    1349,
                    847,
                    1361,
                    852,
                    1366,
                    1372,
                    1374,
                    864,
                    867,
                    1381,
                    870,
                    1383,
                    1385,
                    1386,
                    1390,
                    1392,
                    881,
                    882,
                    371,
                    1394,
                    373,
                    1397,
                    375,
                    376,
                    889,
                    378,
                    379,
                    1092,
                    893,
                    1398,
                    1400,
                    384,
                    896,
                    1402,
                    899,
                    388,
                    1406,
                    1407,
                    1409,
                    392,
                    1411,
                    1412,
                    910,
                    1403,
                    916,
                    918,
                    409,
                    413,
                    925,
                    927,
                    417,
                    418,
                    1441,
                    1443,
                    1444,
                    422,
                    423,
                    936,
                    1446,
                    1449,
                    939,
                    430,
                    945,
                    1457,
                    436,
                    439,
                    952,
                    452,
                    1477,
                    456,
                    1481,
                    469,
                    1499,
                    1501,
                    480,
                    1505,
                    485,
                    486,
                    1001,
                    1513,
                    491,
                    1005,
                    494,
                    1009,
                    510
                ],
                "invalid_comparison": [
                    108,
                    84,
                    95,
                    71
                ],
                "self._recognized_scalars": [
                    672,
                    73
                ],
                "NaT": [
                    1314,
                    1125,
                    1509,
                    1480,
                    73,
                    1038,
                    1262,
                    1552,
                    373,
                    1558,
                    1181,
                    1503
                ],
                "self._scalar_type": [
                    674,
                    678,
                    584,
                    74,
                    748,
                    591
                ],
                "self._check_compatible_with": [
                    673,
                    582,
                    585,
                    75,
                    751,
                    113
                ],
                "other_i8": [
                    1112,
                    77,
                    1110,
                    79
                ],
                "self._unbox_scalar": [
                    586,
                    675,
                    77,
                    755
                ],
                "result": [
                    257,
                    258,
                    1281,
                    1284,
                    1411,
                    1146,
                    650,
                    651,
                    1291,
                    1402,
                    1276,
                    1300,
                    1303,
                    1304,
                    793,
                    1560,
                    795,
                    540,
                    541,
                    797,
                    1562,
                    545,
                    546,
                    1315,
                    548,
                    1317,
                    1406,
                    1407,
                    1320,
                    1322,
                    1328,
                    1331,
                    1336,
                    1339,
                    1342,
                    1345,
                    1349,
                    1477,
                    1478,
                    1481,
                    1354,
                    1357,
                    1358,
                    79,
                    81,
                    849,
                    852,
                    853,
                    1240,
                    1241,
                    102,
                    1511,
                    1513,
                    1130,
                    1131,
                    1132,
                    1263,
                    1265,
                    115,
                    372,
                    373,
                    1268,
                    119,
                    1144,
                    1145,
                    122,
                    379,
                    124,
                    1270,
                    1397,
                    1398
                ],
                "self.view": [
                    115,
                    79
                ],
                "isna": [
                    1478,
                    105,
                    748,
                    1709,
                    80,
                    560,
                    1082,
                    670
                ],
                "result.fill": [
                    81,
                    1131,
                    1145
                ],
                "is_list_like": [
                    563,
                    83
                ],
                "np.array": [
                    485,
                    1178,
                    1720,
                    1210,
                    92
                ],
                "np": [
                    257,
                    130,
                    523,
                    1300,
                    1178,
                    1184,
                    1316,
                    1321,
                    1069,
                    1720,
                    698,
                    442,
                    1084,
                    1210,
                    1354,
                    1103,
                    851,
                    979,
                    92,
                    94,
                    101,
                    485,
                    1130,
                    491,
                    1264,
                    1269,
                    1144,
                    639
                ],
                "np.ndarray": [
                    1184,
                    130,
                    1354,
                    1103,
                    1300,
                    442,
                    94
                ],
                "is_object_dtype": [
                    97,
                    1282,
                    612,
                    484,
                    1337
                ],
                "np.errstate": [
                    101
                ],
                "ops.comp_method_OBJECT_ARRAY": [
                    102
                ],
                "ops": [
                    102
                ],
                "self.astype": [
                    1208,
                    103
                ],
                "o_mask": [
                    105,
                    116,
                    118,
                    119
                ],
                "_is_recognized_dtype": [
                    107
                ],
                "other.dtype": [
                    1376,
                    1385,
                    107,
                    1165
                ],
                "_from_sequence": [
                    112,
                    581,
                    1215
                ],
                "other.view": [
                    115
                ],
                "other._isnan": [
                    116,
                    1175,
                    1112,
                    1115,
                    1180
                ],
                "o_mask.any": [
                    118
                ],
                "self._hasnans": [
                    121,
                    1114,
                    1179,
                    847
                ],
                "self._isnan": [
                    1089,
                    1115,
                    813,
                    852,
                    1175,
                    1112,
                    122,
                    827,
                    1180
                ],
                "unpack_zerodim_and_defer": [
                    1258,
                    62,
                    1310
                ],
                "set_function_name": [
                    126
                ],
                "wrapper": [
                    126
                ],
                "cls": [
                    795,
                    710,
                    134,
                    967,
                    976,
                    791,
                    699,
                    126
                ],
                "_data": [
                    130,
                    787
                ],
                "AbstractMethodError": [
                    166,
                    134,
                    430,
                    144,
                    210,
                    469,
                    1048,
                    185
                ],
                "Type": [
                    137
                ],
                "DatetimeLikeScalar": [
                    137
                ],
                "Union": [
                    168,
                    553,
                    552,
                    148,
                    188
                ],
                "Period": [
                    168,
                    188,
                    148,
                    1330
                ],
                "Timestamp": [
                    168,
                    188,
                    148,
                    1366
                ],
                "Timedelta": [
                    168,
                    188,
                    148
                ],
                "NaTType": [
                    168,
                    553,
                    188,
                    148
                ],
                "self._format_native_types": [
                    257,
                    615
                ],
                "date_format": [
                    257
                ],
                "np.nan": [
                    257,
                    851
                ],
                "result.astype": [
                    849,
                    258
                ],
                "Substitution": [
                    218
                ],
                "_round_doc": [
                    266,
                    390,
                    382,
                    386
                ],
                "_round_example": [
                    382,
                    327
                ],
                "_floor_example": [
                    386,
                    341
                ],
                "_ceil_example": [
                    355,
                    390
                ],
                "values": [
                    768,
                    769,
                    1550,
                    1554,
                    787,
                    1556,
                    789,
                    1560,
                    793,
                    436,
                    698,
                    699,
                    702,
                    703,
                    710,
                    1501,
                    1505,
                    1507,
                    1511,
                    619,
                    623,
                    881,
                    626,
                    371,
                    372,
                    627,
                    886,
                    888
                ],
                "_ensure_datetimelike_to_i8": [
                    371
                ],
                "round_nsint64": [
                    372
                ],
                "mode": [
                    372
                ],
                "freq": [
                    384,
                    388,
                    392,
                    527,
                    912,
                    529,
                    1682,
                    532,
                    1684,
                    534,
                    1685,
                    1688,
                    1689,
                    538,
                    545,
                    548,
                    972,
                    977,
                    1236,
                    1237,
                    1238,
                    1239,
                    993,
                    372,
                    1652,
                    1656,
                    1658,
                    1659,
                    1662
                ],
                "self._maybe_mask_results": [
                    1092,
                    373
                ],
                "dtype": [
                    642,
                    644,
                    696,
                    699,
                    375,
                    610,
                    484,
                    612,
                    614,
                    616,
                    621,
                    629,
                    630,
                    631,
                    377,
                    634,
                    379,
                    636,
                    637,
                    639
                ],
                "self.dtype": [
                    769,
                    642,
                    643,
                    516,
                    651,
                    795,
                    545,
                    418,
                    548,
                    423,
                    690,
                    703,
                    581,
                    587,
                    1361,
                    1374,
                    1383,
                    1386,
                    1132,
                    630,
                    375,
                    893
                ],
                "is_datetime64tz_dtype": [
                    376,
                    889,
                    1340,
                    1285
                ],
                "self._ensure_localized": [
                    378
                ],
                "self._simple_new": [
                    545,
                    1444,
                    379,
                    548
                ],
                "ambiguous": [
                    384,
                    388,
                    392,
                    1449,
                    379
                ],
                "nonexistent": [
                    384,
                    388,
                    392,
                    1449,
                    379
                ],
                "self._round": [
                    384,
                    388,
                    392
                ],
                "RoundTo.NEAREST_HALF_EVEN": [
                    384
                ],
                "RoundTo": [
                    384,
                    388,
                    392
                ],
                "Appender": [
                    386,
                    390,
                    382
                ],
                "RoundTo.MINUS_INFTY": [
                    388
                ],
                "RoundTo.PLUS_INFTY": [
                    392
                ],
                "ExtensionOpsMixin": [
                    395
                ],
                "AttributesMixin": [
                    395
                ],
                "ExtensionArray": [
                    395
                ],
                "self._data.ndim": [
                    409
                ],
                "self._data": [
                    480,
                    417,
                    768,
                    643,
                    452,
                    644,
                    422,
                    486,
                    456,
                    713,
                    494,
                    881,
                    595,
                    789,
                    409,
                    413,
                    510
                ],
                "self._data.shape": [
                    413
                ],
                "data": [
                    417,
                    418,
                    422,
                    423
                ],
                "self._data.reshape": [
                    417
                ],
                "args": [
                    417,
                    1474,
                    422,
                    1496,
                    767
                ],
                "kwargs": [
                    417,
                    1215,
                    1474,
                    422,
                    977,
                    1459,
                    1461,
                    1496,
                    1211,
                    1213,
                    767
                ],
                "self._data.ravel": [
                    422
                ],
                "lib.map_infer": [
                    436
                ],
                "lib": [
                    513,
                    1592,
                    523,
                    1323,
                    1387,
                    1709,
                    560,
                    436,
                    1364,
                    502,
                    503,
                    566,
                    1590,
                    1271
                ],
                "self._box_func": [
                    515,
                    1481,
                    1513,
                    436,
                    439,
                    1562
                ],
                "v": [
                    439
                ],
                "self.asi8": [
                    1089,
                    706,
                    1505,
                    613,
                    1477,
                    1001,
                    650,
                    619,
                    1005,
                    687,
                    1009,
                    820,
                    757,
                    1109,
                    439,
                    1175,
                    702
                ],
                "self._data.view": [
                    644,
                    452
                ],
                "self._data.nbytes": [
                    480
                ],
                "np.prod": [
                    491
                ],
                "self.shape": [
                    1144,
                    1130,
                    491,
                    1084
                ],
                "is_int": [
                    511,
                    502,
                    503
                ],
                "lib.is_integer": [
                    1387,
                    1323,
                    502,
                    1271,
                    1592
                ],
                "key": [
                    512,
                    518,
                    519,
                    520,
                    521,
                    523,
                    530,
                    531,
                    532,
                    535,
                    540,
                    564,
                    566,
                    570,
                    571,
                    573,
                    578,
                    595,
                    502,
                    503
                ],
                "lib.is_scalar": [
                    513,
                    1709,
                    560,
                    1364,
                    566,
                    503
                ],
                "getitem": [
                    512,
                    540,
                    510
                ],
                "self._data.__getitem__": [
                    510
                ],
                "val": [
                    512,
                    513,
                    515,
                    516
                ],
                "com.is_bool_indexer": [
                    571,
                    518
                ],
                "com": [
                    561,
                    571,
                    518
                ],
                "check_bool_array_indexer": [
                    519
                ],
                "key.all": [
                    520
                ],
                "lib.maybe_booleans_to_slice": [
                    523
                ],
                "key.view": [
                    523
                ],
                "np.uint8": [
                    523
                ],
                "is_period": [
                    544,
                    525,
                    526
                ],
                "is_period_dtype": [
                    1409,
                    1123,
                    1347,
                    1540,
                    967,
                    1383,
                    1289,
                    1163,
                    525,
                    1326,
                    882,
                    1400,
                    1274,
                    1212,
                    1343
                ],
                "self.freq": [
                    1247,
                    1250,
                    1251,
                    1178,
                    1256,
                    527,
                    1168,
                    531,
                    532,
                    1236,
                    534,
                    927,
                    538,
                    925,
                    703
                ],
                "key.step": [
                    531,
                    532
                ],
                "result.ndim": [
                    541
                ],
                "Sequence": [
                    552,
                    553,
                    570
                ],
                "Any": [
                    553
                ],
                "value": [
                    897,
                    914,
                    915,
                    916,
                    918,
                    560,
                    561,
                    563,
                    571,
                    575,
                    581,
                    582,
                    583,
                    584,
                    585,
                    586,
                    587,
                    588,
                    592,
                    595,
                    859,
                    860,
                    862,
                    866,
                    867,
                    869,
                    872,
                    745,
                    746,
                    748,
                    749,
                    751,
                    752,
                    753,
                    755,
                    757
                ],
                "com.maybe_box_datetimelike": [
                    561
                ],
                "is_slice": [
                    569,
                    564
                ],
                "cast": [
                    570
                ],
                "msg": [
                    577,
                    590,
                    1169,
                    594,
                    1172,
                    634,
                    635,
                    572
                ],
                "value.asi8": [
                    753,
                    583
                ],
                "is_valid_nat_for_dtype": [
                    587
                ],
                "iNaT": [
                    706,
                    1131,
                    588,
                    1710,
                    1085,
                    820,
                    1145,
                    1116,
                    829,
                    671
                ],
                "self._scalar_type.__name__": [
                    591
                ],
                "self._maybe_clear_freq": [
                    596
                ],
                "pandas_dtype": [
                    610
                ],
                "self._box_values": [
                    613
                ],
                "is_string_dtype": [
                    614
                ],
                "is_categorical_dtype": [
                    636,
                    614
                ],
                "is_integer_dtype": [
                    616,
                    1288,
                    1346,
                    1387
                ],
                "is_unsigned_integer_dtype": [
                    621
                ],
                "values.view": [
                    1560,
                    769,
                    623
                ],
                "copy": [
                    625
                ],
                "values.copy": [
                    626,
                    886
                ],
                "is_datetime_or_timedelta_dtype": [
                    629
                ],
                "is_dtype_equal": [
                    630
                ],
                "is_float_dtype": [
                    631
                ],
                "Categorical": [
                    637
                ],
                "np.asarray": [
                    639
                ],
                "unique1d": [
                    1009,
                    650
                ],
                "fill_value": [
                    672,
                    673,
                    674,
                    675,
                    678,
                    680,
                    684,
                    687,
                    850,
                    851,
                    852,
                    670,
                    671
                ],
                "allow_fill": [
                    683,
                    687
                ],
                "self._validate_fill_value": [
                    684
                ],
                "new_values": [
                    896,
                    897,
                    899,
                    900,
                    1174,
                    1178,
                    1181,
                    1182,
                    686,
                    1070,
                    1073,
                    690,
                    1075,
                    1084,
                    1085,
                    1086,
                    1089,
                    1092,
                    1093,
                    1111,
                    1116,
                    1117,
                    888,
                    892,
                    893
                ],
                "take": [
                    686
                ],
                "indices": [
                    687
                ],
                "dtypes": [
                    696,
                    694,
                    695
                ],
                "x.dtype": [
                    694
                ],
                "x": [
                    698,
                    694,
                    1178
                ],
                "to_concat": [
                    698,
                    694
                ],
                "np.concatenate": [
                    698
                ],
                "x.asi8": [
                    698
                ],
                "self.asi8.copy": [
                    702
                ],
                "_simple_new": [
                    703
                ],
                "original.dtype": [
                    710
                ],
                "original": [
                    710
                ],
                "self.asi8.searchsorted": [
                    757
                ],
                "side": [
                    757
                ],
                "sorter": [
                    757
                ],
                "nv.validate_repeat": [
                    767
                ],
                "nv": [
                    1474,
                    1475,
                    1496,
                    1497,
                    767
                ],
                "self._data.repeat": [
                    768
                ],
                "repeats": [
                    768
                ],
                "dropna": [
                    793,
                    786
                ],
                "self.isna": [
                    864,
                    1477,
                    1548,
                    787,
                    1499
                ],
                "value_counts": [
                    793
                ],
                "index": [
                    971,
                    972,
                    977,
                    979,
                    794,
                    797
                ],
                "Index": [
                    794,
                    1723,
                    807
                ],
                "result.index.view": [
                    795
                ],
                "result.index": [
                    795
                ],
                "result.index.name": [
                    795
                ],
                "Series": [
                    797
                ],
                "result.values": [
                    797
                ],
                "result.name": [
                    797
                ],
                "array": [
                    807
                ],
                "mapper": [
                    807
                ],
                "self._isnan.any": [
                    827
                ],
                "convert": [
                    848,
                    849
                ],
                "ABCSeries": [
                    859
                ],
                "value.array": [
                    860
                ],
                "method": [
                    875,
                    876,
                    862
                ],
                "validate_fillna_kwargs": [
                    862
                ],
                "mask": [
                    864,
                    897,
                    1501,
                    872,
                    874,
                    1548,
                    1550,
                    1551,
                    1180,
                    1499,
                    888,
                    1115,
                    1116,
                    1181,
                    1502
                ],
                "is_array_like": [
                    866
                ],
                "mask.any": [
                    874,
                    1502,
                    1551
                ],
                "func": [
                    888,
                    877,
                    879
                ],
                "missing.pad_1d": [
                    877
                ],
                "missing": [
                    877,
                    879
                ],
                "missing.backfill_1d": [
                    879
                ],
                "limit": [
                    888
                ],
                "new_values.view": [
                    892,
                    1093,
                    1117
                ],
                "self.copy": [
                    896,
                    899,
                    1245
                ],
                "self._freq": [
                    1402,
                    918,
                    1411,
                    910
                ],
                "frequencies.to_offset": [
                    915,
                    1685,
                    1238
                ],
                "frequencies": [
                    939,
                    945,
                    915,
                    1685,
                    1238,
                    952
                ],
                "self._validate_frequency": [
                    916
                ],
                "freq.setter": [
                    912
                ],
                "self.freq.freqstr": [
                    927
                ],
                "self.ndim": [
                    936
                ],
                "frequencies.infer_freq": [
                    939
                ],
                "frequencies.Resolution.get_reso_from_freq": [
                    945
                ],
                "frequencies.Resolution": [
                    952,
                    945
                ],
                "self.freqstr": [
                    945,
                    1170
                ],
                "frequencies.Resolution.get_str": [
                    952
                ],
                "self._resolution": [
                    952
                ],
                "inferred": [
                    992,
                    971,
                    972
                ],
                "index.inferred_freq": [
                    971
                ],
                "index.size": [
                    972
                ],
                "freq.freqstr": [
                    1656,
                    993,
                    972
                ],
                "on_freq": [
                    976,
                    979
                ],
                "cls._generate_range": [
                    976
                ],
                "np.array_equal": [
                    979
                ],
                "index.asi8": [
                    979
                ],
                "on_freq.asi8": [
                    979
                ],
                "e": [
                    985,
                    982
                ],
                "algos.is_monotonic": [
                    1001,
                    1005
                ],
                "algos": [
                    1001,
                    1005
                ],
                "_create_comparison_method": [
                    1013
                ],
                "_datetimelike_array_cmp": [
                    1013
                ],
                "__pow__": [
                    1017
                ],
                "make_invalid_op": [
                    1024,
                    1025,
                    1026,
                    1027,
                    1028,
                    1017,
                    1018,
                    1019,
                    1020,
                    1021,
                    1022,
                    1023
                ],
                "__rpow__": [
                    1018
                ],
                "__mul__": [
                    1019
                ],
                "__rmul__": [
                    1020
                ],
                "__truediv__": [
                    1021
                ],
                "__rtruediv__": [
                    1022
                ],
                "__floordiv__": [
                    1023
                ],
                "__rfloordiv__": [
                    1024
                ],
                "__mod__": [
                    1025
                ],
                "__rmod__": [
                    1026
                ],
                "__divmod__": [
                    1027
                ],
                "__rdivmod__": [
                    1028
                ],
                "_add_datetime_arraylike": [
                    1034
                ],
                "_add_datetimelike_scalar": [
                    1034
                ],
                "_sub_datetime_arraylike": [
                    1041
                ],
                "_sub_datetimelike_scalar": [
                    1041
                ],
                "Tick": [
                    1264,
                    1316,
                    1069
                ],
                "timedelta": [
                    1264,
                    1316,
                    1069
                ],
                "np.timedelta64": [
                    1264,
                    1316,
                    1069
                ],
                "self._add_timedeltalike_scalar": [
                    1070
                ],
                "is_timedelta64_dtype": [
                    1383,
                    1354,
                    1386,
                    1071,
                    1361,
                    1300,
                    1334,
                    1279
                ],
                "self._add_delta_tdi": [
                    1073
                ],
                "np.empty": [
                    1084
                ],
                "inc": [
                    1088,
                    1089
                ],
                "delta_to_nanoseconds": [
                    1088
                ],
                "view": [
                    1720,
                    1089
                ],
                "checked_add_with_arr": [
                    1089,
                    1174,
                    1111
                ],
                "TimedeltaArray._from_sequence": [
                    1107
                ],
                "TimedeltaArray": [
                    1107,
                    1357,
                    1303
                ],
                "self_i8": [
                    1112,
                    1109
                ],
                "other.asi8": [
                    1724,
                    1110,
                    1175
                ],
                "other._hasnans": [
                    1114,
                    1179
                ],
                "np.zeros": [
                    1144,
                    1130
                ],
                "np.int64": [
                    1144,
                    1130
                ],
                "result.view": [
                    1146
                ],
                "other.freq": [
                    1168
                ],
                "DIFFERENT_FREQ.format": [
                    1169
                ],
                "DIFFERENT_FREQ": [
                    1169
                ],
                "other.freqstr": [
                    1170
                ],
                "IncompatibleFrequency": [
                    1172
                ],
                "self.freq.base": [
                    1178
                ],
                "operator.add": [
                    1291,
                    1284,
                    1197
                ],
                "operator": [
                    1284,
                    1349,
                    1291,
                    1197,
                    1339
                ],
                "operator.sub": [
                    1339,
                    1349,
                    1197
                ],
                "warnings.warn": [
                    1201
                ],
                "warnings": [
                    1201
                ],
                "PerformanceWarning": [
                    1204
                ],
                "left": [
                    1208,
                    1210
                ],
                "res_values": [
                    1218,
                    1210,
                    1215
                ],
                "res": [
                    1218,
                    1219,
                    1215
                ],
                "offset": [
                    1240,
                    1239
                ],
                "periods": [
                    1250,
                    1251,
                    1591,
                    1589,
                    1590,
                    1239,
                    1592,
                    1593,
                    1594,
                    1243
                ],
                "NullFrequencyError": [
                    1248
                ],
                "start": [
                    1256,
                    1250
                ],
                "end": [
                    1256,
                    1251
                ],
                "self._generate_range": [
                    1256
                ],
                "self._add_nat": [
                    1263
                ],
                "self._add_delta": [
                    1336,
                    1265,
                    1317,
                    1281
                ],
                "DateOffset": [
                    1266,
                    1318,
                    1682
                ],
                "self._add_offset": [
                    1320,
                    1268
                ],
                "datetime": [
                    1321,
                    1269
                ],
                "np.datetime64": [
                    1321,
                    1269
                ],
                "self._add_datetimelike_scalar": [
                    1270
                ],
                "integer_op_not_supported": [
                    1290,
                    1275,
                    1348,
                    1327
                ],
                "self._time_shift": [
                    1328,
                    1276
                ],
                "self._addsub_object_array": [
                    1339,
                    1284
                ],
                "is_datetime64_dtype": [
                    1340,
                    1285
                ],
                "self._add_datetime_arraylike": [
                    1287
                ],
                "self._addsub_int_array": [
                    1291,
                    1349
                ],
                "self.__add__": [
                    1308
                ],
                "self._sub_nat": [
                    1315
                ],
                "self._sub_datetimelike_scalar": [
                    1322
                ],
                "self._sub_period": [
                    1331
                ],
                "self._sub_datetime_arraylike": [
                    1342
                ],
                "self._sub_period_array": [
                    1345
                ],
                "is_datetime64_any_dtype": [
                    1376,
                    1361,
                    1374
                ],
                "DatetimeLikeArrayMixin": [
                    1711,
                    1565,
                    1367
                ],
                "DatetimeArray": [
                    1371
                ],
                "result._freq": [
                    1402,
                    1411
                ],
                "tz": [
                    1441,
                    1442
                ],
                "arg": [
                    1443,
                    1444,
                    1446,
                    1448,
                    1451
                ],
                "from_utc": [
                    1445
                ],
                "tz_convert": [
                    1446
                ],
                "arg.tz_localize": [
                    1448,
                    1446
                ],
                "self.tz": [
                    1449,
                    1446
                ],
                "name": [
                    1457,
                    1461
                ],
                "skipna": [
                    1477,
                    1511,
                    1549,
                    1459,
                    1461,
                    1560,
                    1500
                ],
                "_reduce": [
                    1461
                ],
                "nv.validate_min": [
                    1474
                ],
                "nv.validate_minmax_axis": [
                    1497,
                    1475
                ],
                "axis": [
                    1497,
                    1475
                ],
                "nanops.nanmin": [
                    1477
                ],
                "nanops": [
                    1560,
                    1477,
                    1511
                ],
                "nv.validate_max": [
                    1496
                ],
                "asi8": [
                    1501
                ],
                "nanops.nanmax": [
                    1511
                ],
                "nanops.nanmean": [
                    1560
                ],
                "DatetimeLikeArrayMixin._add_comparison_ops": [
                    1565
                ],
                "lib.is_float": [
                    1590
                ],
                "left_closed": [
                    1618,
                    1627,
                    1621,
                    1614
                ],
                "right_closed": [
                    1627,
                    1619,
                    1623,
                    1615
                ],
                "closed": [
                    1617,
                    1620,
                    1622
                ],
                "inferred_freq": [
                    1659,
                    1651,
                    1652,
                    1654
                ],
                "freq_infer": [
                    1681,
                    1687,
                    1689,
                    1660,
                    1662
                ],
                "ABCPeriodArray": [
                    1711
                ],
                "ABCIndexClass": [
                    1711
                ],
                "to_utc": [
                    1714
                ],
                "other.tz_convert": [
                    1715
                ],
                "other.tz_localize": [
                    1717
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_93/pandas/tests/indexes/period/test_indexing.py",
                "test_function": "test_where_invalid_dtypes",
                "test_function_code": "    def test_where_invalid_dtypes(self):\n        pi = period_range(\"20130101\", periods=5, freq=\"D\")\n\n        i2 = pi.copy()\n        i2 = pd.PeriodIndex([pd.NaT, pd.NaT] + pi[2:].tolist(), freq=\"D\")\n\n        with pytest.raises(TypeError, match=\"Where requires matching dtype\"):\n            pi.where(notna(i2), i2.asi8)\n\n        with pytest.raises(TypeError, match=\"Where requires matching dtype\"):\n            pi.where(notna(i2), i2.asi8.view(\"timedelta64[ns]\"))\n\n        with pytest.raises(TypeError, match=\"Where requires matching dtype\"):\n            pi.where(notna(i2), i2.to_timestamp(\"S\"))",
                "test_error": "Failed: DID NOT RAISE <class 'TypeError'>",
                "full_test_error": "self = <pandas.tests.indexes.period.test_indexing.TestWhere object at 0x118c041c0>\n\n    def test_where_invalid_dtypes(self):\n        pi = period_range(\"20130101\", periods=5, freq=\"D\")\n    \n        i2 = pi.copy()\n        i2 = pd.PeriodIndex([pd.NaT, pd.NaT] + pi[2:].tolist(), freq=\"D\")\n    \n        with pytest.raises(TypeError, match=\"Where requires matching dtype\"):\n>           pi.where(notna(i2), i2.asi8)\nE           Failed: DID NOT RAISE <class 'TypeError'>\n\npandas/tests/indexes/period/test_indexing.py:245: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            }
        ]
    }
}