{
    "pandas:3": {
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_3/pandas/core/series.py": {
            "buggy_functions": [
                {
                    "function_name": "to_timestamp",
                    "function_code": "def to_timestamp(self, freq=None, how=\"start\", copy=True) -> \"Series\":\n    \"\"\"\n    Cast to DatetimeIndex of Timestamps, at *beginning* of period.\n\n    Parameters\n    ----------\n    freq : str, default frequency of PeriodIndex\n        Desired frequency.\n    how : {'s', 'e', 'start', 'end'}\n        Convention for converting period to timestamp; start of period\n        vs. end.\n    copy : bool, default True\n        Whether or not to return a copy.\n\n    Returns\n    -------\n    Series with DatetimeIndex\n    \"\"\"\n    new_values = self._values\n    if copy:\n        new_values = new_values.copy()\n\n    assert isinstance(self.index, PeriodIndex)\n    new_index = self.index.to_timestamp(freq=freq, how=how)  # type: ignore\n    return self._constructor(new_values, index=new_index).__finalize__(\n        self, method=\"to_timestamp\"\n    )\n",
                    "decorators": [],
                    "docstring": "Cast to DatetimeIndex of Timestamps, at *beginning* of period.\n\nParameters\n----------\nfreq : str, default frequency of PeriodIndex\n    Desired frequency.\nhow : {'s', 'e', 'start', 'end'}\n    Convention for converting period to timestamp; start of period\n    vs. end.\ncopy : bool, default True\n    Whether or not to return a copy.\n\nReturns\n-------\nSeries with DatetimeIndex",
                    "start_line": 4665,
                    "variables": {
                        "new_values": [
                            4689,
                            4683,
                            4685
                        ],
                        "self._values": [
                            4683
                        ],
                        "self": [
                            4683,
                            4687,
                            4688,
                            4689,
                            4690
                        ],
                        "copy": [
                            4684
                        ],
                        "new_values.copy": [
                            4685
                        ],
                        "isinstance": [
                            4687
                        ],
                        "self.index": [
                            4688,
                            4687
                        ],
                        "PeriodIndex": [
                            4687
                        ],
                        "new_index": [
                            4688,
                            4689
                        ],
                        "self.index.to_timestamp": [
                            4688
                        ],
                        "freq": [
                            4688
                        ],
                        "how": [
                            4688
                        ],
                        "__finalize__": [
                            4689
                        ],
                        "self._constructor": [
                            4689
                        ]
                    },
                    "filtered_variables": {
                        "new_values": [
                            4689,
                            4683,
                            4685
                        ],
                        "self._values": [
                            4683
                        ],
                        "self": [
                            4683,
                            4687,
                            4688,
                            4689,
                            4690
                        ],
                        "copy": [
                            4684
                        ],
                        "new_values.copy": [
                            4685
                        ],
                        "self.index": [
                            4688,
                            4687
                        ],
                        "PeriodIndex": [
                            4687
                        ],
                        "new_index": [
                            4688,
                            4689
                        ],
                        "self.index.to_timestamp": [
                            4688
                        ],
                        "freq": [
                            4688
                        ],
                        "how": [
                            4688
                        ],
                        "__finalize__": [
                            4689
                        ],
                        "self._constructor": [
                            4689
                        ]
                    },
                    "diff_line_number": 4687,
                    "class_data": {
                        "signature": "class Series(base.IndexOpsMixin, generic.NDFrame)",
                        "docstring": "One-dimensional ndarray with axis labels (including time series).\n\nLabels need not be unique but must be a hashable type. The object\nsupports both integer- and label-based indexing and provides a host of\nmethods for performing operations involving the index. Statistical\nmethods from ndarray have been overridden to automatically exclude\nmissing data (currently represented as NaN).\n\nOperations between Series (+, -, /, *, **) align values based on their\nassociated index values-- they need not be the same length. The result\nindex will be the sorted union of the two indexes.\n\nParameters\n----------\ndata : array-like, Iterable, dict, or scalar value\n    Contains data stored in Series.\n\n    .. versionchanged:: 0.23.0\n       If data is a dict, argument order is maintained for Python 3.6\n       and later.\n\nindex : array-like or Index (1d)\n    Values must be hashable and have the same length as `data`.\n    Non-unique index values are allowed. Will default to\n    RangeIndex (0, 1, 2, ..., n) if not provided. If both a dict and index\n    sequence are used, the index will override the keys found in the\n    dict.\ndtype : str, numpy.dtype, or ExtensionDtype, optional\n    Data type for the output Series. If not specified, this will be\n    inferred from `data`.\n    See the :ref:`user guide <basics.dtypes>` for more usages.\nname : str, optional\n    The name to give to the Series.\ncopy : bool, default False\n    Copy input data.",
                        "constructor_docstring": null,
                        "functions": [
                            "def __init__(self, data=None, index=None, dtype=None, name=None, copy=False, fastpath=False):\n    if isinstance(data, SingleBlockManager) and index is None and (dtype is None) and (copy is False):\n        NDFrame.__init__(self, data)\n        self.name = name\n        return\n    if fastpath:\n        if not isinstance(data, SingleBlockManager):\n            data = SingleBlockManager.from_array(data, index)\n        if copy:\n            data = data.copy()\n        if index is None:\n            index = data.index\n    else:\n        name = ibase.maybe_extract_name(name, data, type(self))\n        if is_empty_data(data) and dtype is None:\n            warnings.warn(\"The default dtype for empty Series will be 'object' instead of 'float64' in a future version. Specify a dtype explicitly to silence this warning.\", DeprecationWarning, stacklevel=2)\n        if index is not None:\n            index = ensure_index(index)\n        if data is None:\n            data = {}\n        if dtype is not None:\n            dtype = self._validate_dtype(dtype)\n        if isinstance(data, MultiIndex):\n            raise NotImplementedError('initializing a Series from a MultiIndex is not supported')\n        elif isinstance(data, Index):\n            if dtype is not None:\n                data = data.astype(dtype)\n            else:\n                data = data._values.copy()\n            copy = False\n        elif isinstance(data, np.ndarray):\n            if len(data.dtype):\n                raise ValueError('Cannot construct a Series from an ndarray with compound dtype.  Use DataFrame instead.')\n        elif isinstance(data, Series):\n            if index is None:\n                index = data.index\n            else:\n                data = data.reindex(index, copy=copy)\n                copy = False\n            data = data._mgr\n        elif is_dict_like(data):\n            data, index = self._init_dict(data, index, dtype)\n            dtype = None\n            copy = False\n        elif isinstance(data, SingleBlockManager):\n            if index is None:\n                index = data.index\n            elif not data.index.equals(index) or copy:\n                raise AssertionError('Cannot pass both SingleBlockManager `data` argument and a different `index` argument. `copy` must be False.')\n        elif is_extension_array_dtype(data):\n            pass\n        elif isinstance(data, (set, frozenset)):\n            raise TypeError(f\"'{type(data).__name__}' type is unordered\")\n        else:\n            data = com.maybe_iterable_to_list(data)\n        if index is None:\n            if not is_list_like(data):\n                data = [data]\n            index = ibase.default_index(len(data))\n        elif is_list_like(data):\n            try:\n                if len(index) != len(data):\n                    raise ValueError(f'Length of passed values is {len(data)}, index implies {len(index)}.')\n            except TypeError:\n                pass\n        if isinstance(data, SingleBlockManager):\n            if dtype is not None:\n                data = data.astype(dtype=dtype, errors='ignore', copy=copy)\n            elif copy:\n                data = data.copy()\n        else:\n            data = sanitize_array(data, index, dtype, copy, raise_cast_failure=True)\n            data = SingleBlockManager.from_array(data, index)\n    generic.NDFrame.__init__(self, data)\n    self.name = name\n    self._set_axis(0, index, fastpath=True)",
                            "def _init_dict(self, data, index=None, dtype=None):\n    \"\"\"\n    Derive the \"_mgr\" and \"index\" attributes of a new Series from a\n    dictionary input.\n\n    Parameters\n    ----------\n    data : dict or dict-like\n        Data used to populate the new Series.\n    index : Index or index-like, default None\n        Index for the new Series: if None, use dict keys.\n    dtype : dtype, default None\n        The dtype for the new Series: if None, infer from data.\n\n    Returns\n    -------\n    _data : BlockManager for the new Series\n    index : index for the new Series\n    \"\"\"\n    if data:\n        keys, values = zip(*data.items())\n        values = list(values)\n    elif index is not None:\n        values = na_value_for_dtype(dtype)\n        keys = index\n    else:\n        keys, values = ([], [])\n    s = create_series_with_explicit_dtype(values, index=keys, dtype=dtype, dtype_if_empty=np.float64)\n    if data and index is not None:\n        s = s.reindex(index, copy=False)\n    return (s._mgr, s.index)",
                            "@property\ndef _constructor(self) -> Type['Series']:\n    return Series",
                            "@property\ndef _constructor_expanddim(self) -> Type['DataFrame']:\n    from pandas.core.frame import DataFrame\n    return DataFrame",
                            "@property\ndef _can_hold_na(self):\n    return self._mgr._can_hold_na",
                            "def _set_axis(self, axis: int, labels, fastpath: bool=False) -> None:\n    \"\"\"\n    Override generic, we want to set the _typ here.\n\n    This is called from the cython code when we set the `index` attribute\n    directly, e.g. `series.index = [1, 2, 3]`.\n    \"\"\"\n    if not fastpath:\n        labels = ensure_index(labels)\n    is_all_dates = labels.is_all_dates\n    if is_all_dates:\n        if not isinstance(labels, (DatetimeIndex, PeriodIndex, TimedeltaIndex)):\n            try:\n                labels = DatetimeIndex(labels)\n                if fastpath:\n                    self._mgr.set_axis(axis, labels)\n            except (tslibs.OutOfBoundsDatetime, ValueError):\n                pass\n    object.__setattr__(self, '_index', labels)\n    if not fastpath:\n        self._mgr.set_axis(axis, labels)",
                            "@property\ndef dtype(self) -> DtypeObj:\n    \"\"\"\n    Return the dtype object of the underlying data.\n    \"\"\"\n    return self._mgr.dtype",
                            "@property\ndef dtypes(self) -> DtypeObj:\n    \"\"\"\n    Return the dtype object of the underlying data.\n    \"\"\"\n    return self.dtype",
                            "@property\ndef name(self) -> Label:\n    \"\"\"\n    Return the name of the Series.\n\n    The name of a Series becomes its index or column name if it is used\n    to form a DataFrame. It is also used whenever displaying the Series\n    using the interpreter.\n\n    Returns\n    -------\n    label (hashable object)\n        The name of the Series, also the column name if part of a DataFrame.\n\n    See Also\n    --------\n    Series.rename : Sets the Series name when given a scalar input.\n    Index.name : Corresponding Index property.\n\n    Examples\n    --------\n    The Series name can be set initially when calling the constructor.\n\n    >>> s = pd.Series([1, 2, 3], dtype=np.int64, name='Numbers')\n    >>> s\n    0    1\n    1    2\n    2    3\n    Name: Numbers, dtype: int64\n    >>> s.name = \"Integers\"\n    >>> s\n    0    1\n    1    2\n    2    3\n    Name: Integers, dtype: int64\n\n    The name of a Series within a DataFrame is its column name.\n\n    >>> df = pd.DataFrame([[1, 2], [3, 4], [5, 6]],\n    ...                   columns=[\"Odd Numbers\", \"Even Numbers\"])\n    >>> df\n       Odd Numbers  Even Numbers\n    0            1             2\n    1            3             4\n    2            5             6\n    >>> df[\"Even Numbers\"].name\n    'Even Numbers'\n    \"\"\"\n    return self._name",
                            "@name.setter\ndef name(self, value: Label) -> None:\n    if not is_hashable(value):\n        raise TypeError('Series.name must be a hashable type')\n    object.__setattr__(self, '_name', value)",
                            "@property\ndef values(self):\n    \"\"\"\n    Return Series as ndarray or ndarray-like depending on the dtype.\n\n    .. warning::\n\n       We recommend using :attr:`Series.array` or\n       :meth:`Series.to_numpy`, depending on whether you need\n       a reference to the underlying data or a NumPy array.\n\n    Returns\n    -------\n    numpy.ndarray or ndarray-like\n\n    See Also\n    --------\n    Series.array : Reference to the underlying data.\n    Series.to_numpy : A NumPy array representing the underlying data.\n\n    Examples\n    --------\n    >>> pd.Series([1, 2, 3]).values\n    array([1, 2, 3])\n\n    >>> pd.Series(list('aabc')).values\n    array(['a', 'a', 'b', 'c'], dtype=object)\n\n    >>> pd.Series(list('aabc')).astype('category').values\n    [a, a, b, c]\n    Categories (3, object): [a, b, c]\n\n    Timezone aware datetime data is converted to UTC:\n\n    >>> pd.Series(pd.date_range('20130101', periods=3,\n    ...                         tz='US/Eastern')).values\n    array(['2013-01-01T05:00:00.000000000',\n           '2013-01-02T05:00:00.000000000',\n           '2013-01-03T05:00:00.000000000'], dtype='datetime64[ns]')\n    \"\"\"\n    return self._mgr.external_values()",
                            "@property\ndef _values(self):\n    \"\"\"\n    Return the internal repr of this data (defined by Block.interval_values).\n    This are the values as stored in the Block (ndarray or ExtensionArray\n    depending on the Block class), with datetime64[ns] and timedelta64[ns]\n    wrapped in ExtensionArrays to match Index._values behavior.\n\n    Differs from the public ``.values`` for certain data types, because of\n    historical backwards compatibility of the public attribute (e.g. period\n    returns object ndarray and datetimetz a datetime64[ns] ndarray for\n    ``.values`` while it returns an ExtensionArray for ``._values`` in those\n    cases).\n\n    Differs from ``.array`` in that this still returns the numpy array if\n    the Block is backed by a numpy array (except for datetime64 and\n    timedelta64 dtypes), while ``.array`` ensures to always return an\n    ExtensionArray.\n\n    Overview:\n\n    dtype       | values        | _values       | array         |\n    ----------- | ------------- | ------------- | ------------- |\n    Numeric     | ndarray       | ndarray       | PandasArray   |\n    Category    | Categorical   | Categorical   | Categorical   |\n    dt64[ns]    | ndarray[M8ns] | DatetimeArray | DatetimeArray |\n    dt64[ns tz] | ndarray[M8ns] | DatetimeArray | DatetimeArray |\n    td64[ns]    | ndarray[m8ns] | TimedeltaArray| ndarray[m8ns] |\n    Period      | ndarray[obj]  | PeriodArray   | PeriodArray   |\n    Nullable    | EA            | EA            | EA            |\n\n    \"\"\"\n    return self._mgr.internal_values()",
                            "@Appender(base.IndexOpsMixin.array.__doc__)\n@property\ndef array(self) -> ExtensionArray:\n    return self._mgr._block.array_values()",
                            "def ravel(self, order='C'):\n    \"\"\"\n    Return the flattened underlying data as an ndarray.\n\n    Returns\n    -------\n    numpy.ndarray or ndarray-like\n        Flattened data of the Series.\n\n    See Also\n    --------\n    numpy.ndarray.ravel : Return a flattened array.\n    \"\"\"\n    return self._values.ravel(order=order)",
                            "def __len__(self) -> int:\n    \"\"\"\n    Return the length of the Series.\n    \"\"\"\n    return len(self._mgr)",
                            "def view(self, dtype=None) -> 'Series':\n    \"\"\"\n    Create a new view of the Series.\n\n    This function will return a new Series with a view of the same\n    underlying values in memory, optionally reinterpreted with a new data\n    type. The new data type must preserve the same size in bytes as to not\n    cause index misalignment.\n\n    Parameters\n    ----------\n    dtype : data type\n        Data type object or one of their string representations.\n\n    Returns\n    -------\n    Series\n        A new Series object as a view of the same data in memory.\n\n    See Also\n    --------\n    numpy.ndarray.view : Equivalent numpy function to create a new view of\n        the same data in memory.\n\n    Notes\n    -----\n    Series are instantiated with ``dtype=float64`` by default. While\n    ``numpy.ndarray.view()`` will return a view with the same data type as\n    the original array, ``Series.view()`` (without specified dtype)\n    will try using ``float64`` and may fail if the original data type size\n    in bytes is not the same.\n\n    Examples\n    --------\n    >>> s = pd.Series([-2, -1, 0, 1, 2], dtype='int8')\n    >>> s\n    0   -2\n    1   -1\n    2    0\n    3    1\n    4    2\n    dtype: int8\n\n    The 8 bit signed integer representation of `-1` is `0b11111111`, but\n    the same bytes represent 255 if read as an 8 bit unsigned integer:\n\n    >>> us = s.view('uint8')\n    >>> us\n    0    254\n    1    255\n    2      0\n    3      1\n    4      2\n    dtype: uint8\n\n    The views share the same underlying values:\n\n    >>> us[0] = 128\n    >>> s\n    0   -128\n    1     -1\n    2      0\n    3      1\n    4      2\n    dtype: int8\n    \"\"\"\n    return self._constructor(self._values.view(dtype), index=self.index).__finalize__(self, method='view')",
                            "def __array_ufunc__(self, ufunc: Callable, method: str, *inputs: Any, **kwargs: Any):\n    cls = type(self)\n    result = ops.maybe_dispatch_ufunc_to_dunder_op(self, ufunc, method, *inputs, **kwargs)\n    if result is not NotImplemented:\n        return result\n    no_defer = (np.ndarray.__array_ufunc__, cls.__array_ufunc__)\n    for item in inputs:\n        higher_priority = hasattr(item, '__array_priority__') and item.__array_priority__ > self.__array_priority__\n        has_array_ufunc = hasattr(item, '__array_ufunc__') and type(item).__array_ufunc__ not in no_defer and (not isinstance(item, self._HANDLED_TYPES))\n        if higher_priority or has_array_ufunc:\n            return NotImplemented\n    names = [getattr(x, 'name') for x in inputs if hasattr(x, 'name')]\n    types = tuple((type(x) for x in inputs))\n    alignable = [x for x, t in zip(inputs, types) if issubclass(t, Series)]\n    if len(alignable) > 1:\n        index = alignable[0].index\n        for s in alignable[1:]:\n            index |= s.index\n        inputs = tuple((x.reindex(index) if issubclass(t, Series) else x for x, t in zip(inputs, types)))\n    else:\n        index = self.index\n    inputs = tuple((extract_array(x, extract_numpy=True) for x in inputs))\n    result = getattr(ufunc, method)(*inputs, **kwargs)\n    name = names[0] if len(set(names)) == 1 else None\n\n    def construct_return(result):\n        if lib.is_scalar(result):\n            return result\n        elif result.ndim > 1:\n            if method == 'outer':\n                raise NotImplementedError\n            return result\n        return self._constructor(result, index=index, name=name, copy=False)\n    if type(result) is tuple:\n        return tuple((construct_return(x) for x in result))\n    elif method == 'at':\n        return None\n    else:\n        return construct_return(result)",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    \"\"\"\n    Return the values as a NumPy array.\n\n    Users should not call this directly. Rather, it is invoked by\n    :func:`numpy.array` and :func:`numpy.asarray`.\n\n    Parameters\n    ----------\n    dtype : str or numpy.dtype, optional\n        The dtype to use for the resulting NumPy array. By default,\n        the dtype is inferred from the data.\n\n    Returns\n    -------\n    numpy.ndarray\n        The values in the series converted to a :class:`numpy.ndarray`\n        with the specified `dtype`.\n\n    See Also\n    --------\n    array : Create a new array from data.\n    Series.array : Zero-copy view to the array backing the Series.\n    Series.to_numpy : Series method for similar behavior.\n\n    Examples\n    --------\n    >>> ser = pd.Series([1, 2, 3])\n    >>> np.asarray(ser)\n    array([1, 2, 3])\n\n    For timezone-aware data, the timezones may be retained with\n    ``dtype='object'``\n\n    >>> tzser = pd.Series(pd.date_range('2000', periods=2, tz=\"CET\"))\n    >>> np.asarray(tzser, dtype=\"object\")\n    array([Timestamp('2000-01-01 00:00:00+0100', tz='CET', freq='D'),\n           Timestamp('2000-01-02 00:00:00+0100', tz='CET', freq='D')],\n          dtype=object)\n\n    Or the values may be localized to UTC and the tzinfo discarded with\n    ``dtype='datetime64[ns]'``\n\n    >>> np.asarray(tzser, dtype=\"datetime64[ns]\")  # doctest: +ELLIPSIS\n    array(['1999-12-31T23:00:00.000000000', ...],\n          dtype='datetime64[ns]')\n    \"\"\"\n    return np.asarray(self.array, dtype)",
                            "@property\ndef axes(self) -> List[Index]:\n    \"\"\"\n    Return a list of the row axis labels.\n    \"\"\"\n    return [self.index]",
                            "@Appender(generic.NDFrame.take.__doc__)\ndef take(self, indices, axis=0, is_copy=None, **kwargs) -> 'Series':\n    if is_copy is not None:\n        warnings.warn(\"is_copy is deprecated and will be removed in a future version. 'take' always returns a copy, so there is no need to specify this.\", FutureWarning, stacklevel=2)\n    nv.validate_take(tuple(), kwargs)\n    indices = ensure_platform_int(indices)\n    new_index = self.index.take(indices)\n    new_values = self._values.take(indices)\n    result = self._constructor(new_values, index=new_index, fastpath=True)\n    return result.__finalize__(self, method='take')",
                            "def _take_with_is_copy(self, indices, axis=0):\n    \"\"\"\n    Internal version of the `take` method that sets the `_is_copy`\n    attribute to keep track of the parent dataframe (using in indexing\n    for the SettingWithCopyWarning). For Series this does the same\n    as the public take (it never sets `_is_copy`).\n\n    See the docstring of `take` for full explanation of the parameters.\n    \"\"\"\n    return self.take(indices=indices, axis=axis)",
                            "def _ixs(self, i: int, axis: int=0):\n    \"\"\"\n    Return the i-th value or values in the Series by location.\n\n    Parameters\n    ----------\n    i : int\n\n    Returns\n    -------\n    scalar (int) or Series (slice, sequence)\n    \"\"\"\n    return self._values[i]",
                            "def _slice(self, slobj: slice, axis: int=0) -> 'Series':\n    return self._get_values(slobj)",
                            "def __getitem__(self, key):\n    key = com.apply_if_callable(key, self)\n    if key is Ellipsis:\n        return self\n    key_is_scalar = is_scalar(key)\n    if isinstance(key, (list, tuple)):\n        key = unpack_1tuple(key)\n    if is_integer(key) and self.index._should_fallback_to_positional():\n        return self._values[key]\n    elif key_is_scalar:\n        return self._get_value(key)\n    if isinstance(key, tuple) and is_hashable(key) and isinstance(self.index, MultiIndex):\n        try:\n            result = self._get_value(key)\n            return result\n        except KeyError:\n            return self._get_values_tuple(key)\n    if is_iterator(key):\n        key = list(key)\n    if com.is_bool_indexer(key):\n        key = check_bool_indexer(self.index, key)\n        key = np.asarray(key, dtype=bool)\n        return self._get_values(key)\n    return self._get_with(key)",
                            "def _get_with(self, key):\n    if isinstance(key, slice):\n        slobj = self.index._convert_slice_indexer(key, kind='getitem')\n        return self._slice(slobj)\n    elif isinstance(key, ABCDataFrame):\n        raise TypeError('Indexing a Series with DataFrame is not supported, use the appropriate DataFrame column')\n    elif isinstance(key, tuple):\n        return self._get_values_tuple(key)\n    elif not is_list_like(key):\n        return self.loc[key]\n    if not isinstance(key, (list, np.ndarray, ExtensionArray, Series, Index)):\n        key = list(key)\n    if isinstance(key, Index):\n        key_type = key.inferred_type\n    else:\n        key_type = lib.infer_dtype(key, skipna=False)\n    if key_type == 'integer':\n        if not self.index._should_fallback_to_positional():\n            return self.loc[key]\n        else:\n            return self.iloc[key]\n    return self.loc[key]",
                            "def _get_values_tuple(self, key):\n    if com.any_none(*key):\n        with warnings.catch_warnings():\n            warnings.filterwarnings('ignore', 'Support for multi-dim', DeprecationWarning)\n            return self._get_values(key)\n    if not isinstance(self.index, MultiIndex):\n        raise ValueError('Can only tuple-index with a MultiIndex')\n    indexer, new_index = self.index.get_loc_level(key)\n    return self._constructor(self._values[indexer], index=new_index).__finalize__(self)",
                            "def _get_values(self, indexer):\n    try:\n        return self._constructor(self._mgr.get_slice(indexer)).__finalize__(self)\n    except ValueError:\n        return self._values[indexer]",
                            "def _get_value(self, label, takeable: bool=False):\n    \"\"\"\n    Quickly retrieve single value at passed index label.\n\n    Parameters\n    ----------\n    label : object\n    takeable : interpret the index as indexers, default False\n\n    Returns\n    -------\n    scalar value\n    \"\"\"\n    if takeable:\n        return self._values[label]\n    loc = self.index.get_loc(label)\n    return self.index._get_values_for_loc(self, loc, label)",
                            "def __setitem__(self, key, value):\n    key = com.apply_if_callable(key, self)\n    cacher_needs_updating = self._check_is_chained_assignment_possible()\n    if key is Ellipsis:\n        key = slice(None)\n    try:\n        self._set_with_engine(key, value)\n    except (KeyError, ValueError):\n        values = self._values\n        if is_integer(key) and (not self.index.inferred_type == 'integer'):\n            values[key] = value\n        else:\n            self.loc[key] = value\n    except TypeError as e:\n        if isinstance(key, tuple) and (not isinstance(self.index, MultiIndex)):\n            raise ValueError('Can only tuple-index with a MultiIndex') from e\n        if com.is_bool_indexer(key):\n            key = check_bool_indexer(self.index, key)\n            key = np.asarray(key, dtype=bool)\n            try:\n                self._where(~key, value, inplace=True)\n            except InvalidIndexError:\n                self.iloc[key] = value\n            return\n        else:\n            self._set_with(key, value)\n    if cacher_needs_updating:\n        self._maybe_update_cacher()",
                            "def _set_with_engine(self, key, value):\n    loc = self.index._engine.get_loc(key)\n    validate_numeric_casting(self.dtype, value)\n    self._values[loc] = value",
                            "def _set_with(self, key, value):\n    if isinstance(key, slice):\n        indexer = self.index._convert_slice_indexer(key, kind='getitem')\n        self.iloc[indexer] = extract_array(value, extract_numpy=True)\n    else:\n        assert not isinstance(key, tuple)\n        if is_scalar(key):\n            key = [key]\n        if isinstance(key, Index):\n            key_type = key.inferred_type\n            key = key._values\n        else:\n            key_type = lib.infer_dtype(key, skipna=False)\n        if key_type == 'integer':\n            if not self.index._should_fallback_to_positional():\n                self.loc[key] = value\n            else:\n                self.iloc[key] = value\n        else:\n            self.loc[key] = value",
                            "def _set_value(self, label, value, takeable: bool=False):\n    \"\"\"\n    Quickly set single value at passed label.\n\n    If label is not contained, a new object is created with the label\n    placed at the end of the result index.\n\n    Parameters\n    ----------\n    label : object\n        Partial indexing with MultiIndex not allowed.\n    value : object\n        Scalar value.\n    takeable : interpret the index as indexers, default False\n    \"\"\"\n    try:\n        if takeable:\n            self._values[label] = value\n        else:\n            loc = self.index.get_loc(label)\n            validate_numeric_casting(self.dtype, value)\n            self._values[loc] = value\n    except KeyError:\n        self.loc[label] = value",
                            "@property\ndef _is_mixed_type(self):\n    return False",
                            "def repeat(self, repeats, axis=None) -> 'Series':\n    \"\"\"\n    Repeat elements of a Series.\n\n    Returns a new Series where each element of the current Series\n    is repeated consecutively a given number of times.\n\n    Parameters\n    ----------\n    repeats : int or array of ints\n        The number of repetitions for each element. This should be a\n        non-negative integer. Repeating 0 times will return an empty\n        Series.\n    axis : None\n        Must be ``None``. Has no effect but is accepted for compatibility\n        with numpy.\n\n    Returns\n    -------\n    Series\n        Newly created Series with repeated elements.\n\n    See Also\n    --------\n    Index.repeat : Equivalent function for Index.\n    numpy.repeat : Similar method for :class:`numpy.ndarray`.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'b', 'c'])\n    >>> s\n    0    a\n    1    b\n    2    c\n    dtype: object\n    >>> s.repeat(2)\n    0    a\n    0    a\n    1    b\n    1    b\n    2    c\n    2    c\n    dtype: object\n    >>> s.repeat([1, 2, 3])\n    0    a\n    1    b\n    1    b\n    2    c\n    2    c\n    2    c\n    dtype: object\n    \"\"\"\n    nv.validate_repeat(tuple(), dict(axis=axis))\n    new_index = self.index.repeat(repeats)\n    new_values = self._values.repeat(repeats)\n    return self._constructor(new_values, index=new_index).__finalize__(self, method='repeat')",
                            "def reset_index(self, level=None, drop=False, name=None, inplace=False):\n    \"\"\"\n    Generate a new DataFrame or Series with the index reset.\n\n    This is useful when the index needs to be treated as a column, or\n    when the index is meaningless and needs to be reset to the default\n    before another operation.\n\n    Parameters\n    ----------\n    level : int, str, tuple, or list, default optional\n        For a Series with a MultiIndex, only remove the specified levels\n        from the index. Removes all levels by default.\n    drop : bool, default False\n        Just reset the index, without inserting it as a column in\n        the new DataFrame.\n    name : object, optional\n        The name to use for the column containing the original Series\n        values. Uses ``self.name`` by default. This argument is ignored\n        when `drop` is True.\n    inplace : bool, default False\n        Modify the Series in place (do not create a new object).\n\n    Returns\n    -------\n    Series or DataFrame\n        When `drop` is False (the default), a DataFrame is returned.\n        The newly created columns will come first in the DataFrame,\n        followed by the original Series values.\n        When `drop` is True, a `Series` is returned.\n        In either case, if ``inplace=True``, no value is returned.\n\n    See Also\n    --------\n    DataFrame.reset_index: Analogous function for DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3, 4], name='foo',\n    ...               index=pd.Index(['a', 'b', 'c', 'd'], name='idx'))\n\n    Generate a DataFrame with default index.\n\n    >>> s.reset_index()\n      idx  foo\n    0   a    1\n    1   b    2\n    2   c    3\n    3   d    4\n\n    To specify the name of the new column use `name`.\n\n    >>> s.reset_index(name='values')\n      idx  values\n    0   a       1\n    1   b       2\n    2   c       3\n    3   d       4\n\n    To generate a new Series with the default set `drop` to True.\n\n    >>> s.reset_index(drop=True)\n    0    1\n    1    2\n    2    3\n    3    4\n    Name: foo, dtype: int64\n\n    To update the Series in place, without generating a new one\n    set `inplace` to True. Note that it also requires ``drop=True``.\n\n    >>> s.reset_index(inplace=True, drop=True)\n    >>> s\n    0    1\n    1    2\n    2    3\n    3    4\n    Name: foo, dtype: int64\n\n    The `level` parameter is interesting for Series with a multi-level\n    index.\n\n    >>> arrays = [np.array(['bar', 'bar', 'baz', 'baz']),\n    ...           np.array(['one', 'two', 'one', 'two'])]\n    >>> s2 = pd.Series(\n    ...     range(4), name='foo',\n    ...     index=pd.MultiIndex.from_arrays(arrays,\n    ...                                     names=['a', 'b']))\n\n    To remove a specific level from the Index, use `level`.\n\n    >>> s2.reset_index(level='a')\n           a  foo\n    b\n    one  bar    0\n    two  bar    1\n    one  baz    2\n    two  baz    3\n\n    If `level` is not set, all levels are removed from the Index.\n\n    >>> s2.reset_index()\n         a    b  foo\n    0  bar  one    0\n    1  bar  two    1\n    2  baz  one    2\n    3  baz  two    3\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    if drop:\n        new_index = ibase.default_index(len(self))\n        if level is not None:\n            if not isinstance(level, (tuple, list)):\n                level = [level]\n            level = [self.index._get_level_number(lev) for lev in level]\n            if len(level) < self.index.nlevels:\n                new_index = self.index.droplevel(level)\n        if inplace:\n            self.index = new_index\n            self.name = name or self.name\n        else:\n            return self._constructor(self._values.copy(), index=new_index).__finalize__(self, method='reset_index')\n    elif inplace:\n        raise TypeError('Cannot reset_index inplace on a Series to create a DataFrame')\n    else:\n        df = self.to_frame(name)\n        return df.reset_index(level=level, drop=drop)",
                            "def __repr__(self) -> str:\n    \"\"\"\n    Return a string representation for a particular Series.\n    \"\"\"\n    buf = StringIO('')\n    width, height = get_terminal_size()\n    max_rows = height if get_option('display.max_rows') == 0 else get_option('display.max_rows')\n    min_rows = height if get_option('display.max_rows') == 0 else get_option('display.min_rows')\n    show_dimensions = get_option('display.show_dimensions')\n    self.to_string(buf=buf, name=self.name, dtype=self.dtype, min_rows=min_rows, max_rows=max_rows, length=show_dimensions)\n    result = buf.getvalue()\n    return result",
                            "def to_string(self, buf=None, na_rep='NaN', float_format=None, header=True, index=True, length=False, dtype=False, name=False, max_rows=None, min_rows=None):\n    \"\"\"\n    Render a string representation of the Series.\n\n    Parameters\n    ----------\n    buf : StringIO-like, optional\n        Buffer to write to.\n    na_rep : str, optional\n        String representation of NaN to use, default 'NaN'.\n    float_format : one-parameter function, optional\n        Formatter function to apply to columns' elements if they are\n        floats, default None.\n    header : bool, default True\n        Add the Series header (index name).\n    index : bool, optional\n        Add index (row) labels, default True.\n    length : bool, default False\n        Add the Series length.\n    dtype : bool, default False\n        Add the Series dtype.\n    name : bool, default False\n        Add the Series name if not None.\n    max_rows : int, optional\n        Maximum number of rows to show before truncating. If None, show\n        all.\n    min_rows : int, optional\n        The number of rows to display in a truncated repr (when number\n        of rows is above `max_rows`).\n\n    Returns\n    -------\n    str or None\n        String representation of Series if ``buf=None``, otherwise None.\n    \"\"\"\n    formatter = fmt.SeriesFormatter(self, name=name, length=length, header=header, index=index, dtype=dtype, na_rep=na_rep, float_format=float_format, min_rows=min_rows, max_rows=max_rows)\n    result = formatter.to_string()\n    if not isinstance(result, str):\n        raise AssertionError(f'result must be of type str, type of result is {repr(type(result).__name__)}')\n    if buf is None:\n        return result\n    else:\n        try:\n            buf.write(result)\n        except AttributeError:\n            with open(buf, 'w') as f:\n                f.write(result)",
                            "@Appender('\\n        Examples\\n        --------\\n        >>> s = pd.Series([\"elk\", \"pig\", \"dog\", \"quetzal\"], name=\"animal\")\\n        >>> print(s.to_markdown())\\n        |    | animal   |\\n        |---:|:---------|\\n        |  0 | elk      |\\n        |  1 | pig      |\\n        |  2 | dog      |\\n        |  3 | quetzal  |\\n        ')\n@Substitution(klass='Series')\n@Appender(generic._shared_docs['to_markdown'])\ndef to_markdown(self, buf: Optional[IO[str]]=None, mode: Optional[str]=None, **kwargs) -> Optional[str]:\n    return self.to_frame().to_markdown(buf, mode, **kwargs)",
                            "def items(self) -> Iterable[Tuple[Label, Any]]:\n    \"\"\"\n    Lazily iterate over (index, value) tuples.\n\n    This method returns an iterable tuple (index, value). This is\n    convenient if you want to create a lazy iterator.\n\n    Returns\n    -------\n    iterable\n        Iterable of tuples containing the (index, value) pairs from a\n        Series.\n\n    See Also\n    --------\n    DataFrame.items : Iterate over (column name, Series) pairs.\n    DataFrame.iterrows : Iterate over DataFrame rows as (index, Series) pairs.\n\n    Examples\n    --------\n    >>> s = pd.Series(['A', 'B', 'C'])\n    >>> for index, value in s.items():\n    ...     print(f\"Index : {index}, Value : {value}\")\n    Index : 0, Value : A\n    Index : 1, Value : B\n    Index : 2, Value : C\n    \"\"\"\n    return zip(iter(self.index), iter(self))",
                            "@Appender(items.__doc__)\ndef iteritems(self) -> Iterable[Tuple[Label, Any]]:\n    return self.items()",
                            "def keys(self) -> Index:\n    \"\"\"\n    Return alias for index.\n\n    Returns\n    -------\n    Index\n        Index of the Series.\n    \"\"\"\n    return self.index",
                            "def to_dict(self, into=dict):\n    \"\"\"\n    Convert Series to {label -> value} dict or dict-like object.\n\n    Parameters\n    ----------\n    into : class, default dict\n        The collections.abc.Mapping subclass to use as the return\n        object. Can be the actual class or an empty\n        instance of the mapping type you want.  If you want a\n        collections.defaultdict, you must pass it initialized.\n\n    Returns\n    -------\n    collections.abc.Mapping\n        Key-value representation of Series.\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3, 4])\n    >>> s.to_dict()\n    {0: 1, 1: 2, 2: 3, 3: 4}\n    >>> from collections import OrderedDict, defaultdict\n    >>> s.to_dict(OrderedDict)\n    OrderedDict([(0, 1), (1, 2), (2, 3), (3, 4)])\n    >>> dd = defaultdict(list)\n    >>> s.to_dict(dd)\n    defaultdict(<class 'list'>, {0: 1, 1: 2, 2: 3, 3: 4})\n    \"\"\"\n    into_c = com.standardize_mapping(into)\n    return into_c(self.items())",
                            "def to_frame(self, name=None) -> 'DataFrame':\n    \"\"\"\n    Convert Series to DataFrame.\n\n    Parameters\n    ----------\n    name : object, default None\n        The passed name should substitute for the series name (if it has\n        one).\n\n    Returns\n    -------\n    DataFrame\n        DataFrame representation of Series.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"a\", \"b\", \"c\"],\n    ...               name=\"vals\")\n    >>> s.to_frame()\n      vals\n    0    a\n    1    b\n    2    c\n    \"\"\"\n    if name is None:\n        df = self._constructor_expanddim(self)\n    else:\n        df = self._constructor_expanddim({name: self})\n    return df",
                            "def _set_name(self, name, inplace=False) -> 'Series':\n    \"\"\"\n    Set the Series name.\n\n    Parameters\n    ----------\n    name : str\n    inplace : bool\n        Whether to modify `self` directly or return a copy.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    ser = self if inplace else self.copy()\n    ser.name = name\n    return ser",
                            "@Appender('\\nExamples\\n--------\\n>>> ser = pd.Series([390., 350., 30., 20.],\\n...                 index=[\\'Falcon\\', \\'Falcon\\', \\'Parrot\\', \\'Parrot\\'], name=\"Max Speed\")\\n>>> ser\\nFalcon    390.0\\nFalcon    350.0\\nParrot     30.0\\nParrot     20.0\\nName: Max Speed, dtype: float64\\n>>> ser.groupby([\"a\", \"b\", \"a\", \"b\"]).mean()\\na    210.0\\nb    185.0\\nName: Max Speed, dtype: float64\\n>>> ser.groupby(level=0).mean()\\nFalcon    370.0\\nParrot     25.0\\nName: Max Speed, dtype: float64\\n>>> ser.groupby(ser > 100).mean()\\nMax Speed\\nFalse     25.0\\nTrue     370.0\\nName: Max Speed, dtype: float64\\n\\n**Grouping by Indexes**\\n\\nWe can groupby different levels of a hierarchical index\\nusing the `level` parameter:\\n\\n>>> arrays = [[\\'Falcon\\', \\'Falcon\\', \\'Parrot\\', \\'Parrot\\'],\\n...           [\\'Captive\\', \\'Wild\\', \\'Captive\\', \\'Wild\\']]\\n>>> index = pd.MultiIndex.from_arrays(arrays, names=(\\'Animal\\', \\'Type\\'))\\n>>> ser = pd.Series([390., 350., 30., 20.], index=index, name=\"Max Speed\")\\n>>> ser\\nAnimal  Type\\nFalcon  Captive    390.0\\n        Wild       350.0\\nParrot  Captive     30.0\\n        Wild        20.0\\nName: Max Speed, dtype: float64\\n>>> ser.groupby(level=0).mean()\\nAnimal\\nFalcon    370.0\\nParrot     25.0\\nName: Max Speed, dtype: float64\\n>>> ser.groupby(level=\"Type\").mean()\\nType\\nCaptive    210.0\\nWild       185.0\\nName: Max Speed, dtype: float64\\n\\nWe can also choose to include `NA` in group keys or not by defining\\n`dropna` parameter, the default setting is `True`:\\n\\n>>> ser = pd.Series([1, 2, 3, 3], index=[\"a\", \\'a\\', \\'b\\', np.nan])\\n>>> ser.groupby(level=0).sum()\\na    3\\nb    3\\ndtype: int64\\n\\n>>> ser.groupby(level=0, dropna=False).sum()\\na    3\\nb    3\\nNaN  3\\ndtype: int64\\n\\n>>> arrays = [\\'Falcon\\', \\'Falcon\\', \\'Parrot\\', \\'Parrot\\']\\n>>> ser = pd.Series([390., 350., 30., 20.], index=arrays, name=\"Max Speed\")\\n>>> ser.groupby([\"a\", \"b\", \"a\", np.nan]).mean()\\na    210.0\\nb    350.0\\nName: Max Speed, dtype: float64\\n\\n>>> ser.groupby([\"a\", \"b\", \"a\", np.nan], dropna=False).mean()\\na    210.0\\nb    350.0\\nNaN   20.0\\nName: Max Speed, dtype: float64\\n')\n@Appender(generic._shared_docs['groupby'] % _shared_doc_kwargs)\ndef groupby(self, by=None, axis=0, level=None, as_index: bool=True, sort: bool=True, group_keys: bool=True, squeeze: bool=False, observed: bool=False, dropna: bool=True) -> 'SeriesGroupBy':\n    from pandas.core.groupby.generic import SeriesGroupBy\n    if level is None and by is None:\n        raise TypeError(\"You have to supply one of 'by' and 'level'\")\n    axis = self._get_axis_number(axis)\n    return SeriesGroupBy(obj=self, keys=by, axis=axis, level=level, as_index=as_index, sort=sort, group_keys=group_keys, squeeze=squeeze, observed=observed, dropna=dropna)",
                            "def count(self, level=None):\n    \"\"\"\n    Return number of non-NA/null observations in the Series.\n\n    Parameters\n    ----------\n    level : int or level name, default None\n        If the axis is a MultiIndex (hierarchical), count along a\n        particular level, collapsing into a smaller Series.\n\n    Returns\n    -------\n    int or Series (if level specified)\n        Number of non-null values in the Series.\n\n    See Also\n    --------\n    DataFrame.count : Count non-NA cells for each column or row.\n\n    Examples\n    --------\n    >>> s = pd.Series([0.0, 1.0, np.nan])\n    >>> s.count()\n    2\n    \"\"\"\n    if level is None:\n        return notna(self.array).sum()\n    if isinstance(level, str):\n        level = self.index._get_level_number(level)\n    lev = self.index.levels[level]\n    level_codes = np.array(self.index.codes[level], subok=False, copy=True)\n    mask = level_codes == -1\n    if mask.any():\n        level_codes[mask] = cnt = len(lev)\n        lev = lev.insert(cnt, lev._na_value)\n    obs = level_codes[notna(self._values)]\n    out = np.bincount(obs, minlength=len(lev) or None)\n    return self._constructor(out, index=lev, dtype='int64').__finalize__(self, method='count')",
                            "def mode(self, dropna=True) -> 'Series':\n    \"\"\"\n    Return the mode(s) of the dataset.\n\n    Always returns Series even if only one value is returned.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't consider counts of NaN/NaT.\n\n        .. versionadded:: 0.24.0\n\n    Returns\n    -------\n    Series\n        Modes of the Series in sorted order.\n    \"\"\"\n    return algorithms.mode(self, dropna=dropna)",
                            "def unique(self):\n    \"\"\"\n    Return unique values of Series object.\n\n    Uniques are returned in order of appearance. Hash table-based unique,\n    therefore does NOT sort.\n\n    Returns\n    -------\n    ndarray or ExtensionArray\n        The unique values returned as a NumPy array. See Notes.\n\n    See Also\n    --------\n    unique : Top-level unique method for any 1-d array-like object.\n    Index.unique : Return Index with unique values from an Index object.\n\n    Notes\n    -----\n    Returns the unique values as a NumPy array. In case of an\n    extension-array backed Series, a new\n    :class:`~api.extensions.ExtensionArray` of that type with just\n    the unique values is returned. This includes\n\n        * Categorical\n        * Period\n        * Datetime with Timezone\n        * Interval\n        * Sparse\n        * IntegerNA\n\n    See Examples section.\n\n    Examples\n    --------\n    >>> pd.Series([2, 1, 3, 3], name='A').unique()\n    array([2, 1, 3])\n\n    >>> pd.Series([pd.Timestamp('2016-01-01') for _ in range(3)]).unique()\n    array(['2016-01-01T00:00:00.000000000'], dtype='datetime64[ns]')\n\n    >>> pd.Series([pd.Timestamp('2016-01-01', tz='US/Eastern')\n    ...            for _ in range(3)]).unique()\n    <DatetimeArray>\n    ['2016-01-01 00:00:00-05:00']\n    Length: 1, dtype: datetime64[ns, US/Eastern]\n\n    An unordered Categorical will return categories in the order of\n    appearance.\n\n    >>> pd.Series(pd.Categorical(list('baabc'))).unique()\n    [b, a, c]\n    Categories (3, object): [b, a, c]\n\n    An ordered Categorical preserves the category ordering.\n\n    >>> pd.Series(pd.Categorical(list('baabc'), categories=list('abc'),\n    ...                          ordered=True)).unique()\n    [b, a, c]\n    Categories (3, object): [a < b < c]\n    \"\"\"\n    result = super().unique()\n    return result",
                            "def drop_duplicates(self, keep='first', inplace=False) -> Optional['Series']:\n    \"\"\"\n    Return Series with duplicate values removed.\n\n    Parameters\n    ----------\n    keep : {'first', 'last', ``False``}, default 'first'\n        Method to handle dropping duplicates:\n\n        - 'first' : Drop duplicates except for the first occurrence.\n        - 'last' : Drop duplicates except for the last occurrence.\n        - ``False`` : Drop all duplicates.\n\n    inplace : bool, default ``False``\n        If ``True``, performs operation inplace and returns None.\n\n    Returns\n    -------\n    Series\n        Series with duplicates dropped.\n\n    See Also\n    --------\n    Index.drop_duplicates : Equivalent method on Index.\n    DataFrame.drop_duplicates : Equivalent method on DataFrame.\n    Series.duplicated : Related method on Series, indicating duplicate\n        Series values.\n\n    Examples\n    --------\n    Generate a Series with duplicated entries.\n\n    >>> s = pd.Series(['lama', 'cow', 'lama', 'beetle', 'lama', 'hippo'],\n    ...               name='animal')\n    >>> s\n    0      lama\n    1       cow\n    2      lama\n    3    beetle\n    4      lama\n    5     hippo\n    Name: animal, dtype: object\n\n    With the 'keep' parameter, the selection behaviour of duplicated values\n    can be changed. The value 'first' keeps the first occurrence for each\n    set of duplicated entries. The default value of keep is 'first'.\n\n    >>> s.drop_duplicates()\n    0      lama\n    1       cow\n    3    beetle\n    5     hippo\n    Name: animal, dtype: object\n\n    The value 'last' for parameter 'keep' keeps the last occurrence for\n    each set of duplicated entries.\n\n    >>> s.drop_duplicates(keep='last')\n    1       cow\n    3    beetle\n    4      lama\n    5     hippo\n    Name: animal, dtype: object\n\n    The value ``False`` for parameter 'keep' discards all sets of\n    duplicated entries. Setting the value of 'inplace' to ``True`` performs\n    the operation inplace and returns ``None``.\n\n    >>> s.drop_duplicates(keep=False, inplace=True)\n    >>> s\n    1       cow\n    3    beetle\n    5     hippo\n    Name: animal, dtype: object\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    result = super().drop_duplicates(keep=keep)\n    if inplace:\n        self._update_inplace(result)\n        return None\n    else:\n        return result",
                            "def duplicated(self, keep='first') -> 'Series':\n    \"\"\"\n    Indicate duplicate Series values.\n\n    Duplicated values are indicated as ``True`` values in the resulting\n    Series. Either all duplicates, all except the first or all except the\n    last occurrence of duplicates can be indicated.\n\n    Parameters\n    ----------\n    keep : {'first', 'last', False}, default 'first'\n        Method to handle dropping duplicates:\n\n        - 'first' : Mark duplicates as ``True`` except for the first\n          occurrence.\n        - 'last' : Mark duplicates as ``True`` except for the last\n          occurrence.\n        - ``False`` : Mark all duplicates as ``True``.\n\n    Returns\n    -------\n    Series\n        Series indicating whether each value has occurred in the\n        preceding values.\n\n    See Also\n    --------\n    Index.duplicated : Equivalent method on pandas.Index.\n    DataFrame.duplicated : Equivalent method on pandas.DataFrame.\n    Series.drop_duplicates : Remove duplicate values from Series.\n\n    Examples\n    --------\n    By default, for each set of duplicated values, the first occurrence is\n    set on False and all others on True:\n\n    >>> animals = pd.Series(['lama', 'cow', 'lama', 'beetle', 'lama'])\n    >>> animals.duplicated()\n    0    False\n    1    False\n    2     True\n    3    False\n    4     True\n    dtype: bool\n\n    which is equivalent to\n\n    >>> animals.duplicated(keep='first')\n    0    False\n    1    False\n    2     True\n    3    False\n    4     True\n    dtype: bool\n\n    By using 'last', the last occurrence of each set of duplicated values\n    is set on False and all others on True:\n\n    >>> animals.duplicated(keep='last')\n    0     True\n    1    False\n    2     True\n    3    False\n    4    False\n    dtype: bool\n\n    By setting keep on ``False``, all duplicates are True:\n\n    >>> animals.duplicated(keep=False)\n    0     True\n    1    False\n    2     True\n    3    False\n    4     True\n    dtype: bool\n    \"\"\"\n    return super().duplicated(keep=keep)",
                            "def idxmin(self, axis=0, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the row label of the minimum value.\n\n    If multiple values equal the minimum, the first row label with that\n    value is returned.\n\n    Parameters\n    ----------\n    axis : int, default 0\n        For compatibility with DataFrame.idxmin. Redundant for application\n        on Series.\n    skipna : bool, default True\n        Exclude NA/null values. If the entire Series is NA, the result\n        will be NA.\n    *args, **kwargs\n        Additional arguments and keywords have no effect but might be\n        accepted for compatibility with NumPy.\n\n    Returns\n    -------\n    Index\n        Label of the minimum value.\n\n    Raises\n    ------\n    ValueError\n        If the Series is empty.\n\n    See Also\n    --------\n    numpy.argmin : Return indices of the minimum values\n        along the given axis.\n    DataFrame.idxmin : Return index of first occurrence of minimum\n        over requested axis.\n    Series.idxmax : Return index *label* of the first occurrence\n        of maximum of values.\n\n    Notes\n    -----\n    This method is the Series version of ``ndarray.argmin``. This method\n    returns the label of the minimum, while ``ndarray.argmin`` returns\n    the position. To get the position, use ``series.values.argmin()``.\n\n    Examples\n    --------\n    >>> s = pd.Series(data=[1, None, 4, 1],\n    ...               index=['A', 'B', 'C', 'D'])\n    >>> s\n    A    1.0\n    B    NaN\n    C    4.0\n    D    1.0\n    dtype: float64\n\n    >>> s.idxmin()\n    'A'\n\n    If `skipna` is False and there is an NA value in the data,\n    the function returns ``nan``.\n\n    >>> s.idxmin(skipna=False)\n    nan\n    \"\"\"\n    skipna = nv.validate_argmin_with_skipna(skipna, args, kwargs)\n    i = nanops.nanargmin(self._values, skipna=skipna)\n    if i == -1:\n        return np.nan\n    return self.index[i]",
                            "def idxmax(self, axis=0, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the row label of the maximum value.\n\n    If multiple values equal the maximum, the first row label with that\n    value is returned.\n\n    Parameters\n    ----------\n    axis : int, default 0\n        For compatibility with DataFrame.idxmax. Redundant for application\n        on Series.\n    skipna : bool, default True\n        Exclude NA/null values. If the entire Series is NA, the result\n        will be NA.\n    *args, **kwargs\n        Additional arguments and keywords have no effect but might be\n        accepted for compatibility with NumPy.\n\n    Returns\n    -------\n    Index\n        Label of the maximum value.\n\n    Raises\n    ------\n    ValueError\n        If the Series is empty.\n\n    See Also\n    --------\n    numpy.argmax : Return indices of the maximum values\n        along the given axis.\n    DataFrame.idxmax : Return index of first occurrence of maximum\n        over requested axis.\n    Series.idxmin : Return index *label* of the first occurrence\n        of minimum of values.\n\n    Notes\n    -----\n    This method is the Series version of ``ndarray.argmax``. This method\n    returns the label of the maximum, while ``ndarray.argmax`` returns\n    the position. To get the position, use ``series.values.argmax()``.\n\n    Examples\n    --------\n    >>> s = pd.Series(data=[1, None, 4, 3, 4],\n    ...               index=['A', 'B', 'C', 'D', 'E'])\n    >>> s\n    A    1.0\n    B    NaN\n    C    4.0\n    D    3.0\n    E    4.0\n    dtype: float64\n\n    >>> s.idxmax()\n    'C'\n\n    If `skipna` is False and there is an NA value in the data,\n    the function returns ``nan``.\n\n    >>> s.idxmax(skipna=False)\n    nan\n    \"\"\"\n    skipna = nv.validate_argmax_with_skipna(skipna, args, kwargs)\n    i = nanops.nanargmax(self._values, skipna=skipna)\n    if i == -1:\n        return np.nan\n    return self.index[i]",
                            "def round(self, decimals=0, *args, **kwargs) -> 'Series':\n    \"\"\"\n    Round each value in a Series to the given number of decimals.\n\n    Parameters\n    ----------\n    decimals : int, default 0\n        Number of decimal places to round to. If decimals is negative,\n        it specifies the number of positions to the left of the decimal point.\n    *args, **kwargs\n        Additional arguments and keywords have no effect but might be\n        accepted for compatibility with NumPy.\n\n    Returns\n    -------\n    Series\n        Rounded values of the Series.\n\n    See Also\n    --------\n    numpy.around : Round values of an np.array.\n    DataFrame.round : Round values of a DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series([0.1, 1.3, 2.7])\n    >>> s.round()\n    0    0.0\n    1    1.0\n    2    3.0\n    dtype: float64\n    \"\"\"\n    nv.validate_round(args, kwargs)\n    result = self._values.round(decimals)\n    result = self._constructor(result, index=self.index).__finalize__(self, method='round')\n    return result",
                            "def quantile(self, q=0.5, interpolation='linear'):\n    \"\"\"\n    Return value at the given quantile.\n\n    Parameters\n    ----------\n    q : float or array-like, default 0.5 (50% quantile)\n        The quantile(s) to compute, which can lie in range: 0 <= q <= 1.\n    interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}\n        This optional parameter specifies the interpolation method to use,\n        when the desired quantile lies between two data points `i` and `j`:\n\n            * linear: `i + (j - i) * fraction`, where `fraction` is the\n              fractional part of the index surrounded by `i` and `j`.\n            * lower: `i`.\n            * higher: `j`.\n            * nearest: `i` or `j` whichever is nearest.\n            * midpoint: (`i` + `j`) / 2.\n\n    Returns\n    -------\n    float or Series\n        If ``q`` is an array, a Series will be returned where the\n        index is ``q`` and the values are the quantiles, otherwise\n        a float will be returned.\n\n    See Also\n    --------\n    core.window.Rolling.quantile : Calculate the rolling quantile.\n    numpy.percentile : Returns the q-th percentile(s) of the array elements.\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3, 4])\n    >>> s.quantile(.5)\n    2.5\n    >>> s.quantile([.25, .5, .75])\n    0.25    1.75\n    0.50    2.50\n    0.75    3.25\n    dtype: float64\n    \"\"\"\n    validate_percentile(q)\n    df = self.to_frame()\n    result = df.quantile(q=q, interpolation=interpolation, numeric_only=False)\n    if result.ndim == 2:\n        result = result.iloc[:, 0]\n    if is_list_like(q):\n        result.name = self.name\n        return self._constructor(result, index=Float64Index(q), name=self.name)\n    else:\n        return result.iloc[0]",
                            "def corr(self, other, method='pearson', min_periods=None) -> float:\n    \"\"\"\n    Compute correlation with `other` Series, excluding missing values.\n\n    Parameters\n    ----------\n    other : Series\n        Series with which to compute the correlation.\n    method : {'pearson', 'kendall', 'spearman'} or callable\n        Method used to compute correlation:\n\n        - pearson : Standard correlation coefficient\n        - kendall : Kendall Tau correlation coefficient\n        - spearman : Spearman rank correlation\n        - callable: Callable with input two 1d ndarrays and returning a float.\n\n        .. versionadded:: 0.24.0\n            Note that the returned matrix from corr will have 1 along the\n            diagonals and will be symmetric regardless of the callable's\n            behavior.\n    min_periods : int, optional\n        Minimum number of observations needed to have a valid result.\n\n    Returns\n    -------\n    float\n        Correlation with other.\n\n    See Also\n    --------\n    DataFrame.corr : Compute pairwise correlation between columns.\n    DataFrame.corrwith : Compute pairwise correlation with another\n        DataFrame or Series.\n\n    Examples\n    --------\n    >>> def histogram_intersection(a, b):\n    ...     v = np.minimum(a, b).sum().round(decimals=1)\n    ...     return v\n    >>> s1 = pd.Series([.2, .0, .6, .2])\n    >>> s2 = pd.Series([.3, .6, .0, .1])\n    >>> s1.corr(s2, method=histogram_intersection)\n    0.3\n    \"\"\"\n    this, other = self.align(other, join='inner', copy=False)\n    if len(this) == 0:\n        return np.nan\n    if method in ['pearson', 'spearman', 'kendall'] or callable(method):\n        return nanops.nancorr(this.values, other.values, method=method, min_periods=min_periods)\n    raise ValueError(f\"method must be either 'pearson', 'spearman', 'kendall', or a callable, '{method}' was supplied\")",
                            "def cov(self, other, min_periods=None) -> float:\n    \"\"\"\n    Compute covariance with Series, excluding missing values.\n\n    Parameters\n    ----------\n    other : Series\n        Series with which to compute the covariance.\n    min_periods : int, optional\n        Minimum number of observations needed to have a valid result.\n\n    Returns\n    -------\n    float\n        Covariance between Series and other normalized by N-1\n        (unbiased estimator).\n\n    See Also\n    --------\n    DataFrame.cov : Compute pairwise covariance of columns.\n\n    Examples\n    --------\n    >>> s1 = pd.Series([0.90010907, 0.13484424, 0.62036035])\n    >>> s2 = pd.Series([0.12528585, 0.26962463, 0.51111198])\n    >>> s1.cov(s2)\n    -0.01685762652715874\n    \"\"\"\n    this, other = self.align(other, join='inner', copy=False)\n    if len(this) == 0:\n        return np.nan\n    return nanops.nancov(this.values, other.values, min_periods=min_periods)",
                            "def diff(self, periods: int=1) -> 'Series':\n    \"\"\"\n    First discrete difference of element.\n\n    Calculates the difference of a Series element compared with another\n    element in the Series (default is element in previous row).\n\n    Parameters\n    ----------\n    periods : int, default 1\n        Periods to shift for calculating difference, accepts negative\n        values.\n\n    Returns\n    -------\n    Series\n        First differences of the Series.\n\n    See Also\n    --------\n    Series.pct_change: Percent change over given number of periods.\n    Series.shift: Shift index by desired number of periods with an\n        optional time freq.\n    DataFrame.diff: First discrete difference of object.\n\n    Notes\n    -----\n    For boolean dtypes, this uses :meth:`operator.xor` rather than\n    :meth:`operator.sub`.\n\n    Examples\n    --------\n    Difference with previous row\n\n    >>> s = pd.Series([1, 1, 2, 3, 5, 8])\n    >>> s.diff()\n    0    NaN\n    1    0.0\n    2    1.0\n    3    1.0\n    4    2.0\n    5    3.0\n    dtype: float64\n\n    Difference with 3rd previous row\n\n    >>> s.diff(periods=3)\n    0    NaN\n    1    NaN\n    2    NaN\n    3    2.0\n    4    4.0\n    5    6.0\n    dtype: float64\n\n    Difference with following row\n\n    >>> s.diff(periods=-1)\n    0    0.0\n    1   -1.0\n    2   -1.0\n    3   -2.0\n    4   -3.0\n    5    NaN\n    dtype: float64\n    \"\"\"\n    result = algorithms.diff(self.array, periods)\n    return self._constructor(result, index=self.index).__finalize__(self, method='diff')",
                            "def autocorr(self, lag=1) -> float:\n    \"\"\"\n    Compute the lag-N autocorrelation.\n\n    This method computes the Pearson correlation between\n    the Series and its shifted self.\n\n    Parameters\n    ----------\n    lag : int, default 1\n        Number of lags to apply before performing autocorrelation.\n\n    Returns\n    -------\n    float\n        The Pearson correlation between self and self.shift(lag).\n\n    See Also\n    --------\n    Series.corr : Compute the correlation between two Series.\n    Series.shift : Shift index by desired number of periods.\n    DataFrame.corr : Compute pairwise correlation of columns.\n    DataFrame.corrwith : Compute pairwise correlation between rows or\n        columns of two DataFrame objects.\n\n    Notes\n    -----\n    If the Pearson correlation is not well defined return 'NaN'.\n\n    Examples\n    --------\n    >>> s = pd.Series([0.25, 0.5, 0.2, -0.05])\n    >>> s.autocorr()  # doctest: +ELLIPSIS\n    0.10355...\n    >>> s.autocorr(lag=2)  # doctest: +ELLIPSIS\n    -0.99999...\n\n    If the Pearson correlation is not well defined, then 'NaN' is returned.\n\n    >>> s = pd.Series([1, 0, 0, 0])\n    >>> s.autocorr()\n    nan\n    \"\"\"\n    return self.corr(self.shift(lag))",
                            "def dot(self, other):\n    \"\"\"\n    Compute the dot product between the Series and the columns of other.\n\n    This method computes the dot product between the Series and another\n    one, or the Series and each columns of a DataFrame, or the Series and\n    each columns of an array.\n\n    It can also be called using `self @ other` in Python >= 3.5.\n\n    Parameters\n    ----------\n    other : Series, DataFrame or array-like\n        The other object to compute the dot product with its columns.\n\n    Returns\n    -------\n    scalar, Series or numpy.ndarray\n        Return the dot product of the Series and other if other is a\n        Series, the Series of the dot product of Series and each rows of\n        other if other is a DataFrame or a numpy.ndarray between the Series\n        and each columns of the numpy array.\n\n    See Also\n    --------\n    DataFrame.dot: Compute the matrix product with the DataFrame.\n    Series.mul: Multiplication of series and other, element-wise.\n\n    Notes\n    -----\n    The Series and other has to share the same index if other is a Series\n    or a DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series([0, 1, 2, 3])\n    >>> other = pd.Series([-1, 2, -3, 4])\n    >>> s.dot(other)\n    8\n    >>> s @ other\n    8\n    >>> df = pd.DataFrame([[0, 1], [-2, 3], [4, -5], [6, 7]])\n    >>> s.dot(df)\n    0    24\n    1    14\n    dtype: int64\n    >>> arr = np.array([[0, 1], [-2, 3], [4, -5], [6, 7]])\n    >>> s.dot(arr)\n    array([24, 14])\n    \"\"\"\n    if isinstance(other, (Series, ABCDataFrame)):\n        common = self.index.union(other.index)\n        if len(common) > len(self.index) or len(common) > len(other.index):\n            raise ValueError('matrices are not aligned')\n        left = self.reindex(index=common, copy=False)\n        right = other.reindex(index=common, copy=False)\n        lvals = left.values\n        rvals = right.values\n    else:\n        lvals = self.values\n        rvals = np.asarray(other)\n        if lvals.shape[0] != rvals.shape[0]:\n            raise Exception(f'Dot product shape mismatch, {lvals.shape} vs {rvals.shape}')\n    if isinstance(other, ABCDataFrame):\n        return self._constructor(np.dot(lvals, rvals), index=other.columns).__finalize__(self, method='dot')\n    elif isinstance(other, Series):\n        return np.dot(lvals, rvals)\n    elif isinstance(rvals, np.ndarray):\n        return np.dot(lvals, rvals)\n    else:\n        raise TypeError(f'unsupported type: {type(other)}')",
                            "def __matmul__(self, other):\n    \"\"\"\n    Matrix multiplication using binary `@` operator in Python>=3.5.\n    \"\"\"\n    return self.dot(other)",
                            "def __rmatmul__(self, other):\n    \"\"\"\n    Matrix multiplication using binary `@` operator in Python>=3.5.\n    \"\"\"\n    return self.dot(np.transpose(other))",
                            "@doc(base.IndexOpsMixin.searchsorted, klass='Series')\ndef searchsorted(self, value, side='left', sorter=None):\n    return algorithms.searchsorted(self._values, value, side=side, sorter=sorter)",
                            "def append(self, to_append, ignore_index=False, verify_integrity=False):\n    \"\"\"\n    Concatenate two or more Series.\n\n    Parameters\n    ----------\n    to_append : Series or list/tuple of Series\n        Series to append with self.\n    ignore_index : bool, default False\n        If True, do not use the index labels.\n    verify_integrity : bool, default False\n        If True, raise Exception on creating index with duplicates.\n\n    Returns\n    -------\n    Series\n        Concatenated Series.\n\n    See Also\n    --------\n    concat : General function to concatenate DataFrame or Series objects.\n\n    Notes\n    -----\n    Iteratively appending to a Series can be more computationally intensive\n    than a single concatenate. A better solution is to append values to a\n    list and then concatenate the list with the original Series all at\n    once.\n\n    Examples\n    --------\n    >>> s1 = pd.Series([1, 2, 3])\n    >>> s2 = pd.Series([4, 5, 6])\n    >>> s3 = pd.Series([4, 5, 6], index=[3, 4, 5])\n    >>> s1.append(s2)\n    0    1\n    1    2\n    2    3\n    0    4\n    1    5\n    2    6\n    dtype: int64\n\n    >>> s1.append(s3)\n    0    1\n    1    2\n    2    3\n    3    4\n    4    5\n    5    6\n    dtype: int64\n\n    With `ignore_index` set to True:\n\n    >>> s1.append(s2, ignore_index=True)\n    0    1\n    1    2\n    2    3\n    3    4\n    4    5\n    5    6\n    dtype: int64\n\n    With `verify_integrity` set to True:\n\n    >>> s1.append(s2, verify_integrity=True)\n    Traceback (most recent call last):\n    ...\n    ValueError: Indexes have overlapping values: [0, 1, 2]\n    \"\"\"\n    from pandas.core.reshape.concat import concat\n    if isinstance(to_append, (list, tuple)):\n        to_concat = [self]\n        to_concat.extend(to_append)\n    else:\n        to_concat = [self, to_append]\n    if any((isinstance(x, (ABCDataFrame,)) for x in to_concat[1:])):\n        msg = 'to_append should be a Series or list/tuple of Series, got DataFrame'\n        raise TypeError(msg)\n    return concat(to_concat, ignore_index=ignore_index, verify_integrity=verify_integrity)",
                            "def _binop(self, other, func, level=None, fill_value=None):\n    \"\"\"\n    Perform generic binary operation with optional fill value.\n\n    Parameters\n    ----------\n    other : Series\n    func : binary operator\n    fill_value : float or object\n        Value to substitute for NA/null values. If both Series are NA in a\n        location, the result will be NA regardless of the passed fill value.\n    level : int or level name, default None\n        Broadcast across a level, matching Index values on the\n        passed MultiIndex level.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    if not isinstance(other, Series):\n        raise AssertionError('Other operand must be Series')\n    this = self\n    if not self.index.equals(other.index):\n        this, other = self.align(other, level=level, join='outer', copy=False)\n    this_vals, other_vals = ops.fill_binop(this.values, other.values, fill_value)\n    with np.errstate(all='ignore'):\n        result = func(this_vals, other_vals)\n    name = ops.get_op_result_name(self, other)\n    ret = this._construct_result(result, name)\n    return ret",
                            "def _construct_result(self, result: Union[ArrayLike, Tuple[ArrayLike, ArrayLike]], name: Label) -> Union['Series', Tuple['Series', 'Series']]:\n    \"\"\"\n    Construct an appropriately-labelled Series from the result of an op.\n\n    Parameters\n    ----------\n    result : ndarray or ExtensionArray\n    name : Label\n\n    Returns\n    -------\n    Series\n        In the case of __divmod__ or __rdivmod__, a 2-tuple of Series.\n    \"\"\"\n    if isinstance(result, tuple):\n        res1 = self._construct_result(result[0], name=name)\n        res2 = self._construct_result(result[1], name=name)\n        assert isinstance(res1, Series)\n        assert isinstance(res2, Series)\n        return (res1, res2)\n    out = self._constructor(result, index=self.index)\n    out = out.__finalize__(self)\n    out.name = name\n    return out",
                            "def combine(self, other, func, fill_value=None) -> 'Series':\n    \"\"\"\n    Combine the Series with a Series or scalar according to `func`.\n\n    Combine the Series and `other` using `func` to perform elementwise\n    selection for combined Series.\n    `fill_value` is assumed when value is missing at some index\n    from one of the two objects being combined.\n\n    Parameters\n    ----------\n    other : Series or scalar\n        The value(s) to be combined with the `Series`.\n    func : function\n        Function that takes two scalars as inputs and returns an element.\n    fill_value : scalar, optional\n        The value to assume when an index is missing from\n        one Series or the other. The default specifies to use the\n        appropriate NaN value for the underlying dtype of the Series.\n\n    Returns\n    -------\n    Series\n        The result of combining the Series with the other object.\n\n    See Also\n    --------\n    Series.combine_first : Combine Series values, choosing the calling\n        Series' values first.\n\n    Examples\n    --------\n    Consider 2 Datasets ``s1`` and ``s2`` containing\n    highest clocked speeds of different birds.\n\n    >>> s1 = pd.Series({'falcon': 330.0, 'eagle': 160.0})\n    >>> s1\n    falcon    330.0\n    eagle     160.0\n    dtype: float64\n    >>> s2 = pd.Series({'falcon': 345.0, 'eagle': 200.0, 'duck': 30.0})\n    >>> s2\n    falcon    345.0\n    eagle     200.0\n    duck       30.0\n    dtype: float64\n\n    Now, to combine the two datasets and view the highest speeds\n    of the birds across the two datasets\n\n    >>> s1.combine(s2, max)\n    duck        NaN\n    eagle     200.0\n    falcon    345.0\n    dtype: float64\n\n    In the previous example, the resulting value for duck is missing,\n    because the maximum of a NaN and a float is a NaN.\n    So, in the example, we set ``fill_value=0``,\n    so the maximum value returned will be the value from some dataset.\n\n    >>> s1.combine(s2, max, fill_value=0)\n    duck       30.0\n    eagle     200.0\n    falcon    345.0\n    dtype: float64\n    \"\"\"\n    if fill_value is None:\n        fill_value = na_value_for_dtype(self.dtype, compat=False)\n    if isinstance(other, Series):\n        new_index = self.index.union(other.index)\n        new_name = ops.get_op_result_name(self, other)\n        new_values = []\n        for idx in new_index:\n            lv = self.get(idx, fill_value)\n            rv = other.get(idx, fill_value)\n            with np.errstate(all='ignore'):\n                new_values.append(func(lv, rv))\n    else:\n        new_index = self.index\n        with np.errstate(all='ignore'):\n            new_values = [func(lv, other) for lv in self._values]\n        new_name = self.name\n    if is_categorical_dtype(self.dtype):\n        pass\n    elif is_extension_array_dtype(self.dtype):\n        new_values = maybe_cast_to_extension_array(type(self._values), new_values)\n    return self._constructor(new_values, index=new_index, name=new_name)",
                            "def combine_first(self, other) -> 'Series':\n    \"\"\"\n    Combine Series values, choosing the calling Series's values first.\n\n    Parameters\n    ----------\n    other : Series\n        The value(s) to be combined with the `Series`.\n\n    Returns\n    -------\n    Series\n        The result of combining the Series with the other object.\n\n    See Also\n    --------\n    Series.combine : Perform elementwise operation on two Series\n        using a given function.\n\n    Notes\n    -----\n    Result index will be the union of the two indexes.\n\n    Examples\n    --------\n    >>> s1 = pd.Series([1, np.nan])\n    >>> s2 = pd.Series([3, 4])\n    >>> s1.combine_first(s2)\n    0    1.0\n    1    4.0\n    dtype: float64\n    \"\"\"\n    new_index = self.index.union(other.index)\n    this = self.reindex(new_index, copy=False)\n    other = other.reindex(new_index, copy=False)\n    if this.dtype.kind == 'M' and other.dtype.kind != 'M':\n        other = to_datetime(other)\n    return this.where(notna(this), other)",
                            "def update(self, other) -> None:\n    \"\"\"\n    Modify Series in place using non-NA values from passed\n    Series. Aligns on index.\n\n    Parameters\n    ----------\n    other : Series, or object coercible into Series\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3])\n    >>> s.update(pd.Series([4, 5, 6]))\n    >>> s\n    0    4\n    1    5\n    2    6\n    dtype: int64\n\n    >>> s = pd.Series(['a', 'b', 'c'])\n    >>> s.update(pd.Series(['d', 'e'], index=[0, 2]))\n    >>> s\n    0    d\n    1    b\n    2    e\n    dtype: object\n\n    >>> s = pd.Series([1, 2, 3])\n    >>> s.update(pd.Series([4, 5, 6, 7, 8]))\n    >>> s\n    0    4\n    1    5\n    2    6\n    dtype: int64\n\n    If ``other`` contains NaNs the corresponding values are not updated\n    in the original Series.\n\n    >>> s = pd.Series([1, 2, 3])\n    >>> s.update(pd.Series([4, np.nan, 6]))\n    >>> s\n    0    4\n    1    2\n    2    6\n    dtype: int64\n\n    ``other`` can also be a non-Series object type\n    that is coercible into a Series\n\n    >>> s = pd.Series([1, 2, 3])\n    >>> s.update([4, np.nan, 6])\n    >>> s\n    0    4\n    1    2\n    2    6\n    dtype: int64\n\n    >>> s = pd.Series([1, 2, 3])\n    >>> s.update({1: 9})\n    >>> s\n    0    1\n    1    9\n    2    3\n    dtype: int64\n    \"\"\"\n    if not isinstance(other, Series):\n        other = Series(other)\n    other = other.reindex_like(self)\n    mask = notna(other)\n    self._mgr = self._mgr.putmask(mask=mask, new=other)\n    self._maybe_update_cacher()",
                            "def sort_values(self, axis=0, ascending=True, inplace: bool=False, kind: str='quicksort', na_position: str='last', ignore_index: bool=False, key: ValueKeyFunc=None):\n    \"\"\"\n    Sort by the values.\n\n    Sort a Series in ascending or descending order by some\n    criterion.\n\n    Parameters\n    ----------\n    axis : {0 or 'index'}, default 0\n        Axis to direct sorting. The value 'index' is accepted for\n        compatibility with DataFrame.sort_values.\n    ascending : bool, default True\n        If True, sort values in ascending order, otherwise descending.\n    inplace : bool, default False\n        If True, perform operation in-place.\n    kind : {'quicksort', 'mergesort' or 'heapsort'}, default 'quicksort'\n        Choice of sorting algorithm. See also :func:`numpy.sort` for more\n        information. 'mergesort' is the only stable  algorithm.\n    na_position : {'first' or 'last'}, default 'last'\n        Argument 'first' puts NaNs at the beginning, 'last' puts NaNs at\n        the end.\n    ignore_index : bool, default False\n        If True, the resulting axis will be labeled 0, 1, \u2026, n - 1.\n\n        .. versionadded:: 1.0.0\n\n    key : callable, optional\n        If not None, apply the key function to the series values\n        before sorting. This is similar to the `key` argument in the\n        builtin :meth:`sorted` function, with the notable difference that\n        this `key` function should be *vectorized*. It should expect a\n        ``Series`` and return an array-like.\n\n        .. versionadded:: 1.1.0\n\n    Returns\n    -------\n    Series\n        Series ordered by values.\n\n    See Also\n    --------\n    Series.sort_index : Sort by the Series indices.\n    DataFrame.sort_values : Sort DataFrame by the values along either axis.\n    DataFrame.sort_index : Sort DataFrame by indices.\n\n    Examples\n    --------\n    >>> s = pd.Series([np.nan, 1, 3, 10, 5])\n    >>> s\n    0     NaN\n    1     1.0\n    2     3.0\n    3     10.0\n    4     5.0\n    dtype: float64\n\n    Sort values ascending order (default behaviour)\n\n    >>> s.sort_values(ascending=True)\n    1     1.0\n    2     3.0\n    4     5.0\n    3    10.0\n    0     NaN\n    dtype: float64\n\n    Sort values descending order\n\n    >>> s.sort_values(ascending=False)\n    3    10.0\n    4     5.0\n    2     3.0\n    1     1.0\n    0     NaN\n    dtype: float64\n\n    Sort values inplace\n\n    >>> s.sort_values(ascending=False, inplace=True)\n    >>> s\n    3    10.0\n    4     5.0\n    2     3.0\n    1     1.0\n    0     NaN\n    dtype: float64\n\n    Sort values putting NAs first\n\n    >>> s.sort_values(na_position='first')\n    0     NaN\n    1     1.0\n    2     3.0\n    4     5.0\n    3    10.0\n    dtype: float64\n\n    Sort a series of strings\n\n    >>> s = pd.Series(['z', 'b', 'd', 'a', 'c'])\n    >>> s\n    0    z\n    1    b\n    2    d\n    3    a\n    4    c\n    dtype: object\n\n    >>> s.sort_values()\n    3    a\n    1    b\n    4    c\n    2    d\n    0    z\n    dtype: object\n\n    Sort using a key function. Your `key` function will be\n    given the ``Series`` of values and should return an array-like.\n\n    >>> s = pd.Series(['a', 'B', 'c', 'D', 'e'])\n    >>> s.sort_values()\n    1    B\n    3    D\n    0    a\n    2    c\n    4    e\n    dtype: object\n    >>> s.sort_values(key=lambda x: x.str.lower())\n    0    a\n    1    B\n    2    c\n    3    D\n    4    e\n    dtype: object\n\n    NumPy ufuncs work well here. For example, we can\n    sort by the ``sin`` of the value\n\n    >>> s = pd.Series([-4, -2, 0, 2, 4])\n    >>> s.sort_values(key=np.sin)\n    1   -2\n    4    4\n    2    0\n    0   -4\n    3    2\n    dtype: int64\n\n    More complicated user-defined functions can be used,\n    as long as they expect a Series and return an array-like\n\n    >>> s.sort_values(key=lambda x: (np.tan(x.cumsum())))\n    0   -4\n    3    2\n    4    4\n    1   -2\n    2    0\n    dtype: int64\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    self._get_axis_number(axis)\n    if inplace and self._is_cached:\n        raise ValueError('This Series is a view of some other array, to sort in-place you must create a copy')\n\n    def _try_kind_sort(arr):\n        arr = ensure_key_mapped(arr, key)\n        arr = getattr(arr, '_values', arr)\n        try:\n            return arr.argsort(kind=kind)\n        except TypeError:\n            return arr.argsort(kind='quicksort')\n    arr = self._values\n    sorted_index = np.empty(len(self), dtype=np.int32)\n    bad = isna(arr)\n    good = ~bad\n    idx = ibase.default_index(len(self))\n    argsorted = _try_kind_sort(self[good])\n    if is_list_like(ascending):\n        if len(ascending) != 1:\n            raise ValueError(f'Length of ascending ({len(ascending)}) must be 1 for Series')\n        ascending = ascending[0]\n    if not is_bool(ascending):\n        raise ValueError('ascending must be boolean')\n    if not ascending:\n        argsorted = argsorted[::-1]\n    if na_position == 'last':\n        n = good.sum()\n        sorted_index[:n] = idx[good][argsorted]\n        sorted_index[n:] = idx[bad]\n    elif na_position == 'first':\n        n = bad.sum()\n        sorted_index[n:] = idx[good][argsorted]\n        sorted_index[:n] = idx[bad]\n    else:\n        raise ValueError(f'invalid na_position: {na_position}')\n    result = self._constructor(arr[sorted_index], index=self.index[sorted_index])\n    if ignore_index:\n        result.index = ibase.default_index(len(sorted_index))\n    if inplace:\n        self._update_inplace(result)\n    else:\n        return result.__finalize__(self, method='sort_values')",
                            "def sort_index(self, axis=0, level=None, ascending: bool=True, inplace: bool=False, kind: str='quicksort', na_position: str='last', sort_remaining: bool=True, ignore_index: bool=False, key: IndexKeyFunc=None):\n    \"\"\"\n    Sort Series by index labels.\n\n    Returns a new Series sorted by label if `inplace` argument is\n    ``False``, otherwise updates the original series and returns None.\n\n    Parameters\n    ----------\n    axis : int, default 0\n        Axis to direct sorting. This can only be 0 for Series.\n    level : int, optional\n        If not None, sort on values in specified index level(s).\n    ascending : bool or list of bools, default True\n        Sort ascending vs. descending. When the index is a MultiIndex the\n        sort direction can be controlled for each level individually.\n    inplace : bool, default False\n        If True, perform operation in-place.\n    kind : {'quicksort', 'mergesort', 'heapsort'}, default 'quicksort'\n        Choice of sorting algorithm. See also :func:`numpy.sort` for more\n        information.  'mergesort' is the only stable algorithm. For\n        DataFrames, this option is only applied when sorting on a single\n        column or label.\n    na_position : {'first', 'last'}, default 'last'\n        If 'first' puts NaNs at the beginning, 'last' puts NaNs at the end.\n        Not implemented for MultiIndex.\n    sort_remaining : bool, default True\n        If True and sorting by level and index is multilevel, sort by other\n        levels too (in order) after sorting by specified level.\n    ignore_index : bool, default False\n        If True, the resulting axis will be labeled 0, 1, \u2026, n - 1.\n\n        .. versionadded:: 1.0.0\n\n    key : callable, optional\n        If not None, apply the key function to the index values\n        before sorting. This is similar to the `key` argument in the\n        builtin :meth:`sorted` function, with the notable difference that\n        this `key` function should be *vectorized*. It should expect an\n        ``Index`` and return an ``Index`` of the same shape.\n\n        .. versionadded:: 1.1.0\n\n    Returns\n    -------\n    Series\n        The original Series sorted by the labels.\n\n    See Also\n    --------\n    DataFrame.sort_index: Sort DataFrame by the index.\n    DataFrame.sort_values: Sort DataFrame by the value.\n    Series.sort_values : Sort Series by the value.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'b', 'c', 'd'], index=[3, 2, 1, 4])\n    >>> s.sort_index()\n    1    c\n    2    b\n    3    a\n    4    d\n    dtype: object\n\n    Sort Descending\n\n    >>> s.sort_index(ascending=False)\n    4    d\n    3    a\n    2    b\n    1    c\n    dtype: object\n\n    Sort Inplace\n\n    >>> s.sort_index(inplace=True)\n    >>> s\n    1    c\n    2    b\n    3    a\n    4    d\n    dtype: object\n\n    By default NaNs are put at the end, but use `na_position` to place\n    them at the beginning\n\n    >>> s = pd.Series(['a', 'b', 'c', 'd'], index=[3, 2, 1, np.nan])\n    >>> s.sort_index(na_position='first')\n    NaN     d\n     1.0    c\n     2.0    b\n     3.0    a\n    dtype: object\n\n    Specify index level to sort\n\n    >>> arrays = [np.array(['qux', 'qux', 'foo', 'foo',\n    ...                     'baz', 'baz', 'bar', 'bar']),\n    ...           np.array(['two', 'one', 'two', 'one',\n    ...                     'two', 'one', 'two', 'one'])]\n    >>> s = pd.Series([1, 2, 3, 4, 5, 6, 7, 8], index=arrays)\n    >>> s.sort_index(level=1)\n    bar  one    8\n    baz  one    6\n    foo  one    4\n    qux  one    2\n    bar  two    7\n    baz  two    5\n    foo  two    3\n    qux  two    1\n    dtype: int64\n\n    Does not sort by remaining levels when sorting by levels\n\n    >>> s.sort_index(level=1, sort_remaining=False)\n    qux  one    2\n    foo  one    4\n    baz  one    6\n    bar  one    8\n    qux  two    1\n    foo  two    3\n    baz  two    5\n    bar  two    7\n    dtype: int64\n\n    Apply a key function before sorting\n\n    >>> s = pd.Series([1, 2, 3, 4], index=['A', 'b', 'C', 'd'])\n    >>> s.sort_index(key=lambda x : x.str.lower())\n    A    1\n    b    2\n    C    3\n    d    4\n    dtype: int64\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    self._get_axis_number(axis)\n    index = ensure_key_mapped(self.index, key, levels=level)\n    if level is not None:\n        new_index, indexer = index.sortlevel(level, ascending=ascending, sort_remaining=sort_remaining)\n    elif isinstance(index, MultiIndex):\n        from pandas.core.sorting import lexsort_indexer\n        labels = index._sort_levels_monotonic()\n        indexer = lexsort_indexer(labels._get_codes_for_sorting(), orders=ascending, na_position=na_position)\n    else:\n        from pandas.core.sorting import nargsort\n        if ascending and index.is_monotonic_increasing or (not ascending and index.is_monotonic_decreasing):\n            if inplace:\n                return\n            else:\n                return self.copy()\n        indexer = nargsort(index, kind=kind, ascending=ascending, na_position=na_position)\n    indexer = ensure_platform_int(indexer)\n    new_index = self.index.take(indexer)\n    new_index = new_index._sort_levels_monotonic()\n    new_values = self._values.take(indexer)\n    result = self._constructor(new_values, index=new_index)\n    if ignore_index:\n        result.index = ibase.default_index(len(result))\n    if inplace:\n        self._update_inplace(result)\n    else:\n        return result.__finalize__(self, method='sort_index')",
                            "def argsort(self, axis=0, kind='quicksort', order=None) -> 'Series':\n    \"\"\"\n    Override ndarray.argsort. Argsorts the value, omitting NA/null values,\n    and places the result in the same locations as the non-NA values.\n\n    Parameters\n    ----------\n    axis : {0 or \"index\"}\n        Has no effect but is accepted for compatibility with numpy.\n    kind : {'mergesort', 'quicksort', 'heapsort'}, default 'quicksort'\n        Choice of sorting algorithm. See np.sort for more\n        information. 'mergesort' is the only stable algorithm.\n    order : None\n        Has no effect but is accepted for compatibility with numpy.\n\n    Returns\n    -------\n    Series\n        Positions of values within the sort order with -1 indicating\n        nan values.\n\n    See Also\n    --------\n    numpy.ndarray.argsort : Returns the indices that would sort this array.\n    \"\"\"\n    values = self._values\n    mask = isna(values)\n    if mask.any():\n        result = Series(-1, index=self.index, name=self.name, dtype='int64')\n        notmask = ~mask\n        result[notmask] = np.argsort(values[notmask], kind=kind)\n        return self._constructor(result, index=self.index).__finalize__(self, method='argsort')\n    else:\n        return self._constructor(np.argsort(values, kind=kind), index=self.index, dtype='int64').__finalize__(self, method='argsort')",
                            "def nlargest(self, n=5, keep='first') -> 'Series':\n    \"\"\"\n    Return the largest `n` elements.\n\n    Parameters\n    ----------\n    n : int, default 5\n        Return this many descending sorted values.\n    keep : {'first', 'last', 'all'}, default 'first'\n        When there are duplicate values that cannot all fit in a\n        Series of `n` elements:\n\n        - ``first`` : return the first `n` occurrences in order\n            of appearance.\n        - ``last`` : return the last `n` occurrences in reverse\n            order of appearance.\n        - ``all`` : keep all occurrences. This can result in a Series of\n            size larger than `n`.\n\n    Returns\n    -------\n    Series\n        The `n` largest values in the Series, sorted in decreasing order.\n\n    See Also\n    --------\n    Series.nsmallest: Get the `n` smallest elements.\n    Series.sort_values: Sort Series by values.\n    Series.head: Return the first `n` rows.\n\n    Notes\n    -----\n    Faster than ``.sort_values(ascending=False).head(n)`` for small `n`\n    relative to the size of the ``Series`` object.\n\n    Examples\n    --------\n    >>> countries_population = {\"Italy\": 59000000, \"France\": 65000000,\n    ...                         \"Malta\": 434000, \"Maldives\": 434000,\n    ...                         \"Brunei\": 434000, \"Iceland\": 337000,\n    ...                         \"Nauru\": 11300, \"Tuvalu\": 11300,\n    ...                         \"Anguilla\": 11300, \"Montserrat\": 5200}\n    >>> s = pd.Series(countries_population)\n    >>> s\n    Italy       59000000\n    France      65000000\n    Malta         434000\n    Maldives      434000\n    Brunei        434000\n    Iceland       337000\n    Nauru          11300\n    Tuvalu         11300\n    Anguilla       11300\n    Montserrat      5200\n    dtype: int64\n\n    The `n` largest elements where ``n=5`` by default.\n\n    >>> s.nlargest()\n    France      65000000\n    Italy       59000000\n    Malta         434000\n    Maldives      434000\n    Brunei        434000\n    dtype: int64\n\n    The `n` largest elements where ``n=3``. Default `keep` value is 'first'\n    so Malta will be kept.\n\n    >>> s.nlargest(3)\n    France    65000000\n    Italy     59000000\n    Malta       434000\n    dtype: int64\n\n    The `n` largest elements where ``n=3`` and keeping the last duplicates.\n    Brunei will be kept since it is the last with value 434000 based on\n    the index order.\n\n    >>> s.nlargest(3, keep='last')\n    France      65000000\n    Italy       59000000\n    Brunei        434000\n    dtype: int64\n\n    The `n` largest elements where ``n=3`` with all duplicates kept. Note\n    that the returned Series has five elements due to the three duplicates.\n\n    >>> s.nlargest(3, keep='all')\n    France      65000000\n    Italy       59000000\n    Malta         434000\n    Maldives      434000\n    Brunei        434000\n    dtype: int64\n    \"\"\"\n    return algorithms.SelectNSeries(self, n=n, keep=keep).nlargest()",
                            "def nsmallest(self, n=5, keep='first') -> 'Series':\n    \"\"\"\n    Return the smallest `n` elements.\n\n    Parameters\n    ----------\n    n : int, default 5\n        Return this many ascending sorted values.\n    keep : {'first', 'last', 'all'}, default 'first'\n        When there are duplicate values that cannot all fit in a\n        Series of `n` elements:\n\n        - ``first`` : return the first `n` occurrences in order\n            of appearance.\n        - ``last`` : return the last `n` occurrences in reverse\n            order of appearance.\n        - ``all`` : keep all occurrences. This can result in a Series of\n            size larger than `n`.\n\n    Returns\n    -------\n    Series\n        The `n` smallest values in the Series, sorted in increasing order.\n\n    See Also\n    --------\n    Series.nlargest: Get the `n` largest elements.\n    Series.sort_values: Sort Series by values.\n    Series.head: Return the first `n` rows.\n\n    Notes\n    -----\n    Faster than ``.sort_values().head(n)`` for small `n` relative to\n    the size of the ``Series`` object.\n\n    Examples\n    --------\n    >>> countries_population = {\"Italy\": 59000000, \"France\": 65000000,\n    ...                         \"Brunei\": 434000, \"Malta\": 434000,\n    ...                         \"Maldives\": 434000, \"Iceland\": 337000,\n    ...                         \"Nauru\": 11300, \"Tuvalu\": 11300,\n    ...                         \"Anguilla\": 11300, \"Montserrat\": 5200}\n    >>> s = pd.Series(countries_population)\n    >>> s\n    Italy       59000000\n    France      65000000\n    Brunei        434000\n    Malta         434000\n    Maldives      434000\n    Iceland       337000\n    Nauru          11300\n    Tuvalu         11300\n    Anguilla       11300\n    Montserrat      5200\n    dtype: int64\n\n    The `n` smallest elements where ``n=5`` by default.\n\n    >>> s.nsmallest()\n    Montserrat    5200\n    Nauru        11300\n    Tuvalu       11300\n    Anguilla     11300\n    Iceland     337000\n    dtype: int64\n\n    The `n` smallest elements where ``n=3``. Default `keep` value is\n    'first' so Nauru and Tuvalu will be kept.\n\n    >>> s.nsmallest(3)\n    Montserrat   5200\n    Nauru       11300\n    Tuvalu      11300\n    dtype: int64\n\n    The `n` smallest elements where ``n=3`` and keeping the last\n    duplicates. Anguilla and Tuvalu will be kept since they are the last\n    with value 11300 based on the index order.\n\n    >>> s.nsmallest(3, keep='last')\n    Montserrat   5200\n    Anguilla    11300\n    Tuvalu      11300\n    dtype: int64\n\n    The `n` smallest elements where ``n=3`` with all duplicates kept. Note\n    that the returned Series has four elements due to the three duplicates.\n\n    >>> s.nsmallest(3, keep='all')\n    Montserrat   5200\n    Nauru       11300\n    Tuvalu      11300\n    Anguilla    11300\n    dtype: int64\n    \"\"\"\n    return algorithms.SelectNSeries(self, n=n, keep=keep).nsmallest()",
                            "def swaplevel(self, i=-2, j=-1, copy=True) -> 'Series':\n    \"\"\"\n    Swap levels i and j in a :class:`MultiIndex`.\n\n    Default is to swap the two innermost levels of the index.\n\n    Parameters\n    ----------\n    i, j : int, str\n        Level of the indices to be swapped. Can pass level name as string.\n    copy : bool, default True\n        Whether to copy underlying data.\n\n    Returns\n    -------\n    Series\n        Series with levels swapped in MultiIndex.\n    \"\"\"\n    assert isinstance(self.index, MultiIndex)\n    new_index = self.index.swaplevel(i, j)\n    return self._constructor(self._values, index=new_index, copy=copy).__finalize__(self, method='swaplevel')",
                            "def reorder_levels(self, order) -> 'Series':\n    \"\"\"\n    Rearrange index levels using input order.\n\n    May not drop or duplicate levels.\n\n    Parameters\n    ----------\n    order : list of int representing new level order\n        Reference level by number or key.\n\n    Returns\n    -------\n    type of caller (new object)\n    \"\"\"\n    if not isinstance(self.index, MultiIndex):\n        raise Exception('Can only reorder levels on a hierarchical axis.')\n    result = self.copy()\n    assert isinstance(result.index, MultiIndex)\n    result.index = result.index.reorder_levels(order)\n    return result",
                            "def explode(self) -> 'Series':\n    \"\"\"\n    Transform each element of a list-like to a row, replicating the\n    index values.\n\n    .. versionadded:: 0.25.0\n\n    Returns\n    -------\n    Series\n        Exploded lists to rows; index will be duplicated for these rows.\n\n    See Also\n    --------\n    Series.str.split : Split string values on specified separator.\n    Series.unstack : Unstack, a.k.a. pivot, Series with MultiIndex\n        to produce DataFrame.\n    DataFrame.melt : Unpivot a DataFrame from wide format to long format.\n    DataFrame.explode : Explode a DataFrame from list-like\n        columns to long format.\n\n    Notes\n    -----\n    This routine will explode list-likes including lists, tuples,\n    Series, and np.ndarray. The result dtype of the subset rows will\n    be object. Scalars will be returned unchanged. Empty list-likes will\n    result in a np.nan for that row.\n\n    Examples\n    --------\n    >>> s = pd.Series([[1, 2, 3], 'foo', [], [3, 4]])\n    >>> s\n    0    [1, 2, 3]\n    1          foo\n    2           []\n    3       [3, 4]\n    dtype: object\n\n    >>> s.explode()\n    0      1\n    0      2\n    0      3\n    1    foo\n    2    NaN\n    3      3\n    3      4\n    dtype: object\n    \"\"\"\n    if not len(self) or not is_object_dtype(self):\n        return self.copy()\n    values, counts = reshape.explode(np.asarray(self.array))\n    result = self._constructor(values, index=self.index.repeat(counts), name=self.name)\n    return result",
                            "def unstack(self, level=-1, fill_value=None):\n    \"\"\"\n    Unstack, also known as pivot, Series with MultiIndex to produce DataFrame.\n    The level involved will automatically get sorted.\n\n    Parameters\n    ----------\n    level : int, str, or list of these, default last level\n        Level(s) to unstack, can pass level name.\n    fill_value : scalar value, default None\n        Value to use when replacing NaN values.\n\n    Returns\n    -------\n    DataFrame\n        Unstacked Series.\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3, 4],\n    ...               index=pd.MultiIndex.from_product([['one', 'two'],\n    ...                                                 ['a', 'b']]))\n    >>> s\n    one  a    1\n         b    2\n    two  a    3\n         b    4\n    dtype: int64\n\n    >>> s.unstack(level=-1)\n         a  b\n    one  1  2\n    two  3  4\n\n    >>> s.unstack(level=0)\n       one  two\n    a    1    3\n    b    2    4\n    \"\"\"\n    from pandas.core.reshape.reshape import unstack\n    return unstack(self, level, fill_value)",
                            "def map(self, arg, na_action=None) -> 'Series':\n    \"\"\"\n    Map values of Series according to input correspondence.\n\n    Used for substituting each value in a Series with another value,\n    that may be derived from a function, a ``dict`` or\n    a :class:`Series`.\n\n    Parameters\n    ----------\n    arg : function, collections.abc.Mapping subclass or Series\n        Mapping correspondence.\n    na_action : {None, 'ignore'}, default None\n        If 'ignore', propagate NaN values, without passing them to the\n        mapping correspondence.\n\n    Returns\n    -------\n    Series\n        Same index as caller.\n\n    See Also\n    --------\n    Series.apply : For applying more complex functions on a Series.\n    DataFrame.apply : Apply a function row-/column-wise.\n    DataFrame.applymap : Apply a function elementwise on a whole DataFrame.\n\n    Notes\n    -----\n    When ``arg`` is a dictionary, values in Series that are not in the\n    dictionary (as keys) are converted to ``NaN``. However, if the\n    dictionary is a ``dict`` subclass that defines ``__missing__`` (i.e.\n    provides a method for default values), then this default is used\n    rather than ``NaN``.\n\n    Examples\n    --------\n    >>> s = pd.Series(['cat', 'dog', np.nan, 'rabbit'])\n    >>> s\n    0      cat\n    1      dog\n    2      NaN\n    3   rabbit\n    dtype: object\n\n    ``map`` accepts a ``dict`` or a ``Series``. Values that are not found\n    in the ``dict`` are converted to ``NaN``, unless the dict has a default\n    value (e.g. ``defaultdict``):\n\n    >>> s.map({'cat': 'kitten', 'dog': 'puppy'})\n    0   kitten\n    1    puppy\n    2      NaN\n    3      NaN\n    dtype: object\n\n    It also accepts a function:\n\n    >>> s.map('I am a {}'.format)\n    0       I am a cat\n    1       I am a dog\n    2       I am a nan\n    3    I am a rabbit\n    dtype: object\n\n    To avoid applying the function to missing values (and keep them as\n    ``NaN``) ``na_action='ignore'`` can be used:\n\n    >>> s.map('I am a {}'.format, na_action='ignore')\n    0     I am a cat\n    1     I am a dog\n    2            NaN\n    3  I am a rabbit\n    dtype: object\n    \"\"\"\n    new_values = super()._map_values(arg, na_action=na_action)\n    return self._constructor(new_values, index=self.index).__finalize__(self, method='map')",
                            "def _gotitem(self, key, ndim, subset=None) -> 'Series':\n    \"\"\"\n    Sub-classes to define. Return a sliced object.\n\n    Parameters\n    ----------\n    key : string / list of selections\n    ndim : 1,2\n        Requested ndim of result.\n    subset : object, default None\n        Subset to act on.\n    \"\"\"\n    return self",
                            "@Substitution(see_also=_agg_see_also_doc, examples=_agg_examples_doc, versionadded='\\n.. versionadded:: 0.20.0\\n', **_shared_doc_kwargs)\n@Appender(generic._shared_docs['aggregate'])\ndef aggregate(self, func, axis=0, *args, **kwargs):\n    self._get_axis_number(axis)\n    result, how = self._aggregate(func, *args, **kwargs)\n    if result is None:\n        kwargs.pop('_axis', None)\n        kwargs.pop('_level', None)\n        try:\n            result = self.apply(func, *args, **kwargs)\n        except (ValueError, AttributeError, TypeError):\n            result = func(self, *args, **kwargs)\n    return result",
                            "@Appender(generic._shared_docs['transform'] % _shared_doc_kwargs)\ndef transform(self, func, axis=0, *args, **kwargs):\n    self._get_axis_number(axis)\n    return super().transform(func, *args, **kwargs)",
                            "def apply(self, func, convert_dtype=True, args=(), **kwds):\n    \"\"\"\n    Invoke function on values of Series.\n\n    Can be ufunc (a NumPy function that applies to the entire Series)\n    or a Python function that only works on single values.\n\n    Parameters\n    ----------\n    func : function\n        Python function or NumPy ufunc to apply.\n    convert_dtype : bool, default True\n        Try to find better dtype for elementwise function results. If\n        False, leave as dtype=object.\n    args : tuple\n        Positional arguments passed to func after the series value.\n    **kwds\n        Additional keyword arguments passed to func.\n\n    Returns\n    -------\n    Series or DataFrame\n        If func returns a Series object the result will be a DataFrame.\n\n    See Also\n    --------\n    Series.map: For element-wise operations.\n    Series.agg: Only perform aggregating type operations.\n    Series.transform: Only perform transforming type operations.\n\n    Examples\n    --------\n    Create a series with typical summer temperatures for each city.\n\n    >>> s = pd.Series([20, 21, 12],\n    ...               index=['London', 'New York', 'Helsinki'])\n    >>> s\n    London      20\n    New York    21\n    Helsinki    12\n    dtype: int64\n\n    Square the values by defining a function and passing it as an\n    argument to ``apply()``.\n\n    >>> def square(x):\n    ...     return x ** 2\n    >>> s.apply(square)\n    London      400\n    New York    441\n    Helsinki    144\n    dtype: int64\n\n    Square the values by passing an anonymous function as an\n    argument to ``apply()``.\n\n    >>> s.apply(lambda x: x ** 2)\n    London      400\n    New York    441\n    Helsinki    144\n    dtype: int64\n\n    Define a custom function that needs additional positional\n    arguments and pass these additional arguments using the\n    ``args`` keyword.\n\n    >>> def subtract_custom_value(x, custom_value):\n    ...     return x - custom_value\n\n    >>> s.apply(subtract_custom_value, args=(5,))\n    London      15\n    New York    16\n    Helsinki     7\n    dtype: int64\n\n    Define a custom function that takes keyword arguments\n    and pass these arguments to ``apply``.\n\n    >>> def add_custom_values(x, **kwargs):\n    ...     for month in kwargs:\n    ...         x += kwargs[month]\n    ...     return x\n\n    >>> s.apply(add_custom_values, june=30, july=20, august=25)\n    London      95\n    New York    96\n    Helsinki    87\n    dtype: int64\n\n    Use a function from the Numpy library.\n\n    >>> s.apply(np.log)\n    London      2.995732\n    New York    3.044522\n    Helsinki    2.484907\n    dtype: float64\n    \"\"\"\n    if len(self) == 0:\n        return self._constructor(dtype=self.dtype, index=self.index).__finalize__(self, method='apply')\n    if isinstance(func, (list, dict)):\n        return self.aggregate(func, *args, **kwds)\n    if isinstance(func, str):\n        return self._try_aggregate_string_function(func, *args, **kwds)\n    if kwds or (args and (not isinstance(func, np.ufunc))):\n\n        def f(x):\n            return func(x, *args, **kwds)\n    else:\n        f = func\n    with np.errstate(all='ignore'):\n        if isinstance(f, np.ufunc):\n            return f(self)\n        if is_extension_array_dtype(self.dtype) and hasattr(self._values, 'map'):\n            mapped = self._values.map(f)\n        else:\n            values = self.astype(object)._values\n            mapped = lib.map_infer(values, f, convert=convert_dtype)\n    if len(mapped) and isinstance(mapped[0], Series):\n        return self._constructor_expanddim(pd.array(mapped), index=self.index)\n    else:\n        return self._constructor(mapped, index=self.index).__finalize__(self, method='apply')",
                            "def _reduce(self, op, name, axis=0, skipna=True, numeric_only=None, filter_type=None, **kwds):\n    \"\"\"\n    Perform a reduction operation.\n\n    If we have an ndarray as a value, then simply perform the operation,\n    otherwise delegate to the object.\n    \"\"\"\n    delegate = self._values\n    if axis is not None:\n        self._get_axis_number(axis)\n    if isinstance(delegate, ExtensionArray):\n        return delegate._reduce(name, skipna=skipna, **kwds)\n    else:\n        if numeric_only:\n            raise NotImplementedError(f'Series.{name} does not implement numeric_only.')\n        with np.errstate(all='ignore'):\n            return op(delegate, skipna=skipna, **kwds)",
                            "def _reindex_indexer(self, new_index, indexer, copy):\n    if indexer is None:\n        if copy:\n            return self.copy()\n        return self\n    new_values = algorithms.take_1d(self._values, indexer, allow_fill=True, fill_value=None)\n    return self._constructor(new_values, index=new_index)",
                            "def _needs_reindex_multi(self, axes, method, level):\n    \"\"\"\n    Check if we do need a multi reindex; this is for compat with\n    higher dims.\n    \"\"\"\n    return False",
                            "@doc(NDFrame.align, **_shared_doc_kwargs)\ndef align(self, other, join='outer', axis=None, level=None, copy=True, fill_value=None, method=None, limit=None, fill_axis=0, broadcast_axis=None):\n    return super().align(other, join=join, axis=axis, level=level, copy=copy, fill_value=fill_value, method=method, limit=limit, fill_axis=fill_axis, broadcast_axis=broadcast_axis)",
                            "def rename(self, index=None, *, axis=None, copy=True, inplace=False, level=None, errors='ignore'):\n    \"\"\"\n    Alter Series index labels or name.\n\n    Function / dict values must be unique (1-to-1). Labels not contained in\n    a dict / Series will be left as-is. Extra labels listed don't throw an\n    error.\n\n    Alternatively, change ``Series.name`` with a scalar value.\n\n    See the :ref:`user guide <basics.rename>` for more.\n\n    Parameters\n    ----------\n    axis : {0 or \"index\"}\n        Unused. Accepted for compatibility with DataFrame method only.\n    index : scalar, hashable sequence, dict-like or function, optional\n        Functions or dict-like are transformations to apply to\n        the index.\n        Scalar or hashable sequence-like will alter the ``Series.name``\n        attribute.\n\n    **kwargs\n        Additional keyword arguments passed to the function. Only the\n        \"inplace\" keyword is used.\n\n    Returns\n    -------\n    Series\n        Series with index labels or name altered.\n\n    See Also\n    --------\n    DataFrame.rename : Corresponding DataFrame method.\n    Series.rename_axis : Set the name of the axis.\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3])\n    >>> s\n    0    1\n    1    2\n    2    3\n    dtype: int64\n    >>> s.rename(\"my_name\")  # scalar, changes Series.name\n    0    1\n    1    2\n    2    3\n    Name: my_name, dtype: int64\n    >>> s.rename(lambda x: x ** 2)  # function, changes labels\n    0    1\n    1    2\n    4    3\n    dtype: int64\n    >>> s.rename({1: 3, 2: 5})  # mapping, changes labels\n    0    1\n    3    2\n    5    3\n    dtype: int64\n    \"\"\"\n    if callable(index) or is_dict_like(index):\n        return super().rename(index, copy=copy, inplace=inplace, level=level, errors=errors)\n    else:\n        return self._set_name(index, inplace=inplace)",
                            "@Appender(\"\\n        Examples\\n        --------\\n        >>> s = pd.Series([1, 2, 3])\\n        >>> s\\n        0    1\\n        1    2\\n        2    3\\n        dtype: int64\\n\\n        >>> s.set_axis(['a', 'b', 'c'], axis=0)\\n        a    1\\n        b    2\\n        c    3\\n        dtype: int64\\n    \")\n@Substitution(**_shared_doc_kwargs, extended_summary_sub='', axis_description_sub='', see_also_sub='')\n@Appender(generic.NDFrame.set_axis.__doc__)\ndef set_axis(self, labels, axis: Axis=0, inplace: bool=False):\n    return super().set_axis(labels, axis=axis, inplace=inplace)",
                            "@Substitution(**_shared_doc_kwargs)\n@Appender(generic.NDFrame.reindex.__doc__)\ndef reindex(self, index=None, **kwargs):\n    return super().reindex(index=index, **kwargs)",
                            "def drop(self, labels=None, axis=0, index=None, columns=None, level=None, inplace=False, errors='raise') -> 'Series':\n    \"\"\"\n    Return Series with specified index labels removed.\n\n    Remove elements of a Series based on specifying the index labels.\n    When using a multi-index, labels on different levels can be removed\n    by specifying the level.\n\n    Parameters\n    ----------\n    labels : single label or list-like\n        Index labels to drop.\n    axis : 0, default 0\n        Redundant for application on Series.\n    index : single label or list-like\n        Redundant for application on Series, but 'index' can be used instead\n        of 'labels'.\n    columns : single label or list-like\n        No change is made to the Series; use 'index' or 'labels' instead.\n    level : int or level name, optional\n        For MultiIndex, level for which the labels will be removed.\n    inplace : bool, default False\n        If True, do operation inplace and return None.\n    errors : {'ignore', 'raise'}, default 'raise'\n        If 'ignore', suppress error and only existing labels are dropped.\n\n    Returns\n    -------\n    Series\n        Series with specified index labels removed.\n\n    Raises\n    ------\n    KeyError\n        If none of the labels are found in the index.\n\n    See Also\n    --------\n    Series.reindex : Return only specified index labels of Series.\n    Series.dropna : Return series without null values.\n    Series.drop_duplicates : Return Series with duplicate values removed.\n    DataFrame.drop : Drop specified labels from rows or columns.\n\n    Examples\n    --------\n    >>> s = pd.Series(data=np.arange(3), index=['A', 'B', 'C'])\n    >>> s\n    A  0\n    B  1\n    C  2\n    dtype: int64\n\n    Drop labels B en C\n\n    >>> s.drop(labels=['B', 'C'])\n    A  0\n    dtype: int64\n\n    Drop 2nd level label in MultiIndex Series\n\n    >>> midx = pd.MultiIndex(levels=[['lama', 'cow', 'falcon'],\n    ...                              ['speed', 'weight', 'length']],\n    ...                      codes=[[0, 0, 0, 1, 1, 1, 2, 2, 2],\n    ...                             [0, 1, 2, 0, 1, 2, 0, 1, 2]])\n    >>> s = pd.Series([45, 200, 1.2, 30, 250, 1.5, 320, 1, 0.3],\n    ...               index=midx)\n    >>> s\n    lama    speed      45.0\n            weight    200.0\n            length      1.2\n    cow     speed      30.0\n            weight    250.0\n            length      1.5\n    falcon  speed     320.0\n            weight      1.0\n            length      0.3\n    dtype: float64\n\n    >>> s.drop(labels='weight', level=1)\n    lama    speed      45.0\n            length      1.2\n    cow     speed      30.0\n            length      1.5\n    falcon  speed     320.0\n            length      0.3\n    dtype: float64\n    \"\"\"\n    return super().drop(labels=labels, axis=axis, index=index, columns=columns, level=level, inplace=inplace, errors=errors)",
                            "@doc(NDFrame.fillna, **_shared_doc_kwargs)\ndef fillna(self, value=None, method=None, axis=None, inplace=False, limit=None, downcast=None) -> Optional['Series']:\n    return super().fillna(value=value, method=method, axis=axis, inplace=inplace, limit=limit, downcast=downcast)",
                            "@doc(NDFrame.replace, **_shared_doc_kwargs)\ndef replace(self, to_replace=None, value=None, inplace=False, limit=None, regex=False, method='pad'):\n    return super().replace(to_replace=to_replace, value=value, inplace=inplace, limit=limit, regex=regex, method=method)",
                            "@doc(NDFrame.shift, **_shared_doc_kwargs)\ndef shift(self, periods=1, freq=None, axis=0, fill_value=None) -> 'Series':\n    return super().shift(periods=periods, freq=freq, axis=axis, fill_value=fill_value)",
                            "def memory_usage(self, index=True, deep=False):\n    \"\"\"\n    Return the memory usage of the Series.\n\n    The memory usage can optionally include the contribution of\n    the index and of elements of `object` dtype.\n\n    Parameters\n    ----------\n    index : bool, default True\n        Specifies whether to include the memory usage of the Series index.\n    deep : bool, default False\n        If True, introspect the data deeply by interrogating\n        `object` dtypes for system-level memory consumption, and include\n        it in the returned value.\n\n    Returns\n    -------\n    int\n        Bytes of memory consumed.\n\n    See Also\n    --------\n    numpy.ndarray.nbytes : Total bytes consumed by the elements of the\n        array.\n    DataFrame.memory_usage : Bytes consumed by a DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series(range(3))\n    >>> s.memory_usage()\n    152\n\n    Not including the index gives the size of the rest of the data, which\n    is necessarily smaller:\n\n    >>> s.memory_usage(index=False)\n    24\n\n    The memory footprint of `object` values is ignored by default:\n\n    >>> s = pd.Series([\"a\", \"b\"])\n    >>> s.values\n    array(['a', 'b'], dtype=object)\n    >>> s.memory_usage()\n    144\n    >>> s.memory_usage(deep=True)\n    260\n    \"\"\"\n    v = super().memory_usage(deep=deep)\n    if index:\n        v += self.index.memory_usage(deep=deep)\n    return v",
                            "def isin(self, values) -> 'Series':\n    \"\"\"\n    Check whether `values` are contained in Series.\n\n    Return a boolean Series showing whether each element in the Series\n    matches an element in the passed sequence of `values` exactly.\n\n    Parameters\n    ----------\n    values : set or list-like\n        The sequence of values to test. Passing in a single string will\n        raise a ``TypeError``. Instead, turn a single string into a\n        list of one element.\n\n    Returns\n    -------\n    Series\n        Series of booleans indicating if each element is in values.\n\n    Raises\n    ------\n    TypeError\n      * If `values` is a string\n\n    See Also\n    --------\n    DataFrame.isin : Equivalent method on DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series(['lama', 'cow', 'lama', 'beetle', 'lama',\n    ...                'hippo'], name='animal')\n    >>> s.isin(['cow', 'lama'])\n    0     True\n    1     True\n    2     True\n    3    False\n    4     True\n    5    False\n    Name: animal, dtype: bool\n\n    Passing a single string as ``s.isin('lama')`` will raise an error. Use\n    a list of one element instead:\n\n    >>> s.isin(['lama'])\n    0     True\n    1    False\n    2     True\n    3    False\n    4     True\n    5    False\n    Name: animal, dtype: bool\n    \"\"\"\n    result = algorithms.isin(self, values)\n    return self._constructor(result, index=self.index).__finalize__(self, method='isin')",
                            "def between(self, left, right, inclusive=True) -> 'Series':\n    \"\"\"\n    Return boolean Series equivalent to left <= series <= right.\n\n    This function returns a boolean vector containing `True` wherever the\n    corresponding Series element is between the boundary values `left` and\n    `right`. NA values are treated as `False`.\n\n    Parameters\n    ----------\n    left : scalar or list-like\n        Left boundary.\n    right : scalar or list-like\n        Right boundary.\n    inclusive : bool, default True\n        Include boundaries.\n\n    Returns\n    -------\n    Series\n        Series representing whether each element is between left and\n        right (inclusive).\n\n    See Also\n    --------\n    Series.gt : Greater than of series and other.\n    Series.lt : Less than of series and other.\n\n    Notes\n    -----\n    This function is equivalent to ``(left <= ser) & (ser <= right)``\n\n    Examples\n    --------\n    >>> s = pd.Series([2, 0, 4, 8, np.nan])\n\n    Boundary values are included by default:\n\n    >>> s.between(1, 4)\n    0     True\n    1    False\n    2     True\n    3    False\n    4    False\n    dtype: bool\n\n    With `inclusive` set to ``False`` boundary values are excluded:\n\n    >>> s.between(1, 4, inclusive=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    4    False\n    dtype: bool\n\n    `left` and `right` can be any scalar value:\n\n    >>> s = pd.Series(['Alice', 'Bob', 'Carol', 'Eve'])\n    >>> s.between('Anna', 'Daniel')\n    0    False\n    1     True\n    2     True\n    3    False\n    dtype: bool\n    \"\"\"\n    if inclusive:\n        lmask = self >= left\n        rmask = self <= right\n    else:\n        lmask = self > left\n        rmask = self < right\n    return lmask & rmask",
                            "def _convert_dtypes(self, infer_objects: bool=True, convert_string: bool=True, convert_integer: bool=True, convert_boolean: bool=True) -> 'Series':\n    input_series = self\n    if infer_objects:\n        input_series = input_series.infer_objects()\n        if is_object_dtype(input_series):\n            input_series = input_series.copy()\n    if convert_string or convert_integer or convert_boolean:\n        inferred_dtype = convert_dtypes(input_series._values, convert_string, convert_integer, convert_boolean)\n        try:\n            result = input_series.astype(inferred_dtype)\n        except TypeError:\n            result = input_series.copy()\n    else:\n        result = input_series.copy()\n    return result",
                            "@Appender(generic._shared_docs['isna'] % _shared_doc_kwargs)\ndef isna(self) -> 'Series':\n    return super().isna()",
                            "@Appender(generic._shared_docs['isna'] % _shared_doc_kwargs)\ndef isnull(self) -> 'Series':\n    return super().isnull()",
                            "@Appender(generic._shared_docs['notna'] % _shared_doc_kwargs)\ndef notna(self) -> 'Series':\n    return super().notna()",
                            "@Appender(generic._shared_docs['notna'] % _shared_doc_kwargs)\ndef notnull(self) -> 'Series':\n    return super().notnull()",
                            "def dropna(self, axis=0, inplace=False, how=None):\n    \"\"\"\n    Return a new Series with missing values removed.\n\n    See the :ref:`User Guide <missing_data>` for more on which values are\n    considered missing, and how to work with missing data.\n\n    Parameters\n    ----------\n    axis : {0 or 'index'}, default 0\n        There is only one axis to drop values from.\n    inplace : bool, default False\n        If True, do operation inplace and return None.\n    how : str, optional\n        Not in use. Kept for compatibility.\n\n    Returns\n    -------\n    Series\n        Series with NA entries dropped from it.\n\n    See Also\n    --------\n    Series.isna: Indicate missing values.\n    Series.notna : Indicate existing (non-missing) values.\n    Series.fillna : Replace missing values.\n    DataFrame.dropna : Drop rows or columns which contain NA values.\n    Index.dropna : Drop missing indices.\n\n    Examples\n    --------\n    >>> ser = pd.Series([1., 2., np.nan])\n    >>> ser\n    0    1.0\n    1    2.0\n    2    NaN\n    dtype: float64\n\n    Drop NA values from a Series.\n\n    >>> ser.dropna()\n    0    1.0\n    1    2.0\n    dtype: float64\n\n    Keep the Series with valid entries in the same variable.\n\n    >>> ser.dropna(inplace=True)\n    >>> ser\n    0    1.0\n    1    2.0\n    dtype: float64\n\n    Empty strings are not considered NA values. ``None`` is considered an\n    NA value.\n\n    >>> ser = pd.Series([np.NaN, 2, pd.NaT, '', None, 'I stay'])\n    >>> ser\n    0       NaN\n    1         2\n    2       NaT\n    3\n    4      None\n    5    I stay\n    dtype: object\n    >>> ser.dropna()\n    1         2\n    3\n    5    I stay\n    dtype: object\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    self._get_axis_number(axis or 0)\n    if self._can_hold_na:\n        result = remove_na_arraylike(self)\n        if inplace:\n            self._update_inplace(result)\n        else:\n            return result\n    elif inplace:\n        pass\n    else:\n        return self.copy()",
                            "def to_timestamp(self, freq=None, how='start', copy=True) -> 'Series':\n    \"\"\"\n    Cast to DatetimeIndex of Timestamps, at *beginning* of period.\n\n    Parameters\n    ----------\n    freq : str, default frequency of PeriodIndex\n        Desired frequency.\n    how : {'s', 'e', 'start', 'end'}\n        Convention for converting period to timestamp; start of period\n        vs. end.\n    copy : bool, default True\n        Whether or not to return a copy.\n\n    Returns\n    -------\n    Series with DatetimeIndex\n    \"\"\"\n    new_values = self._values\n    if copy:\n        new_values = new_values.copy()\n    assert isinstance(self.index, PeriodIndex)\n    new_index = self.index.to_timestamp(freq=freq, how=how)\n    return self._constructor(new_values, index=new_index).__finalize__(self, method='to_timestamp')",
                            "def to_period(self, freq=None, copy=True) -> 'Series':\n    \"\"\"\n    Convert Series from DatetimeIndex to PeriodIndex with desired\n    frequency (inferred from index if not passed).\n\n    Parameters\n    ----------\n    freq : str, default None\n        Frequency associated with the PeriodIndex.\n    copy : bool, default True\n        Whether or not to return a copy.\n\n    Returns\n    -------\n    Series\n        Series with index converted to PeriodIndex.\n    \"\"\"\n    new_values = self._values\n    if copy:\n        new_values = new_values.copy()\n    assert isinstance(self.index, DatetimeIndex)\n    new_index = self.index.to_period(freq=freq)\n    return self._constructor(new_values, index=new_index).__finalize__(self, method='to_period')",
                            "def construct_return(result):\n    if lib.is_scalar(result):\n        return result\n    elif result.ndim > 1:\n        if method == 'outer':\n            raise NotImplementedError\n        return result\n    return self._constructor(result, index=index, name=name, copy=False)",
                            "def _try_kind_sort(arr):\n    arr = ensure_key_mapped(arr, key)\n    arr = getattr(arr, '_values', arr)\n    try:\n        return arr.argsort(kind=kind)\n    except TypeError:\n        return arr.argsort(kind='quicksort')",
                            "def f(x):\n    return func(x, *args, **kwds)"
                        ],
                        "constructor_variables": [
                            "copy",
                            "index",
                            "dtype",
                            "data",
                            "name"
                        ],
                        "class_level_variables": [
                            "_typ",
                            "_name",
                            "_metadata",
                            "_internal_names_set",
                            "_accessors",
                            "_deprecations",
                            "hasnans",
                            "_mgr",
                            "div",
                            "rdiv",
                            "_index",
                            "_HANDLED_TYPES",
                            "__float__",
                            "__long__",
                            "__int__",
                            "_agg_see_also_doc",
                            "_agg_examples_doc",
                            "agg",
                            "_AXIS_ORDERS",
                            "_AXIS_REVERSED",
                            "_AXIS_LEN",
                            "_info_axis_number",
                            "_info_axis_name",
                            "index",
                            "str",
                            "dt",
                            "cat",
                            "plot",
                            "sparse",
                            "hist"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "__init__(self, data=None, index=None, dtype=None, name=None, copy=False, fastpath=False)",
                            "_init_dict(self, data, index=None, dtype=None)",
                            "_constructor(self) -> Type['Series']",
                            "_constructor_expanddim(self) -> Type['DataFrame']",
                            "_can_hold_na(self)",
                            "_set_axis(self, axis: int, labels, fastpath: bool=False) -> None",
                            "dtype(self) -> DtypeObj",
                            "dtypes(self) -> DtypeObj",
                            "name(self) -> Label",
                            "name(self, value: Label) -> None",
                            "values(self)",
                            "_values(self)",
                            "array(self) -> ExtensionArray",
                            "ravel(self, order='C')",
                            "__len__(self) -> int",
                            "view(self, dtype=None) -> 'Series'",
                            "__array_ufunc__(self, ufunc: Callable, method: str, *inputs: Any, **kwargs: Any)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "axes(self) -> List[Index]",
                            "take(self, indices, axis=0, is_copy=None, **kwargs) -> 'Series'",
                            "_take_with_is_copy(self, indices, axis=0)",
                            "_ixs(self, i: int, axis: int=0)",
                            "_slice(self, slobj: slice, axis: int=0) -> 'Series'",
                            "__getitem__(self, key)",
                            "_get_with(self, key)",
                            "_get_values_tuple(self, key)",
                            "_get_values(self, indexer)",
                            "_get_value(self, label, takeable: bool=False)",
                            "__setitem__(self, key, value)",
                            "_set_with_engine(self, key, value)",
                            "_set_with(self, key, value)",
                            "_set_value(self, label, value, takeable: bool=False)",
                            "_is_mixed_type(self)",
                            "repeat(self, repeats, axis=None) -> 'Series'",
                            "reset_index(self, level=None, drop=False, name=None, inplace=False)",
                            "__repr__(self) -> str",
                            "to_string(self, buf=None, na_rep='NaN', float_format=None, header=True, index=True, length=False, dtype=False, name=False, max_rows=None, min_rows=None)",
                            "to_markdown(self, buf: Optional[IO[str]]=None, mode: Optional[str]=None, **kwargs) -> Optional[str]",
                            "items(self) -> Iterable[Tuple[Label, Any]]",
                            "iteritems(self) -> Iterable[Tuple[Label, Any]]",
                            "keys(self) -> Index",
                            "to_dict(self, into=dict)",
                            "to_frame(self, name=None) -> 'DataFrame'",
                            "_set_name(self, name, inplace=False) -> 'Series'",
                            "groupby(self, by=None, axis=0, level=None, as_index: bool=True, sort: bool=True, group_keys: bool=True, squeeze: bool=False, observed: bool=False, dropna: bool=True) -> 'SeriesGroupBy'",
                            "count(self, level=None)",
                            "mode(self, dropna=True) -> 'Series'",
                            "unique(self)",
                            "drop_duplicates(self, keep='first', inplace=False) -> Optional['Series']",
                            "duplicated(self, keep='first') -> 'Series'",
                            "idxmin(self, axis=0, skipna=True, *args, **kwargs)",
                            "idxmax(self, axis=0, skipna=True, *args, **kwargs)",
                            "round(self, decimals=0, *args, **kwargs) -> 'Series'",
                            "quantile(self, q=0.5, interpolation='linear')",
                            "corr(self, other, method='pearson', min_periods=None) -> float",
                            "cov(self, other, min_periods=None) -> float",
                            "diff(self, periods: int=1) -> 'Series'",
                            "autocorr(self, lag=1) -> float",
                            "dot(self, other)",
                            "__matmul__(self, other)",
                            "__rmatmul__(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "append(self, to_append, ignore_index=False, verify_integrity=False)",
                            "_binop(self, other, func, level=None, fill_value=None)",
                            "_construct_result(self, result: Union[ArrayLike, Tuple[ArrayLike, ArrayLike]], name: Label) -> Union['Series', Tuple['Series', 'Series']]",
                            "combine(self, other, func, fill_value=None) -> 'Series'",
                            "combine_first(self, other) -> 'Series'",
                            "update(self, other) -> None",
                            "sort_values(self, axis=0, ascending=True, inplace: bool=False, kind: str='quicksort', na_position: str='last', ignore_index: bool=False, key: ValueKeyFunc=None)",
                            "sort_index(self, axis=0, level=None, ascending: bool=True, inplace: bool=False, kind: str='quicksort', na_position: str='last', sort_remaining: bool=True, ignore_index: bool=False, key: IndexKeyFunc=None)",
                            "argsort(self, axis=0, kind='quicksort', order=None) -> 'Series'",
                            "nlargest(self, n=5, keep='first') -> 'Series'",
                            "nsmallest(self, n=5, keep='first') -> 'Series'",
                            "swaplevel(self, i=-2, j=-1, copy=True) -> 'Series'",
                            "reorder_levels(self, order) -> 'Series'",
                            "explode(self) -> 'Series'",
                            "unstack(self, level=-1, fill_value=None)",
                            "map(self, arg, na_action=None) -> 'Series'",
                            "_gotitem(self, key, ndim, subset=None) -> 'Series'",
                            "aggregate(self, func, axis=0, *args, **kwargs)",
                            "transform(self, func, axis=0, *args, **kwargs)",
                            "apply(self, func, convert_dtype=True, args=(), **kwds)",
                            "_reduce(self, op, name, axis=0, skipna=True, numeric_only=None, filter_type=None, **kwds)",
                            "_reindex_indexer(self, new_index, indexer, copy)",
                            "_needs_reindex_multi(self, axes, method, level)",
                            "align(self, other, join='outer', axis=None, level=None, copy=True, fill_value=None, method=None, limit=None, fill_axis=0, broadcast_axis=None)",
                            "rename(self, index=None)",
                            "set_axis(self, labels, axis: Axis=0, inplace: bool=False)",
                            "reindex(self, index=None, **kwargs)",
                            "drop(self, labels=None, axis=0, index=None, columns=None, level=None, inplace=False, errors='raise') -> 'Series'",
                            "fillna(self, value=None, method=None, axis=None, inplace=False, limit=None, downcast=None) -> Optional['Series']",
                            "replace(self, to_replace=None, value=None, inplace=False, limit=None, regex=False, method='pad')",
                            "shift(self, periods=1, freq=None, axis=0, fill_value=None) -> 'Series'",
                            "memory_usage(self, index=True, deep=False)",
                            "isin(self, values) -> 'Series'",
                            "between(self, left, right, inclusive=True) -> 'Series'",
                            "_convert_dtypes(self, infer_objects: bool=True, convert_string: bool=True, convert_integer: bool=True, convert_boolean: bool=True) -> 'Series'",
                            "isna(self) -> 'Series'",
                            "isnull(self) -> 'Series'",
                            "notna(self) -> 'Series'",
                            "notnull(self) -> 'Series'",
                            "dropna(self, axis=0, inplace=False, how=None)",
                            "to_timestamp(self, freq=None, how='start', copy=True) -> 'Series'",
                            "to_period(self, freq=None, copy=True) -> 'Series'",
                            "construct_return(result)",
                            "_try_kind_sort(arr)",
                            "f(x)"
                        ]
                    },
                    "variable_values": [
                        [
                            {
                                "new_values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._values": {
                                    "variable_value": "array([nan, nan, nan, nan, nan, nan], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "self": {
                                    "variable_value": "0    NaN\n0    NaN\n1    NaN\n1    NaN\n2    NaN\n2    NaN\ndtype: object",
                                    "variable_type": "Series",
                                    "variable_shape": "6"
                                },
                                "copy": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "new_values.copy": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "Int64Index([0, 0, 1, 1, 2, 2], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "PeriodIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "new_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.to_timestamp": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "how": {
                                    "variable_value": "'start'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "__finalize__": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._constructor": {
                                    "variable_value": "<class 'pandas.core.series.Series'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x1087d5bd0>"
                                }
                            },
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "new_values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._values": {
                                    "variable_value": "array([nan, nan, nan, nan, nan, nan], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "self": {
                                    "variable_value": "0    NaN\n0    NaN\n1    NaN\n1    NaN\n2    NaN\n2    NaN\ndtype: object",
                                    "variable_type": "Series",
                                    "variable_shape": "6"
                                },
                                "copy": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "new_values.copy": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "Int64Index([0, 0, 1, 1, 2, 2], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "PeriodIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "new_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.to_timestamp": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "how": {
                                    "variable_value": "'start'",
                                    "variable_type": "str",
                                    "variable_shape": "5"
                                },
                                "__finalize__": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._constructor": {
                                    "variable_value": "<class 'pandas.core.series.Series'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x114240a40>"
                                }
                            },
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "to_period",
                    "function_code": "def to_period(self, freq=None, copy=True) -> \"Series\":\n    \"\"\"\n    Convert Series from DatetimeIndex to PeriodIndex with desired\n    frequency (inferred from index if not passed).\n\n    Parameters\n    ----------\n    freq : str, default None\n        Frequency associated with the PeriodIndex.\n    copy : bool, default True\n        Whether or not to return a copy.\n\n    Returns\n    -------\n    Series\n        Series with index converted to PeriodIndex.\n    \"\"\"\n    new_values = self._values\n    if copy:\n        new_values = new_values.copy()\n\n    assert isinstance(self.index, DatetimeIndex)\n    new_index = self.index.to_period(freq=freq)  # type: ignore\n    return self._constructor(new_values, index=new_index).__finalize__(\n        self, method=\"to_period\"\n    )\n",
                    "decorators": [],
                    "docstring": "Convert Series from DatetimeIndex to PeriodIndex with desired\nfrequency (inferred from index if not passed).\n\nParameters\n----------\nfreq : str, default None\n    Frequency associated with the PeriodIndex.\ncopy : bool, default True\n    Whether or not to return a copy.\n\nReturns\n-------\nSeries\n    Series with index converted to PeriodIndex.",
                    "start_line": 4693,
                    "variables": {
                        "new_values": [
                            4712,
                            4716,
                            4710
                        ],
                        "self._values": [
                            4710
                        ],
                        "self": [
                            4710,
                            4714,
                            4715,
                            4716,
                            4717
                        ],
                        "copy": [
                            4711
                        ],
                        "new_values.copy": [
                            4712
                        ],
                        "isinstance": [
                            4714
                        ],
                        "self.index": [
                            4714,
                            4715
                        ],
                        "DatetimeIndex": [
                            4714
                        ],
                        "new_index": [
                            4715,
                            4716
                        ],
                        "self.index.to_period": [
                            4715
                        ],
                        "freq": [
                            4715
                        ],
                        "__finalize__": [
                            4716
                        ],
                        "self._constructor": [
                            4716
                        ]
                    },
                    "filtered_variables": {
                        "new_values": [
                            4712,
                            4716,
                            4710
                        ],
                        "self._values": [
                            4710
                        ],
                        "self": [
                            4710,
                            4714,
                            4715,
                            4716,
                            4717
                        ],
                        "copy": [
                            4711
                        ],
                        "new_values.copy": [
                            4712
                        ],
                        "self.index": [
                            4714,
                            4715
                        ],
                        "DatetimeIndex": [
                            4714
                        ],
                        "new_index": [
                            4715,
                            4716
                        ],
                        "self.index.to_period": [
                            4715
                        ],
                        "freq": [
                            4715
                        ],
                        "__finalize__": [
                            4716
                        ],
                        "self._constructor": [
                            4716
                        ]
                    },
                    "diff_line_number": 4714,
                    "class_data": {
                        "signature": "class Series(base.IndexOpsMixin, generic.NDFrame)",
                        "docstring": "One-dimensional ndarray with axis labels (including time series).\n\nLabels need not be unique but must be a hashable type. The object\nsupports both integer- and label-based indexing and provides a host of\nmethods for performing operations involving the index. Statistical\nmethods from ndarray have been overridden to automatically exclude\nmissing data (currently represented as NaN).\n\nOperations between Series (+, -, /, *, **) align values based on their\nassociated index values-- they need not be the same length. The result\nindex will be the sorted union of the two indexes.\n\nParameters\n----------\ndata : array-like, Iterable, dict, or scalar value\n    Contains data stored in Series.\n\n    .. versionchanged:: 0.23.0\n       If data is a dict, argument order is maintained for Python 3.6\n       and later.\n\nindex : array-like or Index (1d)\n    Values must be hashable and have the same length as `data`.\n    Non-unique index values are allowed. Will default to\n    RangeIndex (0, 1, 2, ..., n) if not provided. If both a dict and index\n    sequence are used, the index will override the keys found in the\n    dict.\ndtype : str, numpy.dtype, or ExtensionDtype, optional\n    Data type for the output Series. If not specified, this will be\n    inferred from `data`.\n    See the :ref:`user guide <basics.dtypes>` for more usages.\nname : str, optional\n    The name to give to the Series.\ncopy : bool, default False\n    Copy input data.",
                        "constructor_docstring": null,
                        "functions": [
                            "def __init__(self, data=None, index=None, dtype=None, name=None, copy=False, fastpath=False):\n    if isinstance(data, SingleBlockManager) and index is None and (dtype is None) and (copy is False):\n        NDFrame.__init__(self, data)\n        self.name = name\n        return\n    if fastpath:\n        if not isinstance(data, SingleBlockManager):\n            data = SingleBlockManager.from_array(data, index)\n        if copy:\n            data = data.copy()\n        if index is None:\n            index = data.index\n    else:\n        name = ibase.maybe_extract_name(name, data, type(self))\n        if is_empty_data(data) and dtype is None:\n            warnings.warn(\"The default dtype for empty Series will be 'object' instead of 'float64' in a future version. Specify a dtype explicitly to silence this warning.\", DeprecationWarning, stacklevel=2)\n        if index is not None:\n            index = ensure_index(index)\n        if data is None:\n            data = {}\n        if dtype is not None:\n            dtype = self._validate_dtype(dtype)\n        if isinstance(data, MultiIndex):\n            raise NotImplementedError('initializing a Series from a MultiIndex is not supported')\n        elif isinstance(data, Index):\n            if dtype is not None:\n                data = data.astype(dtype)\n            else:\n                data = data._values.copy()\n            copy = False\n        elif isinstance(data, np.ndarray):\n            if len(data.dtype):\n                raise ValueError('Cannot construct a Series from an ndarray with compound dtype.  Use DataFrame instead.')\n        elif isinstance(data, Series):\n            if index is None:\n                index = data.index\n            else:\n                data = data.reindex(index, copy=copy)\n                copy = False\n            data = data._mgr\n        elif is_dict_like(data):\n            data, index = self._init_dict(data, index, dtype)\n            dtype = None\n            copy = False\n        elif isinstance(data, SingleBlockManager):\n            if index is None:\n                index = data.index\n            elif not data.index.equals(index) or copy:\n                raise AssertionError('Cannot pass both SingleBlockManager `data` argument and a different `index` argument. `copy` must be False.')\n        elif is_extension_array_dtype(data):\n            pass\n        elif isinstance(data, (set, frozenset)):\n            raise TypeError(f\"'{type(data).__name__}' type is unordered\")\n        else:\n            data = com.maybe_iterable_to_list(data)\n        if index is None:\n            if not is_list_like(data):\n                data = [data]\n            index = ibase.default_index(len(data))\n        elif is_list_like(data):\n            try:\n                if len(index) != len(data):\n                    raise ValueError(f'Length of passed values is {len(data)}, index implies {len(index)}.')\n            except TypeError:\n                pass\n        if isinstance(data, SingleBlockManager):\n            if dtype is not None:\n                data = data.astype(dtype=dtype, errors='ignore', copy=copy)\n            elif copy:\n                data = data.copy()\n        else:\n            data = sanitize_array(data, index, dtype, copy, raise_cast_failure=True)\n            data = SingleBlockManager.from_array(data, index)\n    generic.NDFrame.__init__(self, data)\n    self.name = name\n    self._set_axis(0, index, fastpath=True)",
                            "def _init_dict(self, data, index=None, dtype=None):\n    \"\"\"\n    Derive the \"_mgr\" and \"index\" attributes of a new Series from a\n    dictionary input.\n\n    Parameters\n    ----------\n    data : dict or dict-like\n        Data used to populate the new Series.\n    index : Index or index-like, default None\n        Index for the new Series: if None, use dict keys.\n    dtype : dtype, default None\n        The dtype for the new Series: if None, infer from data.\n\n    Returns\n    -------\n    _data : BlockManager for the new Series\n    index : index for the new Series\n    \"\"\"\n    if data:\n        keys, values = zip(*data.items())\n        values = list(values)\n    elif index is not None:\n        values = na_value_for_dtype(dtype)\n        keys = index\n    else:\n        keys, values = ([], [])\n    s = create_series_with_explicit_dtype(values, index=keys, dtype=dtype, dtype_if_empty=np.float64)\n    if data and index is not None:\n        s = s.reindex(index, copy=False)\n    return (s._mgr, s.index)",
                            "@property\ndef _constructor(self) -> Type['Series']:\n    return Series",
                            "@property\ndef _constructor_expanddim(self) -> Type['DataFrame']:\n    from pandas.core.frame import DataFrame\n    return DataFrame",
                            "@property\ndef _can_hold_na(self):\n    return self._mgr._can_hold_na",
                            "def _set_axis(self, axis: int, labels, fastpath: bool=False) -> None:\n    \"\"\"\n    Override generic, we want to set the _typ here.\n\n    This is called from the cython code when we set the `index` attribute\n    directly, e.g. `series.index = [1, 2, 3]`.\n    \"\"\"\n    if not fastpath:\n        labels = ensure_index(labels)\n    is_all_dates = labels.is_all_dates\n    if is_all_dates:\n        if not isinstance(labels, (DatetimeIndex, PeriodIndex, TimedeltaIndex)):\n            try:\n                labels = DatetimeIndex(labels)\n                if fastpath:\n                    self._mgr.set_axis(axis, labels)\n            except (tslibs.OutOfBoundsDatetime, ValueError):\n                pass\n    object.__setattr__(self, '_index', labels)\n    if not fastpath:\n        self._mgr.set_axis(axis, labels)",
                            "@property\ndef dtype(self) -> DtypeObj:\n    \"\"\"\n    Return the dtype object of the underlying data.\n    \"\"\"\n    return self._mgr.dtype",
                            "@property\ndef dtypes(self) -> DtypeObj:\n    \"\"\"\n    Return the dtype object of the underlying data.\n    \"\"\"\n    return self.dtype",
                            "@property\ndef name(self) -> Label:\n    \"\"\"\n    Return the name of the Series.\n\n    The name of a Series becomes its index or column name if it is used\n    to form a DataFrame. It is also used whenever displaying the Series\n    using the interpreter.\n\n    Returns\n    -------\n    label (hashable object)\n        The name of the Series, also the column name if part of a DataFrame.\n\n    See Also\n    --------\n    Series.rename : Sets the Series name when given a scalar input.\n    Index.name : Corresponding Index property.\n\n    Examples\n    --------\n    The Series name can be set initially when calling the constructor.\n\n    >>> s = pd.Series([1, 2, 3], dtype=np.int64, name='Numbers')\n    >>> s\n    0    1\n    1    2\n    2    3\n    Name: Numbers, dtype: int64\n    >>> s.name = \"Integers\"\n    >>> s\n    0    1\n    1    2\n    2    3\n    Name: Integers, dtype: int64\n\n    The name of a Series within a DataFrame is its column name.\n\n    >>> df = pd.DataFrame([[1, 2], [3, 4], [5, 6]],\n    ...                   columns=[\"Odd Numbers\", \"Even Numbers\"])\n    >>> df\n       Odd Numbers  Even Numbers\n    0            1             2\n    1            3             4\n    2            5             6\n    >>> df[\"Even Numbers\"].name\n    'Even Numbers'\n    \"\"\"\n    return self._name",
                            "@name.setter\ndef name(self, value: Label) -> None:\n    if not is_hashable(value):\n        raise TypeError('Series.name must be a hashable type')\n    object.__setattr__(self, '_name', value)",
                            "@property\ndef values(self):\n    \"\"\"\n    Return Series as ndarray or ndarray-like depending on the dtype.\n\n    .. warning::\n\n       We recommend using :attr:`Series.array` or\n       :meth:`Series.to_numpy`, depending on whether you need\n       a reference to the underlying data or a NumPy array.\n\n    Returns\n    -------\n    numpy.ndarray or ndarray-like\n\n    See Also\n    --------\n    Series.array : Reference to the underlying data.\n    Series.to_numpy : A NumPy array representing the underlying data.\n\n    Examples\n    --------\n    >>> pd.Series([1, 2, 3]).values\n    array([1, 2, 3])\n\n    >>> pd.Series(list('aabc')).values\n    array(['a', 'a', 'b', 'c'], dtype=object)\n\n    >>> pd.Series(list('aabc')).astype('category').values\n    [a, a, b, c]\n    Categories (3, object): [a, b, c]\n\n    Timezone aware datetime data is converted to UTC:\n\n    >>> pd.Series(pd.date_range('20130101', periods=3,\n    ...                         tz='US/Eastern')).values\n    array(['2013-01-01T05:00:00.000000000',\n           '2013-01-02T05:00:00.000000000',\n           '2013-01-03T05:00:00.000000000'], dtype='datetime64[ns]')\n    \"\"\"\n    return self._mgr.external_values()",
                            "@property\ndef _values(self):\n    \"\"\"\n    Return the internal repr of this data (defined by Block.interval_values).\n    This are the values as stored in the Block (ndarray or ExtensionArray\n    depending on the Block class), with datetime64[ns] and timedelta64[ns]\n    wrapped in ExtensionArrays to match Index._values behavior.\n\n    Differs from the public ``.values`` for certain data types, because of\n    historical backwards compatibility of the public attribute (e.g. period\n    returns object ndarray and datetimetz a datetime64[ns] ndarray for\n    ``.values`` while it returns an ExtensionArray for ``._values`` in those\n    cases).\n\n    Differs from ``.array`` in that this still returns the numpy array if\n    the Block is backed by a numpy array (except for datetime64 and\n    timedelta64 dtypes), while ``.array`` ensures to always return an\n    ExtensionArray.\n\n    Overview:\n\n    dtype       | values        | _values       | array         |\n    ----------- | ------------- | ------------- | ------------- |\n    Numeric     | ndarray       | ndarray       | PandasArray   |\n    Category    | Categorical   | Categorical   | Categorical   |\n    dt64[ns]    | ndarray[M8ns] | DatetimeArray | DatetimeArray |\n    dt64[ns tz] | ndarray[M8ns] | DatetimeArray | DatetimeArray |\n    td64[ns]    | ndarray[m8ns] | TimedeltaArray| ndarray[m8ns] |\n    Period      | ndarray[obj]  | PeriodArray   | PeriodArray   |\n    Nullable    | EA            | EA            | EA            |\n\n    \"\"\"\n    return self._mgr.internal_values()",
                            "@Appender(base.IndexOpsMixin.array.__doc__)\n@property\ndef array(self) -> ExtensionArray:\n    return self._mgr._block.array_values()",
                            "def ravel(self, order='C'):\n    \"\"\"\n    Return the flattened underlying data as an ndarray.\n\n    Returns\n    -------\n    numpy.ndarray or ndarray-like\n        Flattened data of the Series.\n\n    See Also\n    --------\n    numpy.ndarray.ravel : Return a flattened array.\n    \"\"\"\n    return self._values.ravel(order=order)",
                            "def __len__(self) -> int:\n    \"\"\"\n    Return the length of the Series.\n    \"\"\"\n    return len(self._mgr)",
                            "def view(self, dtype=None) -> 'Series':\n    \"\"\"\n    Create a new view of the Series.\n\n    This function will return a new Series with a view of the same\n    underlying values in memory, optionally reinterpreted with a new data\n    type. The new data type must preserve the same size in bytes as to not\n    cause index misalignment.\n\n    Parameters\n    ----------\n    dtype : data type\n        Data type object or one of their string representations.\n\n    Returns\n    -------\n    Series\n        A new Series object as a view of the same data in memory.\n\n    See Also\n    --------\n    numpy.ndarray.view : Equivalent numpy function to create a new view of\n        the same data in memory.\n\n    Notes\n    -----\n    Series are instantiated with ``dtype=float64`` by default. While\n    ``numpy.ndarray.view()`` will return a view with the same data type as\n    the original array, ``Series.view()`` (without specified dtype)\n    will try using ``float64`` and may fail if the original data type size\n    in bytes is not the same.\n\n    Examples\n    --------\n    >>> s = pd.Series([-2, -1, 0, 1, 2], dtype='int8')\n    >>> s\n    0   -2\n    1   -1\n    2    0\n    3    1\n    4    2\n    dtype: int8\n\n    The 8 bit signed integer representation of `-1` is `0b11111111`, but\n    the same bytes represent 255 if read as an 8 bit unsigned integer:\n\n    >>> us = s.view('uint8')\n    >>> us\n    0    254\n    1    255\n    2      0\n    3      1\n    4      2\n    dtype: uint8\n\n    The views share the same underlying values:\n\n    >>> us[0] = 128\n    >>> s\n    0   -128\n    1     -1\n    2      0\n    3      1\n    4      2\n    dtype: int8\n    \"\"\"\n    return self._constructor(self._values.view(dtype), index=self.index).__finalize__(self, method='view')",
                            "def __array_ufunc__(self, ufunc: Callable, method: str, *inputs: Any, **kwargs: Any):\n    cls = type(self)\n    result = ops.maybe_dispatch_ufunc_to_dunder_op(self, ufunc, method, *inputs, **kwargs)\n    if result is not NotImplemented:\n        return result\n    no_defer = (np.ndarray.__array_ufunc__, cls.__array_ufunc__)\n    for item in inputs:\n        higher_priority = hasattr(item, '__array_priority__') and item.__array_priority__ > self.__array_priority__\n        has_array_ufunc = hasattr(item, '__array_ufunc__') and type(item).__array_ufunc__ not in no_defer and (not isinstance(item, self._HANDLED_TYPES))\n        if higher_priority or has_array_ufunc:\n            return NotImplemented\n    names = [getattr(x, 'name') for x in inputs if hasattr(x, 'name')]\n    types = tuple((type(x) for x in inputs))\n    alignable = [x for x, t in zip(inputs, types) if issubclass(t, Series)]\n    if len(alignable) > 1:\n        index = alignable[0].index\n        for s in alignable[1:]:\n            index |= s.index\n        inputs = tuple((x.reindex(index) if issubclass(t, Series) else x for x, t in zip(inputs, types)))\n    else:\n        index = self.index\n    inputs = tuple((extract_array(x, extract_numpy=True) for x in inputs))\n    result = getattr(ufunc, method)(*inputs, **kwargs)\n    name = names[0] if len(set(names)) == 1 else None\n\n    def construct_return(result):\n        if lib.is_scalar(result):\n            return result\n        elif result.ndim > 1:\n            if method == 'outer':\n                raise NotImplementedError\n            return result\n        return self._constructor(result, index=index, name=name, copy=False)\n    if type(result) is tuple:\n        return tuple((construct_return(x) for x in result))\n    elif method == 'at':\n        return None\n    else:\n        return construct_return(result)",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    \"\"\"\n    Return the values as a NumPy array.\n\n    Users should not call this directly. Rather, it is invoked by\n    :func:`numpy.array` and :func:`numpy.asarray`.\n\n    Parameters\n    ----------\n    dtype : str or numpy.dtype, optional\n        The dtype to use for the resulting NumPy array. By default,\n        the dtype is inferred from the data.\n\n    Returns\n    -------\n    numpy.ndarray\n        The values in the series converted to a :class:`numpy.ndarray`\n        with the specified `dtype`.\n\n    See Also\n    --------\n    array : Create a new array from data.\n    Series.array : Zero-copy view to the array backing the Series.\n    Series.to_numpy : Series method for similar behavior.\n\n    Examples\n    --------\n    >>> ser = pd.Series([1, 2, 3])\n    >>> np.asarray(ser)\n    array([1, 2, 3])\n\n    For timezone-aware data, the timezones may be retained with\n    ``dtype='object'``\n\n    >>> tzser = pd.Series(pd.date_range('2000', periods=2, tz=\"CET\"))\n    >>> np.asarray(tzser, dtype=\"object\")\n    array([Timestamp('2000-01-01 00:00:00+0100', tz='CET', freq='D'),\n           Timestamp('2000-01-02 00:00:00+0100', tz='CET', freq='D')],\n          dtype=object)\n\n    Or the values may be localized to UTC and the tzinfo discarded with\n    ``dtype='datetime64[ns]'``\n\n    >>> np.asarray(tzser, dtype=\"datetime64[ns]\")  # doctest: +ELLIPSIS\n    array(['1999-12-31T23:00:00.000000000', ...],\n          dtype='datetime64[ns]')\n    \"\"\"\n    return np.asarray(self.array, dtype)",
                            "@property\ndef axes(self) -> List[Index]:\n    \"\"\"\n    Return a list of the row axis labels.\n    \"\"\"\n    return [self.index]",
                            "@Appender(generic.NDFrame.take.__doc__)\ndef take(self, indices, axis=0, is_copy=None, **kwargs) -> 'Series':\n    if is_copy is not None:\n        warnings.warn(\"is_copy is deprecated and will be removed in a future version. 'take' always returns a copy, so there is no need to specify this.\", FutureWarning, stacklevel=2)\n    nv.validate_take(tuple(), kwargs)\n    indices = ensure_platform_int(indices)\n    new_index = self.index.take(indices)\n    new_values = self._values.take(indices)\n    result = self._constructor(new_values, index=new_index, fastpath=True)\n    return result.__finalize__(self, method='take')",
                            "def _take_with_is_copy(self, indices, axis=0):\n    \"\"\"\n    Internal version of the `take` method that sets the `_is_copy`\n    attribute to keep track of the parent dataframe (using in indexing\n    for the SettingWithCopyWarning). For Series this does the same\n    as the public take (it never sets `_is_copy`).\n\n    See the docstring of `take` for full explanation of the parameters.\n    \"\"\"\n    return self.take(indices=indices, axis=axis)",
                            "def _ixs(self, i: int, axis: int=0):\n    \"\"\"\n    Return the i-th value or values in the Series by location.\n\n    Parameters\n    ----------\n    i : int\n\n    Returns\n    -------\n    scalar (int) or Series (slice, sequence)\n    \"\"\"\n    return self._values[i]",
                            "def _slice(self, slobj: slice, axis: int=0) -> 'Series':\n    return self._get_values(slobj)",
                            "def __getitem__(self, key):\n    key = com.apply_if_callable(key, self)\n    if key is Ellipsis:\n        return self\n    key_is_scalar = is_scalar(key)\n    if isinstance(key, (list, tuple)):\n        key = unpack_1tuple(key)\n    if is_integer(key) and self.index._should_fallback_to_positional():\n        return self._values[key]\n    elif key_is_scalar:\n        return self._get_value(key)\n    if isinstance(key, tuple) and is_hashable(key) and isinstance(self.index, MultiIndex):\n        try:\n            result = self._get_value(key)\n            return result\n        except KeyError:\n            return self._get_values_tuple(key)\n    if is_iterator(key):\n        key = list(key)\n    if com.is_bool_indexer(key):\n        key = check_bool_indexer(self.index, key)\n        key = np.asarray(key, dtype=bool)\n        return self._get_values(key)\n    return self._get_with(key)",
                            "def _get_with(self, key):\n    if isinstance(key, slice):\n        slobj = self.index._convert_slice_indexer(key, kind='getitem')\n        return self._slice(slobj)\n    elif isinstance(key, ABCDataFrame):\n        raise TypeError('Indexing a Series with DataFrame is not supported, use the appropriate DataFrame column')\n    elif isinstance(key, tuple):\n        return self._get_values_tuple(key)\n    elif not is_list_like(key):\n        return self.loc[key]\n    if not isinstance(key, (list, np.ndarray, ExtensionArray, Series, Index)):\n        key = list(key)\n    if isinstance(key, Index):\n        key_type = key.inferred_type\n    else:\n        key_type = lib.infer_dtype(key, skipna=False)\n    if key_type == 'integer':\n        if not self.index._should_fallback_to_positional():\n            return self.loc[key]\n        else:\n            return self.iloc[key]\n    return self.loc[key]",
                            "def _get_values_tuple(self, key):\n    if com.any_none(*key):\n        with warnings.catch_warnings():\n            warnings.filterwarnings('ignore', 'Support for multi-dim', DeprecationWarning)\n            return self._get_values(key)\n    if not isinstance(self.index, MultiIndex):\n        raise ValueError('Can only tuple-index with a MultiIndex')\n    indexer, new_index = self.index.get_loc_level(key)\n    return self._constructor(self._values[indexer], index=new_index).__finalize__(self)",
                            "def _get_values(self, indexer):\n    try:\n        return self._constructor(self._mgr.get_slice(indexer)).__finalize__(self)\n    except ValueError:\n        return self._values[indexer]",
                            "def _get_value(self, label, takeable: bool=False):\n    \"\"\"\n    Quickly retrieve single value at passed index label.\n\n    Parameters\n    ----------\n    label : object\n    takeable : interpret the index as indexers, default False\n\n    Returns\n    -------\n    scalar value\n    \"\"\"\n    if takeable:\n        return self._values[label]\n    loc = self.index.get_loc(label)\n    return self.index._get_values_for_loc(self, loc, label)",
                            "def __setitem__(self, key, value):\n    key = com.apply_if_callable(key, self)\n    cacher_needs_updating = self._check_is_chained_assignment_possible()\n    if key is Ellipsis:\n        key = slice(None)\n    try:\n        self._set_with_engine(key, value)\n    except (KeyError, ValueError):\n        values = self._values\n        if is_integer(key) and (not self.index.inferred_type == 'integer'):\n            values[key] = value\n        else:\n            self.loc[key] = value\n    except TypeError as e:\n        if isinstance(key, tuple) and (not isinstance(self.index, MultiIndex)):\n            raise ValueError('Can only tuple-index with a MultiIndex') from e\n        if com.is_bool_indexer(key):\n            key = check_bool_indexer(self.index, key)\n            key = np.asarray(key, dtype=bool)\n            try:\n                self._where(~key, value, inplace=True)\n            except InvalidIndexError:\n                self.iloc[key] = value\n            return\n        else:\n            self._set_with(key, value)\n    if cacher_needs_updating:\n        self._maybe_update_cacher()",
                            "def _set_with_engine(self, key, value):\n    loc = self.index._engine.get_loc(key)\n    validate_numeric_casting(self.dtype, value)\n    self._values[loc] = value",
                            "def _set_with(self, key, value):\n    if isinstance(key, slice):\n        indexer = self.index._convert_slice_indexer(key, kind='getitem')\n        self.iloc[indexer] = extract_array(value, extract_numpy=True)\n    else:\n        assert not isinstance(key, tuple)\n        if is_scalar(key):\n            key = [key]\n        if isinstance(key, Index):\n            key_type = key.inferred_type\n            key = key._values\n        else:\n            key_type = lib.infer_dtype(key, skipna=False)\n        if key_type == 'integer':\n            if not self.index._should_fallback_to_positional():\n                self.loc[key] = value\n            else:\n                self.iloc[key] = value\n        else:\n            self.loc[key] = value",
                            "def _set_value(self, label, value, takeable: bool=False):\n    \"\"\"\n    Quickly set single value at passed label.\n\n    If label is not contained, a new object is created with the label\n    placed at the end of the result index.\n\n    Parameters\n    ----------\n    label : object\n        Partial indexing with MultiIndex not allowed.\n    value : object\n        Scalar value.\n    takeable : interpret the index as indexers, default False\n    \"\"\"\n    try:\n        if takeable:\n            self._values[label] = value\n        else:\n            loc = self.index.get_loc(label)\n            validate_numeric_casting(self.dtype, value)\n            self._values[loc] = value\n    except KeyError:\n        self.loc[label] = value",
                            "@property\ndef _is_mixed_type(self):\n    return False",
                            "def repeat(self, repeats, axis=None) -> 'Series':\n    \"\"\"\n    Repeat elements of a Series.\n\n    Returns a new Series where each element of the current Series\n    is repeated consecutively a given number of times.\n\n    Parameters\n    ----------\n    repeats : int or array of ints\n        The number of repetitions for each element. This should be a\n        non-negative integer. Repeating 0 times will return an empty\n        Series.\n    axis : None\n        Must be ``None``. Has no effect but is accepted for compatibility\n        with numpy.\n\n    Returns\n    -------\n    Series\n        Newly created Series with repeated elements.\n\n    See Also\n    --------\n    Index.repeat : Equivalent function for Index.\n    numpy.repeat : Similar method for :class:`numpy.ndarray`.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'b', 'c'])\n    >>> s\n    0    a\n    1    b\n    2    c\n    dtype: object\n    >>> s.repeat(2)\n    0    a\n    0    a\n    1    b\n    1    b\n    2    c\n    2    c\n    dtype: object\n    >>> s.repeat([1, 2, 3])\n    0    a\n    1    b\n    1    b\n    2    c\n    2    c\n    2    c\n    dtype: object\n    \"\"\"\n    nv.validate_repeat(tuple(), dict(axis=axis))\n    new_index = self.index.repeat(repeats)\n    new_values = self._values.repeat(repeats)\n    return self._constructor(new_values, index=new_index).__finalize__(self, method='repeat')",
                            "def reset_index(self, level=None, drop=False, name=None, inplace=False):\n    \"\"\"\n    Generate a new DataFrame or Series with the index reset.\n\n    This is useful when the index needs to be treated as a column, or\n    when the index is meaningless and needs to be reset to the default\n    before another operation.\n\n    Parameters\n    ----------\n    level : int, str, tuple, or list, default optional\n        For a Series with a MultiIndex, only remove the specified levels\n        from the index. Removes all levels by default.\n    drop : bool, default False\n        Just reset the index, without inserting it as a column in\n        the new DataFrame.\n    name : object, optional\n        The name to use for the column containing the original Series\n        values. Uses ``self.name`` by default. This argument is ignored\n        when `drop` is True.\n    inplace : bool, default False\n        Modify the Series in place (do not create a new object).\n\n    Returns\n    -------\n    Series or DataFrame\n        When `drop` is False (the default), a DataFrame is returned.\n        The newly created columns will come first in the DataFrame,\n        followed by the original Series values.\n        When `drop` is True, a `Series` is returned.\n        In either case, if ``inplace=True``, no value is returned.\n\n    See Also\n    --------\n    DataFrame.reset_index: Analogous function for DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3, 4], name='foo',\n    ...               index=pd.Index(['a', 'b', 'c', 'd'], name='idx'))\n\n    Generate a DataFrame with default index.\n\n    >>> s.reset_index()\n      idx  foo\n    0   a    1\n    1   b    2\n    2   c    3\n    3   d    4\n\n    To specify the name of the new column use `name`.\n\n    >>> s.reset_index(name='values')\n      idx  values\n    0   a       1\n    1   b       2\n    2   c       3\n    3   d       4\n\n    To generate a new Series with the default set `drop` to True.\n\n    >>> s.reset_index(drop=True)\n    0    1\n    1    2\n    2    3\n    3    4\n    Name: foo, dtype: int64\n\n    To update the Series in place, without generating a new one\n    set `inplace` to True. Note that it also requires ``drop=True``.\n\n    >>> s.reset_index(inplace=True, drop=True)\n    >>> s\n    0    1\n    1    2\n    2    3\n    3    4\n    Name: foo, dtype: int64\n\n    The `level` parameter is interesting for Series with a multi-level\n    index.\n\n    >>> arrays = [np.array(['bar', 'bar', 'baz', 'baz']),\n    ...           np.array(['one', 'two', 'one', 'two'])]\n    >>> s2 = pd.Series(\n    ...     range(4), name='foo',\n    ...     index=pd.MultiIndex.from_arrays(arrays,\n    ...                                     names=['a', 'b']))\n\n    To remove a specific level from the Index, use `level`.\n\n    >>> s2.reset_index(level='a')\n           a  foo\n    b\n    one  bar    0\n    two  bar    1\n    one  baz    2\n    two  baz    3\n\n    If `level` is not set, all levels are removed from the Index.\n\n    >>> s2.reset_index()\n         a    b  foo\n    0  bar  one    0\n    1  bar  two    1\n    2  baz  one    2\n    3  baz  two    3\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    if drop:\n        new_index = ibase.default_index(len(self))\n        if level is not None:\n            if not isinstance(level, (tuple, list)):\n                level = [level]\n            level = [self.index._get_level_number(lev) for lev in level]\n            if len(level) < self.index.nlevels:\n                new_index = self.index.droplevel(level)\n        if inplace:\n            self.index = new_index\n            self.name = name or self.name\n        else:\n            return self._constructor(self._values.copy(), index=new_index).__finalize__(self, method='reset_index')\n    elif inplace:\n        raise TypeError('Cannot reset_index inplace on a Series to create a DataFrame')\n    else:\n        df = self.to_frame(name)\n        return df.reset_index(level=level, drop=drop)",
                            "def __repr__(self) -> str:\n    \"\"\"\n    Return a string representation for a particular Series.\n    \"\"\"\n    buf = StringIO('')\n    width, height = get_terminal_size()\n    max_rows = height if get_option('display.max_rows') == 0 else get_option('display.max_rows')\n    min_rows = height if get_option('display.max_rows') == 0 else get_option('display.min_rows')\n    show_dimensions = get_option('display.show_dimensions')\n    self.to_string(buf=buf, name=self.name, dtype=self.dtype, min_rows=min_rows, max_rows=max_rows, length=show_dimensions)\n    result = buf.getvalue()\n    return result",
                            "def to_string(self, buf=None, na_rep='NaN', float_format=None, header=True, index=True, length=False, dtype=False, name=False, max_rows=None, min_rows=None):\n    \"\"\"\n    Render a string representation of the Series.\n\n    Parameters\n    ----------\n    buf : StringIO-like, optional\n        Buffer to write to.\n    na_rep : str, optional\n        String representation of NaN to use, default 'NaN'.\n    float_format : one-parameter function, optional\n        Formatter function to apply to columns' elements if they are\n        floats, default None.\n    header : bool, default True\n        Add the Series header (index name).\n    index : bool, optional\n        Add index (row) labels, default True.\n    length : bool, default False\n        Add the Series length.\n    dtype : bool, default False\n        Add the Series dtype.\n    name : bool, default False\n        Add the Series name if not None.\n    max_rows : int, optional\n        Maximum number of rows to show before truncating. If None, show\n        all.\n    min_rows : int, optional\n        The number of rows to display in a truncated repr (when number\n        of rows is above `max_rows`).\n\n    Returns\n    -------\n    str or None\n        String representation of Series if ``buf=None``, otherwise None.\n    \"\"\"\n    formatter = fmt.SeriesFormatter(self, name=name, length=length, header=header, index=index, dtype=dtype, na_rep=na_rep, float_format=float_format, min_rows=min_rows, max_rows=max_rows)\n    result = formatter.to_string()\n    if not isinstance(result, str):\n        raise AssertionError(f'result must be of type str, type of result is {repr(type(result).__name__)}')\n    if buf is None:\n        return result\n    else:\n        try:\n            buf.write(result)\n        except AttributeError:\n            with open(buf, 'w') as f:\n                f.write(result)",
                            "@Appender('\\n        Examples\\n        --------\\n        >>> s = pd.Series([\"elk\", \"pig\", \"dog\", \"quetzal\"], name=\"animal\")\\n        >>> print(s.to_markdown())\\n        |    | animal   |\\n        |---:|:---------|\\n        |  0 | elk      |\\n        |  1 | pig      |\\n        |  2 | dog      |\\n        |  3 | quetzal  |\\n        ')\n@Substitution(klass='Series')\n@Appender(generic._shared_docs['to_markdown'])\ndef to_markdown(self, buf: Optional[IO[str]]=None, mode: Optional[str]=None, **kwargs) -> Optional[str]:\n    return self.to_frame().to_markdown(buf, mode, **kwargs)",
                            "def items(self) -> Iterable[Tuple[Label, Any]]:\n    \"\"\"\n    Lazily iterate over (index, value) tuples.\n\n    This method returns an iterable tuple (index, value). This is\n    convenient if you want to create a lazy iterator.\n\n    Returns\n    -------\n    iterable\n        Iterable of tuples containing the (index, value) pairs from a\n        Series.\n\n    See Also\n    --------\n    DataFrame.items : Iterate over (column name, Series) pairs.\n    DataFrame.iterrows : Iterate over DataFrame rows as (index, Series) pairs.\n\n    Examples\n    --------\n    >>> s = pd.Series(['A', 'B', 'C'])\n    >>> for index, value in s.items():\n    ...     print(f\"Index : {index}, Value : {value}\")\n    Index : 0, Value : A\n    Index : 1, Value : B\n    Index : 2, Value : C\n    \"\"\"\n    return zip(iter(self.index), iter(self))",
                            "@Appender(items.__doc__)\ndef iteritems(self) -> Iterable[Tuple[Label, Any]]:\n    return self.items()",
                            "def keys(self) -> Index:\n    \"\"\"\n    Return alias for index.\n\n    Returns\n    -------\n    Index\n        Index of the Series.\n    \"\"\"\n    return self.index",
                            "def to_dict(self, into=dict):\n    \"\"\"\n    Convert Series to {label -> value} dict or dict-like object.\n\n    Parameters\n    ----------\n    into : class, default dict\n        The collections.abc.Mapping subclass to use as the return\n        object. Can be the actual class or an empty\n        instance of the mapping type you want.  If you want a\n        collections.defaultdict, you must pass it initialized.\n\n    Returns\n    -------\n    collections.abc.Mapping\n        Key-value representation of Series.\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3, 4])\n    >>> s.to_dict()\n    {0: 1, 1: 2, 2: 3, 3: 4}\n    >>> from collections import OrderedDict, defaultdict\n    >>> s.to_dict(OrderedDict)\n    OrderedDict([(0, 1), (1, 2), (2, 3), (3, 4)])\n    >>> dd = defaultdict(list)\n    >>> s.to_dict(dd)\n    defaultdict(<class 'list'>, {0: 1, 1: 2, 2: 3, 3: 4})\n    \"\"\"\n    into_c = com.standardize_mapping(into)\n    return into_c(self.items())",
                            "def to_frame(self, name=None) -> 'DataFrame':\n    \"\"\"\n    Convert Series to DataFrame.\n\n    Parameters\n    ----------\n    name : object, default None\n        The passed name should substitute for the series name (if it has\n        one).\n\n    Returns\n    -------\n    DataFrame\n        DataFrame representation of Series.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"a\", \"b\", \"c\"],\n    ...               name=\"vals\")\n    >>> s.to_frame()\n      vals\n    0    a\n    1    b\n    2    c\n    \"\"\"\n    if name is None:\n        df = self._constructor_expanddim(self)\n    else:\n        df = self._constructor_expanddim({name: self})\n    return df",
                            "def _set_name(self, name, inplace=False) -> 'Series':\n    \"\"\"\n    Set the Series name.\n\n    Parameters\n    ----------\n    name : str\n    inplace : bool\n        Whether to modify `self` directly or return a copy.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    ser = self if inplace else self.copy()\n    ser.name = name\n    return ser",
                            "@Appender('\\nExamples\\n--------\\n>>> ser = pd.Series([390., 350., 30., 20.],\\n...                 index=[\\'Falcon\\', \\'Falcon\\', \\'Parrot\\', \\'Parrot\\'], name=\"Max Speed\")\\n>>> ser\\nFalcon    390.0\\nFalcon    350.0\\nParrot     30.0\\nParrot     20.0\\nName: Max Speed, dtype: float64\\n>>> ser.groupby([\"a\", \"b\", \"a\", \"b\"]).mean()\\na    210.0\\nb    185.0\\nName: Max Speed, dtype: float64\\n>>> ser.groupby(level=0).mean()\\nFalcon    370.0\\nParrot     25.0\\nName: Max Speed, dtype: float64\\n>>> ser.groupby(ser > 100).mean()\\nMax Speed\\nFalse     25.0\\nTrue     370.0\\nName: Max Speed, dtype: float64\\n\\n**Grouping by Indexes**\\n\\nWe can groupby different levels of a hierarchical index\\nusing the `level` parameter:\\n\\n>>> arrays = [[\\'Falcon\\', \\'Falcon\\', \\'Parrot\\', \\'Parrot\\'],\\n...           [\\'Captive\\', \\'Wild\\', \\'Captive\\', \\'Wild\\']]\\n>>> index = pd.MultiIndex.from_arrays(arrays, names=(\\'Animal\\', \\'Type\\'))\\n>>> ser = pd.Series([390., 350., 30., 20.], index=index, name=\"Max Speed\")\\n>>> ser\\nAnimal  Type\\nFalcon  Captive    390.0\\n        Wild       350.0\\nParrot  Captive     30.0\\n        Wild        20.0\\nName: Max Speed, dtype: float64\\n>>> ser.groupby(level=0).mean()\\nAnimal\\nFalcon    370.0\\nParrot     25.0\\nName: Max Speed, dtype: float64\\n>>> ser.groupby(level=\"Type\").mean()\\nType\\nCaptive    210.0\\nWild       185.0\\nName: Max Speed, dtype: float64\\n\\nWe can also choose to include `NA` in group keys or not by defining\\n`dropna` parameter, the default setting is `True`:\\n\\n>>> ser = pd.Series([1, 2, 3, 3], index=[\"a\", \\'a\\', \\'b\\', np.nan])\\n>>> ser.groupby(level=0).sum()\\na    3\\nb    3\\ndtype: int64\\n\\n>>> ser.groupby(level=0, dropna=False).sum()\\na    3\\nb    3\\nNaN  3\\ndtype: int64\\n\\n>>> arrays = [\\'Falcon\\', \\'Falcon\\', \\'Parrot\\', \\'Parrot\\']\\n>>> ser = pd.Series([390., 350., 30., 20.], index=arrays, name=\"Max Speed\")\\n>>> ser.groupby([\"a\", \"b\", \"a\", np.nan]).mean()\\na    210.0\\nb    350.0\\nName: Max Speed, dtype: float64\\n\\n>>> ser.groupby([\"a\", \"b\", \"a\", np.nan], dropna=False).mean()\\na    210.0\\nb    350.0\\nNaN   20.0\\nName: Max Speed, dtype: float64\\n')\n@Appender(generic._shared_docs['groupby'] % _shared_doc_kwargs)\ndef groupby(self, by=None, axis=0, level=None, as_index: bool=True, sort: bool=True, group_keys: bool=True, squeeze: bool=False, observed: bool=False, dropna: bool=True) -> 'SeriesGroupBy':\n    from pandas.core.groupby.generic import SeriesGroupBy\n    if level is None and by is None:\n        raise TypeError(\"You have to supply one of 'by' and 'level'\")\n    axis = self._get_axis_number(axis)\n    return SeriesGroupBy(obj=self, keys=by, axis=axis, level=level, as_index=as_index, sort=sort, group_keys=group_keys, squeeze=squeeze, observed=observed, dropna=dropna)",
                            "def count(self, level=None):\n    \"\"\"\n    Return number of non-NA/null observations in the Series.\n\n    Parameters\n    ----------\n    level : int or level name, default None\n        If the axis is a MultiIndex (hierarchical), count along a\n        particular level, collapsing into a smaller Series.\n\n    Returns\n    -------\n    int or Series (if level specified)\n        Number of non-null values in the Series.\n\n    See Also\n    --------\n    DataFrame.count : Count non-NA cells for each column or row.\n\n    Examples\n    --------\n    >>> s = pd.Series([0.0, 1.0, np.nan])\n    >>> s.count()\n    2\n    \"\"\"\n    if level is None:\n        return notna(self.array).sum()\n    if isinstance(level, str):\n        level = self.index._get_level_number(level)\n    lev = self.index.levels[level]\n    level_codes = np.array(self.index.codes[level], subok=False, copy=True)\n    mask = level_codes == -1\n    if mask.any():\n        level_codes[mask] = cnt = len(lev)\n        lev = lev.insert(cnt, lev._na_value)\n    obs = level_codes[notna(self._values)]\n    out = np.bincount(obs, minlength=len(lev) or None)\n    return self._constructor(out, index=lev, dtype='int64').__finalize__(self, method='count')",
                            "def mode(self, dropna=True) -> 'Series':\n    \"\"\"\n    Return the mode(s) of the dataset.\n\n    Always returns Series even if only one value is returned.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't consider counts of NaN/NaT.\n\n        .. versionadded:: 0.24.0\n\n    Returns\n    -------\n    Series\n        Modes of the Series in sorted order.\n    \"\"\"\n    return algorithms.mode(self, dropna=dropna)",
                            "def unique(self):\n    \"\"\"\n    Return unique values of Series object.\n\n    Uniques are returned in order of appearance. Hash table-based unique,\n    therefore does NOT sort.\n\n    Returns\n    -------\n    ndarray or ExtensionArray\n        The unique values returned as a NumPy array. See Notes.\n\n    See Also\n    --------\n    unique : Top-level unique method for any 1-d array-like object.\n    Index.unique : Return Index with unique values from an Index object.\n\n    Notes\n    -----\n    Returns the unique values as a NumPy array. In case of an\n    extension-array backed Series, a new\n    :class:`~api.extensions.ExtensionArray` of that type with just\n    the unique values is returned. This includes\n\n        * Categorical\n        * Period\n        * Datetime with Timezone\n        * Interval\n        * Sparse\n        * IntegerNA\n\n    See Examples section.\n\n    Examples\n    --------\n    >>> pd.Series([2, 1, 3, 3], name='A').unique()\n    array([2, 1, 3])\n\n    >>> pd.Series([pd.Timestamp('2016-01-01') for _ in range(3)]).unique()\n    array(['2016-01-01T00:00:00.000000000'], dtype='datetime64[ns]')\n\n    >>> pd.Series([pd.Timestamp('2016-01-01', tz='US/Eastern')\n    ...            for _ in range(3)]).unique()\n    <DatetimeArray>\n    ['2016-01-01 00:00:00-05:00']\n    Length: 1, dtype: datetime64[ns, US/Eastern]\n\n    An unordered Categorical will return categories in the order of\n    appearance.\n\n    >>> pd.Series(pd.Categorical(list('baabc'))).unique()\n    [b, a, c]\n    Categories (3, object): [b, a, c]\n\n    An ordered Categorical preserves the category ordering.\n\n    >>> pd.Series(pd.Categorical(list('baabc'), categories=list('abc'),\n    ...                          ordered=True)).unique()\n    [b, a, c]\n    Categories (3, object): [a < b < c]\n    \"\"\"\n    result = super().unique()\n    return result",
                            "def drop_duplicates(self, keep='first', inplace=False) -> Optional['Series']:\n    \"\"\"\n    Return Series with duplicate values removed.\n\n    Parameters\n    ----------\n    keep : {'first', 'last', ``False``}, default 'first'\n        Method to handle dropping duplicates:\n\n        - 'first' : Drop duplicates except for the first occurrence.\n        - 'last' : Drop duplicates except for the last occurrence.\n        - ``False`` : Drop all duplicates.\n\n    inplace : bool, default ``False``\n        If ``True``, performs operation inplace and returns None.\n\n    Returns\n    -------\n    Series\n        Series with duplicates dropped.\n\n    See Also\n    --------\n    Index.drop_duplicates : Equivalent method on Index.\n    DataFrame.drop_duplicates : Equivalent method on DataFrame.\n    Series.duplicated : Related method on Series, indicating duplicate\n        Series values.\n\n    Examples\n    --------\n    Generate a Series with duplicated entries.\n\n    >>> s = pd.Series(['lama', 'cow', 'lama', 'beetle', 'lama', 'hippo'],\n    ...               name='animal')\n    >>> s\n    0      lama\n    1       cow\n    2      lama\n    3    beetle\n    4      lama\n    5     hippo\n    Name: animal, dtype: object\n\n    With the 'keep' parameter, the selection behaviour of duplicated values\n    can be changed. The value 'first' keeps the first occurrence for each\n    set of duplicated entries. The default value of keep is 'first'.\n\n    >>> s.drop_duplicates()\n    0      lama\n    1       cow\n    3    beetle\n    5     hippo\n    Name: animal, dtype: object\n\n    The value 'last' for parameter 'keep' keeps the last occurrence for\n    each set of duplicated entries.\n\n    >>> s.drop_duplicates(keep='last')\n    1       cow\n    3    beetle\n    4      lama\n    5     hippo\n    Name: animal, dtype: object\n\n    The value ``False`` for parameter 'keep' discards all sets of\n    duplicated entries. Setting the value of 'inplace' to ``True`` performs\n    the operation inplace and returns ``None``.\n\n    >>> s.drop_duplicates(keep=False, inplace=True)\n    >>> s\n    1       cow\n    3    beetle\n    5     hippo\n    Name: animal, dtype: object\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    result = super().drop_duplicates(keep=keep)\n    if inplace:\n        self._update_inplace(result)\n        return None\n    else:\n        return result",
                            "def duplicated(self, keep='first') -> 'Series':\n    \"\"\"\n    Indicate duplicate Series values.\n\n    Duplicated values are indicated as ``True`` values in the resulting\n    Series. Either all duplicates, all except the first or all except the\n    last occurrence of duplicates can be indicated.\n\n    Parameters\n    ----------\n    keep : {'first', 'last', False}, default 'first'\n        Method to handle dropping duplicates:\n\n        - 'first' : Mark duplicates as ``True`` except for the first\n          occurrence.\n        - 'last' : Mark duplicates as ``True`` except for the last\n          occurrence.\n        - ``False`` : Mark all duplicates as ``True``.\n\n    Returns\n    -------\n    Series\n        Series indicating whether each value has occurred in the\n        preceding values.\n\n    See Also\n    --------\n    Index.duplicated : Equivalent method on pandas.Index.\n    DataFrame.duplicated : Equivalent method on pandas.DataFrame.\n    Series.drop_duplicates : Remove duplicate values from Series.\n\n    Examples\n    --------\n    By default, for each set of duplicated values, the first occurrence is\n    set on False and all others on True:\n\n    >>> animals = pd.Series(['lama', 'cow', 'lama', 'beetle', 'lama'])\n    >>> animals.duplicated()\n    0    False\n    1    False\n    2     True\n    3    False\n    4     True\n    dtype: bool\n\n    which is equivalent to\n\n    >>> animals.duplicated(keep='first')\n    0    False\n    1    False\n    2     True\n    3    False\n    4     True\n    dtype: bool\n\n    By using 'last', the last occurrence of each set of duplicated values\n    is set on False and all others on True:\n\n    >>> animals.duplicated(keep='last')\n    0     True\n    1    False\n    2     True\n    3    False\n    4    False\n    dtype: bool\n\n    By setting keep on ``False``, all duplicates are True:\n\n    >>> animals.duplicated(keep=False)\n    0     True\n    1    False\n    2     True\n    3    False\n    4     True\n    dtype: bool\n    \"\"\"\n    return super().duplicated(keep=keep)",
                            "def idxmin(self, axis=0, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the row label of the minimum value.\n\n    If multiple values equal the minimum, the first row label with that\n    value is returned.\n\n    Parameters\n    ----------\n    axis : int, default 0\n        For compatibility with DataFrame.idxmin. Redundant for application\n        on Series.\n    skipna : bool, default True\n        Exclude NA/null values. If the entire Series is NA, the result\n        will be NA.\n    *args, **kwargs\n        Additional arguments and keywords have no effect but might be\n        accepted for compatibility with NumPy.\n\n    Returns\n    -------\n    Index\n        Label of the minimum value.\n\n    Raises\n    ------\n    ValueError\n        If the Series is empty.\n\n    See Also\n    --------\n    numpy.argmin : Return indices of the minimum values\n        along the given axis.\n    DataFrame.idxmin : Return index of first occurrence of minimum\n        over requested axis.\n    Series.idxmax : Return index *label* of the first occurrence\n        of maximum of values.\n\n    Notes\n    -----\n    This method is the Series version of ``ndarray.argmin``. This method\n    returns the label of the minimum, while ``ndarray.argmin`` returns\n    the position. To get the position, use ``series.values.argmin()``.\n\n    Examples\n    --------\n    >>> s = pd.Series(data=[1, None, 4, 1],\n    ...               index=['A', 'B', 'C', 'D'])\n    >>> s\n    A    1.0\n    B    NaN\n    C    4.0\n    D    1.0\n    dtype: float64\n\n    >>> s.idxmin()\n    'A'\n\n    If `skipna` is False and there is an NA value in the data,\n    the function returns ``nan``.\n\n    >>> s.idxmin(skipna=False)\n    nan\n    \"\"\"\n    skipna = nv.validate_argmin_with_skipna(skipna, args, kwargs)\n    i = nanops.nanargmin(self._values, skipna=skipna)\n    if i == -1:\n        return np.nan\n    return self.index[i]",
                            "def idxmax(self, axis=0, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the row label of the maximum value.\n\n    If multiple values equal the maximum, the first row label with that\n    value is returned.\n\n    Parameters\n    ----------\n    axis : int, default 0\n        For compatibility with DataFrame.idxmax. Redundant for application\n        on Series.\n    skipna : bool, default True\n        Exclude NA/null values. If the entire Series is NA, the result\n        will be NA.\n    *args, **kwargs\n        Additional arguments and keywords have no effect but might be\n        accepted for compatibility with NumPy.\n\n    Returns\n    -------\n    Index\n        Label of the maximum value.\n\n    Raises\n    ------\n    ValueError\n        If the Series is empty.\n\n    See Also\n    --------\n    numpy.argmax : Return indices of the maximum values\n        along the given axis.\n    DataFrame.idxmax : Return index of first occurrence of maximum\n        over requested axis.\n    Series.idxmin : Return index *label* of the first occurrence\n        of minimum of values.\n\n    Notes\n    -----\n    This method is the Series version of ``ndarray.argmax``. This method\n    returns the label of the maximum, while ``ndarray.argmax`` returns\n    the position. To get the position, use ``series.values.argmax()``.\n\n    Examples\n    --------\n    >>> s = pd.Series(data=[1, None, 4, 3, 4],\n    ...               index=['A', 'B', 'C', 'D', 'E'])\n    >>> s\n    A    1.0\n    B    NaN\n    C    4.0\n    D    3.0\n    E    4.0\n    dtype: float64\n\n    >>> s.idxmax()\n    'C'\n\n    If `skipna` is False and there is an NA value in the data,\n    the function returns ``nan``.\n\n    >>> s.idxmax(skipna=False)\n    nan\n    \"\"\"\n    skipna = nv.validate_argmax_with_skipna(skipna, args, kwargs)\n    i = nanops.nanargmax(self._values, skipna=skipna)\n    if i == -1:\n        return np.nan\n    return self.index[i]",
                            "def round(self, decimals=0, *args, **kwargs) -> 'Series':\n    \"\"\"\n    Round each value in a Series to the given number of decimals.\n\n    Parameters\n    ----------\n    decimals : int, default 0\n        Number of decimal places to round to. If decimals is negative,\n        it specifies the number of positions to the left of the decimal point.\n    *args, **kwargs\n        Additional arguments and keywords have no effect but might be\n        accepted for compatibility with NumPy.\n\n    Returns\n    -------\n    Series\n        Rounded values of the Series.\n\n    See Also\n    --------\n    numpy.around : Round values of an np.array.\n    DataFrame.round : Round values of a DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series([0.1, 1.3, 2.7])\n    >>> s.round()\n    0    0.0\n    1    1.0\n    2    3.0\n    dtype: float64\n    \"\"\"\n    nv.validate_round(args, kwargs)\n    result = self._values.round(decimals)\n    result = self._constructor(result, index=self.index).__finalize__(self, method='round')\n    return result",
                            "def quantile(self, q=0.5, interpolation='linear'):\n    \"\"\"\n    Return value at the given quantile.\n\n    Parameters\n    ----------\n    q : float or array-like, default 0.5 (50% quantile)\n        The quantile(s) to compute, which can lie in range: 0 <= q <= 1.\n    interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}\n        This optional parameter specifies the interpolation method to use,\n        when the desired quantile lies between two data points `i` and `j`:\n\n            * linear: `i + (j - i) * fraction`, where `fraction` is the\n              fractional part of the index surrounded by `i` and `j`.\n            * lower: `i`.\n            * higher: `j`.\n            * nearest: `i` or `j` whichever is nearest.\n            * midpoint: (`i` + `j`) / 2.\n\n    Returns\n    -------\n    float or Series\n        If ``q`` is an array, a Series will be returned where the\n        index is ``q`` and the values are the quantiles, otherwise\n        a float will be returned.\n\n    See Also\n    --------\n    core.window.Rolling.quantile : Calculate the rolling quantile.\n    numpy.percentile : Returns the q-th percentile(s) of the array elements.\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3, 4])\n    >>> s.quantile(.5)\n    2.5\n    >>> s.quantile([.25, .5, .75])\n    0.25    1.75\n    0.50    2.50\n    0.75    3.25\n    dtype: float64\n    \"\"\"\n    validate_percentile(q)\n    df = self.to_frame()\n    result = df.quantile(q=q, interpolation=interpolation, numeric_only=False)\n    if result.ndim == 2:\n        result = result.iloc[:, 0]\n    if is_list_like(q):\n        result.name = self.name\n        return self._constructor(result, index=Float64Index(q), name=self.name)\n    else:\n        return result.iloc[0]",
                            "def corr(self, other, method='pearson', min_periods=None) -> float:\n    \"\"\"\n    Compute correlation with `other` Series, excluding missing values.\n\n    Parameters\n    ----------\n    other : Series\n        Series with which to compute the correlation.\n    method : {'pearson', 'kendall', 'spearman'} or callable\n        Method used to compute correlation:\n\n        - pearson : Standard correlation coefficient\n        - kendall : Kendall Tau correlation coefficient\n        - spearman : Spearman rank correlation\n        - callable: Callable with input two 1d ndarrays and returning a float.\n\n        .. versionadded:: 0.24.0\n            Note that the returned matrix from corr will have 1 along the\n            diagonals and will be symmetric regardless of the callable's\n            behavior.\n    min_periods : int, optional\n        Minimum number of observations needed to have a valid result.\n\n    Returns\n    -------\n    float\n        Correlation with other.\n\n    See Also\n    --------\n    DataFrame.corr : Compute pairwise correlation between columns.\n    DataFrame.corrwith : Compute pairwise correlation with another\n        DataFrame or Series.\n\n    Examples\n    --------\n    >>> def histogram_intersection(a, b):\n    ...     v = np.minimum(a, b).sum().round(decimals=1)\n    ...     return v\n    >>> s1 = pd.Series([.2, .0, .6, .2])\n    >>> s2 = pd.Series([.3, .6, .0, .1])\n    >>> s1.corr(s2, method=histogram_intersection)\n    0.3\n    \"\"\"\n    this, other = self.align(other, join='inner', copy=False)\n    if len(this) == 0:\n        return np.nan\n    if method in ['pearson', 'spearman', 'kendall'] or callable(method):\n        return nanops.nancorr(this.values, other.values, method=method, min_periods=min_periods)\n    raise ValueError(f\"method must be either 'pearson', 'spearman', 'kendall', or a callable, '{method}' was supplied\")",
                            "def cov(self, other, min_periods=None) -> float:\n    \"\"\"\n    Compute covariance with Series, excluding missing values.\n\n    Parameters\n    ----------\n    other : Series\n        Series with which to compute the covariance.\n    min_periods : int, optional\n        Minimum number of observations needed to have a valid result.\n\n    Returns\n    -------\n    float\n        Covariance between Series and other normalized by N-1\n        (unbiased estimator).\n\n    See Also\n    --------\n    DataFrame.cov : Compute pairwise covariance of columns.\n\n    Examples\n    --------\n    >>> s1 = pd.Series([0.90010907, 0.13484424, 0.62036035])\n    >>> s2 = pd.Series([0.12528585, 0.26962463, 0.51111198])\n    >>> s1.cov(s2)\n    -0.01685762652715874\n    \"\"\"\n    this, other = self.align(other, join='inner', copy=False)\n    if len(this) == 0:\n        return np.nan\n    return nanops.nancov(this.values, other.values, min_periods=min_periods)",
                            "def diff(self, periods: int=1) -> 'Series':\n    \"\"\"\n    First discrete difference of element.\n\n    Calculates the difference of a Series element compared with another\n    element in the Series (default is element in previous row).\n\n    Parameters\n    ----------\n    periods : int, default 1\n        Periods to shift for calculating difference, accepts negative\n        values.\n\n    Returns\n    -------\n    Series\n        First differences of the Series.\n\n    See Also\n    --------\n    Series.pct_change: Percent change over given number of periods.\n    Series.shift: Shift index by desired number of periods with an\n        optional time freq.\n    DataFrame.diff: First discrete difference of object.\n\n    Notes\n    -----\n    For boolean dtypes, this uses :meth:`operator.xor` rather than\n    :meth:`operator.sub`.\n\n    Examples\n    --------\n    Difference with previous row\n\n    >>> s = pd.Series([1, 1, 2, 3, 5, 8])\n    >>> s.diff()\n    0    NaN\n    1    0.0\n    2    1.0\n    3    1.0\n    4    2.0\n    5    3.0\n    dtype: float64\n\n    Difference with 3rd previous row\n\n    >>> s.diff(periods=3)\n    0    NaN\n    1    NaN\n    2    NaN\n    3    2.0\n    4    4.0\n    5    6.0\n    dtype: float64\n\n    Difference with following row\n\n    >>> s.diff(periods=-1)\n    0    0.0\n    1   -1.0\n    2   -1.0\n    3   -2.0\n    4   -3.0\n    5    NaN\n    dtype: float64\n    \"\"\"\n    result = algorithms.diff(self.array, periods)\n    return self._constructor(result, index=self.index).__finalize__(self, method='diff')",
                            "def autocorr(self, lag=1) -> float:\n    \"\"\"\n    Compute the lag-N autocorrelation.\n\n    This method computes the Pearson correlation between\n    the Series and its shifted self.\n\n    Parameters\n    ----------\n    lag : int, default 1\n        Number of lags to apply before performing autocorrelation.\n\n    Returns\n    -------\n    float\n        The Pearson correlation between self and self.shift(lag).\n\n    See Also\n    --------\n    Series.corr : Compute the correlation between two Series.\n    Series.shift : Shift index by desired number of periods.\n    DataFrame.corr : Compute pairwise correlation of columns.\n    DataFrame.corrwith : Compute pairwise correlation between rows or\n        columns of two DataFrame objects.\n\n    Notes\n    -----\n    If the Pearson correlation is not well defined return 'NaN'.\n\n    Examples\n    --------\n    >>> s = pd.Series([0.25, 0.5, 0.2, -0.05])\n    >>> s.autocorr()  # doctest: +ELLIPSIS\n    0.10355...\n    >>> s.autocorr(lag=2)  # doctest: +ELLIPSIS\n    -0.99999...\n\n    If the Pearson correlation is not well defined, then 'NaN' is returned.\n\n    >>> s = pd.Series([1, 0, 0, 0])\n    >>> s.autocorr()\n    nan\n    \"\"\"\n    return self.corr(self.shift(lag))",
                            "def dot(self, other):\n    \"\"\"\n    Compute the dot product between the Series and the columns of other.\n\n    This method computes the dot product between the Series and another\n    one, or the Series and each columns of a DataFrame, or the Series and\n    each columns of an array.\n\n    It can also be called using `self @ other` in Python >= 3.5.\n\n    Parameters\n    ----------\n    other : Series, DataFrame or array-like\n        The other object to compute the dot product with its columns.\n\n    Returns\n    -------\n    scalar, Series or numpy.ndarray\n        Return the dot product of the Series and other if other is a\n        Series, the Series of the dot product of Series and each rows of\n        other if other is a DataFrame or a numpy.ndarray between the Series\n        and each columns of the numpy array.\n\n    See Also\n    --------\n    DataFrame.dot: Compute the matrix product with the DataFrame.\n    Series.mul: Multiplication of series and other, element-wise.\n\n    Notes\n    -----\n    The Series and other has to share the same index if other is a Series\n    or a DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series([0, 1, 2, 3])\n    >>> other = pd.Series([-1, 2, -3, 4])\n    >>> s.dot(other)\n    8\n    >>> s @ other\n    8\n    >>> df = pd.DataFrame([[0, 1], [-2, 3], [4, -5], [6, 7]])\n    >>> s.dot(df)\n    0    24\n    1    14\n    dtype: int64\n    >>> arr = np.array([[0, 1], [-2, 3], [4, -5], [6, 7]])\n    >>> s.dot(arr)\n    array([24, 14])\n    \"\"\"\n    if isinstance(other, (Series, ABCDataFrame)):\n        common = self.index.union(other.index)\n        if len(common) > len(self.index) or len(common) > len(other.index):\n            raise ValueError('matrices are not aligned')\n        left = self.reindex(index=common, copy=False)\n        right = other.reindex(index=common, copy=False)\n        lvals = left.values\n        rvals = right.values\n    else:\n        lvals = self.values\n        rvals = np.asarray(other)\n        if lvals.shape[0] != rvals.shape[0]:\n            raise Exception(f'Dot product shape mismatch, {lvals.shape} vs {rvals.shape}')\n    if isinstance(other, ABCDataFrame):\n        return self._constructor(np.dot(lvals, rvals), index=other.columns).__finalize__(self, method='dot')\n    elif isinstance(other, Series):\n        return np.dot(lvals, rvals)\n    elif isinstance(rvals, np.ndarray):\n        return np.dot(lvals, rvals)\n    else:\n        raise TypeError(f'unsupported type: {type(other)}')",
                            "def __matmul__(self, other):\n    \"\"\"\n    Matrix multiplication using binary `@` operator in Python>=3.5.\n    \"\"\"\n    return self.dot(other)",
                            "def __rmatmul__(self, other):\n    \"\"\"\n    Matrix multiplication using binary `@` operator in Python>=3.5.\n    \"\"\"\n    return self.dot(np.transpose(other))",
                            "@doc(base.IndexOpsMixin.searchsorted, klass='Series')\ndef searchsorted(self, value, side='left', sorter=None):\n    return algorithms.searchsorted(self._values, value, side=side, sorter=sorter)",
                            "def append(self, to_append, ignore_index=False, verify_integrity=False):\n    \"\"\"\n    Concatenate two or more Series.\n\n    Parameters\n    ----------\n    to_append : Series or list/tuple of Series\n        Series to append with self.\n    ignore_index : bool, default False\n        If True, do not use the index labels.\n    verify_integrity : bool, default False\n        If True, raise Exception on creating index with duplicates.\n\n    Returns\n    -------\n    Series\n        Concatenated Series.\n\n    See Also\n    --------\n    concat : General function to concatenate DataFrame or Series objects.\n\n    Notes\n    -----\n    Iteratively appending to a Series can be more computationally intensive\n    than a single concatenate. A better solution is to append values to a\n    list and then concatenate the list with the original Series all at\n    once.\n\n    Examples\n    --------\n    >>> s1 = pd.Series([1, 2, 3])\n    >>> s2 = pd.Series([4, 5, 6])\n    >>> s3 = pd.Series([4, 5, 6], index=[3, 4, 5])\n    >>> s1.append(s2)\n    0    1\n    1    2\n    2    3\n    0    4\n    1    5\n    2    6\n    dtype: int64\n\n    >>> s1.append(s3)\n    0    1\n    1    2\n    2    3\n    3    4\n    4    5\n    5    6\n    dtype: int64\n\n    With `ignore_index` set to True:\n\n    >>> s1.append(s2, ignore_index=True)\n    0    1\n    1    2\n    2    3\n    3    4\n    4    5\n    5    6\n    dtype: int64\n\n    With `verify_integrity` set to True:\n\n    >>> s1.append(s2, verify_integrity=True)\n    Traceback (most recent call last):\n    ...\n    ValueError: Indexes have overlapping values: [0, 1, 2]\n    \"\"\"\n    from pandas.core.reshape.concat import concat\n    if isinstance(to_append, (list, tuple)):\n        to_concat = [self]\n        to_concat.extend(to_append)\n    else:\n        to_concat = [self, to_append]\n    if any((isinstance(x, (ABCDataFrame,)) for x in to_concat[1:])):\n        msg = 'to_append should be a Series or list/tuple of Series, got DataFrame'\n        raise TypeError(msg)\n    return concat(to_concat, ignore_index=ignore_index, verify_integrity=verify_integrity)",
                            "def _binop(self, other, func, level=None, fill_value=None):\n    \"\"\"\n    Perform generic binary operation with optional fill value.\n\n    Parameters\n    ----------\n    other : Series\n    func : binary operator\n    fill_value : float or object\n        Value to substitute for NA/null values. If both Series are NA in a\n        location, the result will be NA regardless of the passed fill value.\n    level : int or level name, default None\n        Broadcast across a level, matching Index values on the\n        passed MultiIndex level.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    if not isinstance(other, Series):\n        raise AssertionError('Other operand must be Series')\n    this = self\n    if not self.index.equals(other.index):\n        this, other = self.align(other, level=level, join='outer', copy=False)\n    this_vals, other_vals = ops.fill_binop(this.values, other.values, fill_value)\n    with np.errstate(all='ignore'):\n        result = func(this_vals, other_vals)\n    name = ops.get_op_result_name(self, other)\n    ret = this._construct_result(result, name)\n    return ret",
                            "def _construct_result(self, result: Union[ArrayLike, Tuple[ArrayLike, ArrayLike]], name: Label) -> Union['Series', Tuple['Series', 'Series']]:\n    \"\"\"\n    Construct an appropriately-labelled Series from the result of an op.\n\n    Parameters\n    ----------\n    result : ndarray or ExtensionArray\n    name : Label\n\n    Returns\n    -------\n    Series\n        In the case of __divmod__ or __rdivmod__, a 2-tuple of Series.\n    \"\"\"\n    if isinstance(result, tuple):\n        res1 = self._construct_result(result[0], name=name)\n        res2 = self._construct_result(result[1], name=name)\n        assert isinstance(res1, Series)\n        assert isinstance(res2, Series)\n        return (res1, res2)\n    out = self._constructor(result, index=self.index)\n    out = out.__finalize__(self)\n    out.name = name\n    return out",
                            "def combine(self, other, func, fill_value=None) -> 'Series':\n    \"\"\"\n    Combine the Series with a Series or scalar according to `func`.\n\n    Combine the Series and `other` using `func` to perform elementwise\n    selection for combined Series.\n    `fill_value` is assumed when value is missing at some index\n    from one of the two objects being combined.\n\n    Parameters\n    ----------\n    other : Series or scalar\n        The value(s) to be combined with the `Series`.\n    func : function\n        Function that takes two scalars as inputs and returns an element.\n    fill_value : scalar, optional\n        The value to assume when an index is missing from\n        one Series or the other. The default specifies to use the\n        appropriate NaN value for the underlying dtype of the Series.\n\n    Returns\n    -------\n    Series\n        The result of combining the Series with the other object.\n\n    See Also\n    --------\n    Series.combine_first : Combine Series values, choosing the calling\n        Series' values first.\n\n    Examples\n    --------\n    Consider 2 Datasets ``s1`` and ``s2`` containing\n    highest clocked speeds of different birds.\n\n    >>> s1 = pd.Series({'falcon': 330.0, 'eagle': 160.0})\n    >>> s1\n    falcon    330.0\n    eagle     160.0\n    dtype: float64\n    >>> s2 = pd.Series({'falcon': 345.0, 'eagle': 200.0, 'duck': 30.0})\n    >>> s2\n    falcon    345.0\n    eagle     200.0\n    duck       30.0\n    dtype: float64\n\n    Now, to combine the two datasets and view the highest speeds\n    of the birds across the two datasets\n\n    >>> s1.combine(s2, max)\n    duck        NaN\n    eagle     200.0\n    falcon    345.0\n    dtype: float64\n\n    In the previous example, the resulting value for duck is missing,\n    because the maximum of a NaN and a float is a NaN.\n    So, in the example, we set ``fill_value=0``,\n    so the maximum value returned will be the value from some dataset.\n\n    >>> s1.combine(s2, max, fill_value=0)\n    duck       30.0\n    eagle     200.0\n    falcon    345.0\n    dtype: float64\n    \"\"\"\n    if fill_value is None:\n        fill_value = na_value_for_dtype(self.dtype, compat=False)\n    if isinstance(other, Series):\n        new_index = self.index.union(other.index)\n        new_name = ops.get_op_result_name(self, other)\n        new_values = []\n        for idx in new_index:\n            lv = self.get(idx, fill_value)\n            rv = other.get(idx, fill_value)\n            with np.errstate(all='ignore'):\n                new_values.append(func(lv, rv))\n    else:\n        new_index = self.index\n        with np.errstate(all='ignore'):\n            new_values = [func(lv, other) for lv in self._values]\n        new_name = self.name\n    if is_categorical_dtype(self.dtype):\n        pass\n    elif is_extension_array_dtype(self.dtype):\n        new_values = maybe_cast_to_extension_array(type(self._values), new_values)\n    return self._constructor(new_values, index=new_index, name=new_name)",
                            "def combine_first(self, other) -> 'Series':\n    \"\"\"\n    Combine Series values, choosing the calling Series's values first.\n\n    Parameters\n    ----------\n    other : Series\n        The value(s) to be combined with the `Series`.\n\n    Returns\n    -------\n    Series\n        The result of combining the Series with the other object.\n\n    See Also\n    --------\n    Series.combine : Perform elementwise operation on two Series\n        using a given function.\n\n    Notes\n    -----\n    Result index will be the union of the two indexes.\n\n    Examples\n    --------\n    >>> s1 = pd.Series([1, np.nan])\n    >>> s2 = pd.Series([3, 4])\n    >>> s1.combine_first(s2)\n    0    1.0\n    1    4.0\n    dtype: float64\n    \"\"\"\n    new_index = self.index.union(other.index)\n    this = self.reindex(new_index, copy=False)\n    other = other.reindex(new_index, copy=False)\n    if this.dtype.kind == 'M' and other.dtype.kind != 'M':\n        other = to_datetime(other)\n    return this.where(notna(this), other)",
                            "def update(self, other) -> None:\n    \"\"\"\n    Modify Series in place using non-NA values from passed\n    Series. Aligns on index.\n\n    Parameters\n    ----------\n    other : Series, or object coercible into Series\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3])\n    >>> s.update(pd.Series([4, 5, 6]))\n    >>> s\n    0    4\n    1    5\n    2    6\n    dtype: int64\n\n    >>> s = pd.Series(['a', 'b', 'c'])\n    >>> s.update(pd.Series(['d', 'e'], index=[0, 2]))\n    >>> s\n    0    d\n    1    b\n    2    e\n    dtype: object\n\n    >>> s = pd.Series([1, 2, 3])\n    >>> s.update(pd.Series([4, 5, 6, 7, 8]))\n    >>> s\n    0    4\n    1    5\n    2    6\n    dtype: int64\n\n    If ``other`` contains NaNs the corresponding values are not updated\n    in the original Series.\n\n    >>> s = pd.Series([1, 2, 3])\n    >>> s.update(pd.Series([4, np.nan, 6]))\n    >>> s\n    0    4\n    1    2\n    2    6\n    dtype: int64\n\n    ``other`` can also be a non-Series object type\n    that is coercible into a Series\n\n    >>> s = pd.Series([1, 2, 3])\n    >>> s.update([4, np.nan, 6])\n    >>> s\n    0    4\n    1    2\n    2    6\n    dtype: int64\n\n    >>> s = pd.Series([1, 2, 3])\n    >>> s.update({1: 9})\n    >>> s\n    0    1\n    1    9\n    2    3\n    dtype: int64\n    \"\"\"\n    if not isinstance(other, Series):\n        other = Series(other)\n    other = other.reindex_like(self)\n    mask = notna(other)\n    self._mgr = self._mgr.putmask(mask=mask, new=other)\n    self._maybe_update_cacher()",
                            "def sort_values(self, axis=0, ascending=True, inplace: bool=False, kind: str='quicksort', na_position: str='last', ignore_index: bool=False, key: ValueKeyFunc=None):\n    \"\"\"\n    Sort by the values.\n\n    Sort a Series in ascending or descending order by some\n    criterion.\n\n    Parameters\n    ----------\n    axis : {0 or 'index'}, default 0\n        Axis to direct sorting. The value 'index' is accepted for\n        compatibility with DataFrame.sort_values.\n    ascending : bool, default True\n        If True, sort values in ascending order, otherwise descending.\n    inplace : bool, default False\n        If True, perform operation in-place.\n    kind : {'quicksort', 'mergesort' or 'heapsort'}, default 'quicksort'\n        Choice of sorting algorithm. See also :func:`numpy.sort` for more\n        information. 'mergesort' is the only stable  algorithm.\n    na_position : {'first' or 'last'}, default 'last'\n        Argument 'first' puts NaNs at the beginning, 'last' puts NaNs at\n        the end.\n    ignore_index : bool, default False\n        If True, the resulting axis will be labeled 0, 1, \u2026, n - 1.\n\n        .. versionadded:: 1.0.0\n\n    key : callable, optional\n        If not None, apply the key function to the series values\n        before sorting. This is similar to the `key` argument in the\n        builtin :meth:`sorted` function, with the notable difference that\n        this `key` function should be *vectorized*. It should expect a\n        ``Series`` and return an array-like.\n\n        .. versionadded:: 1.1.0\n\n    Returns\n    -------\n    Series\n        Series ordered by values.\n\n    See Also\n    --------\n    Series.sort_index : Sort by the Series indices.\n    DataFrame.sort_values : Sort DataFrame by the values along either axis.\n    DataFrame.sort_index : Sort DataFrame by indices.\n\n    Examples\n    --------\n    >>> s = pd.Series([np.nan, 1, 3, 10, 5])\n    >>> s\n    0     NaN\n    1     1.0\n    2     3.0\n    3     10.0\n    4     5.0\n    dtype: float64\n\n    Sort values ascending order (default behaviour)\n\n    >>> s.sort_values(ascending=True)\n    1     1.0\n    2     3.0\n    4     5.0\n    3    10.0\n    0     NaN\n    dtype: float64\n\n    Sort values descending order\n\n    >>> s.sort_values(ascending=False)\n    3    10.0\n    4     5.0\n    2     3.0\n    1     1.0\n    0     NaN\n    dtype: float64\n\n    Sort values inplace\n\n    >>> s.sort_values(ascending=False, inplace=True)\n    >>> s\n    3    10.0\n    4     5.0\n    2     3.0\n    1     1.0\n    0     NaN\n    dtype: float64\n\n    Sort values putting NAs first\n\n    >>> s.sort_values(na_position='first')\n    0     NaN\n    1     1.0\n    2     3.0\n    4     5.0\n    3    10.0\n    dtype: float64\n\n    Sort a series of strings\n\n    >>> s = pd.Series(['z', 'b', 'd', 'a', 'c'])\n    >>> s\n    0    z\n    1    b\n    2    d\n    3    a\n    4    c\n    dtype: object\n\n    >>> s.sort_values()\n    3    a\n    1    b\n    4    c\n    2    d\n    0    z\n    dtype: object\n\n    Sort using a key function. Your `key` function will be\n    given the ``Series`` of values and should return an array-like.\n\n    >>> s = pd.Series(['a', 'B', 'c', 'D', 'e'])\n    >>> s.sort_values()\n    1    B\n    3    D\n    0    a\n    2    c\n    4    e\n    dtype: object\n    >>> s.sort_values(key=lambda x: x.str.lower())\n    0    a\n    1    B\n    2    c\n    3    D\n    4    e\n    dtype: object\n\n    NumPy ufuncs work well here. For example, we can\n    sort by the ``sin`` of the value\n\n    >>> s = pd.Series([-4, -2, 0, 2, 4])\n    >>> s.sort_values(key=np.sin)\n    1   -2\n    4    4\n    2    0\n    0   -4\n    3    2\n    dtype: int64\n\n    More complicated user-defined functions can be used,\n    as long as they expect a Series and return an array-like\n\n    >>> s.sort_values(key=lambda x: (np.tan(x.cumsum())))\n    0   -4\n    3    2\n    4    4\n    1   -2\n    2    0\n    dtype: int64\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    self._get_axis_number(axis)\n    if inplace and self._is_cached:\n        raise ValueError('This Series is a view of some other array, to sort in-place you must create a copy')\n\n    def _try_kind_sort(arr):\n        arr = ensure_key_mapped(arr, key)\n        arr = getattr(arr, '_values', arr)\n        try:\n            return arr.argsort(kind=kind)\n        except TypeError:\n            return arr.argsort(kind='quicksort')\n    arr = self._values\n    sorted_index = np.empty(len(self), dtype=np.int32)\n    bad = isna(arr)\n    good = ~bad\n    idx = ibase.default_index(len(self))\n    argsorted = _try_kind_sort(self[good])\n    if is_list_like(ascending):\n        if len(ascending) != 1:\n            raise ValueError(f'Length of ascending ({len(ascending)}) must be 1 for Series')\n        ascending = ascending[0]\n    if not is_bool(ascending):\n        raise ValueError('ascending must be boolean')\n    if not ascending:\n        argsorted = argsorted[::-1]\n    if na_position == 'last':\n        n = good.sum()\n        sorted_index[:n] = idx[good][argsorted]\n        sorted_index[n:] = idx[bad]\n    elif na_position == 'first':\n        n = bad.sum()\n        sorted_index[n:] = idx[good][argsorted]\n        sorted_index[:n] = idx[bad]\n    else:\n        raise ValueError(f'invalid na_position: {na_position}')\n    result = self._constructor(arr[sorted_index], index=self.index[sorted_index])\n    if ignore_index:\n        result.index = ibase.default_index(len(sorted_index))\n    if inplace:\n        self._update_inplace(result)\n    else:\n        return result.__finalize__(self, method='sort_values')",
                            "def sort_index(self, axis=0, level=None, ascending: bool=True, inplace: bool=False, kind: str='quicksort', na_position: str='last', sort_remaining: bool=True, ignore_index: bool=False, key: IndexKeyFunc=None):\n    \"\"\"\n    Sort Series by index labels.\n\n    Returns a new Series sorted by label if `inplace` argument is\n    ``False``, otherwise updates the original series and returns None.\n\n    Parameters\n    ----------\n    axis : int, default 0\n        Axis to direct sorting. This can only be 0 for Series.\n    level : int, optional\n        If not None, sort on values in specified index level(s).\n    ascending : bool or list of bools, default True\n        Sort ascending vs. descending. When the index is a MultiIndex the\n        sort direction can be controlled for each level individually.\n    inplace : bool, default False\n        If True, perform operation in-place.\n    kind : {'quicksort', 'mergesort', 'heapsort'}, default 'quicksort'\n        Choice of sorting algorithm. See also :func:`numpy.sort` for more\n        information.  'mergesort' is the only stable algorithm. For\n        DataFrames, this option is only applied when sorting on a single\n        column or label.\n    na_position : {'first', 'last'}, default 'last'\n        If 'first' puts NaNs at the beginning, 'last' puts NaNs at the end.\n        Not implemented for MultiIndex.\n    sort_remaining : bool, default True\n        If True and sorting by level and index is multilevel, sort by other\n        levels too (in order) after sorting by specified level.\n    ignore_index : bool, default False\n        If True, the resulting axis will be labeled 0, 1, \u2026, n - 1.\n\n        .. versionadded:: 1.0.0\n\n    key : callable, optional\n        If not None, apply the key function to the index values\n        before sorting. This is similar to the `key` argument in the\n        builtin :meth:`sorted` function, with the notable difference that\n        this `key` function should be *vectorized*. It should expect an\n        ``Index`` and return an ``Index`` of the same shape.\n\n        .. versionadded:: 1.1.0\n\n    Returns\n    -------\n    Series\n        The original Series sorted by the labels.\n\n    See Also\n    --------\n    DataFrame.sort_index: Sort DataFrame by the index.\n    DataFrame.sort_values: Sort DataFrame by the value.\n    Series.sort_values : Sort Series by the value.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'b', 'c', 'd'], index=[3, 2, 1, 4])\n    >>> s.sort_index()\n    1    c\n    2    b\n    3    a\n    4    d\n    dtype: object\n\n    Sort Descending\n\n    >>> s.sort_index(ascending=False)\n    4    d\n    3    a\n    2    b\n    1    c\n    dtype: object\n\n    Sort Inplace\n\n    >>> s.sort_index(inplace=True)\n    >>> s\n    1    c\n    2    b\n    3    a\n    4    d\n    dtype: object\n\n    By default NaNs are put at the end, but use `na_position` to place\n    them at the beginning\n\n    >>> s = pd.Series(['a', 'b', 'c', 'd'], index=[3, 2, 1, np.nan])\n    >>> s.sort_index(na_position='first')\n    NaN     d\n     1.0    c\n     2.0    b\n     3.0    a\n    dtype: object\n\n    Specify index level to sort\n\n    >>> arrays = [np.array(['qux', 'qux', 'foo', 'foo',\n    ...                     'baz', 'baz', 'bar', 'bar']),\n    ...           np.array(['two', 'one', 'two', 'one',\n    ...                     'two', 'one', 'two', 'one'])]\n    >>> s = pd.Series([1, 2, 3, 4, 5, 6, 7, 8], index=arrays)\n    >>> s.sort_index(level=1)\n    bar  one    8\n    baz  one    6\n    foo  one    4\n    qux  one    2\n    bar  two    7\n    baz  two    5\n    foo  two    3\n    qux  two    1\n    dtype: int64\n\n    Does not sort by remaining levels when sorting by levels\n\n    >>> s.sort_index(level=1, sort_remaining=False)\n    qux  one    2\n    foo  one    4\n    baz  one    6\n    bar  one    8\n    qux  two    1\n    foo  two    3\n    baz  two    5\n    bar  two    7\n    dtype: int64\n\n    Apply a key function before sorting\n\n    >>> s = pd.Series([1, 2, 3, 4], index=['A', 'b', 'C', 'd'])\n    >>> s.sort_index(key=lambda x : x.str.lower())\n    A    1\n    b    2\n    C    3\n    d    4\n    dtype: int64\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    self._get_axis_number(axis)\n    index = ensure_key_mapped(self.index, key, levels=level)\n    if level is not None:\n        new_index, indexer = index.sortlevel(level, ascending=ascending, sort_remaining=sort_remaining)\n    elif isinstance(index, MultiIndex):\n        from pandas.core.sorting import lexsort_indexer\n        labels = index._sort_levels_monotonic()\n        indexer = lexsort_indexer(labels._get_codes_for_sorting(), orders=ascending, na_position=na_position)\n    else:\n        from pandas.core.sorting import nargsort\n        if ascending and index.is_monotonic_increasing or (not ascending and index.is_monotonic_decreasing):\n            if inplace:\n                return\n            else:\n                return self.copy()\n        indexer = nargsort(index, kind=kind, ascending=ascending, na_position=na_position)\n    indexer = ensure_platform_int(indexer)\n    new_index = self.index.take(indexer)\n    new_index = new_index._sort_levels_monotonic()\n    new_values = self._values.take(indexer)\n    result = self._constructor(new_values, index=new_index)\n    if ignore_index:\n        result.index = ibase.default_index(len(result))\n    if inplace:\n        self._update_inplace(result)\n    else:\n        return result.__finalize__(self, method='sort_index')",
                            "def argsort(self, axis=0, kind='quicksort', order=None) -> 'Series':\n    \"\"\"\n    Override ndarray.argsort. Argsorts the value, omitting NA/null values,\n    and places the result in the same locations as the non-NA values.\n\n    Parameters\n    ----------\n    axis : {0 or \"index\"}\n        Has no effect but is accepted for compatibility with numpy.\n    kind : {'mergesort', 'quicksort', 'heapsort'}, default 'quicksort'\n        Choice of sorting algorithm. See np.sort for more\n        information. 'mergesort' is the only stable algorithm.\n    order : None\n        Has no effect but is accepted for compatibility with numpy.\n\n    Returns\n    -------\n    Series\n        Positions of values within the sort order with -1 indicating\n        nan values.\n\n    See Also\n    --------\n    numpy.ndarray.argsort : Returns the indices that would sort this array.\n    \"\"\"\n    values = self._values\n    mask = isna(values)\n    if mask.any():\n        result = Series(-1, index=self.index, name=self.name, dtype='int64')\n        notmask = ~mask\n        result[notmask] = np.argsort(values[notmask], kind=kind)\n        return self._constructor(result, index=self.index).__finalize__(self, method='argsort')\n    else:\n        return self._constructor(np.argsort(values, kind=kind), index=self.index, dtype='int64').__finalize__(self, method='argsort')",
                            "def nlargest(self, n=5, keep='first') -> 'Series':\n    \"\"\"\n    Return the largest `n` elements.\n\n    Parameters\n    ----------\n    n : int, default 5\n        Return this many descending sorted values.\n    keep : {'first', 'last', 'all'}, default 'first'\n        When there are duplicate values that cannot all fit in a\n        Series of `n` elements:\n\n        - ``first`` : return the first `n` occurrences in order\n            of appearance.\n        - ``last`` : return the last `n` occurrences in reverse\n            order of appearance.\n        - ``all`` : keep all occurrences. This can result in a Series of\n            size larger than `n`.\n\n    Returns\n    -------\n    Series\n        The `n` largest values in the Series, sorted in decreasing order.\n\n    See Also\n    --------\n    Series.nsmallest: Get the `n` smallest elements.\n    Series.sort_values: Sort Series by values.\n    Series.head: Return the first `n` rows.\n\n    Notes\n    -----\n    Faster than ``.sort_values(ascending=False).head(n)`` for small `n`\n    relative to the size of the ``Series`` object.\n\n    Examples\n    --------\n    >>> countries_population = {\"Italy\": 59000000, \"France\": 65000000,\n    ...                         \"Malta\": 434000, \"Maldives\": 434000,\n    ...                         \"Brunei\": 434000, \"Iceland\": 337000,\n    ...                         \"Nauru\": 11300, \"Tuvalu\": 11300,\n    ...                         \"Anguilla\": 11300, \"Montserrat\": 5200}\n    >>> s = pd.Series(countries_population)\n    >>> s\n    Italy       59000000\n    France      65000000\n    Malta         434000\n    Maldives      434000\n    Brunei        434000\n    Iceland       337000\n    Nauru          11300\n    Tuvalu         11300\n    Anguilla       11300\n    Montserrat      5200\n    dtype: int64\n\n    The `n` largest elements where ``n=5`` by default.\n\n    >>> s.nlargest()\n    France      65000000\n    Italy       59000000\n    Malta         434000\n    Maldives      434000\n    Brunei        434000\n    dtype: int64\n\n    The `n` largest elements where ``n=3``. Default `keep` value is 'first'\n    so Malta will be kept.\n\n    >>> s.nlargest(3)\n    France    65000000\n    Italy     59000000\n    Malta       434000\n    dtype: int64\n\n    The `n` largest elements where ``n=3`` and keeping the last duplicates.\n    Brunei will be kept since it is the last with value 434000 based on\n    the index order.\n\n    >>> s.nlargest(3, keep='last')\n    France      65000000\n    Italy       59000000\n    Brunei        434000\n    dtype: int64\n\n    The `n` largest elements where ``n=3`` with all duplicates kept. Note\n    that the returned Series has five elements due to the three duplicates.\n\n    >>> s.nlargest(3, keep='all')\n    France      65000000\n    Italy       59000000\n    Malta         434000\n    Maldives      434000\n    Brunei        434000\n    dtype: int64\n    \"\"\"\n    return algorithms.SelectNSeries(self, n=n, keep=keep).nlargest()",
                            "def nsmallest(self, n=5, keep='first') -> 'Series':\n    \"\"\"\n    Return the smallest `n` elements.\n\n    Parameters\n    ----------\n    n : int, default 5\n        Return this many ascending sorted values.\n    keep : {'first', 'last', 'all'}, default 'first'\n        When there are duplicate values that cannot all fit in a\n        Series of `n` elements:\n\n        - ``first`` : return the first `n` occurrences in order\n            of appearance.\n        - ``last`` : return the last `n` occurrences in reverse\n            order of appearance.\n        - ``all`` : keep all occurrences. This can result in a Series of\n            size larger than `n`.\n\n    Returns\n    -------\n    Series\n        The `n` smallest values in the Series, sorted in increasing order.\n\n    See Also\n    --------\n    Series.nlargest: Get the `n` largest elements.\n    Series.sort_values: Sort Series by values.\n    Series.head: Return the first `n` rows.\n\n    Notes\n    -----\n    Faster than ``.sort_values().head(n)`` for small `n` relative to\n    the size of the ``Series`` object.\n\n    Examples\n    --------\n    >>> countries_population = {\"Italy\": 59000000, \"France\": 65000000,\n    ...                         \"Brunei\": 434000, \"Malta\": 434000,\n    ...                         \"Maldives\": 434000, \"Iceland\": 337000,\n    ...                         \"Nauru\": 11300, \"Tuvalu\": 11300,\n    ...                         \"Anguilla\": 11300, \"Montserrat\": 5200}\n    >>> s = pd.Series(countries_population)\n    >>> s\n    Italy       59000000\n    France      65000000\n    Brunei        434000\n    Malta         434000\n    Maldives      434000\n    Iceland       337000\n    Nauru          11300\n    Tuvalu         11300\n    Anguilla       11300\n    Montserrat      5200\n    dtype: int64\n\n    The `n` smallest elements where ``n=5`` by default.\n\n    >>> s.nsmallest()\n    Montserrat    5200\n    Nauru        11300\n    Tuvalu       11300\n    Anguilla     11300\n    Iceland     337000\n    dtype: int64\n\n    The `n` smallest elements where ``n=3``. Default `keep` value is\n    'first' so Nauru and Tuvalu will be kept.\n\n    >>> s.nsmallest(3)\n    Montserrat   5200\n    Nauru       11300\n    Tuvalu      11300\n    dtype: int64\n\n    The `n` smallest elements where ``n=3`` and keeping the last\n    duplicates. Anguilla and Tuvalu will be kept since they are the last\n    with value 11300 based on the index order.\n\n    >>> s.nsmallest(3, keep='last')\n    Montserrat   5200\n    Anguilla    11300\n    Tuvalu      11300\n    dtype: int64\n\n    The `n` smallest elements where ``n=3`` with all duplicates kept. Note\n    that the returned Series has four elements due to the three duplicates.\n\n    >>> s.nsmallest(3, keep='all')\n    Montserrat   5200\n    Nauru       11300\n    Tuvalu      11300\n    Anguilla    11300\n    dtype: int64\n    \"\"\"\n    return algorithms.SelectNSeries(self, n=n, keep=keep).nsmallest()",
                            "def swaplevel(self, i=-2, j=-1, copy=True) -> 'Series':\n    \"\"\"\n    Swap levels i and j in a :class:`MultiIndex`.\n\n    Default is to swap the two innermost levels of the index.\n\n    Parameters\n    ----------\n    i, j : int, str\n        Level of the indices to be swapped. Can pass level name as string.\n    copy : bool, default True\n        Whether to copy underlying data.\n\n    Returns\n    -------\n    Series\n        Series with levels swapped in MultiIndex.\n    \"\"\"\n    assert isinstance(self.index, MultiIndex)\n    new_index = self.index.swaplevel(i, j)\n    return self._constructor(self._values, index=new_index, copy=copy).__finalize__(self, method='swaplevel')",
                            "def reorder_levels(self, order) -> 'Series':\n    \"\"\"\n    Rearrange index levels using input order.\n\n    May not drop or duplicate levels.\n\n    Parameters\n    ----------\n    order : list of int representing new level order\n        Reference level by number or key.\n\n    Returns\n    -------\n    type of caller (new object)\n    \"\"\"\n    if not isinstance(self.index, MultiIndex):\n        raise Exception('Can only reorder levels on a hierarchical axis.')\n    result = self.copy()\n    assert isinstance(result.index, MultiIndex)\n    result.index = result.index.reorder_levels(order)\n    return result",
                            "def explode(self) -> 'Series':\n    \"\"\"\n    Transform each element of a list-like to a row, replicating the\n    index values.\n\n    .. versionadded:: 0.25.0\n\n    Returns\n    -------\n    Series\n        Exploded lists to rows; index will be duplicated for these rows.\n\n    See Also\n    --------\n    Series.str.split : Split string values on specified separator.\n    Series.unstack : Unstack, a.k.a. pivot, Series with MultiIndex\n        to produce DataFrame.\n    DataFrame.melt : Unpivot a DataFrame from wide format to long format.\n    DataFrame.explode : Explode a DataFrame from list-like\n        columns to long format.\n\n    Notes\n    -----\n    This routine will explode list-likes including lists, tuples,\n    Series, and np.ndarray. The result dtype of the subset rows will\n    be object. Scalars will be returned unchanged. Empty list-likes will\n    result in a np.nan for that row.\n\n    Examples\n    --------\n    >>> s = pd.Series([[1, 2, 3], 'foo', [], [3, 4]])\n    >>> s\n    0    [1, 2, 3]\n    1          foo\n    2           []\n    3       [3, 4]\n    dtype: object\n\n    >>> s.explode()\n    0      1\n    0      2\n    0      3\n    1    foo\n    2    NaN\n    3      3\n    3      4\n    dtype: object\n    \"\"\"\n    if not len(self) or not is_object_dtype(self):\n        return self.copy()\n    values, counts = reshape.explode(np.asarray(self.array))\n    result = self._constructor(values, index=self.index.repeat(counts), name=self.name)\n    return result",
                            "def unstack(self, level=-1, fill_value=None):\n    \"\"\"\n    Unstack, also known as pivot, Series with MultiIndex to produce DataFrame.\n    The level involved will automatically get sorted.\n\n    Parameters\n    ----------\n    level : int, str, or list of these, default last level\n        Level(s) to unstack, can pass level name.\n    fill_value : scalar value, default None\n        Value to use when replacing NaN values.\n\n    Returns\n    -------\n    DataFrame\n        Unstacked Series.\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3, 4],\n    ...               index=pd.MultiIndex.from_product([['one', 'two'],\n    ...                                                 ['a', 'b']]))\n    >>> s\n    one  a    1\n         b    2\n    two  a    3\n         b    4\n    dtype: int64\n\n    >>> s.unstack(level=-1)\n         a  b\n    one  1  2\n    two  3  4\n\n    >>> s.unstack(level=0)\n       one  two\n    a    1    3\n    b    2    4\n    \"\"\"\n    from pandas.core.reshape.reshape import unstack\n    return unstack(self, level, fill_value)",
                            "def map(self, arg, na_action=None) -> 'Series':\n    \"\"\"\n    Map values of Series according to input correspondence.\n\n    Used for substituting each value in a Series with another value,\n    that may be derived from a function, a ``dict`` or\n    a :class:`Series`.\n\n    Parameters\n    ----------\n    arg : function, collections.abc.Mapping subclass or Series\n        Mapping correspondence.\n    na_action : {None, 'ignore'}, default None\n        If 'ignore', propagate NaN values, without passing them to the\n        mapping correspondence.\n\n    Returns\n    -------\n    Series\n        Same index as caller.\n\n    See Also\n    --------\n    Series.apply : For applying more complex functions on a Series.\n    DataFrame.apply : Apply a function row-/column-wise.\n    DataFrame.applymap : Apply a function elementwise on a whole DataFrame.\n\n    Notes\n    -----\n    When ``arg`` is a dictionary, values in Series that are not in the\n    dictionary (as keys) are converted to ``NaN``. However, if the\n    dictionary is a ``dict`` subclass that defines ``__missing__`` (i.e.\n    provides a method for default values), then this default is used\n    rather than ``NaN``.\n\n    Examples\n    --------\n    >>> s = pd.Series(['cat', 'dog', np.nan, 'rabbit'])\n    >>> s\n    0      cat\n    1      dog\n    2      NaN\n    3   rabbit\n    dtype: object\n\n    ``map`` accepts a ``dict`` or a ``Series``. Values that are not found\n    in the ``dict`` are converted to ``NaN``, unless the dict has a default\n    value (e.g. ``defaultdict``):\n\n    >>> s.map({'cat': 'kitten', 'dog': 'puppy'})\n    0   kitten\n    1    puppy\n    2      NaN\n    3      NaN\n    dtype: object\n\n    It also accepts a function:\n\n    >>> s.map('I am a {}'.format)\n    0       I am a cat\n    1       I am a dog\n    2       I am a nan\n    3    I am a rabbit\n    dtype: object\n\n    To avoid applying the function to missing values (and keep them as\n    ``NaN``) ``na_action='ignore'`` can be used:\n\n    >>> s.map('I am a {}'.format, na_action='ignore')\n    0     I am a cat\n    1     I am a dog\n    2            NaN\n    3  I am a rabbit\n    dtype: object\n    \"\"\"\n    new_values = super()._map_values(arg, na_action=na_action)\n    return self._constructor(new_values, index=self.index).__finalize__(self, method='map')",
                            "def _gotitem(self, key, ndim, subset=None) -> 'Series':\n    \"\"\"\n    Sub-classes to define. Return a sliced object.\n\n    Parameters\n    ----------\n    key : string / list of selections\n    ndim : 1,2\n        Requested ndim of result.\n    subset : object, default None\n        Subset to act on.\n    \"\"\"\n    return self",
                            "@Substitution(see_also=_agg_see_also_doc, examples=_agg_examples_doc, versionadded='\\n.. versionadded:: 0.20.0\\n', **_shared_doc_kwargs)\n@Appender(generic._shared_docs['aggregate'])\ndef aggregate(self, func, axis=0, *args, **kwargs):\n    self._get_axis_number(axis)\n    result, how = self._aggregate(func, *args, **kwargs)\n    if result is None:\n        kwargs.pop('_axis', None)\n        kwargs.pop('_level', None)\n        try:\n            result = self.apply(func, *args, **kwargs)\n        except (ValueError, AttributeError, TypeError):\n            result = func(self, *args, **kwargs)\n    return result",
                            "@Appender(generic._shared_docs['transform'] % _shared_doc_kwargs)\ndef transform(self, func, axis=0, *args, **kwargs):\n    self._get_axis_number(axis)\n    return super().transform(func, *args, **kwargs)",
                            "def apply(self, func, convert_dtype=True, args=(), **kwds):\n    \"\"\"\n    Invoke function on values of Series.\n\n    Can be ufunc (a NumPy function that applies to the entire Series)\n    or a Python function that only works on single values.\n\n    Parameters\n    ----------\n    func : function\n        Python function or NumPy ufunc to apply.\n    convert_dtype : bool, default True\n        Try to find better dtype for elementwise function results. If\n        False, leave as dtype=object.\n    args : tuple\n        Positional arguments passed to func after the series value.\n    **kwds\n        Additional keyword arguments passed to func.\n\n    Returns\n    -------\n    Series or DataFrame\n        If func returns a Series object the result will be a DataFrame.\n\n    See Also\n    --------\n    Series.map: For element-wise operations.\n    Series.agg: Only perform aggregating type operations.\n    Series.transform: Only perform transforming type operations.\n\n    Examples\n    --------\n    Create a series with typical summer temperatures for each city.\n\n    >>> s = pd.Series([20, 21, 12],\n    ...               index=['London', 'New York', 'Helsinki'])\n    >>> s\n    London      20\n    New York    21\n    Helsinki    12\n    dtype: int64\n\n    Square the values by defining a function and passing it as an\n    argument to ``apply()``.\n\n    >>> def square(x):\n    ...     return x ** 2\n    >>> s.apply(square)\n    London      400\n    New York    441\n    Helsinki    144\n    dtype: int64\n\n    Square the values by passing an anonymous function as an\n    argument to ``apply()``.\n\n    >>> s.apply(lambda x: x ** 2)\n    London      400\n    New York    441\n    Helsinki    144\n    dtype: int64\n\n    Define a custom function that needs additional positional\n    arguments and pass these additional arguments using the\n    ``args`` keyword.\n\n    >>> def subtract_custom_value(x, custom_value):\n    ...     return x - custom_value\n\n    >>> s.apply(subtract_custom_value, args=(5,))\n    London      15\n    New York    16\n    Helsinki     7\n    dtype: int64\n\n    Define a custom function that takes keyword arguments\n    and pass these arguments to ``apply``.\n\n    >>> def add_custom_values(x, **kwargs):\n    ...     for month in kwargs:\n    ...         x += kwargs[month]\n    ...     return x\n\n    >>> s.apply(add_custom_values, june=30, july=20, august=25)\n    London      95\n    New York    96\n    Helsinki    87\n    dtype: int64\n\n    Use a function from the Numpy library.\n\n    >>> s.apply(np.log)\n    London      2.995732\n    New York    3.044522\n    Helsinki    2.484907\n    dtype: float64\n    \"\"\"\n    if len(self) == 0:\n        return self._constructor(dtype=self.dtype, index=self.index).__finalize__(self, method='apply')\n    if isinstance(func, (list, dict)):\n        return self.aggregate(func, *args, **kwds)\n    if isinstance(func, str):\n        return self._try_aggregate_string_function(func, *args, **kwds)\n    if kwds or (args and (not isinstance(func, np.ufunc))):\n\n        def f(x):\n            return func(x, *args, **kwds)\n    else:\n        f = func\n    with np.errstate(all='ignore'):\n        if isinstance(f, np.ufunc):\n            return f(self)\n        if is_extension_array_dtype(self.dtype) and hasattr(self._values, 'map'):\n            mapped = self._values.map(f)\n        else:\n            values = self.astype(object)._values\n            mapped = lib.map_infer(values, f, convert=convert_dtype)\n    if len(mapped) and isinstance(mapped[0], Series):\n        return self._constructor_expanddim(pd.array(mapped), index=self.index)\n    else:\n        return self._constructor(mapped, index=self.index).__finalize__(self, method='apply')",
                            "def _reduce(self, op, name, axis=0, skipna=True, numeric_only=None, filter_type=None, **kwds):\n    \"\"\"\n    Perform a reduction operation.\n\n    If we have an ndarray as a value, then simply perform the operation,\n    otherwise delegate to the object.\n    \"\"\"\n    delegate = self._values\n    if axis is not None:\n        self._get_axis_number(axis)\n    if isinstance(delegate, ExtensionArray):\n        return delegate._reduce(name, skipna=skipna, **kwds)\n    else:\n        if numeric_only:\n            raise NotImplementedError(f'Series.{name} does not implement numeric_only.')\n        with np.errstate(all='ignore'):\n            return op(delegate, skipna=skipna, **kwds)",
                            "def _reindex_indexer(self, new_index, indexer, copy):\n    if indexer is None:\n        if copy:\n            return self.copy()\n        return self\n    new_values = algorithms.take_1d(self._values, indexer, allow_fill=True, fill_value=None)\n    return self._constructor(new_values, index=new_index)",
                            "def _needs_reindex_multi(self, axes, method, level):\n    \"\"\"\n    Check if we do need a multi reindex; this is for compat with\n    higher dims.\n    \"\"\"\n    return False",
                            "@doc(NDFrame.align, **_shared_doc_kwargs)\ndef align(self, other, join='outer', axis=None, level=None, copy=True, fill_value=None, method=None, limit=None, fill_axis=0, broadcast_axis=None):\n    return super().align(other, join=join, axis=axis, level=level, copy=copy, fill_value=fill_value, method=method, limit=limit, fill_axis=fill_axis, broadcast_axis=broadcast_axis)",
                            "def rename(self, index=None, *, axis=None, copy=True, inplace=False, level=None, errors='ignore'):\n    \"\"\"\n    Alter Series index labels or name.\n\n    Function / dict values must be unique (1-to-1). Labels not contained in\n    a dict / Series will be left as-is. Extra labels listed don't throw an\n    error.\n\n    Alternatively, change ``Series.name`` with a scalar value.\n\n    See the :ref:`user guide <basics.rename>` for more.\n\n    Parameters\n    ----------\n    axis : {0 or \"index\"}\n        Unused. Accepted for compatibility with DataFrame method only.\n    index : scalar, hashable sequence, dict-like or function, optional\n        Functions or dict-like are transformations to apply to\n        the index.\n        Scalar or hashable sequence-like will alter the ``Series.name``\n        attribute.\n\n    **kwargs\n        Additional keyword arguments passed to the function. Only the\n        \"inplace\" keyword is used.\n\n    Returns\n    -------\n    Series\n        Series with index labels or name altered.\n\n    See Also\n    --------\n    DataFrame.rename : Corresponding DataFrame method.\n    Series.rename_axis : Set the name of the axis.\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3])\n    >>> s\n    0    1\n    1    2\n    2    3\n    dtype: int64\n    >>> s.rename(\"my_name\")  # scalar, changes Series.name\n    0    1\n    1    2\n    2    3\n    Name: my_name, dtype: int64\n    >>> s.rename(lambda x: x ** 2)  # function, changes labels\n    0    1\n    1    2\n    4    3\n    dtype: int64\n    >>> s.rename({1: 3, 2: 5})  # mapping, changes labels\n    0    1\n    3    2\n    5    3\n    dtype: int64\n    \"\"\"\n    if callable(index) or is_dict_like(index):\n        return super().rename(index, copy=copy, inplace=inplace, level=level, errors=errors)\n    else:\n        return self._set_name(index, inplace=inplace)",
                            "@Appender(\"\\n        Examples\\n        --------\\n        >>> s = pd.Series([1, 2, 3])\\n        >>> s\\n        0    1\\n        1    2\\n        2    3\\n        dtype: int64\\n\\n        >>> s.set_axis(['a', 'b', 'c'], axis=0)\\n        a    1\\n        b    2\\n        c    3\\n        dtype: int64\\n    \")\n@Substitution(**_shared_doc_kwargs, extended_summary_sub='', axis_description_sub='', see_also_sub='')\n@Appender(generic.NDFrame.set_axis.__doc__)\ndef set_axis(self, labels, axis: Axis=0, inplace: bool=False):\n    return super().set_axis(labels, axis=axis, inplace=inplace)",
                            "@Substitution(**_shared_doc_kwargs)\n@Appender(generic.NDFrame.reindex.__doc__)\ndef reindex(self, index=None, **kwargs):\n    return super().reindex(index=index, **kwargs)",
                            "def drop(self, labels=None, axis=0, index=None, columns=None, level=None, inplace=False, errors='raise') -> 'Series':\n    \"\"\"\n    Return Series with specified index labels removed.\n\n    Remove elements of a Series based on specifying the index labels.\n    When using a multi-index, labels on different levels can be removed\n    by specifying the level.\n\n    Parameters\n    ----------\n    labels : single label or list-like\n        Index labels to drop.\n    axis : 0, default 0\n        Redundant for application on Series.\n    index : single label or list-like\n        Redundant for application on Series, but 'index' can be used instead\n        of 'labels'.\n    columns : single label or list-like\n        No change is made to the Series; use 'index' or 'labels' instead.\n    level : int or level name, optional\n        For MultiIndex, level for which the labels will be removed.\n    inplace : bool, default False\n        If True, do operation inplace and return None.\n    errors : {'ignore', 'raise'}, default 'raise'\n        If 'ignore', suppress error and only existing labels are dropped.\n\n    Returns\n    -------\n    Series\n        Series with specified index labels removed.\n\n    Raises\n    ------\n    KeyError\n        If none of the labels are found in the index.\n\n    See Also\n    --------\n    Series.reindex : Return only specified index labels of Series.\n    Series.dropna : Return series without null values.\n    Series.drop_duplicates : Return Series with duplicate values removed.\n    DataFrame.drop : Drop specified labels from rows or columns.\n\n    Examples\n    --------\n    >>> s = pd.Series(data=np.arange(3), index=['A', 'B', 'C'])\n    >>> s\n    A  0\n    B  1\n    C  2\n    dtype: int64\n\n    Drop labels B en C\n\n    >>> s.drop(labels=['B', 'C'])\n    A  0\n    dtype: int64\n\n    Drop 2nd level label in MultiIndex Series\n\n    >>> midx = pd.MultiIndex(levels=[['lama', 'cow', 'falcon'],\n    ...                              ['speed', 'weight', 'length']],\n    ...                      codes=[[0, 0, 0, 1, 1, 1, 2, 2, 2],\n    ...                             [0, 1, 2, 0, 1, 2, 0, 1, 2]])\n    >>> s = pd.Series([45, 200, 1.2, 30, 250, 1.5, 320, 1, 0.3],\n    ...               index=midx)\n    >>> s\n    lama    speed      45.0\n            weight    200.0\n            length      1.2\n    cow     speed      30.0\n            weight    250.0\n            length      1.5\n    falcon  speed     320.0\n            weight      1.0\n            length      0.3\n    dtype: float64\n\n    >>> s.drop(labels='weight', level=1)\n    lama    speed      45.0\n            length      1.2\n    cow     speed      30.0\n            length      1.5\n    falcon  speed     320.0\n            length      0.3\n    dtype: float64\n    \"\"\"\n    return super().drop(labels=labels, axis=axis, index=index, columns=columns, level=level, inplace=inplace, errors=errors)",
                            "@doc(NDFrame.fillna, **_shared_doc_kwargs)\ndef fillna(self, value=None, method=None, axis=None, inplace=False, limit=None, downcast=None) -> Optional['Series']:\n    return super().fillna(value=value, method=method, axis=axis, inplace=inplace, limit=limit, downcast=downcast)",
                            "@doc(NDFrame.replace, **_shared_doc_kwargs)\ndef replace(self, to_replace=None, value=None, inplace=False, limit=None, regex=False, method='pad'):\n    return super().replace(to_replace=to_replace, value=value, inplace=inplace, limit=limit, regex=regex, method=method)",
                            "@doc(NDFrame.shift, **_shared_doc_kwargs)\ndef shift(self, periods=1, freq=None, axis=0, fill_value=None) -> 'Series':\n    return super().shift(periods=periods, freq=freq, axis=axis, fill_value=fill_value)",
                            "def memory_usage(self, index=True, deep=False):\n    \"\"\"\n    Return the memory usage of the Series.\n\n    The memory usage can optionally include the contribution of\n    the index and of elements of `object` dtype.\n\n    Parameters\n    ----------\n    index : bool, default True\n        Specifies whether to include the memory usage of the Series index.\n    deep : bool, default False\n        If True, introspect the data deeply by interrogating\n        `object` dtypes for system-level memory consumption, and include\n        it in the returned value.\n\n    Returns\n    -------\n    int\n        Bytes of memory consumed.\n\n    See Also\n    --------\n    numpy.ndarray.nbytes : Total bytes consumed by the elements of the\n        array.\n    DataFrame.memory_usage : Bytes consumed by a DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series(range(3))\n    >>> s.memory_usage()\n    152\n\n    Not including the index gives the size of the rest of the data, which\n    is necessarily smaller:\n\n    >>> s.memory_usage(index=False)\n    24\n\n    The memory footprint of `object` values is ignored by default:\n\n    >>> s = pd.Series([\"a\", \"b\"])\n    >>> s.values\n    array(['a', 'b'], dtype=object)\n    >>> s.memory_usage()\n    144\n    >>> s.memory_usage(deep=True)\n    260\n    \"\"\"\n    v = super().memory_usage(deep=deep)\n    if index:\n        v += self.index.memory_usage(deep=deep)\n    return v",
                            "def isin(self, values) -> 'Series':\n    \"\"\"\n    Check whether `values` are contained in Series.\n\n    Return a boolean Series showing whether each element in the Series\n    matches an element in the passed sequence of `values` exactly.\n\n    Parameters\n    ----------\n    values : set or list-like\n        The sequence of values to test. Passing in a single string will\n        raise a ``TypeError``. Instead, turn a single string into a\n        list of one element.\n\n    Returns\n    -------\n    Series\n        Series of booleans indicating if each element is in values.\n\n    Raises\n    ------\n    TypeError\n      * If `values` is a string\n\n    See Also\n    --------\n    DataFrame.isin : Equivalent method on DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series(['lama', 'cow', 'lama', 'beetle', 'lama',\n    ...                'hippo'], name='animal')\n    >>> s.isin(['cow', 'lama'])\n    0     True\n    1     True\n    2     True\n    3    False\n    4     True\n    5    False\n    Name: animal, dtype: bool\n\n    Passing a single string as ``s.isin('lama')`` will raise an error. Use\n    a list of one element instead:\n\n    >>> s.isin(['lama'])\n    0     True\n    1    False\n    2     True\n    3    False\n    4     True\n    5    False\n    Name: animal, dtype: bool\n    \"\"\"\n    result = algorithms.isin(self, values)\n    return self._constructor(result, index=self.index).__finalize__(self, method='isin')",
                            "def between(self, left, right, inclusive=True) -> 'Series':\n    \"\"\"\n    Return boolean Series equivalent to left <= series <= right.\n\n    This function returns a boolean vector containing `True` wherever the\n    corresponding Series element is between the boundary values `left` and\n    `right`. NA values are treated as `False`.\n\n    Parameters\n    ----------\n    left : scalar or list-like\n        Left boundary.\n    right : scalar or list-like\n        Right boundary.\n    inclusive : bool, default True\n        Include boundaries.\n\n    Returns\n    -------\n    Series\n        Series representing whether each element is between left and\n        right (inclusive).\n\n    See Also\n    --------\n    Series.gt : Greater than of series and other.\n    Series.lt : Less than of series and other.\n\n    Notes\n    -----\n    This function is equivalent to ``(left <= ser) & (ser <= right)``\n\n    Examples\n    --------\n    >>> s = pd.Series([2, 0, 4, 8, np.nan])\n\n    Boundary values are included by default:\n\n    >>> s.between(1, 4)\n    0     True\n    1    False\n    2     True\n    3    False\n    4    False\n    dtype: bool\n\n    With `inclusive` set to ``False`` boundary values are excluded:\n\n    >>> s.between(1, 4, inclusive=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    4    False\n    dtype: bool\n\n    `left` and `right` can be any scalar value:\n\n    >>> s = pd.Series(['Alice', 'Bob', 'Carol', 'Eve'])\n    >>> s.between('Anna', 'Daniel')\n    0    False\n    1     True\n    2     True\n    3    False\n    dtype: bool\n    \"\"\"\n    if inclusive:\n        lmask = self >= left\n        rmask = self <= right\n    else:\n        lmask = self > left\n        rmask = self < right\n    return lmask & rmask",
                            "def _convert_dtypes(self, infer_objects: bool=True, convert_string: bool=True, convert_integer: bool=True, convert_boolean: bool=True) -> 'Series':\n    input_series = self\n    if infer_objects:\n        input_series = input_series.infer_objects()\n        if is_object_dtype(input_series):\n            input_series = input_series.copy()\n    if convert_string or convert_integer or convert_boolean:\n        inferred_dtype = convert_dtypes(input_series._values, convert_string, convert_integer, convert_boolean)\n        try:\n            result = input_series.astype(inferred_dtype)\n        except TypeError:\n            result = input_series.copy()\n    else:\n        result = input_series.copy()\n    return result",
                            "@Appender(generic._shared_docs['isna'] % _shared_doc_kwargs)\ndef isna(self) -> 'Series':\n    return super().isna()",
                            "@Appender(generic._shared_docs['isna'] % _shared_doc_kwargs)\ndef isnull(self) -> 'Series':\n    return super().isnull()",
                            "@Appender(generic._shared_docs['notna'] % _shared_doc_kwargs)\ndef notna(self) -> 'Series':\n    return super().notna()",
                            "@Appender(generic._shared_docs['notna'] % _shared_doc_kwargs)\ndef notnull(self) -> 'Series':\n    return super().notnull()",
                            "def dropna(self, axis=0, inplace=False, how=None):\n    \"\"\"\n    Return a new Series with missing values removed.\n\n    See the :ref:`User Guide <missing_data>` for more on which values are\n    considered missing, and how to work with missing data.\n\n    Parameters\n    ----------\n    axis : {0 or 'index'}, default 0\n        There is only one axis to drop values from.\n    inplace : bool, default False\n        If True, do operation inplace and return None.\n    how : str, optional\n        Not in use. Kept for compatibility.\n\n    Returns\n    -------\n    Series\n        Series with NA entries dropped from it.\n\n    See Also\n    --------\n    Series.isna: Indicate missing values.\n    Series.notna : Indicate existing (non-missing) values.\n    Series.fillna : Replace missing values.\n    DataFrame.dropna : Drop rows or columns which contain NA values.\n    Index.dropna : Drop missing indices.\n\n    Examples\n    --------\n    >>> ser = pd.Series([1., 2., np.nan])\n    >>> ser\n    0    1.0\n    1    2.0\n    2    NaN\n    dtype: float64\n\n    Drop NA values from a Series.\n\n    >>> ser.dropna()\n    0    1.0\n    1    2.0\n    dtype: float64\n\n    Keep the Series with valid entries in the same variable.\n\n    >>> ser.dropna(inplace=True)\n    >>> ser\n    0    1.0\n    1    2.0\n    dtype: float64\n\n    Empty strings are not considered NA values. ``None`` is considered an\n    NA value.\n\n    >>> ser = pd.Series([np.NaN, 2, pd.NaT, '', None, 'I stay'])\n    >>> ser\n    0       NaN\n    1         2\n    2       NaT\n    3\n    4      None\n    5    I stay\n    dtype: object\n    >>> ser.dropna()\n    1         2\n    3\n    5    I stay\n    dtype: object\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    self._get_axis_number(axis or 0)\n    if self._can_hold_na:\n        result = remove_na_arraylike(self)\n        if inplace:\n            self._update_inplace(result)\n        else:\n            return result\n    elif inplace:\n        pass\n    else:\n        return self.copy()",
                            "def to_timestamp(self, freq=None, how='start', copy=True) -> 'Series':\n    \"\"\"\n    Cast to DatetimeIndex of Timestamps, at *beginning* of period.\n\n    Parameters\n    ----------\n    freq : str, default frequency of PeriodIndex\n        Desired frequency.\n    how : {'s', 'e', 'start', 'end'}\n        Convention for converting period to timestamp; start of period\n        vs. end.\n    copy : bool, default True\n        Whether or not to return a copy.\n\n    Returns\n    -------\n    Series with DatetimeIndex\n    \"\"\"\n    new_values = self._values\n    if copy:\n        new_values = new_values.copy()\n    assert isinstance(self.index, PeriodIndex)\n    new_index = self.index.to_timestamp(freq=freq, how=how)\n    return self._constructor(new_values, index=new_index).__finalize__(self, method='to_timestamp')",
                            "def to_period(self, freq=None, copy=True) -> 'Series':\n    \"\"\"\n    Convert Series from DatetimeIndex to PeriodIndex with desired\n    frequency (inferred from index if not passed).\n\n    Parameters\n    ----------\n    freq : str, default None\n        Frequency associated with the PeriodIndex.\n    copy : bool, default True\n        Whether or not to return a copy.\n\n    Returns\n    -------\n    Series\n        Series with index converted to PeriodIndex.\n    \"\"\"\n    new_values = self._values\n    if copy:\n        new_values = new_values.copy()\n    assert isinstance(self.index, DatetimeIndex)\n    new_index = self.index.to_period(freq=freq)\n    return self._constructor(new_values, index=new_index).__finalize__(self, method='to_period')",
                            "def construct_return(result):\n    if lib.is_scalar(result):\n        return result\n    elif result.ndim > 1:\n        if method == 'outer':\n            raise NotImplementedError\n        return result\n    return self._constructor(result, index=index, name=name, copy=False)",
                            "def _try_kind_sort(arr):\n    arr = ensure_key_mapped(arr, key)\n    arr = getattr(arr, '_values', arr)\n    try:\n        return arr.argsort(kind=kind)\n    except TypeError:\n        return arr.argsort(kind='quicksort')",
                            "def f(x):\n    return func(x, *args, **kwds)"
                        ],
                        "constructor_variables": [
                            "copy",
                            "index",
                            "dtype",
                            "data",
                            "name"
                        ],
                        "class_level_variables": [
                            "_typ",
                            "_name",
                            "_metadata",
                            "_internal_names_set",
                            "_accessors",
                            "_deprecations",
                            "hasnans",
                            "_mgr",
                            "div",
                            "rdiv",
                            "_index",
                            "_HANDLED_TYPES",
                            "__float__",
                            "__long__",
                            "__int__",
                            "_agg_see_also_doc",
                            "_agg_examples_doc",
                            "agg",
                            "_AXIS_ORDERS",
                            "_AXIS_REVERSED",
                            "_AXIS_LEN",
                            "_info_axis_number",
                            "_info_axis_name",
                            "index",
                            "str",
                            "dt",
                            "cat",
                            "plot",
                            "sparse",
                            "hist"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "__init__(self, data=None, index=None, dtype=None, name=None, copy=False, fastpath=False)",
                            "_init_dict(self, data, index=None, dtype=None)",
                            "_constructor(self) -> Type['Series']",
                            "_constructor_expanddim(self) -> Type['DataFrame']",
                            "_can_hold_na(self)",
                            "_set_axis(self, axis: int, labels, fastpath: bool=False) -> None",
                            "dtype(self) -> DtypeObj",
                            "dtypes(self) -> DtypeObj",
                            "name(self) -> Label",
                            "name(self, value: Label) -> None",
                            "values(self)",
                            "_values(self)",
                            "array(self) -> ExtensionArray",
                            "ravel(self, order='C')",
                            "__len__(self) -> int",
                            "view(self, dtype=None) -> 'Series'",
                            "__array_ufunc__(self, ufunc: Callable, method: str, *inputs: Any, **kwargs: Any)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "axes(self) -> List[Index]",
                            "take(self, indices, axis=0, is_copy=None, **kwargs) -> 'Series'",
                            "_take_with_is_copy(self, indices, axis=0)",
                            "_ixs(self, i: int, axis: int=0)",
                            "_slice(self, slobj: slice, axis: int=0) -> 'Series'",
                            "__getitem__(self, key)",
                            "_get_with(self, key)",
                            "_get_values_tuple(self, key)",
                            "_get_values(self, indexer)",
                            "_get_value(self, label, takeable: bool=False)",
                            "__setitem__(self, key, value)",
                            "_set_with_engine(self, key, value)",
                            "_set_with(self, key, value)",
                            "_set_value(self, label, value, takeable: bool=False)",
                            "_is_mixed_type(self)",
                            "repeat(self, repeats, axis=None) -> 'Series'",
                            "reset_index(self, level=None, drop=False, name=None, inplace=False)",
                            "__repr__(self) -> str",
                            "to_string(self, buf=None, na_rep='NaN', float_format=None, header=True, index=True, length=False, dtype=False, name=False, max_rows=None, min_rows=None)",
                            "to_markdown(self, buf: Optional[IO[str]]=None, mode: Optional[str]=None, **kwargs) -> Optional[str]",
                            "items(self) -> Iterable[Tuple[Label, Any]]",
                            "iteritems(self) -> Iterable[Tuple[Label, Any]]",
                            "keys(self) -> Index",
                            "to_dict(self, into=dict)",
                            "to_frame(self, name=None) -> 'DataFrame'",
                            "_set_name(self, name, inplace=False) -> 'Series'",
                            "groupby(self, by=None, axis=0, level=None, as_index: bool=True, sort: bool=True, group_keys: bool=True, squeeze: bool=False, observed: bool=False, dropna: bool=True) -> 'SeriesGroupBy'",
                            "count(self, level=None)",
                            "mode(self, dropna=True) -> 'Series'",
                            "unique(self)",
                            "drop_duplicates(self, keep='first', inplace=False) -> Optional['Series']",
                            "duplicated(self, keep='first') -> 'Series'",
                            "idxmin(self, axis=0, skipna=True, *args, **kwargs)",
                            "idxmax(self, axis=0, skipna=True, *args, **kwargs)",
                            "round(self, decimals=0, *args, **kwargs) -> 'Series'",
                            "quantile(self, q=0.5, interpolation='linear')",
                            "corr(self, other, method='pearson', min_periods=None) -> float",
                            "cov(self, other, min_periods=None) -> float",
                            "diff(self, periods: int=1) -> 'Series'",
                            "autocorr(self, lag=1) -> float",
                            "dot(self, other)",
                            "__matmul__(self, other)",
                            "__rmatmul__(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "append(self, to_append, ignore_index=False, verify_integrity=False)",
                            "_binop(self, other, func, level=None, fill_value=None)",
                            "_construct_result(self, result: Union[ArrayLike, Tuple[ArrayLike, ArrayLike]], name: Label) -> Union['Series', Tuple['Series', 'Series']]",
                            "combine(self, other, func, fill_value=None) -> 'Series'",
                            "combine_first(self, other) -> 'Series'",
                            "update(self, other) -> None",
                            "sort_values(self, axis=0, ascending=True, inplace: bool=False, kind: str='quicksort', na_position: str='last', ignore_index: bool=False, key: ValueKeyFunc=None)",
                            "sort_index(self, axis=0, level=None, ascending: bool=True, inplace: bool=False, kind: str='quicksort', na_position: str='last', sort_remaining: bool=True, ignore_index: bool=False, key: IndexKeyFunc=None)",
                            "argsort(self, axis=0, kind='quicksort', order=None) -> 'Series'",
                            "nlargest(self, n=5, keep='first') -> 'Series'",
                            "nsmallest(self, n=5, keep='first') -> 'Series'",
                            "swaplevel(self, i=-2, j=-1, copy=True) -> 'Series'",
                            "reorder_levels(self, order) -> 'Series'",
                            "explode(self) -> 'Series'",
                            "unstack(self, level=-1, fill_value=None)",
                            "map(self, arg, na_action=None) -> 'Series'",
                            "_gotitem(self, key, ndim, subset=None) -> 'Series'",
                            "aggregate(self, func, axis=0, *args, **kwargs)",
                            "transform(self, func, axis=0, *args, **kwargs)",
                            "apply(self, func, convert_dtype=True, args=(), **kwds)",
                            "_reduce(self, op, name, axis=0, skipna=True, numeric_only=None, filter_type=None, **kwds)",
                            "_reindex_indexer(self, new_index, indexer, copy)",
                            "_needs_reindex_multi(self, axes, method, level)",
                            "align(self, other, join='outer', axis=None, level=None, copy=True, fill_value=None, method=None, limit=None, fill_axis=0, broadcast_axis=None)",
                            "rename(self, index=None)",
                            "set_axis(self, labels, axis: Axis=0, inplace: bool=False)",
                            "reindex(self, index=None, **kwargs)",
                            "drop(self, labels=None, axis=0, index=None, columns=None, level=None, inplace=False, errors='raise') -> 'Series'",
                            "fillna(self, value=None, method=None, axis=None, inplace=False, limit=None, downcast=None) -> Optional['Series']",
                            "replace(self, to_replace=None, value=None, inplace=False, limit=None, regex=False, method='pad')",
                            "shift(self, periods=1, freq=None, axis=0, fill_value=None) -> 'Series'",
                            "memory_usage(self, index=True, deep=False)",
                            "isin(self, values) -> 'Series'",
                            "between(self, left, right, inclusive=True) -> 'Series'",
                            "_convert_dtypes(self, infer_objects: bool=True, convert_string: bool=True, convert_integer: bool=True, convert_boolean: bool=True) -> 'Series'",
                            "isna(self) -> 'Series'",
                            "isnull(self) -> 'Series'",
                            "notna(self) -> 'Series'",
                            "notnull(self) -> 'Series'",
                            "dropna(self, axis=0, inplace=False, how=None)",
                            "to_timestamp(self, freq=None, how='start', copy=True) -> 'Series'",
                            "to_period(self, freq=None, copy=True) -> 'Series'",
                            "construct_return(result)",
                            "_try_kind_sort(arr)",
                            "f(x)"
                        ]
                    },
                    "variable_values": [
                        [
                            {
                                "new_values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._values": {
                                    "variable_value": "array([nan, nan, nan, nan, nan, nan], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "self": {
                                    "variable_value": "0    NaN\n0    NaN\n1    NaN\n1    NaN\n2    NaN\n2    NaN\ndtype: object",
                                    "variable_type": "Series",
                                    "variable_shape": "6"
                                },
                                "copy": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "new_values.copy": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "Int64Index([0, 0, 1, 1, 2, 2], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "DatetimeIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "new_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.to_period": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "__finalize__": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._constructor": {
                                    "variable_value": "<class 'pandas.core.series.Series'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10d8eba90>"
                                }
                            },
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "new_values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._values": {
                                    "variable_value": "array([nan, nan, nan, nan, nan, nan], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "self": {
                                    "variable_value": "0    NaN\n0    NaN\n1    NaN\n1    NaN\n2    NaN\n2    NaN\ndtype: object",
                                    "variable_type": "Series",
                                    "variable_shape": "6"
                                },
                                "copy": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "new_values.copy": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index": {
                                    "variable_value": "Int64Index([0, 0, 1, 1, 2, 2], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "DatetimeIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "new_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.index.to_period": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "__finalize__": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._constructor": {
                                    "variable_value": "<class 'pandas.core.series.Series'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x11449aa40>"
                                }
                            },
                            {}
                        ]
                    ]
                }
            ],
            "inscope_functions": [
                "def _coerce_method(converter):\n    \"\"\"\n    Install the scalar coercion methods.\n    \"\"\"\n\n    def wrapper(self):\n        if len(self) == 1:\n            return converter(self.iloc[0])\n        raise TypeError(f\"cannot convert the series to {converter}\")\n\n    wrapper.__name__ = f\"__{converter.__name__}__\"\n    return wrapper",
                "def wrapper(self):\n    if len(self) == 1:\n        return converter(self.iloc[0])\n    raise TypeError(f\"cannot convert the series to {converter}\")",
                "def __init__(\n    self, data=None, index=None, dtype=None, name=None, copy=False, fastpath=False\n):\n\n    if (\n        isinstance(data, SingleBlockManager)\n        and index is None\n        and dtype is None\n        and copy is False\n    ):\n        # GH#33357 called with just the SingleBlockManager\n        NDFrame.__init__(self, data)\n        self.name = name\n        return\n\n    # we are called internally, so short-circuit\n    if fastpath:\n\n        # data is an ndarray, index is defined\n        if not isinstance(data, SingleBlockManager):\n            data = SingleBlockManager.from_array(data, index)\n        if copy:\n            data = data.copy()\n        if index is None:\n            index = data.index\n\n    else:\n\n        name = ibase.maybe_extract_name(name, data, type(self))\n\n        if is_empty_data(data) and dtype is None:\n            # gh-17261\n            warnings.warn(\n                \"The default dtype for empty Series will be 'object' instead \"\n                \"of 'float64' in a future version. Specify a dtype explicitly \"\n                \"to silence this warning.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            # uncomment the line below when removing the DeprecationWarning\n            # dtype = np.dtype(object)\n\n        if index is not None:\n            index = ensure_index(index)\n\n        if data is None:\n            data = {}\n        if dtype is not None:\n            dtype = self._validate_dtype(dtype)\n\n        if isinstance(data, MultiIndex):\n            raise NotImplementedError(\n                \"initializing a Series from a MultiIndex is not supported\"\n            )\n        elif isinstance(data, Index):\n\n            if dtype is not None:\n                # astype copies\n                data = data.astype(dtype)\n            else:\n                # GH#24096 we need to ensure the index remains immutable\n                data = data._values.copy()\n            copy = False\n\n        elif isinstance(data, np.ndarray):\n            if len(data.dtype):\n                # GH#13296 we are dealing with a compound dtype, which\n                #  should be treated as 2D\n                raise ValueError(\n                    \"Cannot construct a Series from an ndarray with \"\n                    \"compound dtype.  Use DataFrame instead.\"\n                )\n        elif isinstance(data, Series):\n            if index is None:\n                index = data.index\n            else:\n                data = data.reindex(index, copy=copy)\n                copy = False\n            data = data._mgr\n        elif is_dict_like(data):\n            data, index = self._init_dict(data, index, dtype)\n            dtype = None\n            copy = False\n        elif isinstance(data, SingleBlockManager):\n            if index is None:\n                index = data.index\n            elif not data.index.equals(index) or copy:\n                # GH#19275 SingleBlockManager input should only be called\n                # internally\n                raise AssertionError(\n                    \"Cannot pass both SingleBlockManager \"\n                    \"`data` argument and a different \"\n                    \"`index` argument. `copy` must be False.\"\n                )\n\n        elif is_extension_array_dtype(data):\n            pass\n        elif isinstance(data, (set, frozenset)):\n            raise TypeError(f\"'{type(data).__name__}' type is unordered\")\n        else:\n            data = com.maybe_iterable_to_list(data)\n\n        if index is None:\n            if not is_list_like(data):\n                data = [data]\n            index = ibase.default_index(len(data))\n        elif is_list_like(data):\n\n            # a scalar numpy array is list-like but doesn't\n            # have a proper length\n            try:\n                if len(index) != len(data):\n                    raise ValueError(\n                        f\"Length of passed values is {len(data)}, \"\n                        f\"index implies {len(index)}.\"\n                    )\n            except TypeError:\n                pass\n\n        # create/copy the manager\n        if isinstance(data, SingleBlockManager):\n            if dtype is not None:\n                data = data.astype(dtype=dtype, errors=\"ignore\", copy=copy)\n            elif copy:\n                data = data.copy()\n        else:\n            data = sanitize_array(data, index, dtype, copy, raise_cast_failure=True)\n\n            data = SingleBlockManager.from_array(data, index)\n\n    generic.NDFrame.__init__(self, data)\n    self.name = name\n    self._set_axis(0, index, fastpath=True)",
                "def _init_dict(self, data, index=None, dtype=None):\n    \"\"\"\n    Derive the \"_mgr\" and \"index\" attributes of a new Series from a\n    dictionary input.\n\n    Parameters\n    ----------\n    data : dict or dict-like\n        Data used to populate the new Series.\n    index : Index or index-like, default None\n        Index for the new Series: if None, use dict keys.\n    dtype : dtype, default None\n        The dtype for the new Series: if None, infer from data.\n\n    Returns\n    -------\n    _data : BlockManager for the new Series\n    index : index for the new Series\n    \"\"\"\n    # Looking for NaN in dict doesn't work ({np.nan : 1}[float('nan')]\n    # raises KeyError), so we iterate the entire dict, and align\n    if data:\n        keys, values = zip(*data.items())\n        values = list(values)\n    elif index is not None:\n        # fastpath for Series(data=None). Just use broadcasting a scalar\n        # instead of reindexing.\n        values = na_value_for_dtype(dtype)\n        keys = index\n    else:\n        keys, values = [], []\n\n    # Input is now list-like, so rely on \"standard\" construction:\n\n    # TODO: passing np.float64 to not break anything yet. See GH-17261\n    s = create_series_with_explicit_dtype(\n        values, index=keys, dtype=dtype, dtype_if_empty=np.float64\n    )\n\n    # Now we just make sure the order is respected, if any\n    if data and index is not None:\n        s = s.reindex(index, copy=False)\n    return s._mgr, s.index",
                "@property\ndef _constructor(self) -> Type[\"Series\"]:\n    return Series",
                "@property\ndef _constructor_expanddim(self) -> Type[\"DataFrame\"]:\n    from pandas.core.frame import DataFrame\n\n    return DataFrame",
                "@property\ndef _can_hold_na(self):\n    return self._mgr._can_hold_na",
                "def _set_axis(self, axis: int, labels, fastpath: bool = False) -> None:\n    \"\"\"\n    Override generic, we want to set the _typ here.\n\n    This is called from the cython code when we set the `index` attribute\n    directly, e.g. `series.index = [1, 2, 3]`.\n    \"\"\"\n    if not fastpath:\n        labels = ensure_index(labels)\n\n    is_all_dates = labels.is_all_dates\n    if is_all_dates:\n        if not isinstance(labels, (DatetimeIndex, PeriodIndex, TimedeltaIndex)):\n            try:\n                labels = DatetimeIndex(labels)\n                # need to set here because we changed the index\n                if fastpath:\n                    self._mgr.set_axis(axis, labels)\n            except (tslibs.OutOfBoundsDatetime, ValueError):\n                # labels may exceeds datetime bounds,\n                # or not be a DatetimeIndex\n                pass\n\n    object.__setattr__(self, \"_index\", labels)\n    if not fastpath:\n        # The ensure_index call above ensures we have an Index object\n        self._mgr.set_axis(axis, labels)",
                "@property\ndef dtype(self) -> DtypeObj:\n    \"\"\"\n    Return the dtype object of the underlying data.\n    \"\"\"\n    return self._mgr.dtype",
                "@property\ndef dtypes(self) -> DtypeObj:\n    \"\"\"\n    Return the dtype object of the underlying data.\n    \"\"\"\n    # DataFrame compatibility\n    return self.dtype",
                "@property\ndef name(self) -> Label:\n    \"\"\"\n    Return the name of the Series.\n\n    The name of a Series becomes its index or column name if it is used\n    to form a DataFrame. It is also used whenever displaying the Series\n    using the interpreter.\n\n    Returns\n    -------\n    label (hashable object)\n        The name of the Series, also the column name if part of a DataFrame.\n\n    See Also\n    --------\n    Series.rename : Sets the Series name when given a scalar input.\n    Index.name : Corresponding Index property.\n\n    Examples\n    --------\n    The Series name can be set initially when calling the constructor.\n\n    >>> s = pd.Series([1, 2, 3], dtype=np.int64, name='Numbers')\n    >>> s\n    0    1\n    1    2\n    2    3\n    Name: Numbers, dtype: int64\n    >>> s.name = \"Integers\"\n    >>> s\n    0    1\n    1    2\n    2    3\n    Name: Integers, dtype: int64\n\n    The name of a Series within a DataFrame is its column name.\n\n    >>> df = pd.DataFrame([[1, 2], [3, 4], [5, 6]],\n    ...                   columns=[\"Odd Numbers\", \"Even Numbers\"])\n    >>> df\n       Odd Numbers  Even Numbers\n    0            1             2\n    1            3             4\n    2            5             6\n    >>> df[\"Even Numbers\"].name\n    'Even Numbers'\n    \"\"\"\n    return self._name",
                "@name.setter\ndef name(self, value: Label) -> None:\n    if not is_hashable(value):\n        raise TypeError(\"Series.name must be a hashable type\")\n    object.__setattr__(self, \"_name\", value)",
                "@property\ndef values(self):\n    \"\"\"\n    Return Series as ndarray or ndarray-like depending on the dtype.\n\n    .. warning::\n\n       We recommend using :attr:`Series.array` or\n       :meth:`Series.to_numpy`, depending on whether you need\n       a reference to the underlying data or a NumPy array.\n\n    Returns\n    -------\n    numpy.ndarray or ndarray-like\n\n    See Also\n    --------\n    Series.array : Reference to the underlying data.\n    Series.to_numpy : A NumPy array representing the underlying data.\n\n    Examples\n    --------\n    >>> pd.Series([1, 2, 3]).values\n    array([1, 2, 3])\n\n    >>> pd.Series(list('aabc')).values\n    array(['a', 'a', 'b', 'c'], dtype=object)\n\n    >>> pd.Series(list('aabc')).astype('category').values\n    [a, a, b, c]\n    Categories (3, object): [a, b, c]\n\n    Timezone aware datetime data is converted to UTC:\n\n    >>> pd.Series(pd.date_range('20130101', periods=3,\n    ...                         tz='US/Eastern')).values\n    array(['2013-01-01T05:00:00.000000000',\n           '2013-01-02T05:00:00.000000000',\n           '2013-01-03T05:00:00.000000000'], dtype='datetime64[ns]')\n    \"\"\"\n    return self._mgr.external_values()",
                "@property\ndef _values(self):\n    \"\"\"\n    Return the internal repr of this data (defined by Block.interval_values).\n    This are the values as stored in the Block (ndarray or ExtensionArray\n    depending on the Block class), with datetime64[ns] and timedelta64[ns]\n    wrapped in ExtensionArrays to match Index._values behavior.\n\n    Differs from the public ``.values`` for certain data types, because of\n    historical backwards compatibility of the public attribute (e.g. period\n    returns object ndarray and datetimetz a datetime64[ns] ndarray for\n    ``.values`` while it returns an ExtensionArray for ``._values`` in those\n    cases).\n\n    Differs from ``.array`` in that this still returns the numpy array if\n    the Block is backed by a numpy array (except for datetime64 and\n    timedelta64 dtypes), while ``.array`` ensures to always return an\n    ExtensionArray.\n\n    Overview:\n\n    dtype       | values        | _values       | array         |\n    ----------- | ------------- | ------------- | ------------- |\n    Numeric     | ndarray       | ndarray       | PandasArray   |\n    Category    | Categorical   | Categorical   | Categorical   |\n    dt64[ns]    | ndarray[M8ns] | DatetimeArray | DatetimeArray |\n    dt64[ns tz] | ndarray[M8ns] | DatetimeArray | DatetimeArray |\n    td64[ns]    | ndarray[m8ns] | TimedeltaArray| ndarray[m8ns] |\n    Period      | ndarray[obj]  | PeriodArray   | PeriodArray   |\n    Nullable    | EA            | EA            | EA            |\n\n    \"\"\"\n    return self._mgr.internal_values()",
                "@Appender(base.IndexOpsMixin.array.__doc__)  # type: ignore\n@property\ndef array(self) -> ExtensionArray:\n    return self._mgr._block.array_values()",
                "def ravel(self, order=\"C\"):\n    \"\"\"\n    Return the flattened underlying data as an ndarray.\n\n    Returns\n    -------\n    numpy.ndarray or ndarray-like\n        Flattened data of the Series.\n\n    See Also\n    --------\n    numpy.ndarray.ravel : Return a flattened array.\n    \"\"\"\n    return self._values.ravel(order=order)",
                "def __len__(self) -> int:\n    \"\"\"\n    Return the length of the Series.\n    \"\"\"\n    return len(self._mgr)",
                "def view(self, dtype=None) -> \"Series\":\n    \"\"\"\n    Create a new view of the Series.\n\n    This function will return a new Series with a view of the same\n    underlying values in memory, optionally reinterpreted with a new data\n    type. The new data type must preserve the same size in bytes as to not\n    cause index misalignment.\n\n    Parameters\n    ----------\n    dtype : data type\n        Data type object or one of their string representations.\n\n    Returns\n    -------\n    Series\n        A new Series object as a view of the same data in memory.\n\n    See Also\n    --------\n    numpy.ndarray.view : Equivalent numpy function to create a new view of\n        the same data in memory.\n\n    Notes\n    -----\n    Series are instantiated with ``dtype=float64`` by default. While\n    ``numpy.ndarray.view()`` will return a view with the same data type as\n    the original array, ``Series.view()`` (without specified dtype)\n    will try using ``float64`` and may fail if the original data type size\n    in bytes is not the same.\n\n    Examples\n    --------\n    >>> s = pd.Series([-2, -1, 0, 1, 2], dtype='int8')\n    >>> s\n    0   -2\n    1   -1\n    2    0\n    3    1\n    4    2\n    dtype: int8\n\n    The 8 bit signed integer representation of `-1` is `0b11111111`, but\n    the same bytes represent 255 if read as an 8 bit unsigned integer:\n\n    >>> us = s.view('uint8')\n    >>> us\n    0    254\n    1    255\n    2      0\n    3      1\n    4      2\n    dtype: uint8\n\n    The views share the same underlying values:\n\n    >>> us[0] = 128\n    >>> s\n    0   -128\n    1     -1\n    2      0\n    3      1\n    4      2\n    dtype: int8\n    \"\"\"\n    return self._constructor(\n        self._values.view(dtype), index=self.index\n    ).__finalize__(self, method=\"view\")",
                "def __array_ufunc__(\n    self, ufunc: Callable, method: str, *inputs: Any, **kwargs: Any\n):\n    # TODO: handle DataFrame\n    cls = type(self)\n\n    # for binary ops, use our custom dunder methods\n    result = ops.maybe_dispatch_ufunc_to_dunder_op(\n        self, ufunc, method, *inputs, **kwargs\n    )\n    if result is not NotImplemented:\n        return result\n\n    # Determine if we should defer.\n    no_defer = (np.ndarray.__array_ufunc__, cls.__array_ufunc__)\n\n    for item in inputs:\n        higher_priority = (\n            hasattr(item, \"__array_priority__\")\n            and item.__array_priority__ > self.__array_priority__\n        )\n        has_array_ufunc = (\n            hasattr(item, \"__array_ufunc__\")\n            and type(item).__array_ufunc__ not in no_defer\n            and not isinstance(item, self._HANDLED_TYPES)\n        )\n        if higher_priority or has_array_ufunc:\n            return NotImplemented\n\n    # align all the inputs.\n    names = [getattr(x, \"name\") for x in inputs if hasattr(x, \"name\")]\n    types = tuple(type(x) for x in inputs)\n    # TODO: dataframe\n    alignable = [x for x, t in zip(inputs, types) if issubclass(t, Series)]\n\n    if len(alignable) > 1:\n        # This triggers alignment.\n        # At the moment, there aren't any ufuncs with more than two inputs\n        # so this ends up just being x1.index | x2.index, but we write\n        # it to handle *args.\n        index = alignable[0].index\n        for s in alignable[1:]:\n            index |= s.index\n        inputs = tuple(\n            x.reindex(index) if issubclass(t, Series) else x\n            for x, t in zip(inputs, types)\n        )\n    else:\n        index = self.index\n\n    inputs = tuple(extract_array(x, extract_numpy=True) for x in inputs)\n    result = getattr(ufunc, method)(*inputs, **kwargs)\n\n    name = names[0] if len(set(names)) == 1 else None\n\n    def construct_return(result):\n        if lib.is_scalar(result):\n            return result\n        elif result.ndim > 1:\n            # e.g. np.subtract.outer\n            if method == \"outer\":\n                # GH#27198\n                raise NotImplementedError\n            return result\n        return self._constructor(result, index=index, name=name, copy=False)\n\n    if type(result) is tuple:\n        # multiple return values\n        return tuple(construct_return(x) for x in result)\n    elif method == \"at\":\n        # no return value\n        return None\n    else:\n        return construct_return(result)",
                "def __array__(self, dtype=None) -> np.ndarray:\n    \"\"\"\n    Return the values as a NumPy array.\n\n    Users should not call this directly. Rather, it is invoked by\n    :func:`numpy.array` and :func:`numpy.asarray`.\n\n    Parameters\n    ----------\n    dtype : str or numpy.dtype, optional\n        The dtype to use for the resulting NumPy array. By default,\n        the dtype is inferred from the data.\n\n    Returns\n    -------\n    numpy.ndarray\n        The values in the series converted to a :class:`numpy.ndarray`\n        with the specified `dtype`.\n\n    See Also\n    --------\n    array : Create a new array from data.\n    Series.array : Zero-copy view to the array backing the Series.\n    Series.to_numpy : Series method for similar behavior.\n\n    Examples\n    --------\n    >>> ser = pd.Series([1, 2, 3])\n    >>> np.asarray(ser)\n    array([1, 2, 3])\n\n    For timezone-aware data, the timezones may be retained with\n    ``dtype='object'``\n\n    >>> tzser = pd.Series(pd.date_range('2000', periods=2, tz=\"CET\"))\n    >>> np.asarray(tzser, dtype=\"object\")\n    array([Timestamp('2000-01-01 00:00:00+0100', tz='CET', freq='D'),\n           Timestamp('2000-01-02 00:00:00+0100', tz='CET', freq='D')],\n          dtype=object)\n\n    Or the values may be localized to UTC and the tzinfo discarded with\n    ``dtype='datetime64[ns]'``\n\n    >>> np.asarray(tzser, dtype=\"datetime64[ns]\")  # doctest: +ELLIPSIS\n    array(['1999-12-31T23:00:00.000000000', ...],\n          dtype='datetime64[ns]')\n    \"\"\"\n    return np.asarray(self.array, dtype)",
                "@property\ndef axes(self) -> List[Index]:\n    \"\"\"\n    Return a list of the row axis labels.\n    \"\"\"\n    return [self.index]",
                "@Appender(generic.NDFrame.take.__doc__)\ndef take(self, indices, axis=0, is_copy=None, **kwargs) -> \"Series\":\n    if is_copy is not None:\n        warnings.warn(\n            \"is_copy is deprecated and will be removed in a future version. \"\n            \"'take' always returns a copy, so there is no need to specify this.\",\n            FutureWarning,\n            stacklevel=2,\n        )\n    nv.validate_take(tuple(), kwargs)\n\n    indices = ensure_platform_int(indices)\n    new_index = self.index.take(indices)\n    new_values = self._values.take(indices)\n\n    result = self._constructor(new_values, index=new_index, fastpath=True)\n    return result.__finalize__(self, method=\"take\")",
                "def _take_with_is_copy(self, indices, axis=0):\n    \"\"\"\n    Internal version of the `take` method that sets the `_is_copy`\n    attribute to keep track of the parent dataframe (using in indexing\n    for the SettingWithCopyWarning). For Series this does the same\n    as the public take (it never sets `_is_copy`).\n\n    See the docstring of `take` for full explanation of the parameters.\n    \"\"\"\n    return self.take(indices=indices, axis=axis)",
                "def _ixs(self, i: int, axis: int = 0):\n    \"\"\"\n    Return the i-th value or values in the Series by location.\n\n    Parameters\n    ----------\n    i : int\n\n    Returns\n    -------\n    scalar (int) or Series (slice, sequence)\n    \"\"\"\n    return self._values[i]",
                "def _slice(self, slobj: slice, axis: int = 0) -> \"Series\":\n    # axis kwarg is retained for compat with NDFrame method\n    #  _slice is *always* positional\n    return self._get_values(slobj)",
                "def __getitem__(self, key):\n    key = com.apply_if_callable(key, self)\n\n    if key is Ellipsis:\n        return self\n\n    key_is_scalar = is_scalar(key)\n    if isinstance(key, (list, tuple)):\n        key = unpack_1tuple(key)\n\n    if is_integer(key) and self.index._should_fallback_to_positional():\n        return self._values[key]\n\n    elif key_is_scalar:\n        return self._get_value(key)\n\n    if (\n        isinstance(key, tuple)\n        and is_hashable(key)\n        and isinstance(self.index, MultiIndex)\n    ):\n        # Otherwise index.get_value will raise InvalidIndexError\n        try:\n            result = self._get_value(key)\n\n            return result\n\n        except KeyError:\n            # We still have the corner case where this tuple is a key\n            #  in the first level of our MultiIndex\n            return self._get_values_tuple(key)\n\n    if is_iterator(key):\n        key = list(key)\n\n    if com.is_bool_indexer(key):\n        key = check_bool_indexer(self.index, key)\n        key = np.asarray(key, dtype=bool)\n        return self._get_values(key)\n\n    return self._get_with(key)",
                "def _get_with(self, key):\n    # other: fancy integer or otherwise\n    if isinstance(key, slice):\n        # _convert_slice_indexer to determine if this slice is positional\n        #  or label based, and if the latter, convert to positional\n        slobj = self.index._convert_slice_indexer(key, kind=\"getitem\")\n        return self._slice(slobj)\n    elif isinstance(key, ABCDataFrame):\n        raise TypeError(\n            \"Indexing a Series with DataFrame is not \"\n            \"supported, use the appropriate DataFrame column\"\n        )\n    elif isinstance(key, tuple):\n        return self._get_values_tuple(key)\n\n    elif not is_list_like(key):\n        # e.g. scalars that aren't recognized by lib.is_scalar, GH#32684\n        return self.loc[key]\n\n    if not isinstance(key, (list, np.ndarray, ExtensionArray, Series, Index)):\n        key = list(key)\n\n    if isinstance(key, Index):\n        key_type = key.inferred_type\n    else:\n        key_type = lib.infer_dtype(key, skipna=False)\n\n    # Note: The key_type == \"boolean\" case should be caught by the\n    #  com.is_bool_indexer check in __getitem__\n    if key_type == \"integer\":\n        # We need to decide whether to treat this as a positional indexer\n        #  (i.e. self.iloc) or label-based (i.e. self.loc)\n        if not self.index._should_fallback_to_positional():\n            return self.loc[key]\n        else:\n            return self.iloc[key]\n\n    # handle the dup indexing case GH#4246\n    return self.loc[key]",
                "def _get_values_tuple(self, key):\n    # mpl hackaround\n    if com.any_none(*key):\n        # suppress warning from slicing the index with a 2d indexer.\n        # eventually we'll want Series itself to warn.\n        with warnings.catch_warnings():\n            warnings.filterwarnings(\n                \"ignore\", \"Support for multi-dim\", DeprecationWarning\n            )\n            return self._get_values(key)\n\n    if not isinstance(self.index, MultiIndex):\n        raise ValueError(\"Can only tuple-index with a MultiIndex\")\n\n    # If key is contained, would have returned by now\n    indexer, new_index = self.index.get_loc_level(key)\n    return self._constructor(self._values[indexer], index=new_index).__finalize__(\n        self,\n    )",
                "def _get_values(self, indexer):\n    try:\n        return self._constructor(self._mgr.get_slice(indexer)).__finalize__(self,)\n    except ValueError:\n        # mpl compat if we look up e.g. ser[:, np.newaxis];\n        #  see tests.series.timeseries.test_mpl_compat_hack\n        return self._values[indexer]",
                "def _get_value(self, label, takeable: bool = False):\n    \"\"\"\n    Quickly retrieve single value at passed index label.\n\n    Parameters\n    ----------\n    label : object\n    takeable : interpret the index as indexers, default False\n\n    Returns\n    -------\n    scalar value\n    \"\"\"\n    if takeable:\n        return self._values[label]\n\n    # Similar to Index.get_value, but we do not fall back to positional\n    loc = self.index.get_loc(label)\n    return self.index._get_values_for_loc(self, loc, label)",
                "def __setitem__(self, key, value):\n    key = com.apply_if_callable(key, self)\n    cacher_needs_updating = self._check_is_chained_assignment_possible()\n\n    if key is Ellipsis:\n        key = slice(None)\n\n    try:\n        self._set_with_engine(key, value)\n    except (KeyError, ValueError):\n        values = self._values\n        if is_integer(key) and not self.index.inferred_type == \"integer\":\n            # positional setter\n            values[key] = value\n        else:\n            # GH#12862 adding an new key to the Series\n            self.loc[key] = value\n\n    except TypeError as e:\n        if isinstance(key, tuple) and not isinstance(self.index, MultiIndex):\n            raise ValueError(\"Can only tuple-index with a MultiIndex\") from e\n\n        if com.is_bool_indexer(key):\n            key = check_bool_indexer(self.index, key)\n            key = np.asarray(key, dtype=bool)\n            try:\n                self._where(~key, value, inplace=True)\n            except InvalidIndexError:\n                self.iloc[key] = value\n            return\n\n        else:\n            self._set_with(key, value)\n\n    if cacher_needs_updating:\n        self._maybe_update_cacher()",
                "def _set_with_engine(self, key, value):\n    # fails with AttributeError for IntervalIndex\n    loc = self.index._engine.get_loc(key)\n    validate_numeric_casting(self.dtype, value)\n    self._values[loc] = value",
                "def _set_with(self, key, value):\n    # other: fancy integer or otherwise\n    if isinstance(key, slice):\n        # extract_array so that if we set e.g. ser[-5:] = ser[:5]\n        #  we get the first five values, and not 5 NaNs\n        indexer = self.index._convert_slice_indexer(key, kind=\"getitem\")\n        self.iloc[indexer] = extract_array(value, extract_numpy=True)\n\n    else:\n        assert not isinstance(key, tuple)\n\n        if is_scalar(key):\n            key = [key]\n\n        if isinstance(key, Index):\n            key_type = key.inferred_type\n            key = key._values\n        else:\n            key_type = lib.infer_dtype(key, skipna=False)\n\n        # Note: key_type == \"boolean\" should not occur because that\n        #  should be caught by the is_bool_indexer check in __setitem__\n        if key_type == \"integer\":\n            if not self.index._should_fallback_to_positional():\n                self.loc[key] = value\n            else:\n                self.iloc[key] = value\n        else:\n            self.loc[key] = value",
                "def _set_value(self, label, value, takeable: bool = False):\n    \"\"\"\n    Quickly set single value at passed label.\n\n    If label is not contained, a new object is created with the label\n    placed at the end of the result index.\n\n    Parameters\n    ----------\n    label : object\n        Partial indexing with MultiIndex not allowed.\n    value : object\n        Scalar value.\n    takeable : interpret the index as indexers, default False\n    \"\"\"\n    try:\n        if takeable:\n            self._values[label] = value\n        else:\n            loc = self.index.get_loc(label)\n            validate_numeric_casting(self.dtype, value)\n            self._values[loc] = value\n    except KeyError:\n\n        # set using a non-recursive method\n        self.loc[label] = value",
                "@property\ndef _is_mixed_type(self):\n    return False",
                "def repeat(self, repeats, axis=None) -> \"Series\":\n    \"\"\"\n    Repeat elements of a Series.\n\n    Returns a new Series where each element of the current Series\n    is repeated consecutively a given number of times.\n\n    Parameters\n    ----------\n    repeats : int or array of ints\n        The number of repetitions for each element. This should be a\n        non-negative integer. Repeating 0 times will return an empty\n        Series.\n    axis : None\n        Must be ``None``. Has no effect but is accepted for compatibility\n        with numpy.\n\n    Returns\n    -------\n    Series\n        Newly created Series with repeated elements.\n\n    See Also\n    --------\n    Index.repeat : Equivalent function for Index.\n    numpy.repeat : Similar method for :class:`numpy.ndarray`.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'b', 'c'])\n    >>> s\n    0    a\n    1    b\n    2    c\n    dtype: object\n    >>> s.repeat(2)\n    0    a\n    0    a\n    1    b\n    1    b\n    2    c\n    2    c\n    dtype: object\n    >>> s.repeat([1, 2, 3])\n    0    a\n    1    b\n    1    b\n    2    c\n    2    c\n    2    c\n    dtype: object\n    \"\"\"\n    nv.validate_repeat(tuple(), dict(axis=axis))\n    new_index = self.index.repeat(repeats)\n    new_values = self._values.repeat(repeats)\n    return self._constructor(new_values, index=new_index).__finalize__(\n        self, method=\"repeat\"\n    )",
                "def reset_index(self, level=None, drop=False, name=None, inplace=False):\n    \"\"\"\n    Generate a new DataFrame or Series with the index reset.\n\n    This is useful when the index needs to be treated as a column, or\n    when the index is meaningless and needs to be reset to the default\n    before another operation.\n\n    Parameters\n    ----------\n    level : int, str, tuple, or list, default optional\n        For a Series with a MultiIndex, only remove the specified levels\n        from the index. Removes all levels by default.\n    drop : bool, default False\n        Just reset the index, without inserting it as a column in\n        the new DataFrame.\n    name : object, optional\n        The name to use for the column containing the original Series\n        values. Uses ``self.name`` by default. This argument is ignored\n        when `drop` is True.\n    inplace : bool, default False\n        Modify the Series in place (do not create a new object).\n\n    Returns\n    -------\n    Series or DataFrame\n        When `drop` is False (the default), a DataFrame is returned.\n        The newly created columns will come first in the DataFrame,\n        followed by the original Series values.\n        When `drop` is True, a `Series` is returned.\n        In either case, if ``inplace=True``, no value is returned.\n\n    See Also\n    --------\n    DataFrame.reset_index: Analogous function for DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3, 4], name='foo',\n    ...               index=pd.Index(['a', 'b', 'c', 'd'], name='idx'))\n\n    Generate a DataFrame with default index.\n\n    >>> s.reset_index()\n      idx  foo\n    0   a    1\n    1   b    2\n    2   c    3\n    3   d    4\n\n    To specify the name of the new column use `name`.\n\n    >>> s.reset_index(name='values')\n      idx  values\n    0   a       1\n    1   b       2\n    2   c       3\n    3   d       4\n\n    To generate a new Series with the default set `drop` to True.\n\n    >>> s.reset_index(drop=True)\n    0    1\n    1    2\n    2    3\n    3    4\n    Name: foo, dtype: int64\n\n    To update the Series in place, without generating a new one\n    set `inplace` to True. Note that it also requires ``drop=True``.\n\n    >>> s.reset_index(inplace=True, drop=True)\n    >>> s\n    0    1\n    1    2\n    2    3\n    3    4\n    Name: foo, dtype: int64\n\n    The `level` parameter is interesting for Series with a multi-level\n    index.\n\n    >>> arrays = [np.array(['bar', 'bar', 'baz', 'baz']),\n    ...           np.array(['one', 'two', 'one', 'two'])]\n    >>> s2 = pd.Series(\n    ...     range(4), name='foo',\n    ...     index=pd.MultiIndex.from_arrays(arrays,\n    ...                                     names=['a', 'b']))\n\n    To remove a specific level from the Index, use `level`.\n\n    >>> s2.reset_index(level='a')\n           a  foo\n    b\n    one  bar    0\n    two  bar    1\n    one  baz    2\n    two  baz    3\n\n    If `level` is not set, all levels are removed from the Index.\n\n    >>> s2.reset_index()\n         a    b  foo\n    0  bar  one    0\n    1  bar  two    1\n    2  baz  one    2\n    3  baz  two    3\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    if drop:\n        new_index = ibase.default_index(len(self))\n        if level is not None:\n            if not isinstance(level, (tuple, list)):\n                level = [level]\n            level = [self.index._get_level_number(lev) for lev in level]\n            if len(level) < self.index.nlevels:\n                new_index = self.index.droplevel(level)\n\n        if inplace:\n            self.index = new_index\n            # set name if it was passed, otherwise, keep the previous name\n            self.name = name or self.name\n        else:\n            return self._constructor(\n                self._values.copy(), index=new_index\n            ).__finalize__(self, method=\"reset_index\")\n    elif inplace:\n        raise TypeError(\n            \"Cannot reset_index inplace on a Series to create a DataFrame\"\n        )\n    else:\n        df = self.to_frame(name)\n        return df.reset_index(level=level, drop=drop)",
                "def __repr__(self) -> str:\n    \"\"\"\n    Return a string representation for a particular Series.\n    \"\"\"\n    buf = StringIO(\"\")\n    width, height = get_terminal_size()\n    max_rows = (\n        height\n        if get_option(\"display.max_rows\") == 0\n        else get_option(\"display.max_rows\")\n    )\n    min_rows = (\n        height\n        if get_option(\"display.max_rows\") == 0\n        else get_option(\"display.min_rows\")\n    )\n    show_dimensions = get_option(\"display.show_dimensions\")\n\n    self.to_string(\n        buf=buf,\n        name=self.name,\n        dtype=self.dtype,\n        min_rows=min_rows,\n        max_rows=max_rows,\n        length=show_dimensions,\n    )\n    result = buf.getvalue()\n\n    return result",
                "def to_string(\n    self,\n    buf=None,\n    na_rep=\"NaN\",\n    float_format=None,\n    header=True,\n    index=True,\n    length=False,\n    dtype=False,\n    name=False,\n    max_rows=None,\n    min_rows=None,\n):\n    \"\"\"\n    Render a string representation of the Series.\n\n    Parameters\n    ----------\n    buf : StringIO-like, optional\n        Buffer to write to.\n    na_rep : str, optional\n        String representation of NaN to use, default 'NaN'.\n    float_format : one-parameter function, optional\n        Formatter function to apply to columns' elements if they are\n        floats, default None.\n    header : bool, default True\n        Add the Series header (index name).\n    index : bool, optional\n        Add index (row) labels, default True.\n    length : bool, default False\n        Add the Series length.\n    dtype : bool, default False\n        Add the Series dtype.\n    name : bool, default False\n        Add the Series name if not None.\n    max_rows : int, optional\n        Maximum number of rows to show before truncating. If None, show\n        all.\n    min_rows : int, optional\n        The number of rows to display in a truncated repr (when number\n        of rows is above `max_rows`).\n\n    Returns\n    -------\n    str or None\n        String representation of Series if ``buf=None``, otherwise None.\n    \"\"\"\n    formatter = fmt.SeriesFormatter(\n        self,\n        name=name,\n        length=length,\n        header=header,\n        index=index,\n        dtype=dtype,\n        na_rep=na_rep,\n        float_format=float_format,\n        min_rows=min_rows,\n        max_rows=max_rows,\n    )\n    result = formatter.to_string()\n\n    # catch contract violations\n    if not isinstance(result, str):\n        raise AssertionError(\n            \"result must be of type str, type \"\n            f\"of result is {repr(type(result).__name__)}\"\n        )\n\n    if buf is None:\n        return result\n    else:\n        try:\n            buf.write(result)\n        except AttributeError:\n            with open(buf, \"w\") as f:\n                f.write(result)",
                "@Appender(\n    \"\"\"\n    Examples\n    --------\n    >>> s = pd.Series([\"elk\", \"pig\", \"dog\", \"quetzal\"], name=\"animal\")\n    >>> print(s.to_markdown())\n    |    | animal   |\n    |---:|:---------|\n    |  0 | elk      |\n    |  1 | pig      |\n    |  2 | dog      |\n    |  3 | quetzal  |\n    \"\"\"\n)\n@Substitution(klass=\"Series\")\n@Appender(generic._shared_docs[\"to_markdown\"])\ndef to_markdown(\n    self, buf: Optional[IO[str]] = None, mode: Optional[str] = None, **kwargs\n) -> Optional[str]:\n    return self.to_frame().to_markdown(buf, mode, **kwargs)",
                "def items(self) -> Iterable[Tuple[Label, Any]]:\n    \"\"\"\n    Lazily iterate over (index, value) tuples.\n\n    This method returns an iterable tuple (index, value). This is\n    convenient if you want to create a lazy iterator.\n\n    Returns\n    -------\n    iterable\n        Iterable of tuples containing the (index, value) pairs from a\n        Series.\n\n    See Also\n    --------\n    DataFrame.items : Iterate over (column name, Series) pairs.\n    DataFrame.iterrows : Iterate over DataFrame rows as (index, Series) pairs.\n\n    Examples\n    --------\n    >>> s = pd.Series(['A', 'B', 'C'])\n    >>> for index, value in s.items():\n    ...     print(f\"Index : {index}, Value : {value}\")\n    Index : 0, Value : A\n    Index : 1, Value : B\n    Index : 2, Value : C\n    \"\"\"\n    return zip(iter(self.index), iter(self))",
                "@Appender(items.__doc__)\ndef iteritems(self) -> Iterable[Tuple[Label, Any]]:\n    return self.items()",
                "def keys(self) -> Index:\n    \"\"\"\n    Return alias for index.\n\n    Returns\n    -------\n    Index\n        Index of the Series.\n    \"\"\"\n    return self.index",
                "def to_dict(self, into=dict):\n    \"\"\"\n    Convert Series to {label -> value} dict or dict-like object.\n\n    Parameters\n    ----------\n    into : class, default dict\n        The collections.abc.Mapping subclass to use as the return\n        object. Can be the actual class or an empty\n        instance of the mapping type you want.  If you want a\n        collections.defaultdict, you must pass it initialized.\n\n    Returns\n    -------\n    collections.abc.Mapping\n        Key-value representation of Series.\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3, 4])\n    >>> s.to_dict()\n    {0: 1, 1: 2, 2: 3, 3: 4}\n    >>> from collections import OrderedDict, defaultdict\n    >>> s.to_dict(OrderedDict)\n    OrderedDict([(0, 1), (1, 2), (2, 3), (3, 4)])\n    >>> dd = defaultdict(list)\n    >>> s.to_dict(dd)\n    defaultdict(<class 'list'>, {0: 1, 1: 2, 2: 3, 3: 4})\n    \"\"\"\n    # GH16122\n    into_c = com.standardize_mapping(into)\n    return into_c(self.items())",
                "def to_frame(self, name=None) -> \"DataFrame\":\n    \"\"\"\n    Convert Series to DataFrame.\n\n    Parameters\n    ----------\n    name : object, default None\n        The passed name should substitute for the series name (if it has\n        one).\n\n    Returns\n    -------\n    DataFrame\n        DataFrame representation of Series.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"a\", \"b\", \"c\"],\n    ...               name=\"vals\")\n    >>> s.to_frame()\n      vals\n    0    a\n    1    b\n    2    c\n    \"\"\"\n    if name is None:\n        df = self._constructor_expanddim(self)\n    else:\n        df = self._constructor_expanddim({name: self})\n\n    return df",
                "def _set_name(self, name, inplace=False) -> \"Series\":\n    \"\"\"\n    Set the Series name.\n\n    Parameters\n    ----------\n    name : str\n    inplace : bool\n        Whether to modify `self` directly or return a copy.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    ser = self if inplace else self.copy()\n    ser.name = name\n    return ser",
                "    @Appender(\n        \"\"\"\nExamples\n--------\n>>> ser = pd.Series([390., 350., 30., 20.],\n...                 index=['Falcon', 'Falcon', 'Parrot', 'Parrot'], name=\"Max Speed\")\n>>> ser\nFalcon    390.0\nFalcon    350.0\nParrot     30.0\nParrot     20.0\nName: Max Speed, dtype: float64\n>>> ser.groupby([\"a\", \"b\", \"a\", \"b\"]).mean()\na    210.0\nb    185.0\nName: Max Speed, dtype: float64\n>>> ser.groupby(level=0).mean()\nFalcon    370.0\nParrot     25.0\nName: Max Speed, dtype: float64\n>>> ser.groupby(ser > 100).mean()\nMax Speed\nFalse     25.0\nTrue     370.0\nName: Max Speed, dtype: float64\n\n**Grouping by Indexes**\n\nWe can groupby different levels of a hierarchical index\nusing the `level` parameter:\n\n>>> arrays = [['Falcon', 'Falcon', 'Parrot', 'Parrot'],\n...           ['Captive', 'Wild', 'Captive', 'Wild']]\n>>> index = pd.MultiIndex.from_arrays(arrays, names=('Animal', 'Type'))\n>>> ser = pd.Series([390., 350., 30., 20.], index=index, name=\"Max Speed\")\n>>> ser\nAnimal  Type\nFalcon  Captive    390.0\n        Wild       350.0\nParrot  Captive     30.0\n        Wild        20.0\nName: Max Speed, dtype: float64\n>>> ser.groupby(level=0).mean()\nAnimal\nFalcon    370.0\nParrot     25.0\nName: Max Speed, dtype: float64\n>>> ser.groupby(level=\"Type\").mean()\nType\nCaptive    210.0\nWild       185.0\nName: Max Speed, dtype: float64\n\nWe can also choose to include `NA` in group keys or not by defining\n`dropna` parameter, the default setting is `True`:\n\n>>> ser = pd.Series([1, 2, 3, 3], index=[\"a\", 'a', 'b', np.nan])\n>>> ser.groupby(level=0).sum()\na    3\nb    3\ndtype: int64\n\n>>> ser.groupby(level=0, dropna=False).sum()\na    3\nb    3\nNaN  3\ndtype: int64\n\n>>> arrays = ['Falcon', 'Falcon', 'Parrot', 'Parrot']\n>>> ser = pd.Series([390., 350., 30., 20.], index=arrays, name=\"Max Speed\")\n>>> ser.groupby([\"a\", \"b\", \"a\", np.nan]).mean()\na    210.0\nb    350.0\nName: Max Speed, dtype: float64\n\n>>> ser.groupby([\"a\", \"b\", \"a\", np.nan], dropna=False).mean()\na    210.0\nb    350.0\nNaN   20.0\nName: Max Speed, dtype: float64\n\"\"\"\n    )\n    @Appender(generic._shared_docs[\"groupby\"] % _shared_doc_kwargs)\n    def groupby(\n        self,\n        by=None,\n        axis=0,\n        level=None,\n        as_index: bool = True,\n        sort: bool = True,\n        group_keys: bool = True,\n        squeeze: bool = False,\n        observed: bool = False,\n        dropna: bool = True,\n    ) -> \"SeriesGroupBy\":\n        from pandas.core.groupby.generic import SeriesGroupBy\n\n        if level is None and by is None:\n            raise TypeError(\"You have to supply one of 'by' and 'level'\")\n        axis = self._get_axis_number(axis)\n\n        return SeriesGroupBy(\n            obj=self,\n            keys=by,\n            axis=axis,\n            level=level,\n            as_index=as_index,\n            sort=sort,\n            group_keys=group_keys,\n            squeeze=squeeze,\n            observed=observed,\n            dropna=dropna,\n        )",
                "def count(self, level=None):\n    \"\"\"\n    Return number of non-NA/null observations in the Series.\n\n    Parameters\n    ----------\n    level : int or level name, default None\n        If the axis is a MultiIndex (hierarchical), count along a\n        particular level, collapsing into a smaller Series.\n\n    Returns\n    -------\n    int or Series (if level specified)\n        Number of non-null values in the Series.\n\n    See Also\n    --------\n    DataFrame.count : Count non-NA cells for each column or row.\n\n    Examples\n    --------\n    >>> s = pd.Series([0.0, 1.0, np.nan])\n    >>> s.count()\n    2\n    \"\"\"\n    if level is None:\n        return notna(self.array).sum()\n\n    if isinstance(level, str):\n        level = self.index._get_level_number(level)\n\n    lev = self.index.levels[level]\n    level_codes = np.array(self.index.codes[level], subok=False, copy=True)\n\n    mask = level_codes == -1\n    if mask.any():\n        level_codes[mask] = cnt = len(lev)\n        lev = lev.insert(cnt, lev._na_value)\n\n    obs = level_codes[notna(self._values)]\n    out = np.bincount(obs, minlength=len(lev) or None)\n    return self._constructor(out, index=lev, dtype=\"int64\").__finalize__(\n        self, method=\"count\"\n    )",
                "def mode(self, dropna=True) -> \"Series\":\n    \"\"\"\n    Return the mode(s) of the dataset.\n\n    Always returns Series even if only one value is returned.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't consider counts of NaN/NaT.\n\n        .. versionadded:: 0.24.0\n\n    Returns\n    -------\n    Series\n        Modes of the Series in sorted order.\n    \"\"\"\n    # TODO: Add option for bins like value_counts()\n    return algorithms.mode(self, dropna=dropna)",
                "def unique(self):\n    \"\"\"\n    Return unique values of Series object.\n\n    Uniques are returned in order of appearance. Hash table-based unique,\n    therefore does NOT sort.\n\n    Returns\n    -------\n    ndarray or ExtensionArray\n        The unique values returned as a NumPy array. See Notes.\n\n    See Also\n    --------\n    unique : Top-level unique method for any 1-d array-like object.\n    Index.unique : Return Index with unique values from an Index object.\n\n    Notes\n    -----\n    Returns the unique values as a NumPy array. In case of an\n    extension-array backed Series, a new\n    :class:`~api.extensions.ExtensionArray` of that type with just\n    the unique values is returned. This includes\n\n        * Categorical\n        * Period\n        * Datetime with Timezone\n        * Interval\n        * Sparse\n        * IntegerNA\n\n    See Examples section.\n\n    Examples\n    --------\n    >>> pd.Series([2, 1, 3, 3], name='A').unique()\n    array([2, 1, 3])\n\n    >>> pd.Series([pd.Timestamp('2016-01-01') for _ in range(3)]).unique()\n    array(['2016-01-01T00:00:00.000000000'], dtype='datetime64[ns]')\n\n    >>> pd.Series([pd.Timestamp('2016-01-01', tz='US/Eastern')\n    ...            for _ in range(3)]).unique()\n    <DatetimeArray>\n    ['2016-01-01 00:00:00-05:00']\n    Length: 1, dtype: datetime64[ns, US/Eastern]\n\n    An unordered Categorical will return categories in the order of\n    appearance.\n\n    >>> pd.Series(pd.Categorical(list('baabc'))).unique()\n    [b, a, c]\n    Categories (3, object): [b, a, c]\n\n    An ordered Categorical preserves the category ordering.\n\n    >>> pd.Series(pd.Categorical(list('baabc'), categories=list('abc'),\n    ...                          ordered=True)).unique()\n    [b, a, c]\n    Categories (3, object): [a < b < c]\n    \"\"\"\n    result = super().unique()\n    return result",
                "def drop_duplicates(self, keep=\"first\", inplace=False) -> Optional[\"Series\"]:\n    \"\"\"\n    Return Series with duplicate values removed.\n\n    Parameters\n    ----------\n    keep : {'first', 'last', ``False``}, default 'first'\n        Method to handle dropping duplicates:\n\n        - 'first' : Drop duplicates except for the first occurrence.\n        - 'last' : Drop duplicates except for the last occurrence.\n        - ``False`` : Drop all duplicates.\n\n    inplace : bool, default ``False``\n        If ``True``, performs operation inplace and returns None.\n\n    Returns\n    -------\n    Series\n        Series with duplicates dropped.\n\n    See Also\n    --------\n    Index.drop_duplicates : Equivalent method on Index.\n    DataFrame.drop_duplicates : Equivalent method on DataFrame.\n    Series.duplicated : Related method on Series, indicating duplicate\n        Series values.\n\n    Examples\n    --------\n    Generate a Series with duplicated entries.\n\n    >>> s = pd.Series(['lama', 'cow', 'lama', 'beetle', 'lama', 'hippo'],\n    ...               name='animal')\n    >>> s\n    0      lama\n    1       cow\n    2      lama\n    3    beetle\n    4      lama\n    5     hippo\n    Name: animal, dtype: object\n\n    With the 'keep' parameter, the selection behaviour of duplicated values\n    can be changed. The value 'first' keeps the first occurrence for each\n    set of duplicated entries. The default value of keep is 'first'.\n\n    >>> s.drop_duplicates()\n    0      lama\n    1       cow\n    3    beetle\n    5     hippo\n    Name: animal, dtype: object\n\n    The value 'last' for parameter 'keep' keeps the last occurrence for\n    each set of duplicated entries.\n\n    >>> s.drop_duplicates(keep='last')\n    1       cow\n    3    beetle\n    4      lama\n    5     hippo\n    Name: animal, dtype: object\n\n    The value ``False`` for parameter 'keep' discards all sets of\n    duplicated entries. Setting the value of 'inplace' to ``True`` performs\n    the operation inplace and returns ``None``.\n\n    >>> s.drop_duplicates(keep=False, inplace=True)\n    >>> s\n    1       cow\n    3    beetle\n    5     hippo\n    Name: animal, dtype: object\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    result = super().drop_duplicates(keep=keep)\n    if inplace:\n        self._update_inplace(result)\n        return None\n    else:\n        return result",
                "def duplicated(self, keep=\"first\") -> \"Series\":\n    \"\"\"\n    Indicate duplicate Series values.\n\n    Duplicated values are indicated as ``True`` values in the resulting\n    Series. Either all duplicates, all except the first or all except the\n    last occurrence of duplicates can be indicated.\n\n    Parameters\n    ----------\n    keep : {'first', 'last', False}, default 'first'\n        Method to handle dropping duplicates:\n\n        - 'first' : Mark duplicates as ``True`` except for the first\n          occurrence.\n        - 'last' : Mark duplicates as ``True`` except for the last\n          occurrence.\n        - ``False`` : Mark all duplicates as ``True``.\n\n    Returns\n    -------\n    Series\n        Series indicating whether each value has occurred in the\n        preceding values.\n\n    See Also\n    --------\n    Index.duplicated : Equivalent method on pandas.Index.\n    DataFrame.duplicated : Equivalent method on pandas.DataFrame.\n    Series.drop_duplicates : Remove duplicate values from Series.\n\n    Examples\n    --------\n    By default, for each set of duplicated values, the first occurrence is\n    set on False and all others on True:\n\n    >>> animals = pd.Series(['lama', 'cow', 'lama', 'beetle', 'lama'])\n    >>> animals.duplicated()\n    0    False\n    1    False\n    2     True\n    3    False\n    4     True\n    dtype: bool\n\n    which is equivalent to\n\n    >>> animals.duplicated(keep='first')\n    0    False\n    1    False\n    2     True\n    3    False\n    4     True\n    dtype: bool\n\n    By using 'last', the last occurrence of each set of duplicated values\n    is set on False and all others on True:\n\n    >>> animals.duplicated(keep='last')\n    0     True\n    1    False\n    2     True\n    3    False\n    4    False\n    dtype: bool\n\n    By setting keep on ``False``, all duplicates are True:\n\n    >>> animals.duplicated(keep=False)\n    0     True\n    1    False\n    2     True\n    3    False\n    4     True\n    dtype: bool\n    \"\"\"\n    return super().duplicated(keep=keep)",
                "def idxmin(self, axis=0, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the row label of the minimum value.\n\n    If multiple values equal the minimum, the first row label with that\n    value is returned.\n\n    Parameters\n    ----------\n    axis : int, default 0\n        For compatibility with DataFrame.idxmin. Redundant for application\n        on Series.\n    skipna : bool, default True\n        Exclude NA/null values. If the entire Series is NA, the result\n        will be NA.\n    *args, **kwargs\n        Additional arguments and keywords have no effect but might be\n        accepted for compatibility with NumPy.\n\n    Returns\n    -------\n    Index\n        Label of the minimum value.\n\n    Raises\n    ------\n    ValueError\n        If the Series is empty.\n\n    See Also\n    --------\n    numpy.argmin : Return indices of the minimum values\n        along the given axis.\n    DataFrame.idxmin : Return index of first occurrence of minimum\n        over requested axis.\n    Series.idxmax : Return index *label* of the first occurrence\n        of maximum of values.\n\n    Notes\n    -----\n    This method is the Series version of ``ndarray.argmin``. This method\n    returns the label of the minimum, while ``ndarray.argmin`` returns\n    the position. To get the position, use ``series.values.argmin()``.\n\n    Examples\n    --------\n    >>> s = pd.Series(data=[1, None, 4, 1],\n    ...               index=['A', 'B', 'C', 'D'])\n    >>> s\n    A    1.0\n    B    NaN\n    C    4.0\n    D    1.0\n    dtype: float64\n\n    >>> s.idxmin()\n    'A'\n\n    If `skipna` is False and there is an NA value in the data,\n    the function returns ``nan``.\n\n    >>> s.idxmin(skipna=False)\n    nan\n    \"\"\"\n    skipna = nv.validate_argmin_with_skipna(skipna, args, kwargs)\n    i = nanops.nanargmin(self._values, skipna=skipna)\n    if i == -1:\n        return np.nan\n    return self.index[i]",
                "def idxmax(self, axis=0, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the row label of the maximum value.\n\n    If multiple values equal the maximum, the first row label with that\n    value is returned.\n\n    Parameters\n    ----------\n    axis : int, default 0\n        For compatibility with DataFrame.idxmax. Redundant for application\n        on Series.\n    skipna : bool, default True\n        Exclude NA/null values. If the entire Series is NA, the result\n        will be NA.\n    *args, **kwargs\n        Additional arguments and keywords have no effect but might be\n        accepted for compatibility with NumPy.\n\n    Returns\n    -------\n    Index\n        Label of the maximum value.\n\n    Raises\n    ------\n    ValueError\n        If the Series is empty.\n\n    See Also\n    --------\n    numpy.argmax : Return indices of the maximum values\n        along the given axis.\n    DataFrame.idxmax : Return index of first occurrence of maximum\n        over requested axis.\n    Series.idxmin : Return index *label* of the first occurrence\n        of minimum of values.\n\n    Notes\n    -----\n    This method is the Series version of ``ndarray.argmax``. This method\n    returns the label of the maximum, while ``ndarray.argmax`` returns\n    the position. To get the position, use ``series.values.argmax()``.\n\n    Examples\n    --------\n    >>> s = pd.Series(data=[1, None, 4, 3, 4],\n    ...               index=['A', 'B', 'C', 'D', 'E'])\n    >>> s\n    A    1.0\n    B    NaN\n    C    4.0\n    D    3.0\n    E    4.0\n    dtype: float64\n\n    >>> s.idxmax()\n    'C'\n\n    If `skipna` is False and there is an NA value in the data,\n    the function returns ``nan``.\n\n    >>> s.idxmax(skipna=False)\n    nan\n    \"\"\"\n    skipna = nv.validate_argmax_with_skipna(skipna, args, kwargs)\n    i = nanops.nanargmax(self._values, skipna=skipna)\n    if i == -1:\n        return np.nan\n    return self.index[i]",
                "def round(self, decimals=0, *args, **kwargs) -> \"Series\":\n    \"\"\"\n    Round each value in a Series to the given number of decimals.\n\n    Parameters\n    ----------\n    decimals : int, default 0\n        Number of decimal places to round to. If decimals is negative,\n        it specifies the number of positions to the left of the decimal point.\n    *args, **kwargs\n        Additional arguments and keywords have no effect but might be\n        accepted for compatibility with NumPy.\n\n    Returns\n    -------\n    Series\n        Rounded values of the Series.\n\n    See Also\n    --------\n    numpy.around : Round values of an np.array.\n    DataFrame.round : Round values of a DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series([0.1, 1.3, 2.7])\n    >>> s.round()\n    0    0.0\n    1    1.0\n    2    3.0\n    dtype: float64\n    \"\"\"\n    nv.validate_round(args, kwargs)\n    result = self._values.round(decimals)\n    result = self._constructor(result, index=self.index).__finalize__(\n        self, method=\"round\"\n    )\n\n    return result",
                "def quantile(self, q=0.5, interpolation=\"linear\"):\n    \"\"\"\n    Return value at the given quantile.\n\n    Parameters\n    ----------\n    q : float or array-like, default 0.5 (50% quantile)\n        The quantile(s) to compute, which can lie in range: 0 <= q <= 1.\n    interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}\n        This optional parameter specifies the interpolation method to use,\n        when the desired quantile lies between two data points `i` and `j`:\n\n            * linear: `i + (j - i) * fraction`, where `fraction` is the\n              fractional part of the index surrounded by `i` and `j`.\n            * lower: `i`.\n            * higher: `j`.\n            * nearest: `i` or `j` whichever is nearest.\n            * midpoint: (`i` + `j`) / 2.\n\n    Returns\n    -------\n    float or Series\n        If ``q`` is an array, a Series will be returned where the\n        index is ``q`` and the values are the quantiles, otherwise\n        a float will be returned.\n\n    See Also\n    --------\n    core.window.Rolling.quantile : Calculate the rolling quantile.\n    numpy.percentile : Returns the q-th percentile(s) of the array elements.\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3, 4])\n    >>> s.quantile(.5)\n    2.5\n    >>> s.quantile([.25, .5, .75])\n    0.25    1.75\n    0.50    2.50\n    0.75    3.25\n    dtype: float64\n    \"\"\"\n    validate_percentile(q)\n\n    # We dispatch to DataFrame so that core.internals only has to worry\n    #  about 2D cases.\n    df = self.to_frame()\n\n    result = df.quantile(q=q, interpolation=interpolation, numeric_only=False)\n    if result.ndim == 2:\n        result = result.iloc[:, 0]\n\n    if is_list_like(q):\n        result.name = self.name\n        return self._constructor(result, index=Float64Index(q), name=self.name)\n    else:\n        # scalar\n        return result.iloc[0]",
                "def corr(self, other, method=\"pearson\", min_periods=None) -> float:\n    \"\"\"\n    Compute correlation with `other` Series, excluding missing values.\n\n    Parameters\n    ----------\n    other : Series\n        Series with which to compute the correlation.\n    method : {'pearson', 'kendall', 'spearman'} or callable\n        Method used to compute correlation:\n\n        - pearson : Standard correlation coefficient\n        - kendall : Kendall Tau correlation coefficient\n        - spearman : Spearman rank correlation\n        - callable: Callable with input two 1d ndarrays and returning a float.\n\n        .. versionadded:: 0.24.0\n            Note that the returned matrix from corr will have 1 along the\n            diagonals and will be symmetric regardless of the callable's\n            behavior.\n    min_periods : int, optional\n        Minimum number of observations needed to have a valid result.\n\n    Returns\n    -------\n    float\n        Correlation with other.\n\n    See Also\n    --------\n    DataFrame.corr : Compute pairwise correlation between columns.\n    DataFrame.corrwith : Compute pairwise correlation with another\n        DataFrame or Series.\n\n    Examples\n    --------\n    >>> def histogram_intersection(a, b):\n    ...     v = np.minimum(a, b).sum().round(decimals=1)\n    ...     return v\n    >>> s1 = pd.Series([.2, .0, .6, .2])\n    >>> s2 = pd.Series([.3, .6, .0, .1])\n    >>> s1.corr(s2, method=histogram_intersection)\n    0.3\n    \"\"\"\n    this, other = self.align(other, join=\"inner\", copy=False)\n    if len(this) == 0:\n        return np.nan\n\n    if method in [\"pearson\", \"spearman\", \"kendall\"] or callable(method):\n        return nanops.nancorr(\n            this.values, other.values, method=method, min_periods=min_periods\n        )\n\n    raise ValueError(\n        \"method must be either 'pearson', \"\n        \"'spearman', 'kendall', or a callable, \"\n        f\"'{method}' was supplied\"\n    )",
                "def cov(self, other, min_periods=None) -> float:\n    \"\"\"\n    Compute covariance with Series, excluding missing values.\n\n    Parameters\n    ----------\n    other : Series\n        Series with which to compute the covariance.\n    min_periods : int, optional\n        Minimum number of observations needed to have a valid result.\n\n    Returns\n    -------\n    float\n        Covariance between Series and other normalized by N-1\n        (unbiased estimator).\n\n    See Also\n    --------\n    DataFrame.cov : Compute pairwise covariance of columns.\n\n    Examples\n    --------\n    >>> s1 = pd.Series([0.90010907, 0.13484424, 0.62036035])\n    >>> s2 = pd.Series([0.12528585, 0.26962463, 0.51111198])\n    >>> s1.cov(s2)\n    -0.01685762652715874\n    \"\"\"\n    this, other = self.align(other, join=\"inner\", copy=False)\n    if len(this) == 0:\n        return np.nan\n    return nanops.nancov(this.values, other.values, min_periods=min_periods)",
                "def diff(self, periods: int = 1) -> \"Series\":\n    \"\"\"\n    First discrete difference of element.\n\n    Calculates the difference of a Series element compared with another\n    element in the Series (default is element in previous row).\n\n    Parameters\n    ----------\n    periods : int, default 1\n        Periods to shift for calculating difference, accepts negative\n        values.\n\n    Returns\n    -------\n    Series\n        First differences of the Series.\n\n    See Also\n    --------\n    Series.pct_change: Percent change over given number of periods.\n    Series.shift: Shift index by desired number of periods with an\n        optional time freq.\n    DataFrame.diff: First discrete difference of object.\n\n    Notes\n    -----\n    For boolean dtypes, this uses :meth:`operator.xor` rather than\n    :meth:`operator.sub`.\n\n    Examples\n    --------\n    Difference with previous row\n\n    >>> s = pd.Series([1, 1, 2, 3, 5, 8])\n    >>> s.diff()\n    0    NaN\n    1    0.0\n    2    1.0\n    3    1.0\n    4    2.0\n    5    3.0\n    dtype: float64\n\n    Difference with 3rd previous row\n\n    >>> s.diff(periods=3)\n    0    NaN\n    1    NaN\n    2    NaN\n    3    2.0\n    4    4.0\n    5    6.0\n    dtype: float64\n\n    Difference with following row\n\n    >>> s.diff(periods=-1)\n    0    0.0\n    1   -1.0\n    2   -1.0\n    3   -2.0\n    4   -3.0\n    5    NaN\n    dtype: float64\n    \"\"\"\n    result = algorithms.diff(self.array, periods)\n    return self._constructor(result, index=self.index).__finalize__(\n        self, method=\"diff\"\n    )",
                "def autocorr(self, lag=1) -> float:\n    \"\"\"\n    Compute the lag-N autocorrelation.\n\n    This method computes the Pearson correlation between\n    the Series and its shifted self.\n\n    Parameters\n    ----------\n    lag : int, default 1\n        Number of lags to apply before performing autocorrelation.\n\n    Returns\n    -------\n    float\n        The Pearson correlation between self and self.shift(lag).\n\n    See Also\n    --------\n    Series.corr : Compute the correlation between two Series.\n    Series.shift : Shift index by desired number of periods.\n    DataFrame.corr : Compute pairwise correlation of columns.\n    DataFrame.corrwith : Compute pairwise correlation between rows or\n        columns of two DataFrame objects.\n\n    Notes\n    -----\n    If the Pearson correlation is not well defined return 'NaN'.\n\n    Examples\n    --------\n    >>> s = pd.Series([0.25, 0.5, 0.2, -0.05])\n    >>> s.autocorr()  # doctest: +ELLIPSIS\n    0.10355...\n    >>> s.autocorr(lag=2)  # doctest: +ELLIPSIS\n    -0.99999...\n\n    If the Pearson correlation is not well defined, then 'NaN' is returned.\n\n    >>> s = pd.Series([1, 0, 0, 0])\n    >>> s.autocorr()\n    nan\n    \"\"\"\n    return self.corr(self.shift(lag))",
                "def dot(self, other):\n    \"\"\"\n    Compute the dot product between the Series and the columns of other.\n\n    This method computes the dot product between the Series and another\n    one, or the Series and each columns of a DataFrame, or the Series and\n    each columns of an array.\n\n    It can also be called using `self @ other` in Python >= 3.5.\n\n    Parameters\n    ----------\n    other : Series, DataFrame or array-like\n        The other object to compute the dot product with its columns.\n\n    Returns\n    -------\n    scalar, Series or numpy.ndarray\n        Return the dot product of the Series and other if other is a\n        Series, the Series of the dot product of Series and each rows of\n        other if other is a DataFrame or a numpy.ndarray between the Series\n        and each columns of the numpy array.\n\n    See Also\n    --------\n    DataFrame.dot: Compute the matrix product with the DataFrame.\n    Series.mul: Multiplication of series and other, element-wise.\n\n    Notes\n    -----\n    The Series and other has to share the same index if other is a Series\n    or a DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series([0, 1, 2, 3])\n    >>> other = pd.Series([-1, 2, -3, 4])\n    >>> s.dot(other)\n    8\n    >>> s @ other\n    8\n    >>> df = pd.DataFrame([[0, 1], [-2, 3], [4, -5], [6, 7]])\n    >>> s.dot(df)\n    0    24\n    1    14\n    dtype: int64\n    >>> arr = np.array([[0, 1], [-2, 3], [4, -5], [6, 7]])\n    >>> s.dot(arr)\n    array([24, 14])\n    \"\"\"\n    if isinstance(other, (Series, ABCDataFrame)):\n        common = self.index.union(other.index)\n        if len(common) > len(self.index) or len(common) > len(other.index):\n            raise ValueError(\"matrices are not aligned\")\n\n        left = self.reindex(index=common, copy=False)\n        right = other.reindex(index=common, copy=False)\n        lvals = left.values\n        rvals = right.values\n    else:\n        lvals = self.values\n        rvals = np.asarray(other)\n        if lvals.shape[0] != rvals.shape[0]:\n            raise Exception(\n                f\"Dot product shape mismatch, {lvals.shape} vs {rvals.shape}\"\n            )\n\n    if isinstance(other, ABCDataFrame):\n        return self._constructor(\n            np.dot(lvals, rvals), index=other.columns\n        ).__finalize__(self, method=\"dot\")\n    elif isinstance(other, Series):\n        return np.dot(lvals, rvals)\n    elif isinstance(rvals, np.ndarray):\n        return np.dot(lvals, rvals)\n    else:  # pragma: no cover\n        raise TypeError(f\"unsupported type: {type(other)}\")",
                "def __matmul__(self, other):\n    \"\"\"\n    Matrix multiplication using binary `@` operator in Python>=3.5.\n    \"\"\"\n    return self.dot(other)",
                "def __rmatmul__(self, other):\n    \"\"\"\n    Matrix multiplication using binary `@` operator in Python>=3.5.\n    \"\"\"\n    return self.dot(np.transpose(other))",
                "@doc(base.IndexOpsMixin.searchsorted, klass=\"Series\")\ndef searchsorted(self, value, side=\"left\", sorter=None):\n    return algorithms.searchsorted(self._values, value, side=side, sorter=sorter)",
                "def append(self, to_append, ignore_index=False, verify_integrity=False):\n    \"\"\"\n    Concatenate two or more Series.\n\n    Parameters\n    ----------\n    to_append : Series or list/tuple of Series\n        Series to append with self.\n    ignore_index : bool, default False\n        If True, do not use the index labels.\n    verify_integrity : bool, default False\n        If True, raise Exception on creating index with duplicates.\n\n    Returns\n    -------\n    Series\n        Concatenated Series.\n\n    See Also\n    --------\n    concat : General function to concatenate DataFrame or Series objects.\n\n    Notes\n    -----\n    Iteratively appending to a Series can be more computationally intensive\n    than a single concatenate. A better solution is to append values to a\n    list and then concatenate the list with the original Series all at\n    once.\n\n    Examples\n    --------\n    >>> s1 = pd.Series([1, 2, 3])\n    >>> s2 = pd.Series([4, 5, 6])\n    >>> s3 = pd.Series([4, 5, 6], index=[3, 4, 5])\n    >>> s1.append(s2)\n    0    1\n    1    2\n    2    3\n    0    4\n    1    5\n    2    6\n    dtype: int64\n\n    >>> s1.append(s3)\n    0    1\n    1    2\n    2    3\n    3    4\n    4    5\n    5    6\n    dtype: int64\n\n    With `ignore_index` set to True:\n\n    >>> s1.append(s2, ignore_index=True)\n    0    1\n    1    2\n    2    3\n    3    4\n    4    5\n    5    6\n    dtype: int64\n\n    With `verify_integrity` set to True:\n\n    >>> s1.append(s2, verify_integrity=True)\n    Traceback (most recent call last):\n    ...\n    ValueError: Indexes have overlapping values: [0, 1, 2]\n    \"\"\"\n    from pandas.core.reshape.concat import concat\n\n    if isinstance(to_append, (list, tuple)):\n        to_concat = [self]\n        to_concat.extend(to_append)\n    else:\n        to_concat = [self, to_append]\n    if any(isinstance(x, (ABCDataFrame,)) for x in to_concat[1:]):\n        msg = \"to_append should be a Series or list/tuple of Series, got DataFrame\"\n        raise TypeError(msg)\n    return concat(\n        to_concat, ignore_index=ignore_index, verify_integrity=verify_integrity\n    )",
                "def _binop(self, other, func, level=None, fill_value=None):\n    \"\"\"\n    Perform generic binary operation with optional fill value.\n\n    Parameters\n    ----------\n    other : Series\n    func : binary operator\n    fill_value : float or object\n        Value to substitute for NA/null values. If both Series are NA in a\n        location, the result will be NA regardless of the passed fill value.\n    level : int or level name, default None\n        Broadcast across a level, matching Index values on the\n        passed MultiIndex level.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    if not isinstance(other, Series):\n        raise AssertionError(\"Other operand must be Series\")\n\n    this = self\n\n    if not self.index.equals(other.index):\n        this, other = self.align(other, level=level, join=\"outer\", copy=False)\n\n    this_vals, other_vals = ops.fill_binop(this.values, other.values, fill_value)\n\n    with np.errstate(all=\"ignore\"):\n        result = func(this_vals, other_vals)\n\n    name = ops.get_op_result_name(self, other)\n    ret = this._construct_result(result, name)\n    return ret",
                "def _construct_result(\n    self, result: Union[ArrayLike, Tuple[ArrayLike, ArrayLike]], name: Label\n) -> Union[\"Series\", Tuple[\"Series\", \"Series\"]]:\n    \"\"\"\n    Construct an appropriately-labelled Series from the result of an op.\n\n    Parameters\n    ----------\n    result : ndarray or ExtensionArray\n    name : Label\n\n    Returns\n    -------\n    Series\n        In the case of __divmod__ or __rdivmod__, a 2-tuple of Series.\n    \"\"\"\n    if isinstance(result, tuple):\n        # produced by divmod or rdivmod\n\n        res1 = self._construct_result(result[0], name=name)\n        res2 = self._construct_result(result[1], name=name)\n\n        # GH#33427 assertions to keep mypy happy\n        assert isinstance(res1, Series)\n        assert isinstance(res2, Series)\n        return (res1, res2)\n\n    # We do not pass dtype to ensure that the Series constructor\n    #  does inference in the case where `result` has object-dtype.\n    out = self._constructor(result, index=self.index)\n    out = out.__finalize__(self)\n\n    # Set the result's name after __finalize__ is called because __finalize__\n    #  would set it back to self.name\n    out.name = name\n    return out",
                "def combine(self, other, func, fill_value=None) -> \"Series\":\n    \"\"\"\n    Combine the Series with a Series or scalar according to `func`.\n\n    Combine the Series and `other` using `func` to perform elementwise\n    selection for combined Series.\n    `fill_value` is assumed when value is missing at some index\n    from one of the two objects being combined.\n\n    Parameters\n    ----------\n    other : Series or scalar\n        The value(s) to be combined with the `Series`.\n    func : function\n        Function that takes two scalars as inputs and returns an element.\n    fill_value : scalar, optional\n        The value to assume when an index is missing from\n        one Series or the other. The default specifies to use the\n        appropriate NaN value for the underlying dtype of the Series.\n\n    Returns\n    -------\n    Series\n        The result of combining the Series with the other object.\n\n    See Also\n    --------\n    Series.combine_first : Combine Series values, choosing the calling\n        Series' values first.\n\n    Examples\n    --------\n    Consider 2 Datasets ``s1`` and ``s2`` containing\n    highest clocked speeds of different birds.\n\n    >>> s1 = pd.Series({'falcon': 330.0, 'eagle': 160.0})\n    >>> s1\n    falcon    330.0\n    eagle     160.0\n    dtype: float64\n    >>> s2 = pd.Series({'falcon': 345.0, 'eagle': 200.0, 'duck': 30.0})\n    >>> s2\n    falcon    345.0\n    eagle     200.0\n    duck       30.0\n    dtype: float64\n\n    Now, to combine the two datasets and view the highest speeds\n    of the birds across the two datasets\n\n    >>> s1.combine(s2, max)\n    duck        NaN\n    eagle     200.0\n    falcon    345.0\n    dtype: float64\n\n    In the previous example, the resulting value for duck is missing,\n    because the maximum of a NaN and a float is a NaN.\n    So, in the example, we set ``fill_value=0``,\n    so the maximum value returned will be the value from some dataset.\n\n    >>> s1.combine(s2, max, fill_value=0)\n    duck       30.0\n    eagle     200.0\n    falcon    345.0\n    dtype: float64\n    \"\"\"\n    if fill_value is None:\n        fill_value = na_value_for_dtype(self.dtype, compat=False)\n\n    if isinstance(other, Series):\n        # If other is a Series, result is based on union of Series,\n        # so do this element by element\n        new_index = self.index.union(other.index)\n        new_name = ops.get_op_result_name(self, other)\n        new_values = []\n        for idx in new_index:\n            lv = self.get(idx, fill_value)\n            rv = other.get(idx, fill_value)\n            with np.errstate(all=\"ignore\"):\n                new_values.append(func(lv, rv))\n    else:\n        # Assume that other is a scalar, so apply the function for\n        # each element in the Series\n        new_index = self.index\n        with np.errstate(all=\"ignore\"):\n            new_values = [func(lv, other) for lv in self._values]\n        new_name = self.name\n\n    if is_categorical_dtype(self.dtype):\n        pass\n    elif is_extension_array_dtype(self.dtype):\n        # TODO: can we do this for only SparseDtype?\n        # The function can return something of any type, so check\n        # if the type is compatible with the calling EA.\n        new_values = maybe_cast_to_extension_array(type(self._values), new_values)\n    return self._constructor(new_values, index=new_index, name=new_name)",
                "def combine_first(self, other) -> \"Series\":\n    \"\"\"\n    Combine Series values, choosing the calling Series's values first.\n\n    Parameters\n    ----------\n    other : Series\n        The value(s) to be combined with the `Series`.\n\n    Returns\n    -------\n    Series\n        The result of combining the Series with the other object.\n\n    See Also\n    --------\n    Series.combine : Perform elementwise operation on two Series\n        using a given function.\n\n    Notes\n    -----\n    Result index will be the union of the two indexes.\n\n    Examples\n    --------\n    >>> s1 = pd.Series([1, np.nan])\n    >>> s2 = pd.Series([3, 4])\n    >>> s1.combine_first(s2)\n    0    1.0\n    1    4.0\n    dtype: float64\n    \"\"\"\n    new_index = self.index.union(other.index)\n    this = self.reindex(new_index, copy=False)\n    other = other.reindex(new_index, copy=False)\n    if this.dtype.kind == \"M\" and other.dtype.kind != \"M\":\n        other = to_datetime(other)\n\n    return this.where(notna(this), other)",
                "def update(self, other) -> None:\n    \"\"\"\n    Modify Series in place using non-NA values from passed\n    Series. Aligns on index.\n\n    Parameters\n    ----------\n    other : Series, or object coercible into Series\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3])\n    >>> s.update(pd.Series([4, 5, 6]))\n    >>> s\n    0    4\n    1    5\n    2    6\n    dtype: int64\n\n    >>> s = pd.Series(['a', 'b', 'c'])\n    >>> s.update(pd.Series(['d', 'e'], index=[0, 2]))\n    >>> s\n    0    d\n    1    b\n    2    e\n    dtype: object\n\n    >>> s = pd.Series([1, 2, 3])\n    >>> s.update(pd.Series([4, 5, 6, 7, 8]))\n    >>> s\n    0    4\n    1    5\n    2    6\n    dtype: int64\n\n    If ``other`` contains NaNs the corresponding values are not updated\n    in the original Series.\n\n    >>> s = pd.Series([1, 2, 3])\n    >>> s.update(pd.Series([4, np.nan, 6]))\n    >>> s\n    0    4\n    1    2\n    2    6\n    dtype: int64\n\n    ``other`` can also be a non-Series object type\n    that is coercible into a Series\n\n    >>> s = pd.Series([1, 2, 3])\n    >>> s.update([4, np.nan, 6])\n    >>> s\n    0    4\n    1    2\n    2    6\n    dtype: int64\n\n    >>> s = pd.Series([1, 2, 3])\n    >>> s.update({1: 9})\n    >>> s\n    0    1\n    1    9\n    2    3\n    dtype: int64\n    \"\"\"\n\n    if not isinstance(other, Series):\n        other = Series(other)\n\n    other = other.reindex_like(self)\n    mask = notna(other)\n\n    self._mgr = self._mgr.putmask(mask=mask, new=other)\n    self._maybe_update_cacher()",
                "def sort_values(\n    self,\n    axis=0,\n    ascending=True,\n    inplace: bool = False,\n    kind: str = \"quicksort\",\n    na_position: str = \"last\",\n    ignore_index: bool = False,\n    key: ValueKeyFunc = None,\n):\n    \"\"\"\n    Sort by the values.\n\n    Sort a Series in ascending or descending order by some\n    criterion.\n\n    Parameters\n    ----------\n    axis : {0 or 'index'}, default 0\n        Axis to direct sorting. The value 'index' is accepted for\n        compatibility with DataFrame.sort_values.\n    ascending : bool, default True\n        If True, sort values in ascending order, otherwise descending.\n    inplace : bool, default False\n        If True, perform operation in-place.\n    kind : {'quicksort', 'mergesort' or 'heapsort'}, default 'quicksort'\n        Choice of sorting algorithm. See also :func:`numpy.sort` for more\n        information. 'mergesort' is the only stable  algorithm.\n    na_position : {'first' or 'last'}, default 'last'\n        Argument 'first' puts NaNs at the beginning, 'last' puts NaNs at\n        the end.\n    ignore_index : bool, default False\n        If True, the resulting axis will be labeled 0, 1, \u2026, n - 1.\n\n        .. versionadded:: 1.0.0\n\n    key : callable, optional\n        If not None, apply the key function to the series values\n        before sorting. This is similar to the `key` argument in the\n        builtin :meth:`sorted` function, with the notable difference that\n        this `key` function should be *vectorized*. It should expect a\n        ``Series`` and return an array-like.\n\n        .. versionadded:: 1.1.0\n\n    Returns\n    -------\n    Series\n        Series ordered by values.\n\n    See Also\n    --------\n    Series.sort_index : Sort by the Series indices.\n    DataFrame.sort_values : Sort DataFrame by the values along either axis.\n    DataFrame.sort_index : Sort DataFrame by indices.\n\n    Examples\n    --------\n    >>> s = pd.Series([np.nan, 1, 3, 10, 5])\n    >>> s\n    0     NaN\n    1     1.0\n    2     3.0\n    3     10.0\n    4     5.0\n    dtype: float64\n\n    Sort values ascending order (default behaviour)\n\n    >>> s.sort_values(ascending=True)\n    1     1.0\n    2     3.0\n    4     5.0\n    3    10.0\n    0     NaN\n    dtype: float64\n\n    Sort values descending order\n\n    >>> s.sort_values(ascending=False)\n    3    10.0\n    4     5.0\n    2     3.0\n    1     1.0\n    0     NaN\n    dtype: float64\n\n    Sort values inplace\n\n    >>> s.sort_values(ascending=False, inplace=True)\n    >>> s\n    3    10.0\n    4     5.0\n    2     3.0\n    1     1.0\n    0     NaN\n    dtype: float64\n\n    Sort values putting NAs first\n\n    >>> s.sort_values(na_position='first')\n    0     NaN\n    1     1.0\n    2     3.0\n    4     5.0\n    3    10.0\n    dtype: float64\n\n    Sort a series of strings\n\n    >>> s = pd.Series(['z', 'b', 'd', 'a', 'c'])\n    >>> s\n    0    z\n    1    b\n    2    d\n    3    a\n    4    c\n    dtype: object\n\n    >>> s.sort_values()\n    3    a\n    1    b\n    4    c\n    2    d\n    0    z\n    dtype: object\n\n    Sort using a key function. Your `key` function will be\n    given the ``Series`` of values and should return an array-like.\n\n    >>> s = pd.Series(['a', 'B', 'c', 'D', 'e'])\n    >>> s.sort_values()\n    1    B\n    3    D\n    0    a\n    2    c\n    4    e\n    dtype: object\n    >>> s.sort_values(key=lambda x: x.str.lower())\n    0    a\n    1    B\n    2    c\n    3    D\n    4    e\n    dtype: object\n\n    NumPy ufuncs work well here. For example, we can\n    sort by the ``sin`` of the value\n\n    >>> s = pd.Series([-4, -2, 0, 2, 4])\n    >>> s.sort_values(key=np.sin)\n    1   -2\n    4    4\n    2    0\n    0   -4\n    3    2\n    dtype: int64\n\n    More complicated user-defined functions can be used,\n    as long as they expect a Series and return an array-like\n\n    >>> s.sort_values(key=lambda x: (np.tan(x.cumsum())))\n    0   -4\n    3    2\n    4    4\n    1   -2\n    2    0\n    dtype: int64\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    # Validate the axis parameter\n    self._get_axis_number(axis)\n\n    # GH 5856/5853\n    if inplace and self._is_cached:\n        raise ValueError(\n            \"This Series is a view of some other array, to \"\n            \"sort in-place you must create a copy\"\n        )\n\n    def _try_kind_sort(arr):\n        arr = ensure_key_mapped(arr, key)\n        arr = getattr(arr, \"_values\", arr)\n\n        # easier to ask forgiveness than permission\n        try:\n            # if kind==mergesort, it can fail for object dtype\n            return arr.argsort(kind=kind)\n        except TypeError:\n            # stable sort not available for object dtype\n            # uses the argsort default quicksort\n            return arr.argsort(kind=\"quicksort\")\n\n    arr = self._values\n    sorted_index = np.empty(len(self), dtype=np.int32)\n\n    bad = isna(arr)\n\n    good = ~bad\n    idx = ibase.default_index(len(self))\n\n    argsorted = _try_kind_sort(self[good])\n\n    if is_list_like(ascending):\n        if len(ascending) != 1:\n            raise ValueError(\n                f\"Length of ascending ({len(ascending)}) must be 1 for Series\"\n            )\n        ascending = ascending[0]\n\n    if not is_bool(ascending):\n        raise ValueError(\"ascending must be boolean\")\n\n    if not ascending:\n        argsorted = argsorted[::-1]\n\n    if na_position == \"last\":\n        n = good.sum()\n        sorted_index[:n] = idx[good][argsorted]\n        sorted_index[n:] = idx[bad]\n    elif na_position == \"first\":\n        n = bad.sum()\n        sorted_index[n:] = idx[good][argsorted]\n        sorted_index[:n] = idx[bad]\n    else:\n        raise ValueError(f\"invalid na_position: {na_position}\")\n\n    result = self._constructor(arr[sorted_index], index=self.index[sorted_index])\n\n    if ignore_index:\n        result.index = ibase.default_index(len(sorted_index))\n\n    if inplace:\n        self._update_inplace(result)\n    else:\n        return result.__finalize__(self, method=\"sort_values\")",
                "def sort_index(\n    self,\n    axis=0,\n    level=None,\n    ascending: bool = True,\n    inplace: bool = False,\n    kind: str = \"quicksort\",\n    na_position: str = \"last\",\n    sort_remaining: bool = True,\n    ignore_index: bool = False,\n    key: IndexKeyFunc = None,\n):\n    \"\"\"\n    Sort Series by index labels.\n\n    Returns a new Series sorted by label if `inplace` argument is\n    ``False``, otherwise updates the original series and returns None.\n\n    Parameters\n    ----------\n    axis : int, default 0\n        Axis to direct sorting. This can only be 0 for Series.\n    level : int, optional\n        If not None, sort on values in specified index level(s).\n    ascending : bool or list of bools, default True\n        Sort ascending vs. descending. When the index is a MultiIndex the\n        sort direction can be controlled for each level individually.\n    inplace : bool, default False\n        If True, perform operation in-place.\n    kind : {'quicksort', 'mergesort', 'heapsort'}, default 'quicksort'\n        Choice of sorting algorithm. See also :func:`numpy.sort` for more\n        information.  'mergesort' is the only stable algorithm. For\n        DataFrames, this option is only applied when sorting on a single\n        column or label.\n    na_position : {'first', 'last'}, default 'last'\n        If 'first' puts NaNs at the beginning, 'last' puts NaNs at the end.\n        Not implemented for MultiIndex.\n    sort_remaining : bool, default True\n        If True and sorting by level and index is multilevel, sort by other\n        levels too (in order) after sorting by specified level.\n    ignore_index : bool, default False\n        If True, the resulting axis will be labeled 0, 1, \u2026, n - 1.\n\n        .. versionadded:: 1.0.0\n\n    key : callable, optional\n        If not None, apply the key function to the index values\n        before sorting. This is similar to the `key` argument in the\n        builtin :meth:`sorted` function, with the notable difference that\n        this `key` function should be *vectorized*. It should expect an\n        ``Index`` and return an ``Index`` of the same shape.\n\n        .. versionadded:: 1.1.0\n\n    Returns\n    -------\n    Series\n        The original Series sorted by the labels.\n\n    See Also\n    --------\n    DataFrame.sort_index: Sort DataFrame by the index.\n    DataFrame.sort_values: Sort DataFrame by the value.\n    Series.sort_values : Sort Series by the value.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'b', 'c', 'd'], index=[3, 2, 1, 4])\n    >>> s.sort_index()\n    1    c\n    2    b\n    3    a\n    4    d\n    dtype: object\n\n    Sort Descending\n\n    >>> s.sort_index(ascending=False)\n    4    d\n    3    a\n    2    b\n    1    c\n    dtype: object\n\n    Sort Inplace\n\n    >>> s.sort_index(inplace=True)\n    >>> s\n    1    c\n    2    b\n    3    a\n    4    d\n    dtype: object\n\n    By default NaNs are put at the end, but use `na_position` to place\n    them at the beginning\n\n    >>> s = pd.Series(['a', 'b', 'c', 'd'], index=[3, 2, 1, np.nan])\n    >>> s.sort_index(na_position='first')\n    NaN     d\n     1.0    c\n     2.0    b\n     3.0    a\n    dtype: object\n\n    Specify index level to sort\n\n    >>> arrays = [np.array(['qux', 'qux', 'foo', 'foo',\n    ...                     'baz', 'baz', 'bar', 'bar']),\n    ...           np.array(['two', 'one', 'two', 'one',\n    ...                     'two', 'one', 'two', 'one'])]\n    >>> s = pd.Series([1, 2, 3, 4, 5, 6, 7, 8], index=arrays)\n    >>> s.sort_index(level=1)\n    bar  one    8\n    baz  one    6\n    foo  one    4\n    qux  one    2\n    bar  two    7\n    baz  two    5\n    foo  two    3\n    qux  two    1\n    dtype: int64\n\n    Does not sort by remaining levels when sorting by levels\n\n    >>> s.sort_index(level=1, sort_remaining=False)\n    qux  one    2\n    foo  one    4\n    baz  one    6\n    bar  one    8\n    qux  two    1\n    foo  two    3\n    baz  two    5\n    bar  two    7\n    dtype: int64\n\n    Apply a key function before sorting\n\n    >>> s = pd.Series([1, 2, 3, 4], index=['A', 'b', 'C', 'd'])\n    >>> s.sort_index(key=lambda x : x.str.lower())\n    A    1\n    b    2\n    C    3\n    d    4\n    dtype: int64\n    \"\"\"\n\n    # TODO: this can be combined with DataFrame.sort_index impl as\n    # almost identical\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    # Validate the axis parameter\n    self._get_axis_number(axis)\n    index = ensure_key_mapped(self.index, key, levels=level)\n\n    if level is not None:\n        new_index, indexer = index.sortlevel(\n            level, ascending=ascending, sort_remaining=sort_remaining\n        )\n\n    elif isinstance(index, MultiIndex):\n        from pandas.core.sorting import lexsort_indexer\n\n        labels = index._sort_levels_monotonic()\n\n        indexer = lexsort_indexer(\n            labels._get_codes_for_sorting(),\n            orders=ascending,\n            na_position=na_position,\n        )\n    else:\n        from pandas.core.sorting import nargsort\n\n        # Check monotonic-ness before sort an index\n        # GH11080\n        if (ascending and index.is_monotonic_increasing) or (\n            not ascending and index.is_monotonic_decreasing\n        ):\n            if inplace:\n                return\n            else:\n                return self.copy()\n\n        indexer = nargsort(\n            index, kind=kind, ascending=ascending, na_position=na_position\n        )\n\n    indexer = ensure_platform_int(indexer)\n    new_index = self.index.take(indexer)\n    new_index = new_index._sort_levels_monotonic()\n\n    new_values = self._values.take(indexer)\n    result = self._constructor(new_values, index=new_index)\n\n    if ignore_index:\n        result.index = ibase.default_index(len(result))\n\n    if inplace:\n        self._update_inplace(result)\n    else:\n        return result.__finalize__(self, method=\"sort_index\")",
                "def argsort(self, axis=0, kind=\"quicksort\", order=None) -> \"Series\":\n    \"\"\"\n    Override ndarray.argsort. Argsorts the value, omitting NA/null values,\n    and places the result in the same locations as the non-NA values.\n\n    Parameters\n    ----------\n    axis : {0 or \"index\"}\n        Has no effect but is accepted for compatibility with numpy.\n    kind : {'mergesort', 'quicksort', 'heapsort'}, default 'quicksort'\n        Choice of sorting algorithm. See np.sort for more\n        information. 'mergesort' is the only stable algorithm.\n    order : None\n        Has no effect but is accepted for compatibility with numpy.\n\n    Returns\n    -------\n    Series\n        Positions of values within the sort order with -1 indicating\n        nan values.\n\n    See Also\n    --------\n    numpy.ndarray.argsort : Returns the indices that would sort this array.\n    \"\"\"\n    values = self._values\n    mask = isna(values)\n\n    if mask.any():\n        result = Series(-1, index=self.index, name=self.name, dtype=\"int64\")\n        notmask = ~mask\n        result[notmask] = np.argsort(values[notmask], kind=kind)\n        return self._constructor(result, index=self.index).__finalize__(\n            self, method=\"argsort\"\n        )\n    else:\n        return self._constructor(\n            np.argsort(values, kind=kind), index=self.index, dtype=\"int64\"\n        ).__finalize__(self, method=\"argsort\")",
                "def nlargest(self, n=5, keep=\"first\") -> \"Series\":\n    \"\"\"\n    Return the largest `n` elements.\n\n    Parameters\n    ----------\n    n : int, default 5\n        Return this many descending sorted values.\n    keep : {'first', 'last', 'all'}, default 'first'\n        When there are duplicate values that cannot all fit in a\n        Series of `n` elements:\n\n        - ``first`` : return the first `n` occurrences in order\n            of appearance.\n        - ``last`` : return the last `n` occurrences in reverse\n            order of appearance.\n        - ``all`` : keep all occurrences. This can result in a Series of\n            size larger than `n`.\n\n    Returns\n    -------\n    Series\n        The `n` largest values in the Series, sorted in decreasing order.\n\n    See Also\n    --------\n    Series.nsmallest: Get the `n` smallest elements.\n    Series.sort_values: Sort Series by values.\n    Series.head: Return the first `n` rows.\n\n    Notes\n    -----\n    Faster than ``.sort_values(ascending=False).head(n)`` for small `n`\n    relative to the size of the ``Series`` object.\n\n    Examples\n    --------\n    >>> countries_population = {\"Italy\": 59000000, \"France\": 65000000,\n    ...                         \"Malta\": 434000, \"Maldives\": 434000,\n    ...                         \"Brunei\": 434000, \"Iceland\": 337000,\n    ...                         \"Nauru\": 11300, \"Tuvalu\": 11300,\n    ...                         \"Anguilla\": 11300, \"Montserrat\": 5200}\n    >>> s = pd.Series(countries_population)\n    >>> s\n    Italy       59000000\n    France      65000000\n    Malta         434000\n    Maldives      434000\n    Brunei        434000\n    Iceland       337000\n    Nauru          11300\n    Tuvalu         11300\n    Anguilla       11300\n    Montserrat      5200\n    dtype: int64\n\n    The `n` largest elements where ``n=5`` by default.\n\n    >>> s.nlargest()\n    France      65000000\n    Italy       59000000\n    Malta         434000\n    Maldives      434000\n    Brunei        434000\n    dtype: int64\n\n    The `n` largest elements where ``n=3``. Default `keep` value is 'first'\n    so Malta will be kept.\n\n    >>> s.nlargest(3)\n    France    65000000\n    Italy     59000000\n    Malta       434000\n    dtype: int64\n\n    The `n` largest elements where ``n=3`` and keeping the last duplicates.\n    Brunei will be kept since it is the last with value 434000 based on\n    the index order.\n\n    >>> s.nlargest(3, keep='last')\n    France      65000000\n    Italy       59000000\n    Brunei        434000\n    dtype: int64\n\n    The `n` largest elements where ``n=3`` with all duplicates kept. Note\n    that the returned Series has five elements due to the three duplicates.\n\n    >>> s.nlargest(3, keep='all')\n    France      65000000\n    Italy       59000000\n    Malta         434000\n    Maldives      434000\n    Brunei        434000\n    dtype: int64\n    \"\"\"\n    return algorithms.SelectNSeries(self, n=n, keep=keep).nlargest()",
                "def nsmallest(self, n=5, keep=\"first\") -> \"Series\":\n    \"\"\"\n    Return the smallest `n` elements.\n\n    Parameters\n    ----------\n    n : int, default 5\n        Return this many ascending sorted values.\n    keep : {'first', 'last', 'all'}, default 'first'\n        When there are duplicate values that cannot all fit in a\n        Series of `n` elements:\n\n        - ``first`` : return the first `n` occurrences in order\n            of appearance.\n        - ``last`` : return the last `n` occurrences in reverse\n            order of appearance.\n        - ``all`` : keep all occurrences. This can result in a Series of\n            size larger than `n`.\n\n    Returns\n    -------\n    Series\n        The `n` smallest values in the Series, sorted in increasing order.\n\n    See Also\n    --------\n    Series.nlargest: Get the `n` largest elements.\n    Series.sort_values: Sort Series by values.\n    Series.head: Return the first `n` rows.\n\n    Notes\n    -----\n    Faster than ``.sort_values().head(n)`` for small `n` relative to\n    the size of the ``Series`` object.\n\n    Examples\n    --------\n    >>> countries_population = {\"Italy\": 59000000, \"France\": 65000000,\n    ...                         \"Brunei\": 434000, \"Malta\": 434000,\n    ...                         \"Maldives\": 434000, \"Iceland\": 337000,\n    ...                         \"Nauru\": 11300, \"Tuvalu\": 11300,\n    ...                         \"Anguilla\": 11300, \"Montserrat\": 5200}\n    >>> s = pd.Series(countries_population)\n    >>> s\n    Italy       59000000\n    France      65000000\n    Brunei        434000\n    Malta         434000\n    Maldives      434000\n    Iceland       337000\n    Nauru          11300\n    Tuvalu         11300\n    Anguilla       11300\n    Montserrat      5200\n    dtype: int64\n\n    The `n` smallest elements where ``n=5`` by default.\n\n    >>> s.nsmallest()\n    Montserrat    5200\n    Nauru        11300\n    Tuvalu       11300\n    Anguilla     11300\n    Iceland     337000\n    dtype: int64\n\n    The `n` smallest elements where ``n=3``. Default `keep` value is\n    'first' so Nauru and Tuvalu will be kept.\n\n    >>> s.nsmallest(3)\n    Montserrat   5200\n    Nauru       11300\n    Tuvalu      11300\n    dtype: int64\n\n    The `n` smallest elements where ``n=3`` and keeping the last\n    duplicates. Anguilla and Tuvalu will be kept since they are the last\n    with value 11300 based on the index order.\n\n    >>> s.nsmallest(3, keep='last')\n    Montserrat   5200\n    Anguilla    11300\n    Tuvalu      11300\n    dtype: int64\n\n    The `n` smallest elements where ``n=3`` with all duplicates kept. Note\n    that the returned Series has four elements due to the three duplicates.\n\n    >>> s.nsmallest(3, keep='all')\n    Montserrat   5200\n    Nauru       11300\n    Tuvalu      11300\n    Anguilla    11300\n    dtype: int64\n    \"\"\"\n    return algorithms.SelectNSeries(self, n=n, keep=keep).nsmallest()",
                "def swaplevel(self, i=-2, j=-1, copy=True) -> \"Series\":\n    \"\"\"\n    Swap levels i and j in a :class:`MultiIndex`.\n\n    Default is to swap the two innermost levels of the index.\n\n    Parameters\n    ----------\n    i, j : int, str\n        Level of the indices to be swapped. Can pass level name as string.\n    copy : bool, default True\n        Whether to copy underlying data.\n\n    Returns\n    -------\n    Series\n        Series with levels swapped in MultiIndex.\n    \"\"\"\n    assert isinstance(self.index, MultiIndex)\n    new_index = self.index.swaplevel(i, j)\n    return self._constructor(self._values, index=new_index, copy=copy).__finalize__(\n        self, method=\"swaplevel\"\n    )",
                "def reorder_levels(self, order) -> \"Series\":\n    \"\"\"\n    Rearrange index levels using input order.\n\n    May not drop or duplicate levels.\n\n    Parameters\n    ----------\n    order : list of int representing new level order\n        Reference level by number or key.\n\n    Returns\n    -------\n    type of caller (new object)\n    \"\"\"\n    if not isinstance(self.index, MultiIndex):  # pragma: no cover\n        raise Exception(\"Can only reorder levels on a hierarchical axis.\")\n\n    result = self.copy()\n    assert isinstance(result.index, MultiIndex)\n    result.index = result.index.reorder_levels(order)\n    return result",
                "def explode(self) -> \"Series\":\n    \"\"\"\n    Transform each element of a list-like to a row, replicating the\n    index values.\n\n    .. versionadded:: 0.25.0\n\n    Returns\n    -------\n    Series\n        Exploded lists to rows; index will be duplicated for these rows.\n\n    See Also\n    --------\n    Series.str.split : Split string values on specified separator.\n    Series.unstack : Unstack, a.k.a. pivot, Series with MultiIndex\n        to produce DataFrame.\n    DataFrame.melt : Unpivot a DataFrame from wide format to long format.\n    DataFrame.explode : Explode a DataFrame from list-like\n        columns to long format.\n\n    Notes\n    -----\n    This routine will explode list-likes including lists, tuples,\n    Series, and np.ndarray. The result dtype of the subset rows will\n    be object. Scalars will be returned unchanged. Empty list-likes will\n    result in a np.nan for that row.\n\n    Examples\n    --------\n    >>> s = pd.Series([[1, 2, 3], 'foo', [], [3, 4]])\n    >>> s\n    0    [1, 2, 3]\n    1          foo\n    2           []\n    3       [3, 4]\n    dtype: object\n\n    >>> s.explode()\n    0      1\n    0      2\n    0      3\n    1    foo\n    2    NaN\n    3      3\n    3      4\n    dtype: object\n    \"\"\"\n    if not len(self) or not is_object_dtype(self):\n        return self.copy()\n\n    values, counts = reshape.explode(np.asarray(self.array))\n\n    result = self._constructor(\n        values, index=self.index.repeat(counts), name=self.name\n    )\n    return result",
                "def unstack(self, level=-1, fill_value=None):\n    \"\"\"\n    Unstack, also known as pivot, Series with MultiIndex to produce DataFrame.\n    The level involved will automatically get sorted.\n\n    Parameters\n    ----------\n    level : int, str, or list of these, default last level\n        Level(s) to unstack, can pass level name.\n    fill_value : scalar value, default None\n        Value to use when replacing NaN values.\n\n    Returns\n    -------\n    DataFrame\n        Unstacked Series.\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3, 4],\n    ...               index=pd.MultiIndex.from_product([['one', 'two'],\n    ...                                                 ['a', 'b']]))\n    >>> s\n    one  a    1\n         b    2\n    two  a    3\n         b    4\n    dtype: int64\n\n    >>> s.unstack(level=-1)\n         a  b\n    one  1  2\n    two  3  4\n\n    >>> s.unstack(level=0)\n       one  two\n    a    1    3\n    b    2    4\n    \"\"\"\n    from pandas.core.reshape.reshape import unstack\n\n    return unstack(self, level, fill_value)",
                "def map(self, arg, na_action=None) -> \"Series\":\n    \"\"\"\n    Map values of Series according to input correspondence.\n\n    Used for substituting each value in a Series with another value,\n    that may be derived from a function, a ``dict`` or\n    a :class:`Series`.\n\n    Parameters\n    ----------\n    arg : function, collections.abc.Mapping subclass or Series\n        Mapping correspondence.\n    na_action : {None, 'ignore'}, default None\n        If 'ignore', propagate NaN values, without passing them to the\n        mapping correspondence.\n\n    Returns\n    -------\n    Series\n        Same index as caller.\n\n    See Also\n    --------\n    Series.apply : For applying more complex functions on a Series.\n    DataFrame.apply : Apply a function row-/column-wise.\n    DataFrame.applymap : Apply a function elementwise on a whole DataFrame.\n\n    Notes\n    -----\n    When ``arg`` is a dictionary, values in Series that are not in the\n    dictionary (as keys) are converted to ``NaN``. However, if the\n    dictionary is a ``dict`` subclass that defines ``__missing__`` (i.e.\n    provides a method for default values), then this default is used\n    rather than ``NaN``.\n\n    Examples\n    --------\n    >>> s = pd.Series(['cat', 'dog', np.nan, 'rabbit'])\n    >>> s\n    0      cat\n    1      dog\n    2      NaN\n    3   rabbit\n    dtype: object\n\n    ``map`` accepts a ``dict`` or a ``Series``. Values that are not found\n    in the ``dict`` are converted to ``NaN``, unless the dict has a default\n    value (e.g. ``defaultdict``):\n\n    >>> s.map({'cat': 'kitten', 'dog': 'puppy'})\n    0   kitten\n    1    puppy\n    2      NaN\n    3      NaN\n    dtype: object\n\n    It also accepts a function:\n\n    >>> s.map('I am a {}'.format)\n    0       I am a cat\n    1       I am a dog\n    2       I am a nan\n    3    I am a rabbit\n    dtype: object\n\n    To avoid applying the function to missing values (and keep them as\n    ``NaN``) ``na_action='ignore'`` can be used:\n\n    >>> s.map('I am a {}'.format, na_action='ignore')\n    0     I am a cat\n    1     I am a dog\n    2            NaN\n    3  I am a rabbit\n    dtype: object\n    \"\"\"\n    new_values = super()._map_values(arg, na_action=na_action)\n    return self._constructor(new_values, index=self.index).__finalize__(\n        self, method=\"map\"\n    )",
                "def _gotitem(self, key, ndim, subset=None) -> \"Series\":\n    \"\"\"\n    Sub-classes to define. Return a sliced object.\n\n    Parameters\n    ----------\n    key : string / list of selections\n    ndim : 1,2\n        Requested ndim of result.\n    subset : object, default None\n        Subset to act on.\n    \"\"\"\n    return self",
                "@Substitution(\n    see_also=_agg_see_also_doc,\n    examples=_agg_examples_doc,\n    versionadded=\"\\n.. versionadded:: 0.20.0\\n\",\n    **_shared_doc_kwargs,\n)\n@Appender(generic._shared_docs[\"aggregate\"])\ndef aggregate(self, func, axis=0, *args, **kwargs):\n    # Validate the axis parameter\n    self._get_axis_number(axis)\n    result, how = self._aggregate(func, *args, **kwargs)\n    if result is None:\n\n        # we can be called from an inner function which\n        # passes this meta-data\n        kwargs.pop(\"_axis\", None)\n        kwargs.pop(\"_level\", None)\n\n        # try a regular apply, this evaluates lambdas\n        # row-by-row; however if the lambda is expected a Series\n        # expression, e.g.: lambda x: x-x.quantile(0.25)\n        # this will fail, so we can try a vectorized evaluation\n\n        # we cannot FIRST try the vectorized evaluation, because\n        # then .agg and .apply would have different semantics if the\n        # operation is actually defined on the Series, e.g. str\n        try:\n            result = self.apply(func, *args, **kwargs)\n        except (ValueError, AttributeError, TypeError):\n            result = func(self, *args, **kwargs)\n\n    return result",
                "@Appender(generic._shared_docs[\"transform\"] % _shared_doc_kwargs)\ndef transform(self, func, axis=0, *args, **kwargs):\n    # Validate the axis parameter\n    self._get_axis_number(axis)\n    return super().transform(func, *args, **kwargs)",
                "def apply(self, func, convert_dtype=True, args=(), **kwds):\n    \"\"\"\n    Invoke function on values of Series.\n\n    Can be ufunc (a NumPy function that applies to the entire Series)\n    or a Python function that only works on single values.\n\n    Parameters\n    ----------\n    func : function\n        Python function or NumPy ufunc to apply.\n    convert_dtype : bool, default True\n        Try to find better dtype for elementwise function results. If\n        False, leave as dtype=object.\n    args : tuple\n        Positional arguments passed to func after the series value.\n    **kwds\n        Additional keyword arguments passed to func.\n\n    Returns\n    -------\n    Series or DataFrame\n        If func returns a Series object the result will be a DataFrame.\n\n    See Also\n    --------\n    Series.map: For element-wise operations.\n    Series.agg: Only perform aggregating type operations.\n    Series.transform: Only perform transforming type operations.\n\n    Examples\n    --------\n    Create a series with typical summer temperatures for each city.\n\n    >>> s = pd.Series([20, 21, 12],\n    ...               index=['London', 'New York', 'Helsinki'])\n    >>> s\n    London      20\n    New York    21\n    Helsinki    12\n    dtype: int64\n\n    Square the values by defining a function and passing it as an\n    argument to ``apply()``.\n\n    >>> def square(x):\n    ...     return x ** 2\n    >>> s.apply(square)\n    London      400\n    New York    441\n    Helsinki    144\n    dtype: int64\n\n    Square the values by passing an anonymous function as an\n    argument to ``apply()``.\n\n    >>> s.apply(lambda x: x ** 2)\n    London      400\n    New York    441\n    Helsinki    144\n    dtype: int64\n\n    Define a custom function that needs additional positional\n    arguments and pass these additional arguments using the\n    ``args`` keyword.\n\n    >>> def subtract_custom_value(x, custom_value):\n    ...     return x - custom_value\n\n    >>> s.apply(subtract_custom_value, args=(5,))\n    London      15\n    New York    16\n    Helsinki     7\n    dtype: int64\n\n    Define a custom function that takes keyword arguments\n    and pass these arguments to ``apply``.\n\n    >>> def add_custom_values(x, **kwargs):\n    ...     for month in kwargs:\n    ...         x += kwargs[month]\n    ...     return x\n\n    >>> s.apply(add_custom_values, june=30, july=20, august=25)\n    London      95\n    New York    96\n    Helsinki    87\n    dtype: int64\n\n    Use a function from the Numpy library.\n\n    >>> s.apply(np.log)\n    London      2.995732\n    New York    3.044522\n    Helsinki    2.484907\n    dtype: float64\n    \"\"\"\n    if len(self) == 0:\n        return self._constructor(dtype=self.dtype, index=self.index).__finalize__(\n            self, method=\"apply\"\n        )\n\n    # dispatch to agg\n    if isinstance(func, (list, dict)):\n        return self.aggregate(func, *args, **kwds)\n\n    # if we are a string, try to dispatch\n    if isinstance(func, str):\n        return self._try_aggregate_string_function(func, *args, **kwds)\n\n    # handle ufuncs and lambdas\n    if kwds or args and not isinstance(func, np.ufunc):\n\n        def f(x):\n            return func(x, *args, **kwds)\n\n    else:\n        f = func\n\n    with np.errstate(all=\"ignore\"):\n        if isinstance(f, np.ufunc):\n            return f(self)\n\n        # row-wise access\n        if is_extension_array_dtype(self.dtype) and hasattr(self._values, \"map\"):\n            # GH#23179 some EAs do not have `map`\n            mapped = self._values.map(f)\n        else:\n            values = self.astype(object)._values\n            mapped = lib.map_infer(values, f, convert=convert_dtype)\n\n    if len(mapped) and isinstance(mapped[0], Series):\n        # GH 25959 use pd.array instead of tolist\n        # so extension arrays can be used\n        return self._constructor_expanddim(pd.array(mapped), index=self.index)\n    else:\n        return self._constructor(mapped, index=self.index).__finalize__(\n            self, method=\"apply\"\n        )",
                "def _reduce(\n    self, op, name, axis=0, skipna=True, numeric_only=None, filter_type=None, **kwds\n):\n    \"\"\"\n    Perform a reduction operation.\n\n    If we have an ndarray as a value, then simply perform the operation,\n    otherwise delegate to the object.\n    \"\"\"\n    delegate = self._values\n\n    if axis is not None:\n        self._get_axis_number(axis)\n\n    if isinstance(delegate, ExtensionArray):\n        # dispatch to ExtensionArray interface\n        return delegate._reduce(name, skipna=skipna, **kwds)\n\n    else:\n        # dispatch to numpy arrays\n        if numeric_only:\n            raise NotImplementedError(\n                f\"Series.{name} does not implement numeric_only.\"\n            )\n        with np.errstate(all=\"ignore\"):\n            return op(delegate, skipna=skipna, **kwds)",
                "def _reindex_indexer(self, new_index, indexer, copy):\n    if indexer is None:\n        if copy:\n            return self.copy()\n        return self\n\n    new_values = algorithms.take_1d(\n        self._values, indexer, allow_fill=True, fill_value=None\n    )\n    return self._constructor(new_values, index=new_index)",
                "def _needs_reindex_multi(self, axes, method, level):\n    \"\"\"\n    Check if we do need a multi reindex; this is for compat with\n    higher dims.\n    \"\"\"\n    return False",
                "@doc(NDFrame.align, **_shared_doc_kwargs)\ndef align(\n    self,\n    other,\n    join=\"outer\",\n    axis=None,\n    level=None,\n    copy=True,\n    fill_value=None,\n    method=None,\n    limit=None,\n    fill_axis=0,\n    broadcast_axis=None,\n):\n    return super().align(\n        other,\n        join=join,\n        axis=axis,\n        level=level,\n        copy=copy,\n        fill_value=fill_value,\n        method=method,\n        limit=limit,\n        fill_axis=fill_axis,\n        broadcast_axis=broadcast_axis,\n    )",
                "def rename(\n    self,\n    index=None,\n    *,\n    axis=None,\n    copy=True,\n    inplace=False,\n    level=None,\n    errors=\"ignore\",\n):\n    \"\"\"\n    Alter Series index labels or name.\n\n    Function / dict values must be unique (1-to-1). Labels not contained in\n    a dict / Series will be left as-is. Extra labels listed don't throw an\n    error.\n\n    Alternatively, change ``Series.name`` with a scalar value.\n\n    See the :ref:`user guide <basics.rename>` for more.\n\n    Parameters\n    ----------\n    axis : {0 or \"index\"}\n        Unused. Accepted for compatibility with DataFrame method only.\n    index : scalar, hashable sequence, dict-like or function, optional\n        Functions or dict-like are transformations to apply to\n        the index.\n        Scalar or hashable sequence-like will alter the ``Series.name``\n        attribute.\n\n    **kwargs\n        Additional keyword arguments passed to the function. Only the\n        \"inplace\" keyword is used.\n\n    Returns\n    -------\n    Series\n        Series with index labels or name altered.\n\n    See Also\n    --------\n    DataFrame.rename : Corresponding DataFrame method.\n    Series.rename_axis : Set the name of the axis.\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3])\n    >>> s\n    0    1\n    1    2\n    2    3\n    dtype: int64\n    >>> s.rename(\"my_name\")  # scalar, changes Series.name\n    0    1\n    1    2\n    2    3\n    Name: my_name, dtype: int64\n    >>> s.rename(lambda x: x ** 2)  # function, changes labels\n    0    1\n    1    2\n    4    3\n    dtype: int64\n    >>> s.rename({1: 3, 2: 5})  # mapping, changes labels\n    0    1\n    3    2\n    5    3\n    dtype: int64\n    \"\"\"\n    if callable(index) or is_dict_like(index):\n        return super().rename(\n            index, copy=copy, inplace=inplace, level=level, errors=errors\n        )\n    else:\n        return self._set_name(index, inplace=inplace)",
                "@Appender(\n    \"\"\"\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3])\n    >>> s\n    0    1\n    1    2\n    2    3\n    dtype: int64\n\n    >>> s.set_axis(['a', 'b', 'c'], axis=0)\n    a    1\n    b    2\n    c    3\n    dtype: int64\n\"\"\"\n)\n@Substitution(\n    **_shared_doc_kwargs,\n    extended_summary_sub=\"\",\n    axis_description_sub=\"\",\n    see_also_sub=\"\",\n)\n@Appender(generic.NDFrame.set_axis.__doc__)\ndef set_axis(self, labels, axis: Axis = 0, inplace: bool = False):\n    return super().set_axis(labels, axis=axis, inplace=inplace)",
                "@Substitution(**_shared_doc_kwargs)\n@Appender(generic.NDFrame.reindex.__doc__)\ndef reindex(self, index=None, **kwargs):\n    return super().reindex(index=index, **kwargs)",
                "def drop(\n    self,\n    labels=None,\n    axis=0,\n    index=None,\n    columns=None,\n    level=None,\n    inplace=False,\n    errors=\"raise\",\n) -> \"Series\":\n    \"\"\"\n    Return Series with specified index labels removed.\n\n    Remove elements of a Series based on specifying the index labels.\n    When using a multi-index, labels on different levels can be removed\n    by specifying the level.\n\n    Parameters\n    ----------\n    labels : single label or list-like\n        Index labels to drop.\n    axis : 0, default 0\n        Redundant for application on Series.\n    index : single label or list-like\n        Redundant for application on Series, but 'index' can be used instead\n        of 'labels'.\n    columns : single label or list-like\n        No change is made to the Series; use 'index' or 'labels' instead.\n    level : int or level name, optional\n        For MultiIndex, level for which the labels will be removed.\n    inplace : bool, default False\n        If True, do operation inplace and return None.\n    errors : {'ignore', 'raise'}, default 'raise'\n        If 'ignore', suppress error and only existing labels are dropped.\n\n    Returns\n    -------\n    Series\n        Series with specified index labels removed.\n\n    Raises\n    ------\n    KeyError\n        If none of the labels are found in the index.\n\n    See Also\n    --------\n    Series.reindex : Return only specified index labels of Series.\n    Series.dropna : Return series without null values.\n    Series.drop_duplicates : Return Series with duplicate values removed.\n    DataFrame.drop : Drop specified labels from rows or columns.\n\n    Examples\n    --------\n    >>> s = pd.Series(data=np.arange(3), index=['A', 'B', 'C'])\n    >>> s\n    A  0\n    B  1\n    C  2\n    dtype: int64\n\n    Drop labels B en C\n\n    >>> s.drop(labels=['B', 'C'])\n    A  0\n    dtype: int64\n\n    Drop 2nd level label in MultiIndex Series\n\n    >>> midx = pd.MultiIndex(levels=[['lama', 'cow', 'falcon'],\n    ...                              ['speed', 'weight', 'length']],\n    ...                      codes=[[0, 0, 0, 1, 1, 1, 2, 2, 2],\n    ...                             [0, 1, 2, 0, 1, 2, 0, 1, 2]])\n    >>> s = pd.Series([45, 200, 1.2, 30, 250, 1.5, 320, 1, 0.3],\n    ...               index=midx)\n    >>> s\n    lama    speed      45.0\n            weight    200.0\n            length      1.2\n    cow     speed      30.0\n            weight    250.0\n            length      1.5\n    falcon  speed     320.0\n            weight      1.0\n            length      0.3\n    dtype: float64\n\n    >>> s.drop(labels='weight', level=1)\n    lama    speed      45.0\n            length      1.2\n    cow     speed      30.0\n            length      1.5\n    falcon  speed     320.0\n            length      0.3\n    dtype: float64\n    \"\"\"\n    return super().drop(\n        labels=labels,\n        axis=axis,\n        index=index,\n        columns=columns,\n        level=level,\n        inplace=inplace,\n        errors=errors,\n    )",
                "@doc(NDFrame.fillna, **_shared_doc_kwargs)\ndef fillna(\n    self,\n    value=None,\n    method=None,\n    axis=None,\n    inplace=False,\n    limit=None,\n    downcast=None,\n) -> Optional[\"Series\"]:\n    return super().fillna(\n        value=value,\n        method=method,\n        axis=axis,\n        inplace=inplace,\n        limit=limit,\n        downcast=downcast,\n    )",
                "@doc(NDFrame.replace, **_shared_doc_kwargs)\ndef replace(\n    self,\n    to_replace=None,\n    value=None,\n    inplace=False,\n    limit=None,\n    regex=False,\n    method=\"pad\",\n):\n    return super().replace(\n        to_replace=to_replace,\n        value=value,\n        inplace=inplace,\n        limit=limit,\n        regex=regex,\n        method=method,\n    )",
                "@doc(NDFrame.shift, **_shared_doc_kwargs)\ndef shift(self, periods=1, freq=None, axis=0, fill_value=None) -> \"Series\":\n    return super().shift(\n        periods=periods, freq=freq, axis=axis, fill_value=fill_value\n    )",
                "def memory_usage(self, index=True, deep=False):\n    \"\"\"\n    Return the memory usage of the Series.\n\n    The memory usage can optionally include the contribution of\n    the index and of elements of `object` dtype.\n\n    Parameters\n    ----------\n    index : bool, default True\n        Specifies whether to include the memory usage of the Series index.\n    deep : bool, default False\n        If True, introspect the data deeply by interrogating\n        `object` dtypes for system-level memory consumption, and include\n        it in the returned value.\n\n    Returns\n    -------\n    int\n        Bytes of memory consumed.\n\n    See Also\n    --------\n    numpy.ndarray.nbytes : Total bytes consumed by the elements of the\n        array.\n    DataFrame.memory_usage : Bytes consumed by a DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series(range(3))\n    >>> s.memory_usage()\n    152\n\n    Not including the index gives the size of the rest of the data, which\n    is necessarily smaller:\n\n    >>> s.memory_usage(index=False)\n    24\n\n    The memory footprint of `object` values is ignored by default:\n\n    >>> s = pd.Series([\"a\", \"b\"])\n    >>> s.values\n    array(['a', 'b'], dtype=object)\n    >>> s.memory_usage()\n    144\n    >>> s.memory_usage(deep=True)\n    260\n    \"\"\"\n    v = super().memory_usage(deep=deep)\n    if index:\n        v += self.index.memory_usage(deep=deep)\n    return v",
                "def isin(self, values) -> \"Series\":\n    \"\"\"\n    Check whether `values` are contained in Series.\n\n    Return a boolean Series showing whether each element in the Series\n    matches an element in the passed sequence of `values` exactly.\n\n    Parameters\n    ----------\n    values : set or list-like\n        The sequence of values to test. Passing in a single string will\n        raise a ``TypeError``. Instead, turn a single string into a\n        list of one element.\n\n    Returns\n    -------\n    Series\n        Series of booleans indicating if each element is in values.\n\n    Raises\n    ------\n    TypeError\n      * If `values` is a string\n\n    See Also\n    --------\n    DataFrame.isin : Equivalent method on DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series(['lama', 'cow', 'lama', 'beetle', 'lama',\n    ...                'hippo'], name='animal')\n    >>> s.isin(['cow', 'lama'])\n    0     True\n    1     True\n    2     True\n    3    False\n    4     True\n    5    False\n    Name: animal, dtype: bool\n\n    Passing a single string as ``s.isin('lama')`` will raise an error. Use\n    a list of one element instead:\n\n    >>> s.isin(['lama'])\n    0     True\n    1    False\n    2     True\n    3    False\n    4     True\n    5    False\n    Name: animal, dtype: bool\n    \"\"\"\n    result = algorithms.isin(self, values)\n    return self._constructor(result, index=self.index).__finalize__(\n        self, method=\"isin\"\n    )",
                "def between(self, left, right, inclusive=True) -> \"Series\":\n    \"\"\"\n    Return boolean Series equivalent to left <= series <= right.\n\n    This function returns a boolean vector containing `True` wherever the\n    corresponding Series element is between the boundary values `left` and\n    `right`. NA values are treated as `False`.\n\n    Parameters\n    ----------\n    left : scalar or list-like\n        Left boundary.\n    right : scalar or list-like\n        Right boundary.\n    inclusive : bool, default True\n        Include boundaries.\n\n    Returns\n    -------\n    Series\n        Series representing whether each element is between left and\n        right (inclusive).\n\n    See Also\n    --------\n    Series.gt : Greater than of series and other.\n    Series.lt : Less than of series and other.\n\n    Notes\n    -----\n    This function is equivalent to ``(left <= ser) & (ser <= right)``\n\n    Examples\n    --------\n    >>> s = pd.Series([2, 0, 4, 8, np.nan])\n\n    Boundary values are included by default:\n\n    >>> s.between(1, 4)\n    0     True\n    1    False\n    2     True\n    3    False\n    4    False\n    dtype: bool\n\n    With `inclusive` set to ``False`` boundary values are excluded:\n\n    >>> s.between(1, 4, inclusive=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    4    False\n    dtype: bool\n\n    `left` and `right` can be any scalar value:\n\n    >>> s = pd.Series(['Alice', 'Bob', 'Carol', 'Eve'])\n    >>> s.between('Anna', 'Daniel')\n    0    False\n    1     True\n    2     True\n    3    False\n    dtype: bool\n    \"\"\"\n    if inclusive:\n        lmask = self >= left\n        rmask = self <= right\n    else:\n        lmask = self > left\n        rmask = self < right\n\n    return lmask & rmask",
                "def _convert_dtypes(\n    self,\n    infer_objects: bool = True,\n    convert_string: bool = True,\n    convert_integer: bool = True,\n    convert_boolean: bool = True,\n) -> \"Series\":\n    input_series = self\n    if infer_objects:\n        input_series = input_series.infer_objects()\n        if is_object_dtype(input_series):\n            input_series = input_series.copy()\n\n    if convert_string or convert_integer or convert_boolean:\n        inferred_dtype = convert_dtypes(\n            input_series._values, convert_string, convert_integer, convert_boolean\n        )\n        try:\n            result = input_series.astype(inferred_dtype)\n        except TypeError:\n            result = input_series.copy()\n    else:\n        result = input_series.copy()\n    return result",
                "@Appender(generic._shared_docs[\"isna\"] % _shared_doc_kwargs)\ndef isna(self) -> \"Series\":\n    return super().isna()",
                "@Appender(generic._shared_docs[\"isna\"] % _shared_doc_kwargs)\ndef isnull(self) -> \"Series\":\n    return super().isnull()",
                "@Appender(generic._shared_docs[\"notna\"] % _shared_doc_kwargs)\ndef notna(self) -> \"Series\":\n    return super().notna()",
                "@Appender(generic._shared_docs[\"notna\"] % _shared_doc_kwargs)\ndef notnull(self) -> \"Series\":\n    return super().notnull()",
                "def dropna(self, axis=0, inplace=False, how=None):\n    \"\"\"\n    Return a new Series with missing values removed.\n\n    See the :ref:`User Guide <missing_data>` for more on which values are\n    considered missing, and how to work with missing data.\n\n    Parameters\n    ----------\n    axis : {0 or 'index'}, default 0\n        There is only one axis to drop values from.\n    inplace : bool, default False\n        If True, do operation inplace and return None.\n    how : str, optional\n        Not in use. Kept for compatibility.\n\n    Returns\n    -------\n    Series\n        Series with NA entries dropped from it.\n\n    See Also\n    --------\n    Series.isna: Indicate missing values.\n    Series.notna : Indicate existing (non-missing) values.\n    Series.fillna : Replace missing values.\n    DataFrame.dropna : Drop rows or columns which contain NA values.\n    Index.dropna : Drop missing indices.\n\n    Examples\n    --------\n    >>> ser = pd.Series([1., 2., np.nan])\n    >>> ser\n    0    1.0\n    1    2.0\n    2    NaN\n    dtype: float64\n\n    Drop NA values from a Series.\n\n    >>> ser.dropna()\n    0    1.0\n    1    2.0\n    dtype: float64\n\n    Keep the Series with valid entries in the same variable.\n\n    >>> ser.dropna(inplace=True)\n    >>> ser\n    0    1.0\n    1    2.0\n    dtype: float64\n\n    Empty strings are not considered NA values. ``None`` is considered an\n    NA value.\n\n    >>> ser = pd.Series([np.NaN, 2, pd.NaT, '', None, 'I stay'])\n    >>> ser\n    0       NaN\n    1         2\n    2       NaT\n    3\n    4      None\n    5    I stay\n    dtype: object\n    >>> ser.dropna()\n    1         2\n    3\n    5    I stay\n    dtype: object\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    # Validate the axis parameter\n    self._get_axis_number(axis or 0)\n\n    if self._can_hold_na:\n        result = remove_na_arraylike(self)\n        if inplace:\n            self._update_inplace(result)\n        else:\n            return result\n    else:\n        if inplace:\n            # do nothing\n            pass\n        else:\n            return self.copy()",
                "def to_timestamp(self, freq=None, how=\"start\", copy=True) -> \"Series\":\n    \"\"\"\n    Cast to DatetimeIndex of Timestamps, at *beginning* of period.\n\n    Parameters\n    ----------\n    freq : str, default frequency of PeriodIndex\n        Desired frequency.\n    how : {'s', 'e', 'start', 'end'}\n        Convention for converting period to timestamp; start of period\n        vs. end.\n    copy : bool, default True\n        Whether or not to return a copy.\n\n    Returns\n    -------\n    Series with DatetimeIndex\n    \"\"\"\n    new_values = self._values\n    if copy:\n        new_values = new_values.copy()\n\n    assert isinstance(self.index, PeriodIndex)\n    new_index = self.index.to_timestamp(freq=freq, how=how)  # type: ignore\n    return self._constructor(new_values, index=new_index).__finalize__(\n        self, method=\"to_timestamp\"\n    )",
                "def to_period(self, freq=None, copy=True) -> \"Series\":\n    \"\"\"\n    Convert Series from DatetimeIndex to PeriodIndex with desired\n    frequency (inferred from index if not passed).\n\n    Parameters\n    ----------\n    freq : str, default None\n        Frequency associated with the PeriodIndex.\n    copy : bool, default True\n        Whether or not to return a copy.\n\n    Returns\n    -------\n    Series\n        Series with index converted to PeriodIndex.\n    \"\"\"\n    new_values = self._values\n    if copy:\n        new_values = new_values.copy()\n\n    assert isinstance(self.index, DatetimeIndex)\n    new_index = self.index.to_period(freq=freq)  # type: ignore\n    return self._constructor(new_values, index=new_index).__finalize__(\n        self, method=\"to_period\"\n    )",
                "def construct_return(result):\n    if lib.is_scalar(result):\n        return result\n    elif result.ndim > 1:\n        # e.g. np.subtract.outer\n        if method == \"outer\":\n            # GH#27198\n            raise NotImplementedError\n        return result\n    return self._constructor(result, index=index, name=name, copy=False)",
                "def _try_kind_sort(arr):\n    arr = ensure_key_mapped(arr, key)\n    arr = getattr(arr, \"_values\", arr)\n\n    # easier to ask forgiveness than permission\n    try:\n        # if kind==mergesort, it can fail for object dtype\n        return arr.argsort(kind=kind)\n    except TypeError:\n        # stable sort not available for object dtype\n        # uses the argsort default quicksort\n        return arr.argsort(kind=\"quicksort\")",
                "def f(x):\n    return func(x, *args, **kwds)"
            ],
            "inscope_function_signatures": [
                "_coerce_method(converter)",
                "wrapper(self)",
                "__init__(self, data=None, index=None, dtype=None, name=None, copy=False, fastpath=False)",
                "_init_dict(self, data, index=None, dtype=None)",
                "_constructor(self) -> Type['Series']",
                "_constructor_expanddim(self) -> Type['DataFrame']",
                "_can_hold_na(self)",
                "_set_axis(self, axis: int, labels, fastpath: bool=False) -> None",
                "dtype(self) -> DtypeObj",
                "dtypes(self) -> DtypeObj",
                "name(self) -> Label",
                "name(self, value: Label) -> None",
                "values(self)",
                "_values(self)",
                "array(self) -> ExtensionArray",
                "ravel(self, order='C')",
                "__len__(self) -> int",
                "view(self, dtype=None) -> 'Series'",
                "__array_ufunc__(self, ufunc: Callable, method: str, *inputs: Any, **kwargs: Any)",
                "__array__(self, dtype=None) -> np.ndarray",
                "axes(self) -> List[Index]",
                "take(self, indices, axis=0, is_copy=None, **kwargs) -> 'Series'",
                "_take_with_is_copy(self, indices, axis=0)",
                "_ixs(self, i: int, axis: int=0)",
                "_slice(self, slobj: slice, axis: int=0) -> 'Series'",
                "__getitem__(self, key)",
                "_get_with(self, key)",
                "_get_values_tuple(self, key)",
                "_get_values(self, indexer)",
                "_get_value(self, label, takeable: bool=False)",
                "__setitem__(self, key, value)",
                "_set_with_engine(self, key, value)",
                "_set_with(self, key, value)",
                "_set_value(self, label, value, takeable: bool=False)",
                "_is_mixed_type(self)",
                "repeat(self, repeats, axis=None) -> 'Series'",
                "reset_index(self, level=None, drop=False, name=None, inplace=False)",
                "__repr__(self) -> str",
                "to_string(self, buf=None, na_rep='NaN', float_format=None, header=True, index=True, length=False, dtype=False, name=False, max_rows=None, min_rows=None)",
                "to_markdown(self, buf: Optional[IO[str]]=None, mode: Optional[str]=None, **kwargs) -> Optional[str]",
                "items(self) -> Iterable[Tuple[Label, Any]]",
                "iteritems(self) -> Iterable[Tuple[Label, Any]]",
                "keys(self) -> Index",
                "to_dict(self, into=dict)",
                "to_frame(self, name=None) -> 'DataFrame'",
                "_set_name(self, name, inplace=False) -> 'Series'",
                "groupby(self, by=None, axis=0, level=None, as_index: bool=True, sort: bool=True, group_keys: bool=True, squeeze: bool=False, observed: bool=False, dropna: bool=True) -> 'SeriesGroupBy'",
                "count(self, level=None)",
                "mode(self, dropna=True) -> 'Series'",
                "unique(self)",
                "drop_duplicates(self, keep='first', inplace=False) -> Optional['Series']",
                "duplicated(self, keep='first') -> 'Series'",
                "idxmin(self, axis=0, skipna=True, *args, **kwargs)",
                "idxmax(self, axis=0, skipna=True, *args, **kwargs)",
                "round(self, decimals=0, *args, **kwargs) -> 'Series'",
                "quantile(self, q=0.5, interpolation='linear')",
                "corr(self, other, method='pearson', min_periods=None) -> float",
                "cov(self, other, min_periods=None) -> float",
                "diff(self, periods: int=1) -> 'Series'",
                "autocorr(self, lag=1) -> float",
                "dot(self, other)",
                "__matmul__(self, other)",
                "__rmatmul__(self, other)",
                "searchsorted(self, value, side='left', sorter=None)",
                "append(self, to_append, ignore_index=False, verify_integrity=False)",
                "_binop(self, other, func, level=None, fill_value=None)",
                "_construct_result(self, result: Union[ArrayLike, Tuple[ArrayLike, ArrayLike]], name: Label) -> Union['Series', Tuple['Series', 'Series']]",
                "combine(self, other, func, fill_value=None) -> 'Series'",
                "combine_first(self, other) -> 'Series'",
                "update(self, other) -> None",
                "sort_values(self, axis=0, ascending=True, inplace: bool=False, kind: str='quicksort', na_position: str='last', ignore_index: bool=False, key: ValueKeyFunc=None)",
                "sort_index(self, axis=0, level=None, ascending: bool=True, inplace: bool=False, kind: str='quicksort', na_position: str='last', sort_remaining: bool=True, ignore_index: bool=False, key: IndexKeyFunc=None)",
                "argsort(self, axis=0, kind='quicksort', order=None) -> 'Series'",
                "nlargest(self, n=5, keep='first') -> 'Series'",
                "nsmallest(self, n=5, keep='first') -> 'Series'",
                "swaplevel(self, i=-2, j=-1, copy=True) -> 'Series'",
                "reorder_levels(self, order) -> 'Series'",
                "explode(self) -> 'Series'",
                "unstack(self, level=-1, fill_value=None)",
                "map(self, arg, na_action=None) -> 'Series'",
                "_gotitem(self, key, ndim, subset=None) -> 'Series'",
                "aggregate(self, func, axis=0, *args, **kwargs)",
                "transform(self, func, axis=0, *args, **kwargs)",
                "apply(self, func, convert_dtype=True, args=(), **kwds)",
                "_reduce(self, op, name, axis=0, skipna=True, numeric_only=None, filter_type=None, **kwds)",
                "_reindex_indexer(self, new_index, indexer, copy)",
                "_needs_reindex_multi(self, axes, method, level)",
                "align(self, other, join='outer', axis=None, level=None, copy=True, fill_value=None, method=None, limit=None, fill_axis=0, broadcast_axis=None)",
                "rename(self, index=None)",
                "set_axis(self, labels, axis: Axis=0, inplace: bool=False)",
                "reindex(self, index=None, **kwargs)",
                "drop(self, labels=None, axis=0, index=None, columns=None, level=None, inplace=False, errors='raise') -> 'Series'",
                "fillna(self, value=None, method=None, axis=None, inplace=False, limit=None, downcast=None) -> Optional['Series']",
                "replace(self, to_replace=None, value=None, inplace=False, limit=None, regex=False, method='pad')",
                "shift(self, periods=1, freq=None, axis=0, fill_value=None) -> 'Series'",
                "memory_usage(self, index=True, deep=False)",
                "isin(self, values) -> 'Series'",
                "between(self, left, right, inclusive=True) -> 'Series'",
                "_convert_dtypes(self, infer_objects: bool=True, convert_string: bool=True, convert_integer: bool=True, convert_boolean: bool=True) -> 'Series'",
                "isna(self) -> 'Series'",
                "isnull(self) -> 'Series'",
                "notna(self) -> 'Series'",
                "notnull(self) -> 'Series'",
                "dropna(self, axis=0, inplace=False, how=None)",
                "to_timestamp(self, freq=None, how='start', copy=True) -> 'Series'",
                "to_period(self, freq=None, copy=True) -> 'Series'",
                "construct_return(result)",
                "_try_kind_sort(arr)",
                "f(x)"
            ],
            "variables_in_file": {
                "TYPE_CHECKING": [
                    93
                ],
                "__all__": [
                    97
                ],
                "_shared_doc_kwargs": [
                    99,
                    1636,
                    4299,
                    4558,
                    4337,
                    4562,
                    4179,
                    4570,
                    4566,
                    4057,
                    3866,
                    3835,
                    4188,
                    4318
                ],
                "dict": [
                    1153,
                    1474,
                    99,
                    3975
                ],
                "len": [
                    3969,
                    3076,
                    262,
                    3081,
                    3086,
                    3088,
                    2464,
                    4003,
                    3112,
                    1709,
                    302,
                    1713,
                    308,
                    310,
                    311,
                    706,
                    3650,
                    2249,
                    595,
                    724,
                    123,
                    3313,
                    2292,
                    4724,
                    1270,
                    1275
                ],
                "self": [
                    1026,
                    3075,
                    3076,
                    1029,
                    1033,
                    1034,
                    1035,
                    3081,
                    3083,
                    1550,
                    3594,
                    3597,
                    1042,
                    1043,
                    534,
                    2582,
                    2585,
                    1060,
                    1061,
                    3109,
                    1063,
                    4647,
                    1065,
                    4649,
                    3115,
                    4650,
                    3117,
                    4652,
                    2100,
                    4660,
                    2103,
                    568,
                    2615,
                    2617,
                    2618,
                    1084,
                    573,
                    1086,
                    1087,
                    1088,
                    2625,
                    3650,
                    3575,
                    1092,
                    3651,
                    3653,
                    3655,
                    3656,
                    4683,
                    589,
                    4687,
                    4688,
                    4689,
                    4690,
                    595,
                    2648,
                    2649,
                    2138,
                    2139,
                    2140,
                    2658,
                    2659,
                    4710,
                    4714,
                    4715,
                    4716,
                    4717,
                    1653,
                    3701,
                    1656,
                    123,
                    124,
                    1154,
                    1155,
                    1156,
                    1157,
                    2191,
                    2198,
                    663,
                    664,
                    665,
                    2199,
                    675,
                    1699,
                    1702,
                    679,
                    1704,
                    1705,
                    2734,
                    1712,
                    690,
                    1714,
                    1715,
                    2739,
                    2740,
                    695,
                    2743,
                    2750,
                    2752,
                    2753,
                    2755,
                    2757,
                    3270,
                    3271,
                    2248,
                    1737,
                    2761,
                    2762,
                    3782,
                    3783,
                    719,
                    208,
                    209,
                    3798,
                    735,
                    4522,
                    225,
                    3299,
                    4523,
                    3306,
                    2796,
                    2797,
                    3309,
                    3310,
                    2291,
                    3316,
                    245,
                    1270,
                    3318,
                    1274,
                    1275,
                    1276,
                    1279,
                    3840,
                    1281,
                    3841,
                    1283,
                    1284,
                    1285,
                    1291,
                    3345,
                    3858,
                    3860,
                    277,
                    3349,
                    3352,
                    793,
                    3353,
                    3356,
                    3357,
                    3358,
                    3869,
                    1315,
                    1317,
                    1318,
                    4394,
                    811,
                    2873,
                    2362,
                    2363,
                    828,
                    829,
                    2364,
                    831,
                    832,
                    2876,
                    2877,
                    327,
                    328,
                    329,
                    843,
                    857,
                    1881,
                    862,
                    1375,
                    865,
                    4450,
                    4451,
                    868,
                    4452,
                    874,
                    875,
                    2410,
                    878,
                    883,
                    887,
                    894,
                    3456,
                    3969,
                    3970,
                    3971,
                    900,
                    390,
                    902,
                    904,
                    3976,
                    3980,
                    911,
                    912,
                    1423,
                    919,
                    3993,
                    411,
                    923,
                    3996,
                    3998,
                    2463,
                    2464,
                    417,
                    4000,
                    2467,
                    420,
                    4006,
                    2472,
                    4008,
                    938,
                    939,
                    428,
                    941,
                    1454,
                    4009,
                    944,
                    2480,
                    1458,
                    2482,
                    436,
                    4021,
                    4525,
                    4526,
                    4024,
                    4158,
                    955,
                    4540,
                    957,
                    2494,
                    1472,
                    961,
                    962,
                    963,
                    2500,
                    968,
                    2504,
                    4042,
                    4043,
                    972,
                    4046,
                    4048,
                    988,
                    991,
                    992,
                    1505,
                    3553,
                    995,
                    996,
                    486,
                    1002,
                    492,
                    1004,
                    1005,
                    2029,
                    2032,
                    3053,
                    1010,
                    3056,
                    1013,
                    3573,
                    3574,
                    3576,
                    1017,
                    1020,
                    1533,
                    1022,
                    1535
                ],
                "converter": [
                    124,
                    125,
                    127
                ],
                "self.iloc": [
                    1063,
                    941,
                    1043,
                    124,
                    1022
                ],
                "TypeError": [
                    295,
                    1287,
                    4552,
                    491,
                    914,
                    3859,
                    1012,
                    1652,
                    2488,
                    313,
                    2588,
                    125,
                    3070
                ],
                "wrapper.__name__": [
                    127
                ],
                "wrapper": [
                    128,
                    127
                ],
                "converter.__name__": [
                    127
                ],
                "base.IndexOpsMixin": [
                    2502,
                    135,
                    181,
                    570,
                    188
                ],
                "base": [
                    2502,
                    135,
                    181,
                    570,
                    188
                ],
                "generic.NDFrame": [
                    327,
                    135,
                    816,
                    178,
                    182,
                    4184,
                    4189
                ],
                "generic": [
                    1636,
                    327,
                    135,
                    1419,
                    4558,
                    816,
                    4570,
                    178,
                    4562,
                    4189,
                    182,
                    4566,
                    4184,
                    3866,
                    3837
                ],
                "_typ": [
                    174
                ],
                "_name": [
                    176
                ],
                "Label": [
                    2630,
                    489,
                    176,
                    1457,
                    1427,
                    439
                ],
                "_metadata": [
                    177
                ],
                "List": [
                    177,
                    807
                ],
                "str": [
                    672,
                    1701,
                    2887,
                    2888,
                    3979,
                    1389,
                    1421,
                    1422,
                    177,
                    1297,
                    3125,
                    3126,
                    4735
                ],
                "_internal_names_set": [
                    178
                ],
                "generic.NDFrame._internal_names_set": [
                    178
                ],
                "_accessors": [
                    179
                ],
                "_deprecations": [
                    180
                ],
                "base.IndexOpsMixin._deprecations": [
                    181
                ],
                "generic.NDFrame._deprecations": [
                    182
                ],
                "frozenset": [
                    294,
                    183
                ],
                "hasnans": [
                    187
                ],
                "property": [
                    388,
                    806,
                    423,
                    1097,
                    430,
                    494,
                    438,
                    536,
                    377,
                    187,
                    381,
                    571
                ],
                "base.IndexOpsMixin.hasnans.func": [
                    188
                ],
                "base.IndexOpsMixin.hasnans": [
                    188
                ],
                "base.IndexOpsMixin.hasnans.__doc__": [
                    188
                ],
                "_mgr": [
                    190
                ],
                "SingleBlockManager": [
                    280,
                    325,
                    202,
                    216,
                    217,
                    317,
                    190
                ],
                "div": [
                    191
                ],
                "Callable": [
                    192,
                    672,
                    191
                ],
                "Any": [
                    192,
                    672,
                    1457,
                    1427,
                    191
                ],
                "rdiv": [
                    192
                ],
                "isinstance": [
                    261,
                    3975,
                    3594,
                    3979,
                    908,
                    269,
                    3598,
                    1039,
                    3983,
                    913,
                    2581,
                    406,
                    918,
                    280,
                    1046,
                    2586,
                    1051,
                    3992,
                    925,
                    2462,
                    928,
                    4003,
                    1701,
                    294,
                    2479,
                    2736,
                    2483,
                    2612,
                    2485,
                    2870,
                    695,
                    4026,
                    317,
                    957,
                    202,
                    3278,
                    4687,
                    2645,
                    216,
                    2652,
                    2653,
                    871,
                    4714,
                    1389,
                    881,
                    883,
                    1013,
                    3573,
                    247,
                    1272,
                    251
                ],
                "data": [
                    258,
                    261,
                    262,
                    269,
                    271,
                    273,
                    275,
                    276,
                    277,
                    280,
                    282,
                    283,
                    292,
                    294,
                    295,
                    297,
                    300,
                    301,
                    302,
                    303,
                    308,
                    310,
                    317,
                    319,
                    321,
                    323,
                    325,
                    327,
                    202,
                    208,
                    216,
                    217,
                    219,
                    221,
                    352,
                    225,
                    353,
                    227,
                    242,
                    243,
                    371,
                    247,
                    251,
                    255
                ],
                "index": [
                    270,
                    271,
                    273,
                    277,
                    281,
                    282,
                    283,
                    4393,
                    299,
                    302,
                    308,
                    311,
                    4153,
                    4155,
                    4158,
                    323,
                    4292,
                    325,
                    711,
                    3271,
                    329,
                    713,
                    203,
                    715,
                    3274,
                    3278,
                    719,
                    3281,
                    217,
                    220,
                    221,
                    3293,
                    735,
                    3294,
                    4191,
                    355,
                    1379,
                    3302,
                    359,
                    239,
                    240,
                    371,
                    372,
                    4728
                ],
                "dtype": [
                    227,
                    323,
                    319,
                    358,
                    1380,
                    204,
                    367,
                    244,
                    245,
                    277,
                    278,
                    664,
                    793,
                    253,
                    318,
                    255
                ],
                "copy": [
                    320,
                    259,
                    323,
                    3575,
                    4711,
                    4041,
                    4155,
                    4076,
                    205,
                    4684,
                    273,
                    274,
                    279,
                    218,
                    283,
                    319
                ],
                "NDFrame.__init__": [
                    208
                ],
                "NDFrame": [
                    4299,
                    208,
                    4337,
                    4057,
                    4318
                ],
                "self.name": [
                    1281,
                    2753,
                    1317,
                    328,
                    3656,
                    209,
                    3349,
                    2198,
                    2199
                ],
                "name": [
                    1281,
                    1291,
                    1551,
                    4028,
                    2625,
                    2626,
                    4034,
                    328,
                    209,
                    724,
                    2648,
                    2649,
                    735,
                    1376,
                    225,
                    2663,
                    488,
                    1532,
                    1535
                ],
                "fastpath": [
                    418,
                    401,
                    410,
                    213
                ],
                "SingleBlockManager.from_array": [
                    217,
                    325
                ],
                "data.copy": [
                    321,
                    219
                ],
                "data.index": [
                    282,
                    283,
                    221,
                    271
                ],
                "ibase.maybe_extract_name": [
                    225
                ],
                "ibase": [
                    225,
                    3112,
                    3081,
                    302,
                    3313,
                    1270
                ],
                "type": [
                    225,
                    737,
                    675,
                    295,
                    2761,
                    1392,
                    694,
                    2488,
                    702
                ],
                "is_empty_data": [
                    227
                ],
                "warnings.warn": [
                    819,
                    229
                ],
                "warnings": [
                    952,
                    819,
                    229,
                    951
                ],
                "DeprecationWarning": [
                    233,
                    953
                ],
                "ensure_index": [
                    240,
                    402
                ],
                "self._validate_dtype": [
                    245
                ],
                "MultiIndex": [
                    3594,
                    3278,
                    3598,
                    883,
                    1013,
                    3573,
                    247,
                    957
                ],
                "NotImplementedError": [
                    248,
                    4033,
                    733
                ],
                "Index": [
                    928,
                    807,
                    1051,
                    925,
                    1463,
                    251,
                    669
                ],
                "data.astype": [
                    319,
                    255
                ],
                "data._values.copy": [
                    258
                ],
                "data._values": [
                    258
                ],
                "np.ndarray": [
                    261,
                    669,
                    746,
                    685,
                    2485,
                    925
                ],
                "np": [
                    3076,
                    261,
                    901,
                    3983,
                    3351,
                    3991,
                    793,
                    3992,
                    925,
                    669,
                    3357,
                    1705,
                    2473,
                    685,
                    1713,
                    2481,
                    2484,
                    2485,
                    2102,
                    2486,
                    2745,
                    2622,
                    2751,
                    2500,
                    3653,
                    4036,
                    2250,
                    746,
                    367,
                    2031,
                    2293,
                    1018
                ],
                "data.dtype": [
                    262
                ],
                "ValueError": [
                    2465,
                    3107,
                    265,
                    969,
                    1003,
                    3087,
                    2257,
                    3057,
                    3859,
                    309,
                    1014,
                    3093,
                    412,
                    958
                ],
                "Series": [
                    4746,
                    4747,
                    269,
                    4750,
                    4751,
                    3349,
                    925,
                    2462,
                    4003,
                    2736,
                    2483,
                    2612,
                    2870,
                    2871,
                    704,
                    715,
                    2652,
                    2653,
                    379
                ],
                "data.reindex": [
                    273
                ],
                "data._mgr": [
                    275
                ],
                "is_dict_like": [
                    4153,
                    276
                ],
                "self._init_dict": [
                    277
                ],
                "data.index.equals": [
                    283
                ],
                "AssertionError": [
                    1390,
                    2613,
                    286
                ],
                "is_extension_array_dtype": [
                    3996,
                    292,
                    2757
                ],
                "set": [
                    724,
                    294
                ],
                "__name__": [
                    1392,
                    295
                ],
                "com.maybe_iterable_to_list": [
                    297
                ],
                "com": [
                    1504,
                    865,
                    899,
                    995,
                    297,
                    948,
                    1016
                ],
                "is_list_like": [
                    300,
                    3085,
                    303,
                    2197,
                    921
                ],
                "ibase.default_index": [
                    3112,
                    3081,
                    302,
                    3313,
                    1270
                ],
                "sanitize_array": [
                    323
                ],
                "generic.NDFrame.__init__": [
                    327
                ],
                "self._set_axis": [
                    329
                ],
                "keys": [
                    353,
                    367,
                    361,
                    359
                ],
                "values": [
                    4000,
                    353,
                    354,
                    4001,
                    4450,
                    3653,
                    358,
                    3656,
                    361,
                    1004,
                    367,
                    1007,
                    3345,
                    3346,
                    3351,
                    3357
                ],
                "zip": [
                    704,
                    353,
                    716,
                    1454
                ],
                "data.items": [
                    353
                ],
                "list": [
                    897,
                    354,
                    871,
                    3975,
                    2581,
                    1272,
                    925,
                    926
                ],
                "na_value_for_dtype": [
                    2734,
                    358
                ],
                "s": [
                    712,
                    713,
                    366,
                    372,
                    373
                ],
                "create_series_with_explicit_dtype": [
                    366
                ],
                "np.float64": [
                    367
                ],
                "s.reindex": [
                    372
                ],
                "s._mgr": [
                    373
                ],
                "s.index": [
                    713,
                    373
                ],
                "Type": [
                    378,
                    382
                ],
                "DataFrame": [
                    385
                ],
                "self._mgr._can_hold_na": [
                    390
                ],
                "self._mgr": [
                    420,
                    390,
                    968,
                    428,
                    595,
                    534,
                    568,
                    411,
                    2876,
                    573
                ],
                "_index": [
                    392
                ],
                "int": [
                    800,
                    801,
                    394,
                    845,
                    591,
                    2296,
                    859
                ],
                "bool": [
                    901,
                    394,
                    1067,
                    3123,
                    3124,
                    4535,
                    3127,
                    3128,
                    4536,
                    4537,
                    4538,
                    2886,
                    2889,
                    974,
                    4185,
                    1642,
                    1643,
                    1644,
                    1645,
                    1646,
                    1647,
                    1018
                ],
                "labels": [
                    417,
                    4290,
                    420,
                    3281,
                    402,
                    404,
                    3284,
                    406,
                    408,
                    4186,
                    411
                ],
                "is_all_dates": [
                    404,
                    405
                ],
                "labels.is_all_dates": [
                    404
                ],
                "DatetimeIndex": [
                    408,
                    4714,
                    406
                ],
                "PeriodIndex": [
                    406,
                    4687
                ],
                "TimedeltaIndex": [
                    406
                ],
                "self._mgr.set_axis": [
                    411,
                    420
                ],
                "axis": [
                    3840,
                    1153,
                    4291,
                    420,
                    4186,
                    3270,
                    4647,
                    4074,
                    843,
                    3053,
                    4340,
                    1653,
                    4023,
                    4024,
                    1658,
                    411,
                    3869,
                    4312
                ],
                "tslibs.OutOfBoundsDatetime": [
                    412
                ],
                "tslibs": [
                    412
                ],
                "object.__setattr__": [
                    417,
                    492
                ],
                "object": [
                    4000,
                    417,
                    492
                ],
                "self._mgr.dtype": [
                    428
                ],
                "DtypeObj": [
                    424,
                    431
                ],
                "self.dtype": [
                    3970,
                    2755,
                    2757,
                    1318,
                    1034,
                    2734,
                    436,
                    3996,
                    1087
                ],
                "self._name": [
                    486
                ],
                "is_hashable": [
                    490,
                    882
                ],
                "value": [
                    1026,
                    1034,
                    1035,
                    1043,
                    1061,
                    1063,
                    1065,
                    1084,
                    1087,
                    1088,
                    1092,
                    2504,
                    4310,
                    490,
                    1002,
                    492,
                    4330,
                    1007,
                    1010,
                    1020,
                    1022
                ],
                "name.setter": [
                    488
                ],
                "self._mgr.external_values": [
                    534
                ],
                "self._mgr.internal_values": [
                    568
                ],
                "self._mgr._block.array_values": [
                    573
                ],
                "self._mgr._block": [
                    573
                ],
                "Appender": [
                    4160,
                    1636,
                    1419,
                    4558,
                    816,
                    1456,
                    1554,
                    4562,
                    4189,
                    4570,
                    4566,
                    4184,
                    570,
                    3866,
                    1404,
                    3837
                ],
                "base.IndexOpsMixin.array.__doc__": [
                    570
                ],
                "base.IndexOpsMixin.array": [
                    570
                ],
                "ExtensionArray": [
                    4026,
                    572,
                    669,
                    925
                ],
                "self._values.ravel": [
                    589
                ],
                "self._values": [
                    1155,
                    1284,
                    3075,
                    1035,
                    3345,
                    664,
                    3996,
                    3998,
                    1712,
                    2100,
                    4021,
                    1084,
                    829,
                    1088,
                    2752,
                    962,
                    2504,
                    2761,
                    4683,
                    972,
                    589,
                    4046,
                    857,
                    2138,
                    988,
                    4710,
                    875,
                    1004,
                    2029,
                    3309,
                    3575
                ],
                "order": [
                    589,
                    3599
                ],
                "__finalize__": [
                    962,
                    1283,
                    1156,
                    3575,
                    3782,
                    3970,
                    968,
                    4008,
                    4451,
                    4716,
                    2480,
                    2363,
                    1714,
                    4689,
                    663,
                    3352,
                    2139,
                    3356
                ],
                "self._constructor": [
                    3970,
                    1283,
                    1156,
                    663,
                    3352,
                    2199,
                    3356,
                    3109,
                    4008,
                    2480,
                    1714,
                    2363,
                    831,
                    962,
                    3782,
                    3655,
                    968,
                    2762,
                    4048,
                    4689,
                    2139,
                    735,
                    2658,
                    4451,
                    4716,
                    3310,
                    3575
                ],
                "self._values.view": [
                    664
                ],
                "self.index": [
                    1154,
                    3970,
                    900,
                    1033,
                    3594,
                    911,
                    1042,
                    3349,
                    664,
                    3352,
                    3357,
                    2463,
                    2464,
                    1060,
                    3109,
                    1702,
                    4006,
                    1704,
                    1705,
                    938,
                    811,
                    4008,
                    4394,
                    1454,
                    2739,
                    2103,
                    2617,
                    2363,
                    828,
                    957,
                    1086,
                    2750,
                    1472,
                    961,
                    3782,
                    3271,
                    3656,
                    719,
                    4687,
                    4688,
                    2139,
                    991,
                    992,
                    2658,
                    4451,
                    874,
                    3306,
                    2796,
                    1005,
                    4714,
                    4715,
                    2032,
                    883,
                    1013,
                    3573,
                    3574,
                    1017,
                    1274,
                    1275,
                    1276,
                    1279
                ],
                "_HANDLED_TYPES": [
                    669
                ],
                "cls": [
                    675,
                    685
                ],
                "result": [
                    3597,
                    3598,
                    3599,
                    3600,
                    3109,
                    3112,
                    4650,
                    3115,
                    4652,
                    3117,
                    4654,
                    2623,
                    2626,
                    3655,
                    3658,
                    2645,
                    2648,
                    2649,
                    2138,
                    2139,
                    2143,
                    2658,
                    2193,
                    2194,
                    2195,
                    2198,
                    2199,
                    2202,
                    678,
                    681,
                    682,
                    722,
                    727,
                    728,
                    729,
                    734,
                    735,
                    737,
                    739,
                    744,
                    3310,
                    3313,
                    3316,
                    3318,
                    3841,
                    3842,
                    1800,
                    1801,
                    3858,
                    3860,
                    3349,
                    3862,
                    3351,
                    3352,
                    1323,
                    1325,
                    2362,
                    2363,
                    831,
                    832,
                    1879,
                    1881,
                    1884,
                    4450,
                    4451,
                    1386,
                    1389,
                    1392,
                    1396,
                    887,
                    1399,
                    889,
                    1402,
                    4551,
                    4553,
                    4555,
                    4556
                ],
                "ops.maybe_dispatch_ufunc_to_dunder_op": [
                    678
                ],
                "ops": [
                    2625,
                    678,
                    4750,
                    4751,
                    2740,
                    2620
                ],
                "ufunc": [
                    722,
                    679
                ],
                "method": [
                    740,
                    679,
                    2252,
                    2254,
                    4078,
                    4334,
                    722,
                    2260,
                    4311,
                    731
                ],
                "inputs": [
                    704,
                    679,
                    714,
                    716,
                    687,
                    721,
                    722,
                    701,
                    702
                ],
                "kwargs": [
                    2137,
                    3841,
                    3846,
                    679,
                    3847,
                    2028,
                    1423,
                    722,
                    2099,
                    3858,
                    3860,
                    825,
                    3870,
                    4191
                ],
                "NotImplemented": [
                    681,
                    698
                ],
                "no_defer": [
                    685,
                    694
                ],
                "np.ndarray.__array_ufunc__": [
                    685
                ],
                "cls.__array_ufunc__": [
                    685
                ],
                "item": [
                    687,
                    689,
                    690,
                    693,
                    694,
                    695
                ],
                "higher_priority": [
                    688,
                    697
                ],
                "hasattr": [
                    689,
                    3996,
                    693,
                    701
                ],
                "item.__array_priority__": [
                    690
                ],
                "self.__array_priority__": [
                    690
                ],
                "has_array_ufunc": [
                    697,
                    692
                ],
                "__array_ufunc__": [
                    694
                ],
                "self._HANDLED_TYPES": [
                    695
                ],
                "names": [
                    724,
                    701
                ],
                "getattr": [
                    3064,
                    722,
                    701
                ],
                "x": [
                    704,
                    739,
                    715,
                    716,
                    721,
                    3986,
                    2586,
                    701,
                    702
                ],
                "types": [
                    704,
                    716,
                    702
                ],
                "tuple": [
                    737,
                    1153,
                    739,
                    871,
                    714,
                    721,
                    881,
                    1013,
                    918,
                    1046,
                    1272,
                    825,
                    2581,
                    2645,
                    702
                ],
                "alignable": [
                    704,
                    706,
                    712,
                    711
                ],
                "t": [
                    704,
                    715,
                    716
                ],
                "issubclass": [
                    704,
                    715
                ],
                "x.reindex": [
                    715
                ],
                "extract_array": [
                    721,
                    1043
                ],
                "lib.is_scalar": [
                    727
                ],
                "lib": [
                    4001,
                    931,
                    1055,
                    727
                ],
                "result.ndim": [
                    729,
                    2194
                ],
                "construct_return": [
                    744,
                    739
                ],
                "np.asarray": [
                    3653,
                    901,
                    2473,
                    793,
                    1018
                ],
                "self.array": [
                    793,
                    2362,
                    1699,
                    3653
                ],
                "__float__": [
                    799
                ],
                "_coerce_method": [
                    800,
                    801,
                    799
                ],
                "float": [
                    2263,
                    2204,
                    2367,
                    799
                ],
                "__long__": [
                    800
                ],
                "__int__": [
                    801
                ],
                "is_copy": [
                    818
                ],
                "FutureWarning": [
                    822
                ],
                "nv.validate_take": [
                    825
                ],
                "nv": [
                    1153,
                    2028,
                    2099,
                    825,
                    2137
                ],
                "indices": [
                    843,
                    827,
                    828,
                    829
                ],
                "ensure_platform_int": [
                    3305,
                    827
                ],
                "new_index": [
                    1154,
                    1156,
                    1284,
                    2739,
                    2742,
                    828,
                    2750,
                    831,
                    961,
                    962,
                    3575,
                    2762,
                    3274,
                    4048,
                    4688,
                    4689,
                    3306,
                    3307,
                    2796,
                    2797,
                    2798,
                    3310,
                    4715,
                    4716,
                    1270,
                    3574,
                    1276,
                    1279
                ],
                "self.index.take": [
                    3306,
                    828
                ],
                "new_values": [
                    1155,
                    1156,
                    2741,
                    2746,
                    829,
                    831,
                    2752,
                    3781,
                    3782,
                    2761,
                    2762,
                    4683,
                    4045,
                    4685,
                    4048,
                    4689,
                    4710,
                    4712,
                    4716,
                    3309,
                    3310
                ],
                "self._values.take": [
                    3309,
                    829
                ],
                "result.__finalize__": [
                    832,
                    3117,
                    3318
                ],
                "generic.NDFrame.take.__doc__": [
                    816
                ],
                "generic.NDFrame.take": [
                    816
                ],
                "self.take": [
                    843
                ],
                "i": [
                    2029,
                    2030,
                    2032,
                    2100,
                    2101,
                    3574,
                    2103,
                    857
                ],
                "slice": [
                    859,
                    908,
                    1039,
                    999
                ],
                "self._get_values": [
                    902,
                    955,
                    862
                ],
                "slobj": [
                    912,
                    862,
                    911
                ],
                "key": [
                    896,
                    897,
                    1026,
                    899,
                    900,
                    901,
                    902,
                    904,
                    1033,
                    908,
                    911,
                    1039,
                    913,
                    1042,
                    918,
                    919,
                    1022,
                    921,
                    1046,
                    923,
                    1048,
                    925,
                    926,
                    1049,
                    928,
                    929,
                    1051,
                    931,
                    1052,
                    1053,
                    1055,
                    1061,
                    1063,
                    1065,
                    939,
                    941,
                    944,
                    3063,
                    948,
                    955,
                    961,
                    3271,
                    865,
                    867,
                    995,
                    870,
                    871,
                    872,
                    998,
                    874,
                    875,
                    999,
                    1002,
                    878,
                    1005,
                    1007,
                    881,
                    882,
                    1010,
                    1013,
                    887,
                    1016,
                    1017,
                    1018,
                    1020,
                    894
                ],
                "com.apply_if_callable": [
                    865,
                    995
                ],
                "Ellipsis": [
                    867,
                    998
                ],
                "key_is_scalar": [
                    877,
                    870
                ],
                "is_scalar": [
                    1048,
                    870
                ],
                "unpack_1tuple": [
                    872
                ],
                "is_integer": [
                    874,
                    1005
                ],
                "self.index._should_fallback_to_positional": [
                    938,
                    874,
                    1060
                ],
                "self._get_value": [
                    878,
                    887
                ],
                "KeyError": [
                    1089,
                    891,
                    1003
                ],
                "self._get_values_tuple": [
                    894,
                    919
                ],
                "is_iterator": [
                    896
                ],
                "com.is_bool_indexer": [
                    1016,
                    899
                ],
                "check_bool_indexer": [
                    1017,
                    900
                ],
                "self._get_with": [
                    904
                ],
                "self.index._convert_slice_indexer": [
                    1042,
                    911
                ],
                "self._slice": [
                    912
                ],
                "ABCDataFrame": [
                    913,
                    2586,
                    2462,
                    2479
                ],
                "self.loc": [
                    1092,
                    1061,
                    1065,
                    939,
                    944,
                    1010,
                    923
                ],
                "key_type": [
                    929,
                    931,
                    1059,
                    935,
                    1052,
                    1055
                ],
                "key.inferred_type": [
                    929,
                    1052
                ],
                "lib.infer_dtype": [
                    931,
                    1055
                ],
                "com.any_none": [
                    948
                ],
                "warnings.catch_warnings": [
                    951
                ],
                "warnings.filterwarnings": [
                    952
                ],
                "indexer": [
                    961,
                    962,
                    3301,
                    968,
                    3305,
                    3274,
                    3306,
                    972,
                    3309,
                    4040,
                    4046,
                    1042,
                    1043,
                    3283
                ],
                "self.index.get_loc_level": [
                    961
                ],
                "self._mgr.get_slice": [
                    968
                ],
                "takeable": [
                    1083,
                    987
                ],
                "label": [
                    992,
                    1092,
                    1084,
                    988,
                    1086,
                    991
                ],
                "loc": [
                    992,
                    1088,
                    1033,
                    1035,
                    1086,
                    991
                ],
                "self.index.get_loc": [
                    1086,
                    991
                ],
                "self.index._get_values_for_loc": [
                    992
                ],
                "cacher_needs_updating": [
                    996,
                    1028
                ],
                "self._check_is_chained_assignment_possible": [
                    996
                ],
                "self._set_with_engine": [
                    1002
                ],
                "self.index.inferred_type": [
                    1005
                ],
                "e": [
                    1014
                ],
                "self._where": [
                    1020
                ],
                "InvalidIndexError": [
                    1021
                ],
                "self._set_with": [
                    1026
                ],
                "self._maybe_update_cacher": [
                    2877,
                    1029
                ],
                "self.index._engine.get_loc": [
                    1033
                ],
                "self.index._engine": [
                    1033
                ],
                "validate_numeric_casting": [
                    1034,
                    1087
                ],
                "key._values": [
                    1053
                ],
                "nv.validate_repeat": [
                    1153
                ],
                "self.index.repeat": [
                    3656,
                    1154
                ],
                "repeats": [
                    1154,
                    1155
                ],
                "self._values.repeat": [
                    1155
                ],
                "inplace": [
                    1286,
                    1549,
                    1550,
                    4645,
                    3114,
                    4651,
                    4656,
                    4155,
                    4158,
                    3268,
                    4295,
                    1878,
                    1880,
                    4313,
                    4186,
                    3296,
                    3051,
                    4331,
                    3056,
                    3315,
                    1268,
                    1278
                ],
                "validate_bool_kwarg": [
                    3268,
                    4645,
                    3051,
                    1549,
                    1268,
                    1878
                ],
                "drop": [
                    4289,
                    1292,
                    1269
                ],
                "level": [
                    1292,
                    1275,
                    1698,
                    1701,
                    1702,
                    1704,
                    1705,
                    2618,
                    4155,
                    4294,
                    3271,
                    3273,
                    3275,
                    4075,
                    1651,
                    3701,
                    1271,
                    1272,
                    1273,
                    1274,
                    1659,
                    1276
                ],
                "self.index._get_level_number": [
                    1274,
                    1702
                ],
                "lev": [
                    1704,
                    1709,
                    1710,
                    1713,
                    1714,
                    1274
                ],
                "self.index.nlevels": [
                    1275
                ],
                "self.index.droplevel": [
                    1276
                ],
                "self._values.copy": [
                    1284
                ],
                "df": [
                    1537,
                    1291,
                    1292,
                    2191,
                    2193,
                    1533,
                    1535
                ],
                "self.to_frame": [
                    2191,
                    1291,
                    1423
                ],
                "df.reset_index": [
                    1292
                ],
                "buf": [
                    1316,
                    1323,
                    1423,
                    1395,
                    1301,
                    1399,
                    1401
                ],
                "StringIO": [
                    1301
                ],
                "width": [
                    1302
                ],
                "height": [
                    1304,
                    1309,
                    1302
                ],
                "get_terminal_size": [
                    1302
                ],
                "max_rows": [
                    1320,
                    1384,
                    1303
                ],
                "get_option": [
                    1313,
                    1305,
                    1306,
                    1310,
                    1311
                ],
                "min_rows": [
                    1308,
                    1383,
                    1319
                ],
                "show_dimensions": [
                    1313,
                    1321
                ],
                "self.to_string": [
                    1315
                ],
                "buf.getvalue": [
                    1323
                ],
                "formatter": [
                    1386,
                    1374
                ],
                "fmt.SeriesFormatter": [
                    1374
                ],
                "fmt": [
                    1374
                ],
                "length": [
                    1377
                ],
                "header": [
                    1378
                ],
                "na_rep": [
                    1381
                ],
                "float_format": [
                    1382
                ],
                "formatter.to_string": [
                    1386
                ],
                "repr": [
                    1392
                ],
                "buf.write": [
                    1399
                ],
                "AttributeError": [
                    1400,
                    3859
                ],
                "open": [
                    1401
                ],
                "f": [
                    4001,
                    3993,
                    3989,
                    3992,
                    1401,
                    1402,
                    3998
                ],
                "f.write": [
                    1402
                ],
                "Optional": [
                    1803,
                    4308,
                    1421,
                    1422
                ],
                "IO": [
                    1421
                ],
                "to_markdown": [
                    1423
                ],
                "mode": [
                    1423
                ],
                "Substitution": [
                    1418,
                    4188,
                    4178,
                    3831
                ],
                "generic._shared_docs": [
                    1636,
                    1419,
                    4558,
                    4570,
                    4562,
                    4566,
                    3866,
                    3837
                ],
                "iter": [
                    1454
                ],
                "Iterable": [
                    1457,
                    1427
                ],
                "Tuple": [
                    1457,
                    1427,
                    2630,
                    2631
                ],
                "self.items": [
                    1505,
                    1458
                ],
                "items.__doc__": [
                    1456
                ],
                "items": [
                    1456
                ],
                "into_c": [
                    1504,
                    1505
                ],
                "com.standardize_mapping": [
                    1504
                ],
                "into": [
                    1504
                ],
                "self._constructor_expanddim": [
                    1533,
                    4006,
                    1535
                ],
                "ser": [
                    1552,
                    1550,
                    1551
                ],
                "self.copy": [
                    3651,
                    3299,
                    4042,
                    3597,
                    1550,
                    4660
                ],
                "ser.name": [
                    1551
                ],
                "by": [
                    1657,
                    1651
                ],
                "self._get_axis_number": [
                    3840,
                    3270,
                    4647,
                    3053,
                    1653,
                    4024,
                    3869
                ],
                "SeriesGroupBy": [
                    1655
                ],
                "as_index": [
                    1660
                ],
                "sort": [
                    1661
                ],
                "group_keys": [
                    1662
                ],
                "squeeze": [
                    1663
                ],
                "observed": [
                    1664
                ],
                "dropna": [
                    1665,
                    1737
                ],
                "sum": [
                    1699
                ],
                "notna": [
                    1699,
                    1712,
                    2802,
                    4568,
                    2874
                ],
                "self.index.levels": [
                    1704
                ],
                "level_codes": [
                    1712,
                    1705,
                    1707,
                    1709
                ],
                "np.array": [
                    1705
                ],
                "self.index.codes": [
                    1705
                ],
                "mask": [
                    1707,
                    1708,
                    1709,
                    3346,
                    3348,
                    3350,
                    2874,
                    2876
                ],
                "mask.any": [
                    1708,
                    3348
                ],
                "cnt": [
                    1709,
                    1710
                ],
                "lev.insert": [
                    1710
                ],
                "lev._na_value": [
                    1710
                ],
                "obs": [
                    1712,
                    1713
                ],
                "out": [
                    2658,
                    2659,
                    2663,
                    2664,
                    1713,
                    1714
                ],
                "np.bincount": [
                    1713
                ],
                "algorithms.mode": [
                    1737
                ],
                "algorithms": [
                    3456,
                    3553,
                    4450,
                    2504,
                    1737,
                    4045,
                    2362
                ],
                "unique": [
                    1800
                ],
                "super": [
                    4289,
                    3781,
                    4186,
                    4071,
                    1800,
                    4328,
                    1962,
                    4392,
                    4560,
                    4339,
                    4564,
                    4309,
                    1879,
                    4568,
                    4154,
                    4572,
                    3870,
                    4191
                ],
                "drop_duplicates": [
                    1879
                ],
                "keep": [
                    3456,
                    3553,
                    1962,
                    1879
                ],
                "self._update_inplace": [
                    1881,
                    3115,
                    3316,
                    4652
                ],
                "duplicated": [
                    1962
                ],
                "skipna": [
                    4037,
                    2028,
                    2029,
                    2099,
                    2100,
                    4028
                ],
                "nv.validate_argmin_with_skipna": [
                    2028
                ],
                "args": [
                    3841,
                    3976,
                    2028,
                    3980,
                    3983,
                    3858,
                    2099,
                    3860,
                    3986,
                    2137,
                    3870
                ],
                "nanops.nanargmin": [
                    2029
                ],
                "nanops": [
                    2253,
                    2100,
                    2029,
                    2294
                ],
                "np.nan": [
                    2250,
                    2293,
                    2102,
                    2031
                ],
                "nv.validate_argmax_with_skipna": [
                    2099
                ],
                "nanops.nanargmax": [
                    2100
                ],
                "nv.validate_round": [
                    2137
                ],
                "self._values.round": [
                    2138
                ],
                "decimals": [
                    2138
                ],
                "validate_percentile": [
                    2187
                ],
                "q": [
                    2193,
                    2187,
                    2197,
                    2199
                ],
                "df.quantile": [
                    2193
                ],
                "interpolation": [
                    2193
                ],
                "result.iloc": [
                    2202,
                    2195
                ],
                "result.name": [
                    2198
                ],
                "Float64Index": [
                    2199
                ],
                "this": [
                    2626,
                    2248,
                    2249,
                    2797,
                    2254,
                    2799,
                    2802,
                    2291,
                    2292,
                    2294,
                    2615,
                    2618,
                    2620
                ],
                "other": [
                    2462,
                    2463,
                    2464,
                    2468,
                    2473,
                    2479,
                    2736,
                    2481,
                    2483,
                    2612,
                    2739,
                    2740,
                    2870,
                    2488,
                    2617,
                    2618,
                    2744,
                    2620,
                    2871,
                    2494,
                    2873,
                    2752,
                    2625,
                    2874,
                    2876,
                    2500,
                    2248,
                    2254,
                    4072,
                    2796,
                    2798,
                    2799,
                    2800,
                    2802,
                    2291,
                    2294
                ],
                "self.align": [
                    2248,
                    2618,
                    2291
                ],
                "callable": [
                    4153,
                    2252
                ],
                "nanops.nancorr": [
                    2253
                ],
                "this.values": [
                    2294,
                    2620,
                    2254
                ],
                "other.values": [
                    2294,
                    2620,
                    2254
                ],
                "min_periods": [
                    2294,
                    2254
                ],
                "nanops.nancov": [
                    2294
                ],
                "algorithms.diff": [
                    2362
                ],
                "periods": [
                    2362,
                    4340
                ],
                "self.corr": [
                    2410
                ],
                "self.shift": [
                    2410
                ],
                "lag": [
                    2410
                ],
                "common": [
                    2464,
                    2467,
                    2468,
                    2463
                ],
                "self.index.union": [
                    2739,
                    2796,
                    2463
                ],
                "other.index": [
                    2464,
                    2796,
                    2739,
                    2617,
                    2463
                ],
                "left": [
                    4522,
                    2467,
                    2469,
                    4525
                ],
                "self.reindex": [
                    2467,
                    2797
                ],
                "right": [
                    4526,
                    4523,
                    2468,
                    2470
                ],
                "other.reindex": [
                    2468,
                    2798
                ],
                "lvals": [
                    2469,
                    2472,
                    2474,
                    2476,
                    2481,
                    2484,
                    2486
                ],
                "left.values": [
                    2469
                ],
                "rvals": [
                    2470,
                    2473,
                    2474,
                    2476,
                    2481,
                    2484,
                    2485,
                    2486
                ],
                "right.values": [
                    2470
                ],
                "self.values": [
                    2472
                ],
                "lvals.shape": [
                    2474,
                    2476
                ],
                "rvals.shape": [
                    2474,
                    2476
                ],
                "Exception": [
                    3595,
                    2475
                ],
                "np.dot": [
                    2481,
                    2484,
                    2486
                ],
                "other.columns": [
                    2481
                ],
                "self.dot": [
                    2500,
                    2494
                ],
                "np.transpose": [
                    2500
                ],
                "algorithms.searchsorted": [
                    2504
                ],
                "side": [
                    2504
                ],
                "sorter": [
                    2504
                ],
                "doc": [
                    2502,
                    4299,
                    4337,
                    4057,
                    4318
                ],
                "base.IndexOpsMixin.searchsorted": [
                    2502
                ],
                "to_append": [
                    2585,
                    2581,
                    2583
                ],
                "to_concat": [
                    2582,
                    2583,
                    2585,
                    2586,
                    2590
                ],
                "to_concat.extend": [
                    2583
                ],
                "any": [
                    2586
                ],
                "msg": [
                    2587,
                    2588
                ],
                "concat": [
                    2589
                ],
                "ignore_index": [
                    3312,
                    2590,
                    3111
                ],
                "verify_integrity": [
                    2590
                ],
                "self.index.equals": [
                    2617
                ],
                "this_vals": [
                    2620,
                    2623
                ],
                "other_vals": [
                    2620,
                    2623
                ],
                "ops.fill_binop": [
                    2620
                ],
                "fill_value": [
                    2733,
                    2734,
                    4077,
                    4340,
                    3701,
                    2743,
                    2744,
                    2620
                ],
                "np.errstate": [
                    4036,
                    3991,
                    2745,
                    2622,
                    2751
                ],
                "func": [
                    2752,
                    3841,
                    3975,
                    3976,
                    3979,
                    3980,
                    3983,
                    3858,
                    3986,
                    3860,
                    3989,
                    2746,
                    3870,
                    2623
                ],
                "ops.get_op_result_name": [
                    2625,
                    2740
                ],
                "ret": [
                    2626,
                    2627
                ],
                "this._construct_result": [
                    2626
                ],
                "Union": [
                    2630,
                    2631
                ],
                "ArrayLike": [
                    2630
                ],
                "res1": [
                    2648,
                    2652,
                    2654
                ],
                "self._construct_result": [
                    2648,
                    2649
                ],
                "res2": [
                    2649,
                    2653,
                    2654
                ],
                "out.__finalize__": [
                    2659
                ],
                "out.name": [
                    2663
                ],
                "new_name": [
                    2753,
                    2762,
                    2740
                ],
                "idx": [
                    3104,
                    3105,
                    3081,
                    2742,
                    2743,
                    2744,
                    3100,
                    3101
                ],
                "lv": [
                    2752,
                    2746,
                    2743
                ],
                "self.get": [
                    2743
                ],
                "rv": [
                    2744,
                    2746
                ],
                "other.get": [
                    2744
                ],
                "new_values.append": [
                    2746
                ],
                "is_categorical_dtype": [
                    2755
                ],
                "maybe_cast_to_extension_array": [
                    2761
                ],
                "this.dtype.kind": [
                    2799
                ],
                "this.dtype": [
                    2799
                ],
                "other.dtype.kind": [
                    2799
                ],
                "other.dtype": [
                    2799
                ],
                "to_datetime": [
                    2800
                ],
                "this.where": [
                    2802
                ],
                "other.reindex_like": [
                    2873
                ],
                "self._mgr.putmask": [
                    2876
                ],
                "ValueKeyFunc": [
                    2890
                ],
                "self._is_cached": [
                    3056
                ],
                "arr": [
                    3073,
                    3075,
                    3109,
                    3078,
                    3063,
                    3064,
                    3069
                ],
                "ensure_key_mapped": [
                    3271,
                    3063
                ],
                "arr.argsort": [
                    3073,
                    3069
                ],
                "kind": [
                    3357,
                    3069,
                    3302,
                    3351
                ],
                "sorted_index": [
                    3104,
                    3105,
                    3076,
                    3109,
                    3112,
                    3100,
                    3101
                ],
                "np.empty": [
                    3076
                ],
                "np.int32": [
                    3076
                ],
                "bad": [
                    3105,
                    3078,
                    3080,
                    3101,
                    3103
                ],
                "isna": [
                    4560,
                    3346,
                    3078
                ],
                "good": [
                    3104,
                    3080,
                    3083,
                    3099,
                    3100
                ],
                "argsorted": [
                    3096,
                    3104,
                    3083,
                    3100
                ],
                "_try_kind_sort": [
                    3083
                ],
                "ascending": [
                    3302,
                    3275,
                    3085,
                    3086,
                    3088,
                    3090,
                    3092,
                    3285,
                    3095,
                    3293,
                    3294
                ],
                "is_bool": [
                    3092
                ],
                "na_position": [
                    3107,
                    3302,
                    3286,
                    3098,
                    3102
                ],
                "n": [
                    3104,
                    3105,
                    3456,
                    3553,
                    3099,
                    3100,
                    3101,
                    3103
                ],
                "good.sum": [
                    3099
                ],
                "bad.sum": [
                    3103
                ],
                "result.index": [
                    3112,
                    3313,
                    3598,
                    3599
                ],
                "IndexKeyFunc": [
                    3129
                ],
                "index.sortlevel": [
                    3274
                ],
                "sort_remaining": [
                    3275
                ],
                "index._sort_levels_monotonic": [
                    3281
                ],
                "lexsort_indexer": [
                    3283
                ],
                "labels._get_codes_for_sorting": [
                    3284
                ],
                "index.is_monotonic_increasing": [
                    3293
                ],
                "index.is_monotonic_decreasing": [
                    3294
                ],
                "nargsort": [
                    3301
                ],
                "new_index._sort_levels_monotonic": [
                    3307
                ],
                "notmask": [
                    3350,
                    3351
                ],
                "np.argsort": [
                    3357,
                    3351
                ],
                "nlargest": [
                    3456
                ],
                "algorithms.SelectNSeries": [
                    3456,
                    3553
                ],
                "nsmallest": [
                    3553
                ],
                "self.index.swaplevel": [
                    3574
                ],
                "j": [
                    3574
                ],
                "result.index.reorder_levels": [
                    3599
                ],
                "is_object_dtype": [
                    3650,
                    4543
                ],
                "counts": [
                    3656,
                    3653
                ],
                "reshape.explode": [
                    3653
                ],
                "reshape": [
                    3653
                ],
                "unstack": [
                    3701
                ],
                "_map_values": [
                    3781
                ],
                "arg": [
                    3781
                ],
                "na_action": [
                    3781
                ],
                "_agg_see_also_doc": [
                    3800,
                    3832
                ],
                "dedent": [
                    3800,
                    3809
                ],
                "_agg_examples_doc": [
                    3809,
                    3833
                ],
                "how": [
                    4688,
                    3841
                ],
                "self._aggregate": [
                    3841
                ],
                "kwargs.pop": [
                    3846,
                    3847
                ],
                "self.apply": [
                    3858
                ],
                "agg": [
                    3864
                ],
                "aggregate": [
                    3864
                ],
                "transform": [
                    3870
                ],
                "self.aggregate": [
                    3976
                ],
                "kwds": [
                    4037,
                    3976,
                    3980,
                    3983,
                    3986,
                    4028
                ],
                "self._try_aggregate_string_function": [
                    3980
                ],
                "np.ufunc": [
                    3992,
                    3983
                ],
                "mapped": [
                    4001,
                    4003,
                    4006,
                    4008,
                    3998
                ],
                "self._values.map": [
                    3998
                ],
                "_values": [
                    4000
                ],
                "self.astype": [
                    4000
                ],
                "lib.map_infer": [
                    4001
                ],
                "convert_dtype": [
                    4001
                ],
                "pd.array": [
                    4006
                ],
                "pd": [
                    4006
                ],
                "delegate": [
                    4037,
                    4026,
                    4028,
                    4021
                ],
                "delegate._reduce": [
                    4028
                ],
                "numeric_only": [
                    4032
                ],
                "op": [
                    4037
                ],
                "algorithms.take_1d": [
                    4045
                ],
                "align": [
                    4071
                ],
                "join": [
                    4073
                ],
                "limit": [
                    4314,
                    4332,
                    4079
                ],
                "fill_axis": [
                    4080
                ],
                "broadcast_axis": [
                    4081
                ],
                "NDFrame.align": [
                    4057
                ],
                "rename": [
                    4154
                ],
                "errors": [
                    4296,
                    4155
                ],
                "self._set_name": [
                    4158
                ],
                "Axis": [
                    4185
                ],
                "set_axis": [
                    4186
                ],
                "generic.NDFrame.set_axis.__doc__": [
                    4184
                ],
                "generic.NDFrame.set_axis": [
                    4184
                ],
                "reindex": [
                    4191
                ],
                "generic.NDFrame.reindex.__doc__": [
                    4189
                ],
                "generic.NDFrame.reindex": [
                    4189
                ],
                "columns": [
                    4293
                ],
                "fillna": [
                    4309
                ],
                "downcast": [
                    4315
                ],
                "NDFrame.fillna": [
                    4299
                ],
                "replace": [
                    4328
                ],
                "to_replace": [
                    4329
                ],
                "regex": [
                    4333
                ],
                "NDFrame.replace": [
                    4318
                ],
                "shift": [
                    4339
                ],
                "freq": [
                    4688,
                    4715,
                    4340
                ],
                "NDFrame.shift": [
                    4337
                ],
                "v": [
                    4392,
                    4394,
                    4395
                ],
                "memory_usage": [
                    4392
                ],
                "deep": [
                    4392,
                    4394
                ],
                "self.index.memory_usage": [
                    4394
                ],
                "algorithms.isin": [
                    4450
                ],
                "inclusive": [
                    4521
                ],
                "lmask": [
                    4528,
                    4522,
                    4525
                ],
                "rmask": [
                    4528,
                    4523,
                    4526
                ],
                "input_series": [
                    4544,
                    4548,
                    4551,
                    4553,
                    4555,
                    4540,
                    4542,
                    4543
                ],
                "infer_objects": [
                    4541
                ],
                "input_series.infer_objects": [
                    4542
                ],
                "input_series.copy": [
                    4544,
                    4553,
                    4555
                ],
                "convert_string": [
                    4546,
                    4548
                ],
                "convert_integer": [
                    4546,
                    4548
                ],
                "convert_boolean": [
                    4546,
                    4548
                ],
                "inferred_dtype": [
                    4547,
                    4551
                ],
                "convert_dtypes": [
                    4547
                ],
                "input_series._values": [
                    4548
                ],
                "input_series.astype": [
                    4551
                ],
                "isnull": [
                    4564
                ],
                "notnull": [
                    4572
                ],
                "self._can_hold_na": [
                    4649
                ],
                "remove_na_arraylike": [
                    4650
                ],
                "new_values.copy": [
                    4712,
                    4685
                ],
                "self.index.to_timestamp": [
                    4688
                ],
                "self.index.to_period": [
                    4715
                ],
                "_AXIS_ORDERS": [
                    4722,
                    4724
                ],
                "_AXIS_REVERSED": [
                    4723
                ],
                "_AXIS_LEN": [
                    4724
                ],
                "_info_axis_number": [
                    4725
                ],
                "_info_axis_name": [
                    4726
                ],
                "properties.AxisProperty": [
                    4728
                ],
                "properties": [
                    4728
                ],
                "CachedAccessor": [
                    4736,
                    4737,
                    4738,
                    4739,
                    4735
                ],
                "StringMethods": [
                    4735
                ],
                "dt": [
                    4736
                ],
                "CombinedDatetimelikeProperties": [
                    4736
                ],
                "cat": [
                    4737
                ],
                "CategoricalAccessor": [
                    4737
                ],
                "plot": [
                    4738
                ],
                "pandas.plotting.PlotAccessor": [
                    4738
                ],
                "pandas.plotting": [
                    4738,
                    4743
                ],
                "pandas": [
                    4738,
                    4743
                ],
                "sparse": [
                    4739
                ],
                "SparseAccessor": [
                    4739
                ],
                "hist": [
                    4743
                ],
                "pandas.plotting.hist_series": [
                    4743
                ],
                "Series._add_numeric_operations": [
                    4746
                ],
                "Series._add_series_or_dataframe_operations": [
                    4747
                ],
                "ops.add_flex_arithmetic_methods": [
                    4750
                ],
                "ops.add_special_arithmetic_methods": [
                    4751
                ]
            },
            "filtered_variables_in_file": {
                "TYPE_CHECKING": [
                    93
                ],
                "__all__": [
                    97
                ],
                "_shared_doc_kwargs": [
                    99,
                    1636,
                    4299,
                    4558,
                    4337,
                    4562,
                    4179,
                    4570,
                    4566,
                    4057,
                    3866,
                    3835,
                    4188,
                    4318
                ],
                "self": [
                    1026,
                    3075,
                    3076,
                    1029,
                    1033,
                    1034,
                    1035,
                    3081,
                    3083,
                    1550,
                    3594,
                    3597,
                    1042,
                    1043,
                    534,
                    2582,
                    2585,
                    1060,
                    1061,
                    3109,
                    1063,
                    4647,
                    1065,
                    4649,
                    3115,
                    4650,
                    3117,
                    4652,
                    2100,
                    4660,
                    2103,
                    568,
                    2615,
                    2617,
                    2618,
                    1084,
                    573,
                    1086,
                    1087,
                    1088,
                    2625,
                    3650,
                    3575,
                    1092,
                    3651,
                    3653,
                    3655,
                    3656,
                    4683,
                    589,
                    4687,
                    4688,
                    4689,
                    4690,
                    595,
                    2648,
                    2649,
                    2138,
                    2139,
                    2140,
                    2658,
                    2659,
                    4710,
                    4714,
                    4715,
                    4716,
                    4717,
                    1653,
                    3701,
                    1656,
                    123,
                    124,
                    1154,
                    1155,
                    1156,
                    1157,
                    2191,
                    2198,
                    663,
                    664,
                    665,
                    2199,
                    675,
                    1699,
                    1702,
                    679,
                    1704,
                    1705,
                    2734,
                    1712,
                    690,
                    1714,
                    1715,
                    2739,
                    2740,
                    695,
                    2743,
                    2750,
                    2752,
                    2753,
                    2755,
                    2757,
                    3270,
                    3271,
                    2248,
                    1737,
                    2761,
                    2762,
                    3782,
                    3783,
                    719,
                    208,
                    209,
                    3798,
                    735,
                    4522,
                    225,
                    3299,
                    4523,
                    3306,
                    2796,
                    2797,
                    3309,
                    3310,
                    2291,
                    3316,
                    245,
                    1270,
                    3318,
                    1274,
                    1275,
                    1276,
                    1279,
                    3840,
                    1281,
                    3841,
                    1283,
                    1284,
                    1285,
                    1291,
                    3345,
                    3858,
                    3860,
                    277,
                    3349,
                    3352,
                    793,
                    3353,
                    3356,
                    3357,
                    3358,
                    3869,
                    1315,
                    1317,
                    1318,
                    4394,
                    811,
                    2873,
                    2362,
                    2363,
                    828,
                    829,
                    2364,
                    831,
                    832,
                    2876,
                    2877,
                    327,
                    328,
                    329,
                    843,
                    857,
                    1881,
                    862,
                    1375,
                    865,
                    4450,
                    4451,
                    868,
                    4452,
                    874,
                    875,
                    2410,
                    878,
                    883,
                    887,
                    894,
                    3456,
                    3969,
                    3970,
                    3971,
                    900,
                    390,
                    902,
                    904,
                    3976,
                    3980,
                    911,
                    912,
                    1423,
                    919,
                    3993,
                    411,
                    923,
                    3996,
                    3998,
                    2463,
                    2464,
                    417,
                    4000,
                    2467,
                    420,
                    4006,
                    2472,
                    4008,
                    938,
                    939,
                    428,
                    941,
                    1454,
                    4009,
                    944,
                    2480,
                    1458,
                    2482,
                    436,
                    4021,
                    4525,
                    4526,
                    4024,
                    4158,
                    955,
                    4540,
                    957,
                    2494,
                    1472,
                    961,
                    962,
                    963,
                    2500,
                    968,
                    2504,
                    4042,
                    4043,
                    972,
                    4046,
                    4048,
                    988,
                    991,
                    992,
                    1505,
                    3553,
                    995,
                    996,
                    486,
                    1002,
                    492,
                    1004,
                    1005,
                    2029,
                    2032,
                    3053,
                    1010,
                    3056,
                    1013,
                    3573,
                    3574,
                    3576,
                    1017,
                    1020,
                    1533,
                    1022,
                    1535
                ],
                "converter": [
                    124,
                    125,
                    127
                ],
                "self.iloc": [
                    1063,
                    941,
                    1043,
                    124,
                    1022
                ],
                "wrapper.__name__": [
                    127
                ],
                "wrapper": [
                    128,
                    127
                ],
                "converter.__name__": [
                    127
                ],
                "base.IndexOpsMixin": [
                    2502,
                    135,
                    181,
                    570,
                    188
                ],
                "base": [
                    2502,
                    135,
                    181,
                    570,
                    188
                ],
                "generic.NDFrame": [
                    327,
                    135,
                    816,
                    178,
                    182,
                    4184,
                    4189
                ],
                "generic": [
                    1636,
                    327,
                    135,
                    1419,
                    4558,
                    816,
                    4570,
                    178,
                    4562,
                    4189,
                    182,
                    4566,
                    4184,
                    3866,
                    3837
                ],
                "_typ": [
                    174
                ],
                "_name": [
                    176
                ],
                "Label": [
                    2630,
                    489,
                    176,
                    1457,
                    1427,
                    439
                ],
                "_metadata": [
                    177
                ],
                "List": [
                    177,
                    807
                ],
                "_internal_names_set": [
                    178
                ],
                "generic.NDFrame._internal_names_set": [
                    178
                ],
                "_accessors": [
                    179
                ],
                "_deprecations": [
                    180
                ],
                "base.IndexOpsMixin._deprecations": [
                    181
                ],
                "generic.NDFrame._deprecations": [
                    182
                ],
                "hasnans": [
                    187
                ],
                "base.IndexOpsMixin.hasnans.func": [
                    188
                ],
                "base.IndexOpsMixin.hasnans": [
                    188
                ],
                "base.IndexOpsMixin.hasnans.__doc__": [
                    188
                ],
                "_mgr": [
                    190
                ],
                "SingleBlockManager": [
                    280,
                    325,
                    202,
                    216,
                    217,
                    317,
                    190
                ],
                "div": [
                    191
                ],
                "Callable": [
                    192,
                    672,
                    191
                ],
                "Any": [
                    192,
                    672,
                    1457,
                    1427,
                    191
                ],
                "rdiv": [
                    192
                ],
                "data": [
                    258,
                    261,
                    262,
                    269,
                    271,
                    273,
                    275,
                    276,
                    277,
                    280,
                    282,
                    283,
                    292,
                    294,
                    295,
                    297,
                    300,
                    301,
                    302,
                    303,
                    308,
                    310,
                    317,
                    319,
                    321,
                    323,
                    325,
                    327,
                    202,
                    208,
                    216,
                    217,
                    219,
                    221,
                    352,
                    225,
                    353,
                    227,
                    242,
                    243,
                    371,
                    247,
                    251,
                    255
                ],
                "index": [
                    270,
                    271,
                    273,
                    277,
                    281,
                    282,
                    283,
                    4393,
                    299,
                    302,
                    308,
                    311,
                    4153,
                    4155,
                    4158,
                    323,
                    4292,
                    325,
                    711,
                    3271,
                    329,
                    713,
                    203,
                    715,
                    3274,
                    3278,
                    719,
                    3281,
                    217,
                    220,
                    221,
                    3293,
                    735,
                    3294,
                    4191,
                    355,
                    1379,
                    3302,
                    359,
                    239,
                    240,
                    371,
                    372,
                    4728
                ],
                "dtype": [
                    227,
                    323,
                    319,
                    358,
                    1380,
                    204,
                    367,
                    244,
                    245,
                    277,
                    278,
                    664,
                    793,
                    253,
                    318,
                    255
                ],
                "copy": [
                    320,
                    259,
                    323,
                    3575,
                    4711,
                    4041,
                    4155,
                    4076,
                    205,
                    4684,
                    273,
                    274,
                    279,
                    218,
                    283,
                    319
                ],
                "NDFrame.__init__": [
                    208
                ],
                "NDFrame": [
                    4299,
                    208,
                    4337,
                    4057,
                    4318
                ],
                "self.name": [
                    1281,
                    2753,
                    1317,
                    328,
                    3656,
                    209,
                    3349,
                    2198,
                    2199
                ],
                "name": [
                    1281,
                    1291,
                    1551,
                    4028,
                    2625,
                    2626,
                    4034,
                    328,
                    209,
                    724,
                    2648,
                    2649,
                    735,
                    1376,
                    225,
                    2663,
                    488,
                    1532,
                    1535
                ],
                "fastpath": [
                    418,
                    401,
                    410,
                    213
                ],
                "SingleBlockManager.from_array": [
                    217,
                    325
                ],
                "data.copy": [
                    321,
                    219
                ],
                "data.index": [
                    282,
                    283,
                    221,
                    271
                ],
                "ibase.maybe_extract_name": [
                    225
                ],
                "ibase": [
                    225,
                    3112,
                    3081,
                    302,
                    3313,
                    1270
                ],
                "is_empty_data": [
                    227
                ],
                "warnings.warn": [
                    819,
                    229
                ],
                "warnings": [
                    952,
                    819,
                    229,
                    951
                ],
                "ensure_index": [
                    240,
                    402
                ],
                "self._validate_dtype": [
                    245
                ],
                "MultiIndex": [
                    3594,
                    3278,
                    3598,
                    883,
                    1013,
                    3573,
                    247,
                    957
                ],
                "Index": [
                    928,
                    807,
                    1051,
                    925,
                    1463,
                    251,
                    669
                ],
                "data.astype": [
                    319,
                    255
                ],
                "data._values.copy": [
                    258
                ],
                "data._values": [
                    258
                ],
                "np.ndarray": [
                    261,
                    669,
                    746,
                    685,
                    2485,
                    925
                ],
                "np": [
                    3076,
                    261,
                    901,
                    3983,
                    3351,
                    3991,
                    793,
                    3992,
                    925,
                    669,
                    3357,
                    1705,
                    2473,
                    685,
                    1713,
                    2481,
                    2484,
                    2485,
                    2102,
                    2486,
                    2745,
                    2622,
                    2751,
                    2500,
                    3653,
                    4036,
                    2250,
                    746,
                    367,
                    2031,
                    2293,
                    1018
                ],
                "data.dtype": [
                    262
                ],
                "Series": [
                    4746,
                    4747,
                    269,
                    4750,
                    4751,
                    3349,
                    925,
                    2462,
                    4003,
                    2736,
                    2483,
                    2612,
                    2870,
                    2871,
                    704,
                    715,
                    2652,
                    2653,
                    379
                ],
                "data.reindex": [
                    273
                ],
                "data._mgr": [
                    275
                ],
                "is_dict_like": [
                    4153,
                    276
                ],
                "self._init_dict": [
                    277
                ],
                "data.index.equals": [
                    283
                ],
                "is_extension_array_dtype": [
                    3996,
                    292,
                    2757
                ],
                "com.maybe_iterable_to_list": [
                    297
                ],
                "com": [
                    1504,
                    865,
                    899,
                    995,
                    297,
                    948,
                    1016
                ],
                "is_list_like": [
                    300,
                    3085,
                    303,
                    2197,
                    921
                ],
                "ibase.default_index": [
                    3112,
                    3081,
                    302,
                    3313,
                    1270
                ],
                "sanitize_array": [
                    323
                ],
                "generic.NDFrame.__init__": [
                    327
                ],
                "self._set_axis": [
                    329
                ],
                "keys": [
                    353,
                    367,
                    361,
                    359
                ],
                "values": [
                    4000,
                    353,
                    354,
                    4001,
                    4450,
                    3653,
                    358,
                    3656,
                    361,
                    1004,
                    367,
                    1007,
                    3345,
                    3346,
                    3351,
                    3357
                ],
                "data.items": [
                    353
                ],
                "na_value_for_dtype": [
                    2734,
                    358
                ],
                "s": [
                    712,
                    713,
                    366,
                    372,
                    373
                ],
                "create_series_with_explicit_dtype": [
                    366
                ],
                "np.float64": [
                    367
                ],
                "s.reindex": [
                    372
                ],
                "s._mgr": [
                    373
                ],
                "s.index": [
                    713,
                    373
                ],
                "Type": [
                    378,
                    382
                ],
                "DataFrame": [
                    385
                ],
                "self._mgr._can_hold_na": [
                    390
                ],
                "self._mgr": [
                    420,
                    390,
                    968,
                    428,
                    595,
                    534,
                    568,
                    411,
                    2876,
                    573
                ],
                "_index": [
                    392
                ],
                "labels": [
                    417,
                    4290,
                    420,
                    3281,
                    402,
                    404,
                    3284,
                    406,
                    408,
                    4186,
                    411
                ],
                "is_all_dates": [
                    404,
                    405
                ],
                "labels.is_all_dates": [
                    404
                ],
                "DatetimeIndex": [
                    408,
                    4714,
                    406
                ],
                "PeriodIndex": [
                    406,
                    4687
                ],
                "TimedeltaIndex": [
                    406
                ],
                "self._mgr.set_axis": [
                    411,
                    420
                ],
                "axis": [
                    3840,
                    1153,
                    4291,
                    420,
                    4186,
                    3270,
                    4647,
                    4074,
                    843,
                    3053,
                    4340,
                    1653,
                    4023,
                    4024,
                    1658,
                    411,
                    3869,
                    4312
                ],
                "tslibs.OutOfBoundsDatetime": [
                    412
                ],
                "tslibs": [
                    412
                ],
                "object.__setattr__": [
                    417,
                    492
                ],
                "self._mgr.dtype": [
                    428
                ],
                "DtypeObj": [
                    424,
                    431
                ],
                "self.dtype": [
                    3970,
                    2755,
                    2757,
                    1318,
                    1034,
                    2734,
                    436,
                    3996,
                    1087
                ],
                "self._name": [
                    486
                ],
                "is_hashable": [
                    490,
                    882
                ],
                "value": [
                    1026,
                    1034,
                    1035,
                    1043,
                    1061,
                    1063,
                    1065,
                    1084,
                    1087,
                    1088,
                    1092,
                    2504,
                    4310,
                    490,
                    1002,
                    492,
                    4330,
                    1007,
                    1010,
                    1020,
                    1022
                ],
                "name.setter": [
                    488
                ],
                "self._mgr.external_values": [
                    534
                ],
                "self._mgr.internal_values": [
                    568
                ],
                "self._mgr._block.array_values": [
                    573
                ],
                "self._mgr._block": [
                    573
                ],
                "Appender": [
                    4160,
                    1636,
                    1419,
                    4558,
                    816,
                    1456,
                    1554,
                    4562,
                    4189,
                    4570,
                    4566,
                    4184,
                    570,
                    3866,
                    1404,
                    3837
                ],
                "base.IndexOpsMixin.array.__doc__": [
                    570
                ],
                "base.IndexOpsMixin.array": [
                    570
                ],
                "ExtensionArray": [
                    4026,
                    572,
                    669,
                    925
                ],
                "self._values.ravel": [
                    589
                ],
                "self._values": [
                    1155,
                    1284,
                    3075,
                    1035,
                    3345,
                    664,
                    3996,
                    3998,
                    1712,
                    2100,
                    4021,
                    1084,
                    829,
                    1088,
                    2752,
                    962,
                    2504,
                    2761,
                    4683,
                    972,
                    589,
                    4046,
                    857,
                    2138,
                    988,
                    4710,
                    875,
                    1004,
                    2029,
                    3309,
                    3575
                ],
                "order": [
                    589,
                    3599
                ],
                "__finalize__": [
                    962,
                    1283,
                    1156,
                    3575,
                    3782,
                    3970,
                    968,
                    4008,
                    4451,
                    4716,
                    2480,
                    2363,
                    1714,
                    4689,
                    663,
                    3352,
                    2139,
                    3356
                ],
                "self._constructor": [
                    3970,
                    1283,
                    1156,
                    663,
                    3352,
                    2199,
                    3356,
                    3109,
                    4008,
                    2480,
                    1714,
                    2363,
                    831,
                    962,
                    3782,
                    3655,
                    968,
                    2762,
                    4048,
                    4689,
                    2139,
                    735,
                    2658,
                    4451,
                    4716,
                    3310,
                    3575
                ],
                "self._values.view": [
                    664
                ],
                "self.index": [
                    1154,
                    3970,
                    900,
                    1033,
                    3594,
                    911,
                    1042,
                    3349,
                    664,
                    3352,
                    3357,
                    2463,
                    2464,
                    1060,
                    3109,
                    1702,
                    4006,
                    1704,
                    1705,
                    938,
                    811,
                    4008,
                    4394,
                    1454,
                    2739,
                    2103,
                    2617,
                    2363,
                    828,
                    957,
                    1086,
                    2750,
                    1472,
                    961,
                    3782,
                    3271,
                    3656,
                    719,
                    4687,
                    4688,
                    2139,
                    991,
                    992,
                    2658,
                    4451,
                    874,
                    3306,
                    2796,
                    1005,
                    4714,
                    4715,
                    2032,
                    883,
                    1013,
                    3573,
                    3574,
                    1017,
                    1274,
                    1275,
                    1276,
                    1279
                ],
                "_HANDLED_TYPES": [
                    669
                ],
                "cls": [
                    675,
                    685
                ],
                "result": [
                    3597,
                    3598,
                    3599,
                    3600,
                    3109,
                    3112,
                    4650,
                    3115,
                    4652,
                    3117,
                    4654,
                    2623,
                    2626,
                    3655,
                    3658,
                    2645,
                    2648,
                    2649,
                    2138,
                    2139,
                    2143,
                    2658,
                    2193,
                    2194,
                    2195,
                    2198,
                    2199,
                    2202,
                    678,
                    681,
                    682,
                    722,
                    727,
                    728,
                    729,
                    734,
                    735,
                    737,
                    739,
                    744,
                    3310,
                    3313,
                    3316,
                    3318,
                    3841,
                    3842,
                    1800,
                    1801,
                    3858,
                    3860,
                    3349,
                    3862,
                    3351,
                    3352,
                    1323,
                    1325,
                    2362,
                    2363,
                    831,
                    832,
                    1879,
                    1881,
                    1884,
                    4450,
                    4451,
                    1386,
                    1389,
                    1392,
                    1396,
                    887,
                    1399,
                    889,
                    1402,
                    4551,
                    4553,
                    4555,
                    4556
                ],
                "ops.maybe_dispatch_ufunc_to_dunder_op": [
                    678
                ],
                "ops": [
                    2625,
                    678,
                    4750,
                    4751,
                    2740,
                    2620
                ],
                "ufunc": [
                    722,
                    679
                ],
                "method": [
                    740,
                    679,
                    2252,
                    2254,
                    4078,
                    4334,
                    722,
                    2260,
                    4311,
                    731
                ],
                "inputs": [
                    704,
                    679,
                    714,
                    716,
                    687,
                    721,
                    722,
                    701,
                    702
                ],
                "kwargs": [
                    2137,
                    3841,
                    3846,
                    679,
                    3847,
                    2028,
                    1423,
                    722,
                    2099,
                    3858,
                    3860,
                    825,
                    3870,
                    4191
                ],
                "no_defer": [
                    685,
                    694
                ],
                "np.ndarray.__array_ufunc__": [
                    685
                ],
                "cls.__array_ufunc__": [
                    685
                ],
                "item": [
                    687,
                    689,
                    690,
                    693,
                    694,
                    695
                ],
                "higher_priority": [
                    688,
                    697
                ],
                "item.__array_priority__": [
                    690
                ],
                "self.__array_priority__": [
                    690
                ],
                "has_array_ufunc": [
                    697,
                    692
                ],
                "__array_ufunc__": [
                    694
                ],
                "self._HANDLED_TYPES": [
                    695
                ],
                "names": [
                    724,
                    701
                ],
                "x": [
                    704,
                    739,
                    715,
                    716,
                    721,
                    3986,
                    2586,
                    701,
                    702
                ],
                "types": [
                    704,
                    716,
                    702
                ],
                "alignable": [
                    704,
                    706,
                    712,
                    711
                ],
                "t": [
                    704,
                    715,
                    716
                ],
                "x.reindex": [
                    715
                ],
                "extract_array": [
                    721,
                    1043
                ],
                "lib.is_scalar": [
                    727
                ],
                "lib": [
                    4001,
                    931,
                    1055,
                    727
                ],
                "result.ndim": [
                    729,
                    2194
                ],
                "construct_return": [
                    744,
                    739
                ],
                "np.asarray": [
                    3653,
                    901,
                    2473,
                    793,
                    1018
                ],
                "self.array": [
                    793,
                    2362,
                    1699,
                    3653
                ],
                "__float__": [
                    799
                ],
                "_coerce_method": [
                    800,
                    801,
                    799
                ],
                "__long__": [
                    800
                ],
                "__int__": [
                    801
                ],
                "is_copy": [
                    818
                ],
                "nv.validate_take": [
                    825
                ],
                "nv": [
                    1153,
                    2028,
                    2099,
                    825,
                    2137
                ],
                "indices": [
                    843,
                    827,
                    828,
                    829
                ],
                "ensure_platform_int": [
                    3305,
                    827
                ],
                "new_index": [
                    1154,
                    1156,
                    1284,
                    2739,
                    2742,
                    828,
                    2750,
                    831,
                    961,
                    962,
                    3575,
                    2762,
                    3274,
                    4048,
                    4688,
                    4689,
                    3306,
                    3307,
                    2796,
                    2797,
                    2798,
                    3310,
                    4715,
                    4716,
                    1270,
                    3574,
                    1276,
                    1279
                ],
                "self.index.take": [
                    3306,
                    828
                ],
                "new_values": [
                    1155,
                    1156,
                    2741,
                    2746,
                    829,
                    831,
                    2752,
                    3781,
                    3782,
                    2761,
                    2762,
                    4683,
                    4045,
                    4685,
                    4048,
                    4689,
                    4710,
                    4712,
                    4716,
                    3309,
                    3310
                ],
                "self._values.take": [
                    3309,
                    829
                ],
                "result.__finalize__": [
                    832,
                    3117,
                    3318
                ],
                "generic.NDFrame.take.__doc__": [
                    816
                ],
                "generic.NDFrame.take": [
                    816
                ],
                "self.take": [
                    843
                ],
                "i": [
                    2029,
                    2030,
                    2032,
                    2100,
                    2101,
                    3574,
                    2103,
                    857
                ],
                "self._get_values": [
                    902,
                    955,
                    862
                ],
                "slobj": [
                    912,
                    862,
                    911
                ],
                "key": [
                    896,
                    897,
                    1026,
                    899,
                    900,
                    901,
                    902,
                    904,
                    1033,
                    908,
                    911,
                    1039,
                    913,
                    1042,
                    918,
                    919,
                    1022,
                    921,
                    1046,
                    923,
                    1048,
                    925,
                    926,
                    1049,
                    928,
                    929,
                    1051,
                    931,
                    1052,
                    1053,
                    1055,
                    1061,
                    1063,
                    1065,
                    939,
                    941,
                    944,
                    3063,
                    948,
                    955,
                    961,
                    3271,
                    865,
                    867,
                    995,
                    870,
                    871,
                    872,
                    998,
                    874,
                    875,
                    999,
                    1002,
                    878,
                    1005,
                    1007,
                    881,
                    882,
                    1010,
                    1013,
                    887,
                    1016,
                    1017,
                    1018,
                    1020,
                    894
                ],
                "com.apply_if_callable": [
                    865,
                    995
                ],
                "key_is_scalar": [
                    877,
                    870
                ],
                "is_scalar": [
                    1048,
                    870
                ],
                "unpack_1tuple": [
                    872
                ],
                "is_integer": [
                    874,
                    1005
                ],
                "self.index._should_fallback_to_positional": [
                    938,
                    874,
                    1060
                ],
                "self._get_value": [
                    878,
                    887
                ],
                "self._get_values_tuple": [
                    894,
                    919
                ],
                "is_iterator": [
                    896
                ],
                "com.is_bool_indexer": [
                    1016,
                    899
                ],
                "check_bool_indexer": [
                    1017,
                    900
                ],
                "self._get_with": [
                    904
                ],
                "self.index._convert_slice_indexer": [
                    1042,
                    911
                ],
                "self._slice": [
                    912
                ],
                "ABCDataFrame": [
                    913,
                    2586,
                    2462,
                    2479
                ],
                "self.loc": [
                    1092,
                    1061,
                    1065,
                    939,
                    944,
                    1010,
                    923
                ],
                "key_type": [
                    929,
                    931,
                    1059,
                    935,
                    1052,
                    1055
                ],
                "key.inferred_type": [
                    929,
                    1052
                ],
                "lib.infer_dtype": [
                    931,
                    1055
                ],
                "com.any_none": [
                    948
                ],
                "warnings.catch_warnings": [
                    951
                ],
                "warnings.filterwarnings": [
                    952
                ],
                "indexer": [
                    961,
                    962,
                    3301,
                    968,
                    3305,
                    3274,
                    3306,
                    972,
                    3309,
                    4040,
                    4046,
                    1042,
                    1043,
                    3283
                ],
                "self.index.get_loc_level": [
                    961
                ],
                "self._mgr.get_slice": [
                    968
                ],
                "takeable": [
                    1083,
                    987
                ],
                "label": [
                    992,
                    1092,
                    1084,
                    988,
                    1086,
                    991
                ],
                "loc": [
                    992,
                    1088,
                    1033,
                    1035,
                    1086,
                    991
                ],
                "self.index.get_loc": [
                    1086,
                    991
                ],
                "self.index._get_values_for_loc": [
                    992
                ],
                "cacher_needs_updating": [
                    996,
                    1028
                ],
                "self._check_is_chained_assignment_possible": [
                    996
                ],
                "self._set_with_engine": [
                    1002
                ],
                "self.index.inferred_type": [
                    1005
                ],
                "e": [
                    1014
                ],
                "self._where": [
                    1020
                ],
                "InvalidIndexError": [
                    1021
                ],
                "self._set_with": [
                    1026
                ],
                "self._maybe_update_cacher": [
                    2877,
                    1029
                ],
                "self.index._engine.get_loc": [
                    1033
                ],
                "self.index._engine": [
                    1033
                ],
                "validate_numeric_casting": [
                    1034,
                    1087
                ],
                "key._values": [
                    1053
                ],
                "nv.validate_repeat": [
                    1153
                ],
                "self.index.repeat": [
                    3656,
                    1154
                ],
                "repeats": [
                    1154,
                    1155
                ],
                "self._values.repeat": [
                    1155
                ],
                "inplace": [
                    1286,
                    1549,
                    1550,
                    4645,
                    3114,
                    4651,
                    4656,
                    4155,
                    4158,
                    3268,
                    4295,
                    1878,
                    1880,
                    4313,
                    4186,
                    3296,
                    3051,
                    4331,
                    3056,
                    3315,
                    1268,
                    1278
                ],
                "validate_bool_kwarg": [
                    3268,
                    4645,
                    3051,
                    1549,
                    1268,
                    1878
                ],
                "drop": [
                    4289,
                    1292,
                    1269
                ],
                "level": [
                    1292,
                    1275,
                    1698,
                    1701,
                    1702,
                    1704,
                    1705,
                    2618,
                    4155,
                    4294,
                    3271,
                    3273,
                    3275,
                    4075,
                    1651,
                    3701,
                    1271,
                    1272,
                    1273,
                    1274,
                    1659,
                    1276
                ],
                "self.index._get_level_number": [
                    1274,
                    1702
                ],
                "lev": [
                    1704,
                    1709,
                    1710,
                    1713,
                    1714,
                    1274
                ],
                "self.index.nlevels": [
                    1275
                ],
                "self.index.droplevel": [
                    1276
                ],
                "self._values.copy": [
                    1284
                ],
                "df": [
                    1537,
                    1291,
                    1292,
                    2191,
                    2193,
                    1533,
                    1535
                ],
                "self.to_frame": [
                    2191,
                    1291,
                    1423
                ],
                "df.reset_index": [
                    1292
                ],
                "buf": [
                    1316,
                    1323,
                    1423,
                    1395,
                    1301,
                    1399,
                    1401
                ],
                "StringIO": [
                    1301
                ],
                "width": [
                    1302
                ],
                "height": [
                    1304,
                    1309,
                    1302
                ],
                "get_terminal_size": [
                    1302
                ],
                "max_rows": [
                    1320,
                    1384,
                    1303
                ],
                "get_option": [
                    1313,
                    1305,
                    1306,
                    1310,
                    1311
                ],
                "min_rows": [
                    1308,
                    1383,
                    1319
                ],
                "show_dimensions": [
                    1313,
                    1321
                ],
                "self.to_string": [
                    1315
                ],
                "buf.getvalue": [
                    1323
                ],
                "formatter": [
                    1386,
                    1374
                ],
                "fmt.SeriesFormatter": [
                    1374
                ],
                "fmt": [
                    1374
                ],
                "length": [
                    1377
                ],
                "header": [
                    1378
                ],
                "na_rep": [
                    1381
                ],
                "float_format": [
                    1382
                ],
                "formatter.to_string": [
                    1386
                ],
                "buf.write": [
                    1399
                ],
                "f": [
                    4001,
                    3993,
                    3989,
                    3992,
                    1401,
                    1402,
                    3998
                ],
                "f.write": [
                    1402
                ],
                "Optional": [
                    1803,
                    4308,
                    1421,
                    1422
                ],
                "IO": [
                    1421
                ],
                "to_markdown": [
                    1423
                ],
                "mode": [
                    1423
                ],
                "Substitution": [
                    1418,
                    4188,
                    4178,
                    3831
                ],
                "generic._shared_docs": [
                    1636,
                    1419,
                    4558,
                    4570,
                    4562,
                    4566,
                    3866,
                    3837
                ],
                "Iterable": [
                    1457,
                    1427
                ],
                "Tuple": [
                    1457,
                    1427,
                    2630,
                    2631
                ],
                "self.items": [
                    1505,
                    1458
                ],
                "items.__doc__": [
                    1456
                ],
                "items": [
                    1456
                ],
                "into_c": [
                    1504,
                    1505
                ],
                "com.standardize_mapping": [
                    1504
                ],
                "into": [
                    1504
                ],
                "self._constructor_expanddim": [
                    1533,
                    4006,
                    1535
                ],
                "ser": [
                    1552,
                    1550,
                    1551
                ],
                "self.copy": [
                    3651,
                    3299,
                    4042,
                    3597,
                    1550,
                    4660
                ],
                "ser.name": [
                    1551
                ],
                "by": [
                    1657,
                    1651
                ],
                "self._get_axis_number": [
                    3840,
                    3270,
                    4647,
                    3053,
                    1653,
                    4024,
                    3869
                ],
                "SeriesGroupBy": [
                    1655
                ],
                "as_index": [
                    1660
                ],
                "sort": [
                    1661
                ],
                "group_keys": [
                    1662
                ],
                "squeeze": [
                    1663
                ],
                "observed": [
                    1664
                ],
                "dropna": [
                    1665,
                    1737
                ],
                "notna": [
                    1699,
                    1712,
                    2802,
                    4568,
                    2874
                ],
                "self.index.levels": [
                    1704
                ],
                "level_codes": [
                    1712,
                    1705,
                    1707,
                    1709
                ],
                "np.array": [
                    1705
                ],
                "self.index.codes": [
                    1705
                ],
                "mask": [
                    1707,
                    1708,
                    1709,
                    3346,
                    3348,
                    3350,
                    2874,
                    2876
                ],
                "mask.any": [
                    1708,
                    3348
                ],
                "cnt": [
                    1709,
                    1710
                ],
                "lev.insert": [
                    1710
                ],
                "lev._na_value": [
                    1710
                ],
                "obs": [
                    1712,
                    1713
                ],
                "out": [
                    2658,
                    2659,
                    2663,
                    2664,
                    1713,
                    1714
                ],
                "np.bincount": [
                    1713
                ],
                "algorithms.mode": [
                    1737
                ],
                "algorithms": [
                    3456,
                    3553,
                    4450,
                    2504,
                    1737,
                    4045,
                    2362
                ],
                "unique": [
                    1800
                ],
                "drop_duplicates": [
                    1879
                ],
                "keep": [
                    3456,
                    3553,
                    1962,
                    1879
                ],
                "self._update_inplace": [
                    1881,
                    3115,
                    3316,
                    4652
                ],
                "duplicated": [
                    1962
                ],
                "skipna": [
                    4037,
                    2028,
                    2029,
                    2099,
                    2100,
                    4028
                ],
                "nv.validate_argmin_with_skipna": [
                    2028
                ],
                "args": [
                    3841,
                    3976,
                    2028,
                    3980,
                    3983,
                    3858,
                    2099,
                    3860,
                    3986,
                    2137,
                    3870
                ],
                "nanops.nanargmin": [
                    2029
                ],
                "nanops": [
                    2253,
                    2100,
                    2029,
                    2294
                ],
                "np.nan": [
                    2250,
                    2293,
                    2102,
                    2031
                ],
                "nv.validate_argmax_with_skipna": [
                    2099
                ],
                "nanops.nanargmax": [
                    2100
                ],
                "nv.validate_round": [
                    2137
                ],
                "self._values.round": [
                    2138
                ],
                "decimals": [
                    2138
                ],
                "validate_percentile": [
                    2187
                ],
                "q": [
                    2193,
                    2187,
                    2197,
                    2199
                ],
                "df.quantile": [
                    2193
                ],
                "interpolation": [
                    2193
                ],
                "result.iloc": [
                    2202,
                    2195
                ],
                "result.name": [
                    2198
                ],
                "Float64Index": [
                    2199
                ],
                "this": [
                    2626,
                    2248,
                    2249,
                    2797,
                    2254,
                    2799,
                    2802,
                    2291,
                    2292,
                    2294,
                    2615,
                    2618,
                    2620
                ],
                "other": [
                    2462,
                    2463,
                    2464,
                    2468,
                    2473,
                    2479,
                    2736,
                    2481,
                    2483,
                    2612,
                    2739,
                    2740,
                    2870,
                    2488,
                    2617,
                    2618,
                    2744,
                    2620,
                    2871,
                    2494,
                    2873,
                    2752,
                    2625,
                    2874,
                    2876,
                    2500,
                    2248,
                    2254,
                    4072,
                    2796,
                    2798,
                    2799,
                    2800,
                    2802,
                    2291,
                    2294
                ],
                "self.align": [
                    2248,
                    2618,
                    2291
                ],
                "nanops.nancorr": [
                    2253
                ],
                "this.values": [
                    2294,
                    2620,
                    2254
                ],
                "other.values": [
                    2294,
                    2620,
                    2254
                ],
                "min_periods": [
                    2294,
                    2254
                ],
                "nanops.nancov": [
                    2294
                ],
                "algorithms.diff": [
                    2362
                ],
                "periods": [
                    2362,
                    4340
                ],
                "self.corr": [
                    2410
                ],
                "self.shift": [
                    2410
                ],
                "lag": [
                    2410
                ],
                "common": [
                    2464,
                    2467,
                    2468,
                    2463
                ],
                "self.index.union": [
                    2739,
                    2796,
                    2463
                ],
                "other.index": [
                    2464,
                    2796,
                    2739,
                    2617,
                    2463
                ],
                "left": [
                    4522,
                    2467,
                    2469,
                    4525
                ],
                "self.reindex": [
                    2467,
                    2797
                ],
                "right": [
                    4526,
                    4523,
                    2468,
                    2470
                ],
                "other.reindex": [
                    2468,
                    2798
                ],
                "lvals": [
                    2469,
                    2472,
                    2474,
                    2476,
                    2481,
                    2484,
                    2486
                ],
                "left.values": [
                    2469
                ],
                "rvals": [
                    2470,
                    2473,
                    2474,
                    2476,
                    2481,
                    2484,
                    2485,
                    2486
                ],
                "right.values": [
                    2470
                ],
                "self.values": [
                    2472
                ],
                "lvals.shape": [
                    2474,
                    2476
                ],
                "rvals.shape": [
                    2474,
                    2476
                ],
                "np.dot": [
                    2481,
                    2484,
                    2486
                ],
                "other.columns": [
                    2481
                ],
                "self.dot": [
                    2500,
                    2494
                ],
                "np.transpose": [
                    2500
                ],
                "algorithms.searchsorted": [
                    2504
                ],
                "side": [
                    2504
                ],
                "sorter": [
                    2504
                ],
                "doc": [
                    2502,
                    4299,
                    4337,
                    4057,
                    4318
                ],
                "base.IndexOpsMixin.searchsorted": [
                    2502
                ],
                "to_append": [
                    2585,
                    2581,
                    2583
                ],
                "to_concat": [
                    2582,
                    2583,
                    2585,
                    2586,
                    2590
                ],
                "to_concat.extend": [
                    2583
                ],
                "msg": [
                    2587,
                    2588
                ],
                "concat": [
                    2589
                ],
                "ignore_index": [
                    3312,
                    2590,
                    3111
                ],
                "verify_integrity": [
                    2590
                ],
                "self.index.equals": [
                    2617
                ],
                "this_vals": [
                    2620,
                    2623
                ],
                "other_vals": [
                    2620,
                    2623
                ],
                "ops.fill_binop": [
                    2620
                ],
                "fill_value": [
                    2733,
                    2734,
                    4077,
                    4340,
                    3701,
                    2743,
                    2744,
                    2620
                ],
                "np.errstate": [
                    4036,
                    3991,
                    2745,
                    2622,
                    2751
                ],
                "func": [
                    2752,
                    3841,
                    3975,
                    3976,
                    3979,
                    3980,
                    3983,
                    3858,
                    3986,
                    3860,
                    3989,
                    2746,
                    3870,
                    2623
                ],
                "ops.get_op_result_name": [
                    2625,
                    2740
                ],
                "ret": [
                    2626,
                    2627
                ],
                "this._construct_result": [
                    2626
                ],
                "Union": [
                    2630,
                    2631
                ],
                "ArrayLike": [
                    2630
                ],
                "res1": [
                    2648,
                    2652,
                    2654
                ],
                "self._construct_result": [
                    2648,
                    2649
                ],
                "res2": [
                    2649,
                    2653,
                    2654
                ],
                "out.__finalize__": [
                    2659
                ],
                "out.name": [
                    2663
                ],
                "new_name": [
                    2753,
                    2762,
                    2740
                ],
                "idx": [
                    3104,
                    3105,
                    3081,
                    2742,
                    2743,
                    2744,
                    3100,
                    3101
                ],
                "lv": [
                    2752,
                    2746,
                    2743
                ],
                "self.get": [
                    2743
                ],
                "rv": [
                    2744,
                    2746
                ],
                "other.get": [
                    2744
                ],
                "new_values.append": [
                    2746
                ],
                "is_categorical_dtype": [
                    2755
                ],
                "maybe_cast_to_extension_array": [
                    2761
                ],
                "this.dtype.kind": [
                    2799
                ],
                "this.dtype": [
                    2799
                ],
                "other.dtype.kind": [
                    2799
                ],
                "other.dtype": [
                    2799
                ],
                "to_datetime": [
                    2800
                ],
                "this.where": [
                    2802
                ],
                "other.reindex_like": [
                    2873
                ],
                "self._mgr.putmask": [
                    2876
                ],
                "ValueKeyFunc": [
                    2890
                ],
                "self._is_cached": [
                    3056
                ],
                "arr": [
                    3073,
                    3075,
                    3109,
                    3078,
                    3063,
                    3064,
                    3069
                ],
                "ensure_key_mapped": [
                    3271,
                    3063
                ],
                "arr.argsort": [
                    3073,
                    3069
                ],
                "kind": [
                    3357,
                    3069,
                    3302,
                    3351
                ],
                "sorted_index": [
                    3104,
                    3105,
                    3076,
                    3109,
                    3112,
                    3100,
                    3101
                ],
                "np.empty": [
                    3076
                ],
                "np.int32": [
                    3076
                ],
                "bad": [
                    3105,
                    3078,
                    3080,
                    3101,
                    3103
                ],
                "isna": [
                    4560,
                    3346,
                    3078
                ],
                "good": [
                    3104,
                    3080,
                    3083,
                    3099,
                    3100
                ],
                "argsorted": [
                    3096,
                    3104,
                    3083,
                    3100
                ],
                "_try_kind_sort": [
                    3083
                ],
                "ascending": [
                    3302,
                    3275,
                    3085,
                    3086,
                    3088,
                    3090,
                    3092,
                    3285,
                    3095,
                    3293,
                    3294
                ],
                "is_bool": [
                    3092
                ],
                "na_position": [
                    3107,
                    3302,
                    3286,
                    3098,
                    3102
                ],
                "n": [
                    3104,
                    3105,
                    3456,
                    3553,
                    3099,
                    3100,
                    3101,
                    3103
                ],
                "good.sum": [
                    3099
                ],
                "bad.sum": [
                    3103
                ],
                "result.index": [
                    3112,
                    3313,
                    3598,
                    3599
                ],
                "IndexKeyFunc": [
                    3129
                ],
                "index.sortlevel": [
                    3274
                ],
                "sort_remaining": [
                    3275
                ],
                "index._sort_levels_monotonic": [
                    3281
                ],
                "lexsort_indexer": [
                    3283
                ],
                "labels._get_codes_for_sorting": [
                    3284
                ],
                "index.is_monotonic_increasing": [
                    3293
                ],
                "index.is_monotonic_decreasing": [
                    3294
                ],
                "nargsort": [
                    3301
                ],
                "new_index._sort_levels_monotonic": [
                    3307
                ],
                "notmask": [
                    3350,
                    3351
                ],
                "np.argsort": [
                    3357,
                    3351
                ],
                "nlargest": [
                    3456
                ],
                "algorithms.SelectNSeries": [
                    3456,
                    3553
                ],
                "nsmallest": [
                    3553
                ],
                "self.index.swaplevel": [
                    3574
                ],
                "j": [
                    3574
                ],
                "result.index.reorder_levels": [
                    3599
                ],
                "is_object_dtype": [
                    3650,
                    4543
                ],
                "counts": [
                    3656,
                    3653
                ],
                "reshape.explode": [
                    3653
                ],
                "reshape": [
                    3653
                ],
                "unstack": [
                    3701
                ],
                "_map_values": [
                    3781
                ],
                "arg": [
                    3781
                ],
                "na_action": [
                    3781
                ],
                "_agg_see_also_doc": [
                    3800,
                    3832
                ],
                "dedent": [
                    3800,
                    3809
                ],
                "_agg_examples_doc": [
                    3809,
                    3833
                ],
                "how": [
                    4688,
                    3841
                ],
                "self._aggregate": [
                    3841
                ],
                "kwargs.pop": [
                    3846,
                    3847
                ],
                "self.apply": [
                    3858
                ],
                "agg": [
                    3864
                ],
                "aggregate": [
                    3864
                ],
                "transform": [
                    3870
                ],
                "self.aggregate": [
                    3976
                ],
                "kwds": [
                    4037,
                    3976,
                    3980,
                    3983,
                    3986,
                    4028
                ],
                "self._try_aggregate_string_function": [
                    3980
                ],
                "np.ufunc": [
                    3992,
                    3983
                ],
                "mapped": [
                    4001,
                    4003,
                    4006,
                    4008,
                    3998
                ],
                "self._values.map": [
                    3998
                ],
                "_values": [
                    4000
                ],
                "self.astype": [
                    4000
                ],
                "lib.map_infer": [
                    4001
                ],
                "convert_dtype": [
                    4001
                ],
                "pd.array": [
                    4006
                ],
                "pd": [
                    4006
                ],
                "delegate": [
                    4037,
                    4026,
                    4028,
                    4021
                ],
                "delegate._reduce": [
                    4028
                ],
                "numeric_only": [
                    4032
                ],
                "op": [
                    4037
                ],
                "algorithms.take_1d": [
                    4045
                ],
                "align": [
                    4071
                ],
                "join": [
                    4073
                ],
                "limit": [
                    4314,
                    4332,
                    4079
                ],
                "fill_axis": [
                    4080
                ],
                "broadcast_axis": [
                    4081
                ],
                "NDFrame.align": [
                    4057
                ],
                "rename": [
                    4154
                ],
                "errors": [
                    4296,
                    4155
                ],
                "self._set_name": [
                    4158
                ],
                "Axis": [
                    4185
                ],
                "set_axis": [
                    4186
                ],
                "generic.NDFrame.set_axis.__doc__": [
                    4184
                ],
                "generic.NDFrame.set_axis": [
                    4184
                ],
                "reindex": [
                    4191
                ],
                "generic.NDFrame.reindex.__doc__": [
                    4189
                ],
                "generic.NDFrame.reindex": [
                    4189
                ],
                "columns": [
                    4293
                ],
                "fillna": [
                    4309
                ],
                "downcast": [
                    4315
                ],
                "NDFrame.fillna": [
                    4299
                ],
                "replace": [
                    4328
                ],
                "to_replace": [
                    4329
                ],
                "regex": [
                    4333
                ],
                "NDFrame.replace": [
                    4318
                ],
                "shift": [
                    4339
                ],
                "freq": [
                    4688,
                    4715,
                    4340
                ],
                "NDFrame.shift": [
                    4337
                ],
                "v": [
                    4392,
                    4394,
                    4395
                ],
                "memory_usage": [
                    4392
                ],
                "deep": [
                    4392,
                    4394
                ],
                "self.index.memory_usage": [
                    4394
                ],
                "algorithms.isin": [
                    4450
                ],
                "inclusive": [
                    4521
                ],
                "lmask": [
                    4528,
                    4522,
                    4525
                ],
                "rmask": [
                    4528,
                    4523,
                    4526
                ],
                "input_series": [
                    4544,
                    4548,
                    4551,
                    4553,
                    4555,
                    4540,
                    4542,
                    4543
                ],
                "infer_objects": [
                    4541
                ],
                "input_series.infer_objects": [
                    4542
                ],
                "input_series.copy": [
                    4544,
                    4553,
                    4555
                ],
                "convert_string": [
                    4546,
                    4548
                ],
                "convert_integer": [
                    4546,
                    4548
                ],
                "convert_boolean": [
                    4546,
                    4548
                ],
                "inferred_dtype": [
                    4547,
                    4551
                ],
                "convert_dtypes": [
                    4547
                ],
                "input_series._values": [
                    4548
                ],
                "input_series.astype": [
                    4551
                ],
                "isnull": [
                    4564
                ],
                "notnull": [
                    4572
                ],
                "self._can_hold_na": [
                    4649
                ],
                "remove_na_arraylike": [
                    4650
                ],
                "new_values.copy": [
                    4712,
                    4685
                ],
                "self.index.to_timestamp": [
                    4688
                ],
                "self.index.to_period": [
                    4715
                ],
                "_AXIS_ORDERS": [
                    4722,
                    4724
                ],
                "_AXIS_REVERSED": [
                    4723
                ],
                "_AXIS_LEN": [
                    4724
                ],
                "_info_axis_number": [
                    4725
                ],
                "_info_axis_name": [
                    4726
                ],
                "properties.AxisProperty": [
                    4728
                ],
                "properties": [
                    4728
                ],
                "CachedAccessor": [
                    4736,
                    4737,
                    4738,
                    4739,
                    4735
                ],
                "StringMethods": [
                    4735
                ],
                "dt": [
                    4736
                ],
                "CombinedDatetimelikeProperties": [
                    4736
                ],
                "cat": [
                    4737
                ],
                "CategoricalAccessor": [
                    4737
                ],
                "plot": [
                    4738
                ],
                "pandas.plotting.PlotAccessor": [
                    4738
                ],
                "pandas.plotting": [
                    4738,
                    4743
                ],
                "pandas": [
                    4738,
                    4743
                ],
                "sparse": [
                    4739
                ],
                "SparseAccessor": [
                    4739
                ],
                "hist": [
                    4743
                ],
                "pandas.plotting.hist_series": [
                    4743
                ],
                "Series._add_numeric_operations": [
                    4746
                ],
                "Series._add_series_or_dataframe_operations": [
                    4747
                ],
                "ops.add_flex_arithmetic_methods": [
                    4750
                ],
                "ops.add_special_arithmetic_methods": [
                    4751
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_3/pandas/tests/series/methods/test_to_period.py",
                "test_function": "test_to_period_raises",
                "test_function_code": "    def test_to_period_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, DatetimeIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n                ser.to_period()",
                "test_error": "AssertionError",
                "full_test_error": "self = <pandas.tests.series.methods.test_to_period.TestToPeriod object at 0x1100267c0>\nindices = Index(['82\u05dc\u05e6\u05e9\u05e6\u05e78\u05db0', '\u05e3\u05e0\u05e8\u05d7\u05d5\u05e368\u05d7\u05e3', '\u05dc63\u05d677\u05e3\u05d7\u05d6\u05e7', '7\u05d77\u05e809\u05d4\u05e1\u05e4\u05d9', '\u05de21\u05e4\u05e9\u05db\u05d05\u05dc0',\n       '\u05e7\u05e7\u05d9\u05e84\u05dd\u05d3\u05d0\u05dc\u05d6', '\u05d0\u05d0\u05d1\u05e2\u05d7\u05da\u05e5\u05e0\u05e24', '\u05e1\u05de\u05e6\u05d49...\u05e03\u05d5', '\u05dc\u05d8\u05e130\u05de\u05e2\u05e631',\n       '\u05e4\u05e5\u05da\u05e5\u05d1\u05d74\u05e3\u05e7\u05e3', '\u05e4\u05d3568\u05d9\u05e7\u05e8\u05d0\u05d8', '8\u05d36\u05de\u05d4\u05db\u05d1\u05d87\u05da', '\u05d2\u05e5\u05dc\u05e8\u05db\u05d2\u05d8\u05d37\u05e2', '380\u05e2\u05d2\u05df\u05e8\u05e6\u05e36'],\n      dtype='object')\n\n    def test_to_period_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, DatetimeIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n>               ser.to_period()\n\npandas/tests/series/methods/test_to_period.py:57: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = 82\u05dc\u05e6\u05e9\u05e6\u05e78\u05db0    NaN\n\u05e3\u05e0\u05e8\u05d7\u05d5\u05e368\u05d7\u05e3    NaN\n\u05dc63\u05d677\u05e3\u05d7\u05d6\u05e7    NaN\n7\u05d77\u05e809\u05d4\u05e1\u05e4\u05d9    NaN\n\u05de21\u05e4\u05e9\u05db\u05d05\u05dc0    NaN\n             ... \n\u05e4\u05e5\u05da\u05e5\u05d1\u05d74\u05e3\u05e7\u05e3    NaN\n\u05e4\u05d3568\u05d9\u05e7\u05e8\u05d0\u05d8    NaN\n8\u05d36\u05de\u05d4\u05db\u05d1\u05d87\u05da    NaN\n\u05d2\u05e5\u05dc\u05e8\u05db\u05d2\u05d8\u05d37\u05e2    NaN\n380\u05e2\u05d2\u05df\u05e8\u05e6\u05e36    NaN\nLength: 100, dtype: object\nfreq = None, copy = True\n\n    def to_period(self, freq=None, copy=True) -> \"Series\":\n        \"\"\"\n        Convert Series from DatetimeIndex to PeriodIndex with desired\n        frequency (inferred from index if not passed).\n    \n        Parameters\n        ----------\n        freq : str, default None\n            Frequency associated with the PeriodIndex.\n        copy : bool, default True\n            Whether or not to return a copy.\n    \n        Returns\n        -------\n        Series\n            Series with index converted to PeriodIndex.\n        \"\"\"\n        new_values = self._values\n        if copy:\n            new_values = new_values.copy()\n    \n>       assert isinstance(self.index, DatetimeIndex)\nE       AssertionError\n\npandas/core/series.py:4714: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_3/pandas/tests/series/methods/test_to_period.py",
                "test_function": "test_to_period_raises",
                "test_function_code": "    def test_to_period_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, DatetimeIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n                ser.to_period()",
                "test_error": "AssertionError",
                "full_test_error": "self = <pandas.tests.series.methods.test_to_period.TestToPeriod object at 0x1100735e0>\nindices = Index(['DPLFgJk6HK', 'zUN436bHlo', 'ZrB9rgCYvJ', 'Es8Qxl00mG', 'VuFquO79uU',\n       'bcB8ffrkLY', '7iDZXg5psf', 'uHJsU...sFz', 'yztKXmoECs',\n       'NQFzDFDmj9', 'QShs4JGDwI', 'uuz69nY5TB', 'SJn8ZzUosl', 'HU4ANxvRa4'],\n      dtype='object')\n\n    def test_to_period_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, DatetimeIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n>               ser.to_period()\n\npandas/tests/series/methods/test_to_period.py:57: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = DPLFgJk6HK    NaN\nzUN436bHlo    NaN\nZrB9rgCYvJ    NaN\nEs8Qxl00mG    NaN\nVuFquO79uU    NaN\n             ... \nNQFzDFDmj9    NaN\nQShs4JGDwI    NaN\nuuz69nY5TB    NaN\nSJn8ZzUosl    NaN\nHU4ANxvRa4    NaN\nLength: 100, dtype: object\nfreq = None, copy = True\n\n    def to_period(self, freq=None, copy=True) -> \"Series\":\n        \"\"\"\n        Convert Series from DatetimeIndex to PeriodIndex with desired\n        frequency (inferred from index if not passed).\n    \n        Parameters\n        ----------\n        freq : str, default None\n            Frequency associated with the PeriodIndex.\n        copy : bool, default True\n            Whether or not to return a copy.\n    \n        Returns\n        -------\n        Series\n            Series with index converted to PeriodIndex.\n        \"\"\"\n        new_values = self._values\n        if copy:\n            new_values = new_values.copy()\n    \n>       assert isinstance(self.index, DatetimeIndex)\nE       AssertionError\n\npandas/core/series.py:4714: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_3/pandas/tests/series/methods/test_to_period.py",
                "test_function": "test_to_period_raises",
                "test_function_code": "    def test_to_period_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, DatetimeIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n                ser.to_period()",
                "test_error": "AssertionError",
                "full_test_error": "self = <pandas.tests.series.methods.test_to_period.TestToPeriod object at 0x1102b7a90>\nindices = PeriodIndex(['2000-01-03', '2000-01-04', '2000-01-05', '2000-01-06',\n             '2000-01-07', '2000-01-10', '2000-01...-05-15',\n             '2000-05-16', '2000-05-17', '2000-05-18', '2000-05-19'],\n            dtype='period[B]', freq='B')\n\n    def test_to_period_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, DatetimeIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n>               ser.to_period()\n\npandas/tests/series/methods/test_to_period.py:57: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = 2000-01-03    NaN\n2000-01-04    NaN\n2000-01-05    NaN\n2000-01-06    NaN\n2000-01-07    NaN\n             ... \n2000-05-15    NaN\n2000-05-16    NaN\n2000-05-17    NaN\n2000-05-18    NaN\n2000-05-19    NaN\nFreq: B, Length: 100, dtype: object\nfreq = None, copy = True\n\n    def to_period(self, freq=None, copy=True) -> \"Series\":\n        \"\"\"\n        Convert Series from DatetimeIndex to PeriodIndex with desired\n        frequency (inferred from index if not passed).\n    \n        Parameters\n        ----------\n        freq : str, default None\n            Frequency associated with the PeriodIndex.\n        copy : bool, default True\n            Whether or not to return a copy.\n    \n        Returns\n        -------\n        Series\n            Series with index converted to PeriodIndex.\n        \"\"\"\n        new_values = self._values\n        if copy:\n            new_values = new_values.copy()\n    \n>       assert isinstance(self.index, DatetimeIndex)\nE       AssertionError\n\npandas/core/series.py:4714: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_3/pandas/tests/series/methods/test_to_period.py",
                "test_function": "test_to_period_raises",
                "test_function_code": "    def test_to_period_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, DatetimeIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n                ser.to_period()",
                "test_error": "AssertionError",
                "full_test_error": "self = <pandas.tests.series.methods.test_to_period.TestToPeriod object at 0x11006cf40>\nindices = TimedeltaIndex([  '1 days',   '2 days',   '3 days',   '4 days',   '5 days',\n                  '6 days',   '7 days',   ...          '96 days',  '97 days',  '98 days',  '99 days', '100 days'],\n               dtype='timedelta64[ns]', freq='D')\n\n    def test_to_period_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, DatetimeIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n>               ser.to_period()\n\npandas/tests/series/methods/test_to_period.py:57: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = 1 days      NaN\n2 days      NaN\n3 days      NaN\n4 days      NaN\n5 days      NaN\n           ... \n96 days     NaN\n97 days     NaN\n98 days     NaN\n99 days     NaN\n100 days    NaN\nFreq: D, Length: 100, dtype: object\nfreq = None, copy = True\n\n    def to_period(self, freq=None, copy=True) -> \"Series\":\n        \"\"\"\n        Convert Series from DatetimeIndex to PeriodIndex with desired\n        frequency (inferred from index if not passed).\n    \n        Parameters\n        ----------\n        freq : str, default None\n            Frequency associated with the PeriodIndex.\n        copy : bool, default True\n            Whether or not to return a copy.\n    \n        Returns\n        -------\n        Series\n            Series with index converted to PeriodIndex.\n        \"\"\"\n        new_values = self._values\n        if copy:\n            new_values = new_values.copy()\n    \n>       assert isinstance(self.index, DatetimeIndex)\nE       AssertionError\n\npandas/core/series.py:4714: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_3/pandas/tests/series/methods/test_to_period.py",
                "test_function": "test_to_period_raises",
                "test_function_code": "    def test_to_period_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, DatetimeIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n                ser.to_period()",
                "test_error": "AssertionError",
                "full_test_error": "self = <pandas.tests.series.methods.test_to_period.TestToPeriod object at 0x1100cd250>\nindices = Int64Index([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n            17, 18, 19, 20, 21, 22, 23... 80, 81, 82, 83, 84,\n            85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99],\n           dtype='int64')\n\n    def test_to_period_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, DatetimeIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n>               ser.to_period()\n\npandas/tests/series/methods/test_to_period.py:57: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = 0     NaN\n1     NaN\n2     NaN\n3     NaN\n4     NaN\n     ... \n95    NaN\n96    NaN\n97    NaN\n98    NaN\n99    NaN\nLength: 100, dtype: object\nfreq = None, copy = True\n\n    def to_period(self, freq=None, copy=True) -> \"Series\":\n        \"\"\"\n        Convert Series from DatetimeIndex to PeriodIndex with desired\n        frequency (inferred from index if not passed).\n    \n        Parameters\n        ----------\n        freq : str, default None\n            Frequency associated with the PeriodIndex.\n        copy : bool, default True\n            Whether or not to return a copy.\n    \n        Returns\n        -------\n        Series\n            Series with index converted to PeriodIndex.\n        \"\"\"\n        new_values = self._values\n        if copy:\n            new_values = new_values.copy()\n    \n>       assert isinstance(self.index, DatetimeIndex)\nE       AssertionError\n\npandas/core/series.py:4714: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_3/pandas/tests/series/methods/test_to_period.py",
                "test_function": "test_to_period_raises",
                "test_function_code": "    def test_to_period_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, DatetimeIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n                ser.to_period()",
                "test_error": "AssertionError",
                "full_test_error": "self = <pandas.tests.series.methods.test_to_period.TestToPeriod object at 0x1101a6520>\nindices = UInt64Index([9223372036854775808, 9223372036854775809, 9223372036854775810,\n             9223372036854775811, 92233720...2036854775904, 9223372036854775905, 9223372036854775906,\n             9223372036854775907],\n            dtype='uint64')\n\n    def test_to_period_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, DatetimeIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n>               ser.to_period()\n\npandas/tests/series/methods/test_to_period.py:57: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = 9223372036854775808    NaN\n9223372036854775809    NaN\n9223372036854775810    NaN\n9223372036854775811    NaN\n9223372036...5904    NaN\n9223372036854775905    NaN\n9223372036854775906    NaN\n9223372036854775907    NaN\nLength: 100, dtype: object\nfreq = None, copy = True\n\n    def to_period(self, freq=None, copy=True) -> \"Series\":\n        \"\"\"\n        Convert Series from DatetimeIndex to PeriodIndex with desired\n        frequency (inferred from index if not passed).\n    \n        Parameters\n        ----------\n        freq : str, default None\n            Frequency associated with the PeriodIndex.\n        copy : bool, default True\n            Whether or not to return a copy.\n    \n        Returns\n        -------\n        Series\n            Series with index converted to PeriodIndex.\n        \"\"\"\n        new_values = self._values\n        if copy:\n            new_values = new_values.copy()\n    \n>       assert isinstance(self.index, DatetimeIndex)\nE       AssertionError\n\npandas/core/series.py:4714: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_3/pandas/tests/series/methods/test_to_period.py",
                "test_function": "test_to_period_raises",
                "test_function_code": "    def test_to_period_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, DatetimeIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n                ser.to_period()",
                "test_error": "AssertionError",
                "full_test_error": "self = <pandas.tests.series.methods.test_to_period.TestToPeriod object at 0x110320760>\nindices = RangeIndex(start=0, stop=100, step=1)\n\n    def test_to_period_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, DatetimeIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n>               ser.to_period()\n\npandas/tests/series/methods/test_to_period.py:57: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = 0     NaN\n1     NaN\n2     NaN\n3     NaN\n4     NaN\n     ... \n95    NaN\n96    NaN\n97    NaN\n98    NaN\n99    NaN\nLength: 100, dtype: object\nfreq = None, copy = True\n\n    def to_period(self, freq=None, copy=True) -> \"Series\":\n        \"\"\"\n        Convert Series from DatetimeIndex to PeriodIndex with desired\n        frequency (inferred from index if not passed).\n    \n        Parameters\n        ----------\n        freq : str, default None\n            Frequency associated with the PeriodIndex.\n        copy : bool, default True\n            Whether or not to return a copy.\n    \n        Returns\n        -------\n        Series\n            Series with index converted to PeriodIndex.\n        \"\"\"\n        new_values = self._values\n        if copy:\n            new_values = new_values.copy()\n    \n>       assert isinstance(self.index, DatetimeIndex)\nE       AssertionError\n\npandas/core/series.py:4714: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_3/pandas/tests/series/methods/test_to_period.py",
                "test_function": "test_to_period_raises",
                "test_function_code": "    def test_to_period_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, DatetimeIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n                ser.to_period()",
                "test_error": "AssertionError",
                "full_test_error": "self = <pandas.tests.series.methods.test_to_period.TestToPeriod object at 0x11004a4f0>\nindices = Float64Index([-60.073024128532325,  -59.23530400090402,  -58.40759026901854,\n               -56.90612546044854, -56.78...4500850125,  36.307919316861806,  37.494191792937215,\n                38.61399356312093],\n             dtype='float64')\n\n    def test_to_period_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, DatetimeIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n>               ser.to_period()\n\npandas/tests/series/methods/test_to_period.py:57: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = -60.073024    NaN\n-59.235304    NaN\n-58.407590    NaN\n-56.906125    NaN\n-56.784449    NaN\n             ... \n 31.791700    NaN\n 34.869545    NaN\n 36.307919    NaN\n 37.494192    NaN\n 38.613994    NaN\nLength: 100, dtype: object\nfreq = None, copy = True\n\n    def to_period(self, freq=None, copy=True) -> \"Series\":\n        \"\"\"\n        Convert Series from DatetimeIndex to PeriodIndex with desired\n        frequency (inferred from index if not passed).\n    \n        Parameters\n        ----------\n        freq : str, default None\n            Frequency associated with the PeriodIndex.\n        copy : bool, default True\n            Whether or not to return a copy.\n    \n        Returns\n        -------\n        Series\n            Series with index converted to PeriodIndex.\n        \"\"\"\n        new_values = self._values\n        if copy:\n            new_values = new_values.copy()\n    \n>       assert isinstance(self.index, DatetimeIndex)\nE       AssertionError\n\npandas/core/series.py:4714: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_3/pandas/tests/series/methods/test_to_period.py",
                "test_function": "test_to_period_raises",
                "test_function_code": "    def test_to_period_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, DatetimeIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n                ser.to_period()",
                "test_error": "AssertionError",
                "full_test_error": "self = <pandas.tests.series.methods.test_to_period.TestToPeriod object at 0x110353160>\nindices = Index([False, True, False, False, False, False, False, False, False, False], dtype='object')\n\n    def test_to_period_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, DatetimeIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n>               ser.to_period()\n\npandas/tests/series/methods/test_to_period.py:57: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = False    NaN\nTrue     NaN\nFalse    NaN\nFalse    NaN\nFalse    NaN\nFalse    NaN\nFalse    NaN\nFalse    NaN\nFalse    NaN\nFalse    NaN\ndtype: object\nfreq = None, copy = True\n\n    def to_period(self, freq=None, copy=True) -> \"Series\":\n        \"\"\"\n        Convert Series from DatetimeIndex to PeriodIndex with desired\n        frequency (inferred from index if not passed).\n    \n        Parameters\n        ----------\n        freq : str, default None\n            Frequency associated with the PeriodIndex.\n        copy : bool, default True\n            Whether or not to return a copy.\n    \n        Returns\n        -------\n        Series\n            Series with index converted to PeriodIndex.\n        \"\"\"\n        new_values = self._values\n        if copy:\n            new_values = new_values.copy()\n    \n>       assert isinstance(self.index, DatetimeIndex)\nE       AssertionError\n\npandas/core/series.py:4714: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_3/pandas/tests/series/methods/test_to_period.py",
                "test_function": "test_to_period_raises",
                "test_function_code": "    def test_to_period_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, DatetimeIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n                ser.to_period()",
                "test_error": "AssertionError",
                "full_test_error": "self = <pandas.tests.series.methods.test_to_period.TestToPeriod object at 0x110073b50>\nindices = CategoricalIndex(['0Xuq', 'hiJy', 'Jjqf', '0Xuq', 'hiJy', 'Jjqf', '0Xuq',\n                  'hiJy', 'Jjqf', '0Xuq', 'h...                'Jjqf', '0Xuq'],\n                 categories=['0Xuq', 'hiJy', 'Jjqf'], ordered=False, dtype='category')\n\n    def test_to_period_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, DatetimeIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n>               ser.to_period()\n\npandas/tests/series/methods/test_to_period.py:57: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = 0Xuq    NaN\nhiJy    NaN\nJjqf    NaN\n0Xuq    NaN\nhiJy    NaN\n       ... \nJjqf    NaN\n0Xuq    NaN\nhiJy    NaN\nJjqf    NaN\n0Xuq    NaN\nLength: 100, dtype: object\nfreq = None, copy = True\n\n    def to_period(self, freq=None, copy=True) -> \"Series\":\n        \"\"\"\n        Convert Series from DatetimeIndex to PeriodIndex with desired\n        frequency (inferred from index if not passed).\n    \n        Parameters\n        ----------\n        freq : str, default None\n            Frequency associated with the PeriodIndex.\n        copy : bool, default True\n            Whether or not to return a copy.\n    \n        Returns\n        -------\n        Series\n            Series with index converted to PeriodIndex.\n        \"\"\"\n        new_values = self._values\n        if copy:\n            new_values = new_values.copy()\n    \n>       assert isinstance(self.index, DatetimeIndex)\nE       AssertionError\n\npandas/core/series.py:4714: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_3/pandas/tests/series/methods/test_to_period.py",
                "test_function": "test_to_period_raises",
                "test_function_code": "    def test_to_period_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, DatetimeIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n                ser.to_period()",
                "test_error": "AssertionError",
                "full_test_error": "self = <pandas.tests.series.methods.test_to_period.TestToPeriod object at 0x110485e50>\nindices = IntervalIndex([(0.0, 1.0], (1.0, 2.0], (2.0, 3.0], (3.0, 4.0], (4.0, 5.0] ... (95.0, 96.0], (96.0, 97.0], (97.0, 98.0], (98.0, 99.0], (99.0, 100.0]],\n              closed='right',\n              dtype='interval[float64]')\n\n    def test_to_period_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, DatetimeIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n>               ser.to_period()\n\npandas/tests/series/methods/test_to_period.py:57: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = (0.0, 1.0]       NaN\n(1.0, 2.0]       NaN\n(2.0, 3.0]       NaN\n(3.0, 4.0]       NaN\n(4.0, 5.0]       NaN\n             ...     NaN\n(96.0, 97.0]     NaN\n(97.0, 98.0]     NaN\n(98.0, 99.0]     NaN\n(99.0, 100.0]    NaN\nLength: 100, dtype: object\nfreq = None, copy = True\n\n    def to_period(self, freq=None, copy=True) -> \"Series\":\n        \"\"\"\n        Convert Series from DatetimeIndex to PeriodIndex with desired\n        frequency (inferred from index if not passed).\n    \n        Parameters\n        ----------\n        freq : str, default None\n            Frequency associated with the PeriodIndex.\n        copy : bool, default True\n            Whether or not to return a copy.\n    \n        Returns\n        -------\n        Series\n            Series with index converted to PeriodIndex.\n        \"\"\"\n        new_values = self._values\n        if copy:\n            new_values = new_values.copy()\n    \n>       assert isinstance(self.index, DatetimeIndex)\nE       AssertionError\n\npandas/core/series.py:4714: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_3/pandas/tests/series/methods/test_to_period.py",
                "test_function": "test_to_period_raises",
                "test_function_code": "    def test_to_period_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, DatetimeIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n                ser.to_period()",
                "test_error": "AssertionError",
                "full_test_error": "self = <pandas.tests.series.methods.test_to_period.TestToPeriod object at 0x1100cd2e0>\nindices = Index([], dtype='object')\n\n    def test_to_period_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, DatetimeIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n>               ser.to_period()\n\npandas/tests/series/methods/test_to_period.py:57: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Series([], dtype: object), freq = None, copy = True\n\n    def to_period(self, freq=None, copy=True) -> \"Series\":\n        \"\"\"\n        Convert Series from DatetimeIndex to PeriodIndex with desired\n        frequency (inferred from index if not passed).\n    \n        Parameters\n        ----------\n        freq : str, default None\n            Frequency associated with the PeriodIndex.\n        copy : bool, default True\n            Whether or not to return a copy.\n    \n        Returns\n        -------\n        Series\n            Series with index converted to PeriodIndex.\n        \"\"\"\n        new_values = self._values\n        if copy:\n            new_values = new_values.copy()\n    \n>       assert isinstance(self.index, DatetimeIndex)\nE       AssertionError\n\npandas/core/series.py:4714: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_3/pandas/tests/series/methods/test_to_period.py",
                "test_function": "test_to_period_raises",
                "test_function_code": "    def test_to_period_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, DatetimeIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n                ser.to_period()",
                "test_error": "AssertionError",
                "full_test_error": "self = <pandas.tests.series.methods.test_to_period.TestToPeriod object at 0x1104c8400>\nindices = MultiIndex([('foo', 1),\n            ('bar', 2),\n            ('baz', 3)],\n           )\n\n    def test_to_period_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, DatetimeIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n>               ser.to_period()\n\npandas/tests/series/methods/test_to_period.py:57: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = foo  1    NaN\nbar  2    NaN\nbaz  3    NaN\ndtype: object, freq = None\ncopy = True\n\n    def to_period(self, freq=None, copy=True) -> \"Series\":\n        \"\"\"\n        Convert Series from DatetimeIndex to PeriodIndex with desired\n        frequency (inferred from index if not passed).\n    \n        Parameters\n        ----------\n        freq : str, default None\n            Frequency associated with the PeriodIndex.\n        copy : bool, default True\n            Whether or not to return a copy.\n    \n        Returns\n        -------\n        Series\n            Series with index converted to PeriodIndex.\n        \"\"\"\n        new_values = self._values\n        if copy:\n            new_values = new_values.copy()\n    \n>       assert isinstance(self.index, DatetimeIndex)\nE       AssertionError\n\npandas/core/series.py:4714: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_3/pandas/tests/series/methods/test_to_period.py",
                "test_function": "test_to_period_raises",
                "test_function_code": "    def test_to_period_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, DatetimeIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n                ser.to_period()",
                "test_error": "AssertionError",
                "full_test_error": "self = <pandas.tests.series.methods.test_to_period.TestToPeriod object at 0x110282dc0>\nindices = MultiIndex([(1, 'a', '2013-01-01 00:00:00-05:00'),\n            (1, 'a', '2013-01-02 00:00:00-05:00'),\n            (1, ...3-01-02 00:00:00-05:00'),\n            (2, 'b', '2013-01-03 00:00:00-05:00')],\n           names=['one', 'two', 'three'])\n\n    def test_to_period_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, DatetimeIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n>               ser.to_period()\n\npandas/tests/series/methods/test_to_period.py:57: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = one  two  three                    \n1    a    2013-01-01 00:00:00-05:00    NaN\n          2013-01-02 00:00:00-05:00    ...:00:00-05:00    NaN\n          2013-01-02 00:00:00-05:00    NaN\n          2013-01-03 00:00:00-05:00    NaN\ndtype: object\nfreq = None, copy = True\n\n    def to_period(self, freq=None, copy=True) -> \"Series\":\n        \"\"\"\n        Convert Series from DatetimeIndex to PeriodIndex with desired\n        frequency (inferred from index if not passed).\n    \n        Parameters\n        ----------\n        freq : str, default None\n            Frequency associated with the PeriodIndex.\n        copy : bool, default True\n            Whether or not to return a copy.\n    \n        Returns\n        -------\n        Series\n            Series with index converted to PeriodIndex.\n        \"\"\"\n        new_values = self._values\n        if copy:\n            new_values = new_values.copy()\n    \n>       assert isinstance(self.index, DatetimeIndex)\nE       AssertionError\n\npandas/core/series.py:4714: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_3/pandas/tests/series/methods/test_to_period.py",
                "test_function": "test_to_period_raises",
                "test_function_code": "    def test_to_period_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, DatetimeIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n                ser.to_period()",
                "test_error": "AssertionError",
                "full_test_error": "self = <pandas.tests.series.methods.test_to_period.TestToPeriod object at 0x110398160>\nindices = MultiIndex([('foo', 'one'),\n            ('foo', 'two'),\n            ('bar', 'one'),\n            ('baz', 'two'),\n            ('qux', 'one'),\n            ('qux', 'two')],\n           names=['first', 'second'])\n\n    def test_to_period_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, DatetimeIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n>               ser.to_period()\n\npandas/tests/series/methods/test_to_period.py:57: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = first  second\nfoo    one       NaN\n       two       NaN\nbar    one       NaN\nbaz    two       NaN\nqux    one       NaN\n       two       NaN\ndtype: object\nfreq = None, copy = True\n\n    def to_period(self, freq=None, copy=True) -> \"Series\":\n        \"\"\"\n        Convert Series from DatetimeIndex to PeriodIndex with desired\n        frequency (inferred from index if not passed).\n    \n        Parameters\n        ----------\n        freq : str, default None\n            Frequency associated with the PeriodIndex.\n        copy : bool, default True\n            Whether or not to return a copy.\n    \n        Returns\n        -------\n        Series\n            Series with index converted to PeriodIndex.\n        \"\"\"\n        new_values = self._values\n        if copy:\n            new_values = new_values.copy()\n    \n>       assert isinstance(self.index, DatetimeIndex)\nE       AssertionError\n\npandas/core/series.py:4714: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_3/pandas/tests/series/methods/test_to_period.py",
                "test_function": "test_to_period_raises",
                "test_function_code": "    def test_to_period_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, DatetimeIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n                ser.to_period()",
                "test_error": "AssertionError",
                "full_test_error": "self = <pandas.tests.series.methods.test_to_period.TestToPeriod object at 0x1103204c0>\nindices = Int64Index([0, 0, 1, 1, 2, 2], dtype='int64')\n\n    def test_to_period_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, DatetimeIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n>               ser.to_period()\n\npandas/tests/series/methods/test_to_period.py:57: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = 0    NaN\n0    NaN\n1    NaN\n1    NaN\n2    NaN\n2    NaN\ndtype: object\nfreq = None, copy = True\n\n    def to_period(self, freq=None, copy=True) -> \"Series\":\n        \"\"\"\n        Convert Series from DatetimeIndex to PeriodIndex with desired\n        frequency (inferred from index if not passed).\n    \n        Parameters\n        ----------\n        freq : str, default None\n            Frequency associated with the PeriodIndex.\n        copy : bool, default True\n            Whether or not to return a copy.\n    \n        Returns\n        -------\n        Series\n            Series with index converted to PeriodIndex.\n        \"\"\"\n        new_values = self._values\n        if copy:\n            new_values = new_values.copy()\n    \n>       assert isinstance(self.index, DatetimeIndex)\nE       AssertionError\n\npandas/core/series.py:4714: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_3/pandas/tests/series/methods/test_to_timestamp.py",
                "test_function": "test_to_timestamp_raises",
                "test_function_code": "    def test_to_timestamp_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, PeriodIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n                ser.to_timestamp()",
                "test_error": "AssertionError",
                "full_test_error": "self = <pandas.tests.series.methods.test_to_timestamp.TestToTimestamp object at 0x110320a60>\nindices = Index(['82\u05dc\u05e6\u05e9\u05e6\u05e78\u05db0', '\u05e3\u05e0\u05e8\u05d7\u05d5\u05e368\u05d7\u05e3', '\u05dc63\u05d677\u05e3\u05d7\u05d6\u05e7', '7\u05d77\u05e809\u05d4\u05e1\u05e4\u05d9', '\u05de21\u05e4\u05e9\u05db\u05d05\u05dc0',\n       '\u05e7\u05e7\u05d9\u05e84\u05dd\u05d3\u05d0\u05dc\u05d6', '\u05d0\u05d0\u05d1\u05e2\u05d7\u05da\u05e5\u05e0\u05e24', '\u05e1\u05de\u05e6\u05d49...\u05e03\u05d5', '\u05dc\u05d8\u05e130\u05de\u05e2\u05e631',\n       '\u05e4\u05e5\u05da\u05e5\u05d1\u05d74\u05e3\u05e7\u05e3', '\u05e4\u05d3568\u05d9\u05e7\u05e8\u05d0\u05d8', '8\u05d36\u05de\u05d4\u05db\u05d1\u05d87\u05da', '\u05d2\u05e5\u05dc\u05e8\u05db\u05d2\u05d8\u05d37\u05e2', '380\u05e2\u05d2\u05df\u05e8\u05e6\u05e36'],\n      dtype='object')\n\n    def test_to_timestamp_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, PeriodIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n>               ser.to_timestamp()\n\npandas/tests/series/methods/test_to_timestamp.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = 82\u05dc\u05e6\u05e9\u05e6\u05e78\u05db0    NaN\n\u05e3\u05e0\u05e8\u05d7\u05d5\u05e368\u05d7\u05e3    NaN\n\u05dc63\u05d677\u05e3\u05d7\u05d6\u05e7    NaN\n7\u05d77\u05e809\u05d4\u05e1\u05e4\u05d9    NaN\n\u05de21\u05e4\u05e9\u05db\u05d05\u05dc0    NaN\n             ... \n\u05e4\u05e5\u05da\u05e5\u05d1\u05d74\u05e3\u05e7\u05e3    NaN\n\u05e4\u05d3568\u05d9\u05e7\u05e8\u05d0\u05d8    NaN\n8\u05d36\u05de\u05d4\u05db\u05d1\u05d87\u05da    NaN\n\u05d2\u05e5\u05dc\u05e8\u05db\u05d2\u05d8\u05d37\u05e2    NaN\n380\u05e2\u05d2\u05df\u05e8\u05e6\u05e36    NaN\nLength: 100, dtype: object\nfreq = None, how = 'start', copy = True\n\n    def to_timestamp(self, freq=None, how=\"start\", copy=True) -> \"Series\":\n        \"\"\"\n        Cast to DatetimeIndex of Timestamps, at *beginning* of period.\n    \n        Parameters\n        ----------\n        freq : str, default frequency of PeriodIndex\n            Desired frequency.\n        how : {'s', 'e', 'start', 'end'}\n            Convention for converting period to timestamp; start of period\n            vs. end.\n        copy : bool, default True\n            Whether or not to return a copy.\n    \n        Returns\n        -------\n        Series with DatetimeIndex\n        \"\"\"\n        new_values = self._values\n        if copy:\n            new_values = new_values.copy()\n    \n>       assert isinstance(self.index, PeriodIndex)\nE       AssertionError\n\npandas/core/series.py:4687: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_3/pandas/tests/series/methods/test_to_timestamp.py",
                "test_function": "test_to_timestamp_raises",
                "test_function_code": "    def test_to_timestamp_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, PeriodIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n                ser.to_timestamp()",
                "test_error": "AssertionError",
                "full_test_error": "self = <pandas.tests.series.methods.test_to_timestamp.TestToTimestamp object at 0x11035c880>\nindices = Index(['DPLFgJk6HK', 'zUN436bHlo', 'ZrB9rgCYvJ', 'Es8Qxl00mG', 'VuFquO79uU',\n       'bcB8ffrkLY', '7iDZXg5psf', 'uHJsU...sFz', 'yztKXmoECs',\n       'NQFzDFDmj9', 'QShs4JGDwI', 'uuz69nY5TB', 'SJn8ZzUosl', 'HU4ANxvRa4'],\n      dtype='object')\n\n    def test_to_timestamp_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, PeriodIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n>               ser.to_timestamp()\n\npandas/tests/series/methods/test_to_timestamp.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = DPLFgJk6HK    NaN\nzUN436bHlo    NaN\nZrB9rgCYvJ    NaN\nEs8Qxl00mG    NaN\nVuFquO79uU    NaN\n             ... \nNQFzDFDmj9    NaN\nQShs4JGDwI    NaN\nuuz69nY5TB    NaN\nSJn8ZzUosl    NaN\nHU4ANxvRa4    NaN\nLength: 100, dtype: object\nfreq = None, how = 'start', copy = True\n\n    def to_timestamp(self, freq=None, how=\"start\", copy=True) -> \"Series\":\n        \"\"\"\n        Cast to DatetimeIndex of Timestamps, at *beginning* of period.\n    \n        Parameters\n        ----------\n        freq : str, default frequency of PeriodIndex\n            Desired frequency.\n        how : {'s', 'e', 'start', 'end'}\n            Convention for converting period to timestamp; start of period\n            vs. end.\n        copy : bool, default True\n            Whether or not to return a copy.\n    \n        Returns\n        -------\n        Series with DatetimeIndex\n        \"\"\"\n        new_values = self._values\n        if copy:\n            new_values = new_values.copy()\n    \n>       assert isinstance(self.index, PeriodIndex)\nE       AssertionError\n\npandas/core/series.py:4687: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_3/pandas/tests/series/methods/test_to_timestamp.py",
                "test_function": "test_to_timestamp_raises",
                "test_function_code": "    def test_to_timestamp_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, PeriodIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n                ser.to_timestamp()",
                "test_error": "AssertionError",
                "full_test_error": "self = <pandas.tests.series.methods.test_to_timestamp.TestToTimestamp object at 0x11029dca0>\nindices = DatetimeIndex(['2000-01-03', '2000-01-04', '2000-01-05', '2000-01-06',\n               '2000-01-07', '2000-01-10', '200...               '2000-05-16', '2000-05-17', '2000-05-18', '2000-05-19'],\n              dtype='datetime64[ns]', freq='B')\n\n    def test_to_timestamp_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, PeriodIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n>               ser.to_timestamp()\n\npandas/tests/series/methods/test_to_timestamp.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = 2000-01-03    NaN\n2000-01-04    NaN\n2000-01-05    NaN\n2000-01-06    NaN\n2000-01-07    NaN\n             ... \n2000-05-15    NaN\n2000-05-16    NaN\n2000-05-17    NaN\n2000-05-18    NaN\n2000-05-19    NaN\nFreq: B, Length: 100, dtype: object\nfreq = None, how = 'start', copy = True\n\n    def to_timestamp(self, freq=None, how=\"start\", copy=True) -> \"Series\":\n        \"\"\"\n        Cast to DatetimeIndex of Timestamps, at *beginning* of period.\n    \n        Parameters\n        ----------\n        freq : str, default frequency of PeriodIndex\n            Desired frequency.\n        how : {'s', 'e', 'start', 'end'}\n            Convention for converting period to timestamp; start of period\n            vs. end.\n        copy : bool, default True\n            Whether or not to return a copy.\n    \n        Returns\n        -------\n        Series with DatetimeIndex\n        \"\"\"\n        new_values = self._values\n        if copy:\n            new_values = new_values.copy()\n    \n>       assert isinstance(self.index, PeriodIndex)\nE       AssertionError\n\npandas/core/series.py:4687: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_3/pandas/tests/series/methods/test_to_timestamp.py",
                "test_function": "test_to_timestamp_raises",
                "test_function_code": "    def test_to_timestamp_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, PeriodIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n                ser.to_timestamp()",
                "test_error": "AssertionError",
                "full_test_error": "self = <pandas.tests.series.methods.test_to_timestamp.TestToTimestamp object at 0x1102d3880>\nindices = DatetimeIndex(['2000-01-03 00:00:00-08:00', '2000-01-04 00:00:00-08:00',\n               '2000-01-05 00:00:00-08:00', '... '2000-05-18 00:00:00-07:00', '2000-05-19 00:00:00-07:00'],\n              dtype='datetime64[ns, US/Pacific]', freq='B')\n\n    def test_to_timestamp_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, PeriodIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n>               ser.to_timestamp()\n\npandas/tests/series/methods/test_to_timestamp.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = 2000-01-03 00:00:00-08:00    NaN\n2000-01-04 00:00:00-08:00    NaN\n2000-01-05 00:00:00-08:00    NaN\n2000-01-06 00:00:00...0:00-07:00    NaN\n2000-05-18 00:00:00-07:00    NaN\n2000-05-19 00:00:00-07:00    NaN\nFreq: B, Length: 100, dtype: object\nfreq = None, how = 'start', copy = True\n\n    def to_timestamp(self, freq=None, how=\"start\", copy=True) -> \"Series\":\n        \"\"\"\n        Cast to DatetimeIndex of Timestamps, at *beginning* of period.\n    \n        Parameters\n        ----------\n        freq : str, default frequency of PeriodIndex\n            Desired frequency.\n        how : {'s', 'e', 'start', 'end'}\n            Convention for converting period to timestamp; start of period\n            vs. end.\n        copy : bool, default True\n            Whether or not to return a copy.\n    \n        Returns\n        -------\n        Series with DatetimeIndex\n        \"\"\"\n        new_values = self._values\n        if copy:\n            new_values = new_values.copy()\n    \n>       assert isinstance(self.index, PeriodIndex)\nE       AssertionError\n\npandas/core/series.py:4687: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_3/pandas/tests/series/methods/test_to_timestamp.py",
                "test_function": "test_to_timestamp_raises",
                "test_function_code": "    def test_to_timestamp_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, PeriodIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n                ser.to_timestamp()",
                "test_error": "AssertionError",
                "full_test_error": "self = <pandas.tests.series.methods.test_to_timestamp.TestToTimestamp object at 0x110282e50>\nindices = TimedeltaIndex([  '1 days',   '2 days',   '3 days',   '4 days',   '5 days',\n                  '6 days',   '7 days',   ...          '96 days',  '97 days',  '98 days',  '99 days', '100 days'],\n               dtype='timedelta64[ns]', freq='D')\n\n    def test_to_timestamp_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, PeriodIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n>               ser.to_timestamp()\n\npandas/tests/series/methods/test_to_timestamp.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = 1 days      NaN\n2 days      NaN\n3 days      NaN\n4 days      NaN\n5 days      NaN\n           ... \n96 days     NaN\n97 days     NaN\n98 days     NaN\n99 days     NaN\n100 days    NaN\nFreq: D, Length: 100, dtype: object\nfreq = None, how = 'start', copy = True\n\n    def to_timestamp(self, freq=None, how=\"start\", copy=True) -> \"Series\":\n        \"\"\"\n        Cast to DatetimeIndex of Timestamps, at *beginning* of period.\n    \n        Parameters\n        ----------\n        freq : str, default frequency of PeriodIndex\n            Desired frequency.\n        how : {'s', 'e', 'start', 'end'}\n            Convention for converting period to timestamp; start of period\n            vs. end.\n        copy : bool, default True\n            Whether or not to return a copy.\n    \n        Returns\n        -------\n        Series with DatetimeIndex\n        \"\"\"\n        new_values = self._values\n        if copy:\n            new_values = new_values.copy()\n    \n>       assert isinstance(self.index, PeriodIndex)\nE       AssertionError\n\npandas/core/series.py:4687: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_3/pandas/tests/series/methods/test_to_timestamp.py",
                "test_function": "test_to_timestamp_raises",
                "test_function_code": "    def test_to_timestamp_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, PeriodIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n                ser.to_timestamp()",
                "test_error": "AssertionError",
                "full_test_error": "self = <pandas.tests.series.methods.test_to_timestamp.TestToTimestamp object at 0x1102b7b80>\nindices = Int64Index([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,\n            17, 18, 19, 20, 21, 22, 23... 80, 81, 82, 83, 84,\n            85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99],\n           dtype='int64')\n\n    def test_to_timestamp_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, PeriodIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n>               ser.to_timestamp()\n\npandas/tests/series/methods/test_to_timestamp.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = 0     NaN\n1     NaN\n2     NaN\n3     NaN\n4     NaN\n     ... \n95    NaN\n96    NaN\n97    NaN\n98    NaN\n99    NaN\nLength: 100, dtype: object\nfreq = None, how = 'start', copy = True\n\n    def to_timestamp(self, freq=None, how=\"start\", copy=True) -> \"Series\":\n        \"\"\"\n        Cast to DatetimeIndex of Timestamps, at *beginning* of period.\n    \n        Parameters\n        ----------\n        freq : str, default frequency of PeriodIndex\n            Desired frequency.\n        how : {'s', 'e', 'start', 'end'}\n            Convention for converting period to timestamp; start of period\n            vs. end.\n        copy : bool, default True\n            Whether or not to return a copy.\n    \n        Returns\n        -------\n        Series with DatetimeIndex\n        \"\"\"\n        new_values = self._values\n        if copy:\n            new_values = new_values.copy()\n    \n>       assert isinstance(self.index, PeriodIndex)\nE       AssertionError\n\npandas/core/series.py:4687: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_3/pandas/tests/series/methods/test_to_timestamp.py",
                "test_function": "test_to_timestamp_raises",
                "test_function_code": "    def test_to_timestamp_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, PeriodIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n                ser.to_timestamp()",
                "test_error": "AssertionError",
                "full_test_error": "self = <pandas.tests.series.methods.test_to_timestamp.TestToTimestamp object at 0x11049b2b0>\nindices = UInt64Index([9223372036854775808, 9223372036854775809, 9223372036854775810,\n             9223372036854775811, 92233720...2036854775904, 9223372036854775905, 9223372036854775906,\n             9223372036854775907],\n            dtype='uint64')\n\n    def test_to_timestamp_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, PeriodIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n>               ser.to_timestamp()\n\npandas/tests/series/methods/test_to_timestamp.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = 9223372036854775808    NaN\n9223372036854775809    NaN\n9223372036854775810    NaN\n9223372036854775811    NaN\n9223372036...5904    NaN\n9223372036854775905    NaN\n9223372036854775906    NaN\n9223372036854775907    NaN\nLength: 100, dtype: object\nfreq = None, how = 'start', copy = True\n\n    def to_timestamp(self, freq=None, how=\"start\", copy=True) -> \"Series\":\n        \"\"\"\n        Cast to DatetimeIndex of Timestamps, at *beginning* of period.\n    \n        Parameters\n        ----------\n        freq : str, default frequency of PeriodIndex\n            Desired frequency.\n        how : {'s', 'e', 'start', 'end'}\n            Convention for converting period to timestamp; start of period\n            vs. end.\n        copy : bool, default True\n            Whether or not to return a copy.\n    \n        Returns\n        -------\n        Series with DatetimeIndex\n        \"\"\"\n        new_values = self._values\n        if copy:\n            new_values = new_values.copy()\n    \n>       assert isinstance(self.index, PeriodIndex)\nE       AssertionError\n\npandas/core/series.py:4687: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_3/pandas/tests/series/methods/test_to_timestamp.py",
                "test_function": "test_to_timestamp_raises",
                "test_function_code": "    def test_to_timestamp_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, PeriodIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n                ser.to_timestamp()",
                "test_error": "AssertionError",
                "full_test_error": "self = <pandas.tests.series.methods.test_to_timestamp.TestToTimestamp object at 0x1100cd430>\nindices = RangeIndex(start=0, stop=100, step=1)\n\n    def test_to_timestamp_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, PeriodIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n>               ser.to_timestamp()\n\npandas/tests/series/methods/test_to_timestamp.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = 0     NaN\n1     NaN\n2     NaN\n3     NaN\n4     NaN\n     ... \n95    NaN\n96    NaN\n97    NaN\n98    NaN\n99    NaN\nLength: 100, dtype: object\nfreq = None, how = 'start', copy = True\n\n    def to_timestamp(self, freq=None, how=\"start\", copy=True) -> \"Series\":\n        \"\"\"\n        Cast to DatetimeIndex of Timestamps, at *beginning* of period.\n    \n        Parameters\n        ----------\n        freq : str, default frequency of PeriodIndex\n            Desired frequency.\n        how : {'s', 'e', 'start', 'end'}\n            Convention for converting period to timestamp; start of period\n            vs. end.\n        copy : bool, default True\n            Whether or not to return a copy.\n    \n        Returns\n        -------\n        Series with DatetimeIndex\n        \"\"\"\n        new_values = self._values\n        if copy:\n            new_values = new_values.copy()\n    \n>       assert isinstance(self.index, PeriodIndex)\nE       AssertionError\n\npandas/core/series.py:4687: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_3/pandas/tests/series/methods/test_to_timestamp.py",
                "test_function": "test_to_timestamp_raises",
                "test_function_code": "    def test_to_timestamp_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, PeriodIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n                ser.to_timestamp()",
                "test_error": "AssertionError",
                "full_test_error": "self = <pandas.tests.series.methods.test_to_timestamp.TestToTimestamp object at 0x110485d90>\nindices = Float64Index([-60.073024128532325,  -59.23530400090402,  -58.40759026901854,\n               -56.90612546044854, -56.78...4500850125,  36.307919316861806,  37.494191792937215,\n                38.61399356312093],\n             dtype='float64')\n\n    def test_to_timestamp_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, PeriodIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n>               ser.to_timestamp()\n\npandas/tests/series/methods/test_to_timestamp.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = -60.073024    NaN\n-59.235304    NaN\n-58.407590    NaN\n-56.906125    NaN\n-56.784449    NaN\n             ... \n 31.791700    NaN\n 34.869545    NaN\n 36.307919    NaN\n 37.494192    NaN\n 38.613994    NaN\nLength: 100, dtype: object\nfreq = None, how = 'start', copy = True\n\n    def to_timestamp(self, freq=None, how=\"start\", copy=True) -> \"Series\":\n        \"\"\"\n        Cast to DatetimeIndex of Timestamps, at *beginning* of period.\n    \n        Parameters\n        ----------\n        freq : str, default frequency of PeriodIndex\n            Desired frequency.\n        how : {'s', 'e', 'start', 'end'}\n            Convention for converting period to timestamp; start of period\n            vs. end.\n        copy : bool, default True\n            Whether or not to return a copy.\n    \n        Returns\n        -------\n        Series with DatetimeIndex\n        \"\"\"\n        new_values = self._values\n        if copy:\n            new_values = new_values.copy()\n    \n>       assert isinstance(self.index, PeriodIndex)\nE       AssertionError\n\npandas/core/series.py:4687: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_3/pandas/tests/series/methods/test_to_timestamp.py",
                "test_function": "test_to_timestamp_raises",
                "test_function_code": "    def test_to_timestamp_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, PeriodIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n                ser.to_timestamp()",
                "test_error": "AssertionError",
                "full_test_error": "self = <pandas.tests.series.methods.test_to_timestamp.TestToTimestamp object at 0x1104c8b80>\nindices = Index([False, True, False, False, False, False, False, False, False, False], dtype='object')\n\n    def test_to_timestamp_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, PeriodIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n>               ser.to_timestamp()\n\npandas/tests/series/methods/test_to_timestamp.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = False    NaN\nTrue     NaN\nFalse    NaN\nFalse    NaN\nFalse    NaN\nFalse    NaN\nFalse    NaN\nFalse    NaN\nFalse    NaN\nFalse    NaN\ndtype: object\nfreq = None, how = 'start', copy = True\n\n    def to_timestamp(self, freq=None, how=\"start\", copy=True) -> \"Series\":\n        \"\"\"\n        Cast to DatetimeIndex of Timestamps, at *beginning* of period.\n    \n        Parameters\n        ----------\n        freq : str, default frequency of PeriodIndex\n            Desired frequency.\n        how : {'s', 'e', 'start', 'end'}\n            Convention for converting period to timestamp; start of period\n            vs. end.\n        copy : bool, default True\n            Whether or not to return a copy.\n    \n        Returns\n        -------\n        Series with DatetimeIndex\n        \"\"\"\n        new_values = self._values\n        if copy:\n            new_values = new_values.copy()\n    \n>       assert isinstance(self.index, PeriodIndex)\nE       AssertionError\n\npandas/core/series.py:4687: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_3/pandas/tests/series/methods/test_to_timestamp.py",
                "test_function": "test_to_timestamp_raises",
                "test_function_code": "    def test_to_timestamp_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, PeriodIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n                ser.to_timestamp()",
                "test_error": "AssertionError",
                "full_test_error": "self = <pandas.tests.series.methods.test_to_timestamp.TestToTimestamp object at 0x110080190>\nindices = CategoricalIndex(['0Xuq', 'hiJy', 'Jjqf', '0Xuq', 'hiJy', 'Jjqf', '0Xuq',\n                  'hiJy', 'Jjqf', '0Xuq', 'h...                'Jjqf', '0Xuq'],\n                 categories=['0Xuq', 'hiJy', 'Jjqf'], ordered=False, dtype='category')\n\n    def test_to_timestamp_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, PeriodIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n>               ser.to_timestamp()\n\npandas/tests/series/methods/test_to_timestamp.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = 0Xuq    NaN\nhiJy    NaN\nJjqf    NaN\n0Xuq    NaN\nhiJy    NaN\n       ... \nJjqf    NaN\n0Xuq    NaN\nhiJy    NaN\nJjqf    NaN\n0Xuq    NaN\nLength: 100, dtype: object\nfreq = None, how = 'start', copy = True\n\n    def to_timestamp(self, freq=None, how=\"start\", copy=True) -> \"Series\":\n        \"\"\"\n        Cast to DatetimeIndex of Timestamps, at *beginning* of period.\n    \n        Parameters\n        ----------\n        freq : str, default frequency of PeriodIndex\n            Desired frequency.\n        how : {'s', 'e', 'start', 'end'}\n            Convention for converting period to timestamp; start of period\n            vs. end.\n        copy : bool, default True\n            Whether or not to return a copy.\n    \n        Returns\n        -------\n        Series with DatetimeIndex\n        \"\"\"\n        new_values = self._values\n        if copy:\n            new_values = new_values.copy()\n    \n>       assert isinstance(self.index, PeriodIndex)\nE       AssertionError\n\npandas/core/series.py:4687: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_3/pandas/tests/series/methods/test_to_timestamp.py",
                "test_function": "test_to_timestamp_raises",
                "test_function_code": "    def test_to_timestamp_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, PeriodIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n                ser.to_timestamp()",
                "test_error": "AssertionError",
                "full_test_error": "self = <pandas.tests.series.methods.test_to_timestamp.TestToTimestamp object at 0x110255610>\nindices = IntervalIndex([(0.0, 1.0], (1.0, 2.0], (2.0, 3.0], (3.0, 4.0], (4.0, 5.0] ... (95.0, 96.0], (96.0, 97.0], (97.0, 98.0], (98.0, 99.0], (99.0, 100.0]],\n              closed='right',\n              dtype='interval[float64]')\n\n    def test_to_timestamp_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, PeriodIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n>               ser.to_timestamp()\n\npandas/tests/series/methods/test_to_timestamp.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = (0.0, 1.0]       NaN\n(1.0, 2.0]       NaN\n(2.0, 3.0]       NaN\n(3.0, 4.0]       NaN\n(4.0, 5.0]       NaN\n             ...     NaN\n(96.0, 97.0]     NaN\n(97.0, 98.0]     NaN\n(98.0, 99.0]     NaN\n(99.0, 100.0]    NaN\nLength: 100, dtype: object\nfreq = None, how = 'start', copy = True\n\n    def to_timestamp(self, freq=None, how=\"start\", copy=True) -> \"Series\":\n        \"\"\"\n        Cast to DatetimeIndex of Timestamps, at *beginning* of period.\n    \n        Parameters\n        ----------\n        freq : str, default frequency of PeriodIndex\n            Desired frequency.\n        how : {'s', 'e', 'start', 'end'}\n            Convention for converting period to timestamp; start of period\n            vs. end.\n        copy : bool, default True\n            Whether or not to return a copy.\n    \n        Returns\n        -------\n        Series with DatetimeIndex\n        \"\"\"\n        new_values = self._values\n        if copy:\n            new_values = new_values.copy()\n    \n>       assert isinstance(self.index, PeriodIndex)\nE       AssertionError\n\npandas/core/series.py:4687: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_3/pandas/tests/series/methods/test_to_timestamp.py",
                "test_function": "test_to_timestamp_raises",
                "test_function_code": "    def test_to_timestamp_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, PeriodIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n                ser.to_timestamp()",
                "test_error": "AssertionError",
                "full_test_error": "self = <pandas.tests.series.methods.test_to_timestamp.TestToTimestamp object at 0x11017f1c0>\nindices = Index([], dtype='object')\n\n    def test_to_timestamp_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, PeriodIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n>               ser.to_timestamp()\n\npandas/tests/series/methods/test_to_timestamp.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Series([], dtype: object), freq = None, how = 'start', copy = True\n\n    def to_timestamp(self, freq=None, how=\"start\", copy=True) -> \"Series\":\n        \"\"\"\n        Cast to DatetimeIndex of Timestamps, at *beginning* of period.\n    \n        Parameters\n        ----------\n        freq : str, default frequency of PeriodIndex\n            Desired frequency.\n        how : {'s', 'e', 'start', 'end'}\n            Convention for converting period to timestamp; start of period\n            vs. end.\n        copy : bool, default True\n            Whether or not to return a copy.\n    \n        Returns\n        -------\n        Series with DatetimeIndex\n        \"\"\"\n        new_values = self._values\n        if copy:\n            new_values = new_values.copy()\n    \n>       assert isinstance(self.index, PeriodIndex)\nE       AssertionError\n\npandas/core/series.py:4687: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_3/pandas/tests/series/methods/test_to_timestamp.py",
                "test_function": "test_to_timestamp_raises",
                "test_function_code": "    def test_to_timestamp_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, PeriodIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n                ser.to_timestamp()",
                "test_error": "AssertionError",
                "full_test_error": "self = <pandas.tests.series.methods.test_to_timestamp.TestToTimestamp object at 0x11018c760>\nindices = MultiIndex([('foo', 1),\n            ('bar', 2),\n            ('baz', 3)],\n           )\n\n    def test_to_timestamp_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, PeriodIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n>               ser.to_timestamp()\n\npandas/tests/series/methods/test_to_timestamp.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = foo  1    NaN\nbar  2    NaN\nbaz  3    NaN\ndtype: object, freq = None\nhow = 'start', copy = True\n\n    def to_timestamp(self, freq=None, how=\"start\", copy=True) -> \"Series\":\n        \"\"\"\n        Cast to DatetimeIndex of Timestamps, at *beginning* of period.\n    \n        Parameters\n        ----------\n        freq : str, default frequency of PeriodIndex\n            Desired frequency.\n        how : {'s', 'e', 'start', 'end'}\n            Convention for converting period to timestamp; start of period\n            vs. end.\n        copy : bool, default True\n            Whether or not to return a copy.\n    \n        Returns\n        -------\n        Series with DatetimeIndex\n        \"\"\"\n        new_values = self._values\n        if copy:\n            new_values = new_values.copy()\n    \n>       assert isinstance(self.index, PeriodIndex)\nE       AssertionError\n\npandas/core/series.py:4687: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_3/pandas/tests/series/methods/test_to_timestamp.py",
                "test_function": "test_to_timestamp_raises",
                "test_function_code": "    def test_to_timestamp_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, PeriodIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n                ser.to_timestamp()",
                "test_error": "AssertionError",
                "full_test_error": "self = <pandas.tests.series.methods.test_to_timestamp.TestToTimestamp object at 0x11037d3d0>\nindices = MultiIndex([(1, 'a', '2013-01-01 00:00:00-05:00'),\n            (1, 'a', '2013-01-02 00:00:00-05:00'),\n            (1, ...3-01-02 00:00:00-05:00'),\n            (2, 'b', '2013-01-03 00:00:00-05:00')],\n           names=['one', 'two', 'three'])\n\n    def test_to_timestamp_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, PeriodIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n>               ser.to_timestamp()\n\npandas/tests/series/methods/test_to_timestamp.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = one  two  three                    \n1    a    2013-01-01 00:00:00-05:00    NaN\n          2013-01-02 00:00:00-05:00    ...:00:00-05:00    NaN\n          2013-01-02 00:00:00-05:00    NaN\n          2013-01-03 00:00:00-05:00    NaN\ndtype: object\nfreq = None, how = 'start', copy = True\n\n    def to_timestamp(self, freq=None, how=\"start\", copy=True) -> \"Series\":\n        \"\"\"\n        Cast to DatetimeIndex of Timestamps, at *beginning* of period.\n    \n        Parameters\n        ----------\n        freq : str, default frequency of PeriodIndex\n            Desired frequency.\n        how : {'s', 'e', 'start', 'end'}\n            Convention for converting period to timestamp; start of period\n            vs. end.\n        copy : bool, default True\n            Whether or not to return a copy.\n    \n        Returns\n        -------\n        Series with DatetimeIndex\n        \"\"\"\n        new_values = self._values\n        if copy:\n            new_values = new_values.copy()\n    \n>       assert isinstance(self.index, PeriodIndex)\nE       AssertionError\n\npandas/core/series.py:4687: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_3/pandas/tests/series/methods/test_to_timestamp.py",
                "test_function": "test_to_timestamp_raises",
                "test_function_code": "    def test_to_timestamp_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, PeriodIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n                ser.to_timestamp()",
                "test_error": "AssertionError",
                "full_test_error": "self = <pandas.tests.series.methods.test_to_timestamp.TestToTimestamp object at 0x1104ed280>\nindices = MultiIndex([('foo', 'one'),\n            ('foo', 'two'),\n            ('bar', 'one'),\n            ('baz', 'two'),\n            ('qux', 'one'),\n            ('qux', 'two')],\n           names=['first', 'second'])\n\n    def test_to_timestamp_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, PeriodIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n>               ser.to_timestamp()\n\npandas/tests/series/methods/test_to_timestamp.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = first  second\nfoo    one       NaN\n       two       NaN\nbar    one       NaN\nbaz    two       NaN\nqux    one       NaN\n       two       NaN\ndtype: object\nfreq = None, how = 'start', copy = True\n\n    def to_timestamp(self, freq=None, how=\"start\", copy=True) -> \"Series\":\n        \"\"\"\n        Cast to DatetimeIndex of Timestamps, at *beginning* of period.\n    \n        Parameters\n        ----------\n        freq : str, default frequency of PeriodIndex\n            Desired frequency.\n        how : {'s', 'e', 'start', 'end'}\n            Convention for converting period to timestamp; start of period\n            vs. end.\n        copy : bool, default True\n            Whether or not to return a copy.\n    \n        Returns\n        -------\n        Series with DatetimeIndex\n        \"\"\"\n        new_values = self._values\n        if copy:\n            new_values = new_values.copy()\n    \n>       assert isinstance(self.index, PeriodIndex)\nE       AssertionError\n\npandas/core/series.py:4687: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_3/pandas/tests/series/methods/test_to_timestamp.py",
                "test_function": "test_to_timestamp_raises",
                "test_function_code": "    def test_to_timestamp_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, PeriodIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n                ser.to_timestamp()",
                "test_error": "AssertionError",
                "full_test_error": "self = <pandas.tests.series.methods.test_to_timestamp.TestToTimestamp object at 0x1102220a0>\nindices = Int64Index([0, 0, 1, 1, 2, 2], dtype='int64')\n\n    def test_to_timestamp_raises(self, indices):\n        # https://github.com/pandas-dev/pandas/issues/33327\n        index = indices\n        ser = Series(index=index, dtype=object)\n        if not isinstance(index, PeriodIndex):\n            msg = f\"unsupported Type {type(index).__name__}\"\n            with pytest.raises(TypeError, match=msg):\n>               ser.to_timestamp()\n\npandas/tests/series/methods/test_to_timestamp.py:65: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = 0    NaN\n0    NaN\n1    NaN\n1    NaN\n2    NaN\n2    NaN\ndtype: object\nfreq = None, how = 'start', copy = True\n\n    def to_timestamp(self, freq=None, how=\"start\", copy=True) -> \"Series\":\n        \"\"\"\n        Cast to DatetimeIndex of Timestamps, at *beginning* of period.\n    \n        Parameters\n        ----------\n        freq : str, default frequency of PeriodIndex\n            Desired frequency.\n        how : {'s', 'e', 'start', 'end'}\n            Convention for converting period to timestamp; start of period\n            vs. end.\n        copy : bool, default True\n            Whether or not to return a copy.\n    \n        Returns\n        -------\n        Series with DatetimeIndex\n        \"\"\"\n        new_values = self._values\n        if copy:\n            new_values = new_values.copy()\n    \n>       assert isinstance(self.index, PeriodIndex)\nE       AssertionError\n\npandas/core/series.py:4687: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            }
        ]
    }
}